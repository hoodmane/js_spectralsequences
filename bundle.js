(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
/*
 * Konva JavaScript Framework v2.1.3
 * http://konvajs.github.io/
 * Licensed under the MIT
 * Date: Thu May 17 2018
 *
 * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
 * Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva)
 *
 * @license
 */

// runtime check for already included Konva
(function() {
  'use strict';
  /**
   * @namespace Konva
   */

  var PI_OVER_180 = Math.PI / 180;

  var Konva = {
    // public
    version: '2.1.3',

    // private
    stages: [],
    idCounter: 0,
    ids: {},
    names: {},
    shapes: {},
    listenClickTap: false,
    inDblClickWindow: false,

    isBrowser:
      typeof window !== 'undefined' &&
      // browser case
      ({}.toString.call(window) === '[object Window]' ||
        // electron case
        {}.toString.call(window) === '[object global]'),

    // configurations
    enableTrace: false,
    traceArrMax: 100,
    dblClickWindow: 400,
    /**
     * Global pixel ratio configuration. KonvaJS automatically detect pixel ratio of current device.
     * But you may override such property, if you want to use your value.
     * @property pixelRatio
     * @default undefined
     * @memberof Konva
     * @example
     * Konva.pixelRatio = 1;
     */
    pixelRatio: undefined,
    /**
     * Drag distance property. If you start to drag a node you may want to wait until pointer is moved to some distance from start point,
     * only then start dragging. Default is 3px.
     * @property dragDistance
     * @default 0
     * @memberof Konva
     * @example
     * Konva.dragDistance = 10;
     */
    dragDistance: 3,
    /**
     * Use degree values for angle properties. You may set this property to false if you want to use radiant values.
     * @property angleDeg
     * @default true
     * @memberof Konva
     * @example
     * node.rotation(45); // 45 degrees
     * Konva.angleDeg = false;
     * node.rotation(Math.PI / 2); // PI/2 radian
     */
    angleDeg: true,
    /**
     * Show different warnings about errors or wrong API usage
     * @property showWarnings
     * @default true
     * @memberof Konva
     * @example
     * Konva.showWarnings = false;
     */
    showWarnings: true,

    /**
     * @namespace Filters
     * @memberof Konva
     */
    Filters: {},

    /**
     * returns whether or not drag and drop is currently active
     * @method
     * @memberof Konva
     */
    isDragging: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return dd.isDragging;
      }
      return false;
    },
    /**
     * returns whether or not a drag and drop operation is ready, but may
     *  not necessarily have started
     * @method
     * @memberof Konva
     */
    isDragReady: function() {
      var dd = Konva.DD;

      // if DD is not included with the build, then
      // drag and drop is not even possible
      if (dd) {
        return !!dd.node;
      }
      return false;
    },
    _addId: function(node, id) {
      if (id !== undefined) {
        this.ids[id] = node;
      }
    },
    _removeId: function(id) {
      if (id !== undefined) {
        delete this.ids[id];
      }
    },
    _addName: function(node, name) {
      if (name) {
        if (!this.names[name]) {
          this.names[name] = [];
        }
        this.names[name].push(node);
      }
    },
    _removeName: function(name, _id) {
      if (!name) {
        return;
      }
      var nodes = this.names[name];
      if (!nodes) {
        return;
      }
      for (var n = 0; n < nodes.length; n++) {
        var no = nodes[n];
        if (no._id === _id) {
          nodes.splice(n, 1);
        }
      }
      if (nodes.length === 0) {
        delete this.names[name];
      }
    },
    getAngle: function(angle) {
      return this.angleDeg ? angle * PI_OVER_180 : angle;
    },
    _detectIE: function(ua) {
      var msie = ua.indexOf('msie ');
      if (msie > 0) {
        // IE 10 or older => return version number
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      }

      var trident = ua.indexOf('trident/');
      if (trident > 0) {
        // IE 11 => return version number
        var rv = ua.indexOf('rv:');
        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
      }

      var edge = ua.indexOf('edge/');
      if (edge > 0) {
        // Edge (IE 12+) => return version number
        return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
      }

      // other browser
      return false;
    },
    _parseUA: function(userAgent) {
      var ua = userAgent.toLowerCase(),
        // jQuery UA regex
        match =
          /(chrome)[ /]([\w.]+)/.exec(ua) ||
          /(webkit)[ /]([\w.]+)/.exec(ua) ||
          /(opera)(?:.*version|)[ /]([\w.]+)/.exec(ua) ||
          /(msie) ([\w.]+)/.exec(ua) ||
          (ua.indexOf('compatible') < 0 &&
            /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua)) ||
          [],
        // adding mobile flag as well
        mobile = !!userAgent.match(
          /Android|BlackBerry|iPhone|iPad|iPod|Opera Mini|IEMobile/i
        ),
        ieMobile = !!userAgent.match(/IEMobile/i);

      return {
        browser: match[1] || '',
        version: match[2] || '0',
        isIE: Konva._detectIE(ua),
        // adding mobile flab
        mobile: mobile,
        ieMobile: ieMobile // If this is true (i.e., WP8), then Konva touch events are executed instead of equivalent Konva mouse events
      };
    },
    // user agent
    UA: undefined
  };

  var glob =
    typeof global !== 'undefined'
      ? global
      : typeof window !== 'undefined'
        ? window
        : typeof WorkerGlobalScope !== 'undefined' ? self : {};

  Konva.UA = Konva._parseUA((glob.navigator && glob.navigator.userAgent) || '');

  if (glob.Konva) {
    console.error(
      'Konva instance is already exist in current eviroment. ' +
        'Please use only one instance.'
    );
  }
  glob.Konva = Konva;
  Konva.global = glob;
  Konva.window = glob;
  Konva.document = glob.document;

  if (typeof exports === 'object') {
    module.exports = Konva;
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(function() {
      return Konva;
    });
  }
})();

/*eslint-disable  eqeqeq, no-cond-assign, no-empty*/
(function() {
  'use strict';
  /**
   * Collection constructor.  Collection extends
   *  Array.  This class is used in conjunction with {@link Konva.Container#get}
   * @constructor
   * @memberof Konva
   */
  Konva.Collection = function() {
    var args = [].slice.call(arguments),
      length = args.length,
      i = 0;

    this.length = length;
    for (; i < length; i++) {
      this[i] = args[i];
    }
    return this;
  };
  Konva.Collection.prototype = [];
  /**
   * iterate through node array and run a function for each node.
   *  The node and index is passed into the function
   * @method
   * @memberof Konva.Collection.prototype
   * @param {Function} func
   * @example
   * // get all nodes with name foo inside layer, and set x to 10 for each
   * layer.get('.foo').each(function(shape, n) {
   *   shape.setX(10);
   * });
   */
  Konva.Collection.prototype.each = function(func) {
    for (var n = 0; n < this.length; n++) {
      func(this[n], n);
    }
  };
  /**
   * convert collection into an array
   * @method
   * @memberof Konva.Collection.prototype
   */
  Konva.Collection.prototype.toArray = function() {
    var arr = [],
      len = this.length,
      n;

    for (n = 0; n < len; n++) {
      arr.push(this[n]);
    }
    return arr;
  };
  /**
   * convert array into a collection
   * @method
   * @memberof Konva.Collection
   * @param {Array} arr
   */
  Konva.Collection.toCollection = function(arr) {
    var collection = new Konva.Collection(),
      len = arr.length,
      n;

    for (n = 0; n < len; n++) {
      collection.push(arr[n]);
    }
    return collection;
  };

  // map one method by it's name
  Konva.Collection._mapMethod = function(methodName) {
    Konva.Collection.prototype[methodName] = function() {
      var len = this.length,
        i;

      var args = [].slice.call(arguments);
      for (i = 0; i < len; i++) {
        this[i][methodName].apply(this[i], args);
      }

      return this;
    };
  };

  Konva.Collection.mapMethods = function(constructor) {
    var prot = constructor.prototype;
    for (var methodName in prot) {
      Konva.Collection._mapMethod(methodName);
    }
  };

  /*
    * Last updated November 2011
    * By Simon Sarris
    * www.simonsarris.com
    * sarris@acm.org
    *
    * Free to use and distribute at will
    * So long as you are nice to people, etc
    */

  /*
    * The usage of this class was inspired by some of the work done by a forked
    * project, KineticJS-Ext by Wappworks, which is based on Simon's Transform
    * class.  Modified by Eric Rowell
    */

  /**
   * Transform constructor. Transform object is a private class of Konva framework.
   * In most of the cases you don't need to use it in your app.
   * But there is a documentation for that class in case you still want
   * to make some manual calculations.
   * @constructor
   * @param {Array} [m] Optional six-element matrix
   * @memberof Konva
   */
  Konva.Transform = function(m) {
    this.m = (m && m.slice()) || [1, 0, 0, 1, 0, 0];
  };

  Konva.Transform.prototype = {
    /**
     * Copy Konva.Transform object
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     */
    copy: function() {
      return new Konva.Transform(this.m);
    },
    /**
     * Transform point
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Object} point 2D point(x, y)
     * @returns {Object} 2D point(x, y)
     */
    point: function(point) {
      var m = this.m;
      return {
        x: m[0] * point.x + m[2] * point.y + m[4],
        y: m[1] * point.x + m[3] * point.y + m[5]
      };
    },
    /**
     * Apply translation
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} x
     * @param {Number} y
     * @returns {Konva.Transform}
     */
    translate: function(x, y) {
      this.m[4] += this.m[0] * x + this.m[2] * y;
      this.m[5] += this.m[1] * x + this.m[3] * y;
      return this;
    },
    /**
     * Apply scale
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} sx
     * @param {Number} sy
     * @returns {Konva.Transform}
     */
    scale: function(sx, sy) {
      this.m[0] *= sx;
      this.m[1] *= sx;
      this.m[2] *= sy;
      this.m[3] *= sy;
      return this;
    },
    /**
     * Apply rotation
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} rad  Angle in radians
     * @returns {Konva.Transform}
     */
    rotate: function(rad) {
      var c = Math.cos(rad);
      var s = Math.sin(rad);
      var m11 = this.m[0] * c + this.m[2] * s;
      var m12 = this.m[1] * c + this.m[3] * s;
      var m21 = this.m[0] * -s + this.m[2] * c;
      var m22 = this.m[1] * -s + this.m[3] * c;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
     * Returns the translation
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Object} 2D point(x, y)
     */
    getTranslation: function() {
      return {
        x: this.m[4],
        y: this.m[5]
      };
    },
    /**
     * Apply skew
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Number} sx
     * @param {Number} sy
     * @returns {Konva.Transform}
     */
    skew: function(sx, sy) {
      var m11 = this.m[0] + this.m[2] * sy;
      var m12 = this.m[1] + this.m[3] * sy;
      var m21 = this.m[2] + this.m[0] * sx;
      var m22 = this.m[3] + this.m[1] * sx;
      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      return this;
    },
    /**
     * Transform multiplication
     * @method
     * @memberof Konva.Transform.prototype
     * @param {Konva.Transform} matrix
     * @returns {Konva.Transform}
     */
    multiply: function(matrix) {
      var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1];
      var m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1];

      var m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3];
      var m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3];

      var dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4];
      var dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

      this.m[0] = m11;
      this.m[1] = m12;
      this.m[2] = m21;
      this.m[3] = m22;
      this.m[4] = dx;
      this.m[5] = dy;
      return this;
    },
    /**
     * Invert the matrix
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     */
    invert: function() {
      var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]);
      var m0 = this.m[3] * d;
      var m1 = -this.m[1] * d;
      var m2 = -this.m[2] * d;
      var m3 = this.m[0] * d;
      var m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]);
      var m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);
      this.m[0] = m0;
      this.m[1] = m1;
      this.m[2] = m2;
      this.m[3] = m3;
      this.m[4] = m4;
      this.m[5] = m5;
      return this;
    },
    /**
     * return matrix
     * @method
     * @memberof Konva.Transform.prototype
     */
    getMatrix: function() {
      return this.m;
    },
    /**
     * set to absolute position via translation
     * @method
     * @memberof Konva.Transform.prototype
     * @returns {Konva.Transform}
     * @author ericdrowell
     */
    setAbsolutePosition: function(x, y) {
      var m0 = this.m[0],
        m1 = this.m[1],
        m2 = this.m[2],
        m3 = this.m[3],
        m4 = this.m[4],
        m5 = this.m[5],
        yt = (m0 * (y - m5) - m1 * (x - m4)) / (m0 * m3 - m1 * m2),
        xt = (x - m4 - m2 * yt) / m0;

      return this.translate(xt, yt);
    }
  };

  // CONSTANTS
  var CONTEXT_2D = '2d',
    OBJECT_ARRAY = '[object Array]',
    OBJECT_NUMBER = '[object Number]',
    OBJECT_STRING = '[object String]',
    PI_OVER_DEG180 = Math.PI / 180,
    DEG180_OVER_PI = 180 / Math.PI,
    HASH = '#',
    EMPTY_STRING = '',
    ZERO = '0',
    KONVA_WARNING = 'Konva warning: ',
    KONVA_ERROR = 'Konva error: ',
    RGB_PAREN = 'rgb(',
    COLORS = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 132, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 255, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 203],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [119, 128, 144],
      slategrey: [119, 128, 144],
      snow: [255, 255, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      transparent: [255, 255, 255, 0],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 5]
    },
    RGB_REGEX = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/;

  /**
   * @namespace Util
   * @memberof Konva
   */
  Konva.Util = {
    /*
    * cherry-picked utilities from underscore.js
    */
    _isElement: function(obj) {
      return !!(obj && obj.nodeType == 1);
    },
    _isFunction: function(obj) {
      return !!(obj && obj.constructor && obj.call && obj.apply);
    },
    _isObject: function(obj) {
      return !!obj && obj.constructor === Object;
    },
    _isArray: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_ARRAY;
    },
    _isNumber: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_NUMBER;
    },
    _isString: function(obj) {
      return Object.prototype.toString.call(obj) === OBJECT_STRING;
    },
    // arrays are objects too
    isObject: function(val) {
      return val instanceof Object;
    },
    isValidSelector: function(selector) {
      if (typeof selector !== 'string') {
        return false;
      }
      var firstChar = selector[0];
      return (
        firstChar === '#' ||
        firstChar === '.' ||
        firstChar === firstChar.toUpperCase()
      );
    },
    _sign: function(number) {
      if (number === 0) {
        return 0;
      }
      if (number > 0) {
        return 1;
      } else {
        return -1;
      }
    },
    createCanvasElement: function() {
      var canvas = Konva.isBrowser
        ? Konva.document.createElement('canvas')
        : new Konva._nodeCanvas();
      // on some environments canvas.style is readonly
      try {
        canvas.style = canvas.style || {};
      } catch (e) {}
      return canvas;
    },
    _isInDocument: function(el) {
      while ((el = el.parentNode)) {
        if (el == Konva.document) {
          return true;
        }
      }
      return false;
    },
    _simplifyArray: function(arr) {
      var retArr = [],
        len = arr.length,
        util = Konva.Util,
        n,
        val;

      for (n = 0; n < len; n++) {
        val = arr[n];
        if (util._isNumber(val)) {
          val = Math.round(val * 1000) / 1000;
        } else if (!util._isString(val)) {
          val = val.toString();
        }

        retArr.push(val);
      }

      return retArr;
    },
    /*
    * arg can be an image object or image data
    */
    _getImage: function(arg, callback) {
      var imageObj, canvas;

      // if arg is null or undefined
      if (!arg) {
        callback(null);
      } else if (this._isElement(arg)) {
        // if arg is already an image object
        callback(arg);
      } else if (this._isString(arg)) {
        // if arg is a string, then it's a data url
        imageObj = new Konva.window.Image();
        imageObj.onload = function() {
          callback(imageObj);
        };
        imageObj.src = arg;
      } else if (arg.data) {
        //if arg is an object that contains the data property, it's an image object
        canvas = Konva.Util.createCanvasElement();
        canvas.width = arg.width;
        canvas.height = arg.height;
        var _context = canvas.getContext(CONTEXT_2D);
        _context.putImageData(arg, 0, 0);
        this._getImage(canvas.toDataURL(), callback);
      } else {
        callback(null);
      }
    },
    _getRGBAString: function(obj) {
      var red = obj.red || 0,
        green = obj.green || 0,
        blue = obj.blue || 0,
        alpha = obj.alpha || 1;

      return ['rgba(', red, ',', green, ',', blue, ',', alpha, ')'].join(
        EMPTY_STRING
      );
    },
    _rgbToHex: function(r, g, b) {
      return ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    },
    _hexToRgb: function(hex) {
      hex = hex.replace(HASH, EMPTY_STRING);
      var bigint = parseInt(hex, 16);
      return {
        r: (bigint >> 16) & 255,
        g: (bigint >> 8) & 255,
        b: bigint & 255
      };
    },
    /**
     * return random hex color
     * @method
     * @memberof Konva.Util.prototype
     */
    getRandomColor: function() {
      var randColor = ((Math.random() * 0xffffff) << 0).toString(16);
      while (randColor.length < 6) {
        randColor = ZERO + randColor;
      }
      return HASH + randColor;
    },
    /**
     * return value with default fallback
     * @method
     * @memberof Konva.Util.prototype
     */
    get: function(val, def) {
      if (val === undefined) {
        return def;
      } else {
        return val;
      }
    },
    /**
     * get RGB components of a color
     * @method
     * @memberof Konva.Util.prototype
     * @param {String} color
     * @example
     * // each of the following examples return {r:0, g:0, b:255}
     * var rgb = Konva.Util.getRGB('blue');
     * var rgb = Konva.Util.getRGB('#0000ff');
     * var rgb = Konva.Util.getRGB('rgb(0,0,255)');
     */
    getRGB: function(color) {
      var rgb;
      // color string
      if (color in COLORS) {
        rgb = COLORS[color];
        return {
          r: rgb[0],
          g: rgb[1],
          b: rgb[2]
        };
      } else if (color[0] === HASH) {
        // hex
        return this._hexToRgb(color.substring(1));
      } else if (color.substr(0, 4) === RGB_PAREN) {
        // rgb string
        rgb = RGB_REGEX.exec(color.replace(/ /g, ''));
        return {
          r: parseInt(rgb[1], 10),
          g: parseInt(rgb[2], 10),
          b: parseInt(rgb[3], 10)
        };
      } else {
        // default
        return {
          r: 0,
          g: 0,
          b: 0
        };
      }
    },
    // convert any color string to RGBA object
    // from https://github.com/component/color-parser
    colorToRGBA: function(str) {
      str = str || 'black';
      return (
        Konva.Util._namedColorToRBA(str) ||
        Konva.Util._hex3ColorToRGBA(str) ||
        Konva.Util._hex6ColorToRGBA(str) ||
        Konva.Util._rgbColorToRGBA(str) ||
        Konva.Util._rgbaColorToRGBA(str)
      );
    },
    // Parse named css color. Like "green"
    _namedColorToRBA: function(str) {
      var c = COLORS[str.toLowerCase()];
      if (!c) {
        return null;
      }
      return {
        r: c[0],
        g: c[1],
        b: c[2],
        a: 1
      };
    },
    // Parse rgb(n, n, n)
    _rgbColorToRGBA: function(str) {
      if (str.indexOf('rgb(') === 0) {
        str = str.match(/rgb\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: 1
        };
      }
    },
    // Parse rgba(n, n, n, n)
    _rgbaColorToRGBA: function(str) {
      if (str.indexOf('rgba(') === 0) {
        str = str.match(/rgba\(([^)]+)\)/)[1];
        var parts = str.split(/ *, */).map(Number);
        return {
          r: parts[0],
          g: parts[1],
          b: parts[2],
          a: parts[3]
        };
      }
    },
    // Parse #nnnnnn
    _hex6ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 7) {
        return {
          r: parseInt(str.slice(1, 3), 16),
          g: parseInt(str.slice(3, 5), 16),
          b: parseInt(str.slice(5, 7), 16),
          a: 1
        };
      }
    },
    // Parse #nnn
    _hex3ColorToRGBA: function(str) {
      if (str[0] === '#' && str.length === 4) {
        return {
          r: parseInt(str[1] + str[1], 16),
          g: parseInt(str[2] + str[2], 16),
          b: parseInt(str[3] + str[3], 16),
          a: 1
        };
      }
    },
    // o1 takes precedence over o2
    _merge: function(o1, o2) {
      var retObj = this._clone(o2);
      for (var key in o1) {
        if (this._isObject(o1[key])) {
          retObj[key] = this._merge(o1[key], retObj[key]);
        } else {
          retObj[key] = o1[key];
        }
      }
      return retObj;
    },
    /**
     * check intersection of two client rectangles
     * @method
     * @memberof Konva.Util.prototype
     */
    haveIntersection: function(r1, r2) {
      return !(
        r2.x > r1.x + r1.width ||
        r2.x + r2.width < r1.x ||
        r2.y > r1.y + r1.height ||
        r2.y + r2.height < r1.y
      );
    },
    cloneObject: function(obj) {
      var retObj = {};
      for (var key in obj) {
        if (this._isObject(obj[key])) {
          retObj[key] = this.cloneObject(obj[key]);
        } else if (this._isArray(obj[key])) {
          retObj[key] = this.cloneArray(obj[key]);
        } else {
          retObj[key] = obj[key];
        }
      }
      return retObj;
    },
    cloneArray: function(arr) {
      return arr.slice(0);
    },
    _degToRad: function(deg) {
      return deg * PI_OVER_DEG180;
    },
    _radToDeg: function(rad) {
      return rad * DEG180_OVER_PI;
    },
    _capitalize: function(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    },
    throw: function(str) {
      throw new Error(KONVA_ERROR + str);
    },
    error: function(str) {
      console.error(KONVA_ERROR + str);
    },
    warn: function(str) {
      /*
             * IE9 on Windows7 64bit will throw a JS error
             * if we don't use window.console in the conditional
             */
      if (Konva.global.console && console.warn && Konva.showWarnings) {
        console.warn(KONVA_WARNING + str);
      }
    },
    extend: function(child, parent) {
      function Ctor() {
        this.constructor = child;
      }
      Ctor.prototype = parent.prototype;
      var oldProto = child.prototype;
      child.prototype = new Ctor();
      for (var key in oldProto) {
        if (oldProto.hasOwnProperty(key)) {
          child.prototype[key] = oldProto[key];
        }
      }
      child.__super__ = parent.prototype;
      // create reference to parent
      child.super = parent;
    },
    /**
     * adds methods to a constructor prototype
     * @method
     * @memberof Konva.Util.prototype
     * @param {Function} constructor
     * @param {Object} methods
     */
    addMethods: function(constructor, methods) {
      var key;

      for (key in methods) {
        constructor.prototype[key] = methods[key];
      }
    },
    _getControlPoints: function(x0, y0, x1, y1, x2, y2, t) {
      var d01 = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2)),
        d12 = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
        fa = t * d01 / (d01 + d12),
        fb = t * d12 / (d01 + d12),
        p1x = x1 - fa * (x2 - x0),
        p1y = y1 - fa * (y2 - y0),
        p2x = x1 + fb * (x2 - x0),
        p2y = y1 + fb * (y2 - y0);

      return [p1x, p1y, p2x, p2y];
    },
    _expandPoints: function(p, tension) {
      var len = p.length,
        allPoints = [],
        n,
        cp;

      for (n = 2; n < len - 2; n += 2) {
        cp = Konva.Util._getControlPoints(
          p[n - 2],
          p[n - 1],
          p[n],
          p[n + 1],
          p[n + 2],
          p[n + 3],
          tension
        );
        allPoints.push(cp[0]);
        allPoints.push(cp[1]);
        allPoints.push(p[n]);
        allPoints.push(p[n + 1]);
        allPoints.push(cp[2]);
        allPoints.push(cp[3]);
      }

      return allPoints;
    },
    _removeLastLetter: function(str) {
      return str.substring(0, str.length - 1);
    },
    each: function(obj, func) {
      for (var key in obj) {
        func(key, obj[key]);
      }
    },
    _inRange: function(val, left, right) {
      return left <= val && val < right;
    },
    _getProjectionToSegment: function(x1, y1, x2, y2, x3, y3) {
      var x, y, dist;

      var pd2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
      if (pd2 == 0) {
        x = x1;
        y = y1;
        dist = (x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2);
      } else {
        var u = ((x3 - x1) * (x2 - x1) + (y3 - y1) * (y2 - y1)) / pd2;
        if (u < 0) {
          x = x1;
          y = y1;
          dist = (x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3);
        } else if (u > 1.0) {
          x = x2;
          y = y2;
          dist = (x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3);
        } else {
          x = x1 + u * (x2 - x1);
          y = y1 + u * (y2 - y1);
          dist = (x - x3) * (x - x3) + (y - y3) * (y - y3);
        }
      }
      return [x, y, dist];
    },
    // line as array of points.
    // line might be closed
    _getProjectionToLine: function(pt, line, isClosed) {
      var pc = Konva.Util.cloneObject(pt);
      var dist = Number.MAX_VALUE;
      line.forEach(function(p1, i) {
        if (!isClosed && i === line.length - 1) {
          return;
        }
        var p2 = line[(i + 1) % line.length];
        var proj = Konva.Util._getProjectionToSegment(
          p1.x,
          p1.y,
          p2.x,
          p2.y,
          pt.x,
          pt.y
        );
        var px = proj[0],
          py = proj[1],
          pdist = proj[2];
        if (pdist < dist) {
          pc.x = px;
          pc.y = py;
          dist = pdist;
        }
      });
      return pc;
    },
    _prepareArrayForTween: function(startArray, endArray, isClosed) {
      var n,
        start = [],
        end = [];
      if (startArray.length > endArray.length) {
        var temp = endArray;
        endArray = startArray;
        startArray = temp;
      }
      for (n = 0; n < startArray.length; n += 2) {
        start.push({
          x: startArray[n],
          y: startArray[n + 1]
        });
      }
      for (n = 0; n < endArray.length; n += 2) {
        end.push({
          x: endArray[n],
          y: endArray[n + 1]
        });
      }

      var newStart = [];
      end.forEach(function(point) {
        var pr = Konva.Util._getProjectionToLine(point, start, isClosed);
        newStart.push(pr.x);
        newStart.push(pr.y);
      });
      return newStart;
    },
    _prepareToStringify: function(obj) {
      var desc;

      obj.visitedByCircularReferenceRemoval = true;

      for (var key in obj) {
        if (
          !(obj.hasOwnProperty(key) && obj[key] && typeof obj[key] == 'object')
        ) {
          continue;
        }
        desc = Object.getOwnPropertyDescriptor(obj, key);
        if (
          obj[key].visitedByCircularReferenceRemoval ||
          Konva.Util._isElement(obj[key])
        ) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        } else if (Konva.Util._prepareToStringify(obj[key]) === null) {
          if (desc.configurable) {
            delete obj[key];
          } else {
            return null;
          }
        }
      }

      delete obj.visitedByCircularReferenceRemoval;

      return obj;
    }
  };
})();

(function() {
  'use strict';
  // calculate pixel ratio

  var _pixelRatio;
  function getDevicePixelRatio() {
    if (_pixelRatio) {
      return _pixelRatio;
    }
    var canvas = Konva.Util.createCanvasElement();
    var context = canvas.getContext('2d');
    _pixelRatio = (function() {
      var devicePixelRatio = Konva.window.devicePixelRatio || 1,
        backingStoreRatio =
          context.webkitBackingStorePixelRatio ||
          context.mozBackingStorePixelRatio ||
          context.msBackingStorePixelRatio ||
          context.oBackingStorePixelRatio ||
          context.backingStorePixelRatio ||
          1;
      return devicePixelRatio / backingStoreRatio;
    })();
    return _pixelRatio;
  }

  /**
     * Canvas Renderer constructor
     * @constructor
     * @abstract
     * @memberof Konva
     * @param {Object} config
     * @param {Number} config.width
     * @param {Number} config.height
     * @param {Number} config.pixelRatio KonvaJS automatically handles pixel ratio adjustments in order to render crisp drawings
     *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
     *  of 1.  Some high end tablets and phones, like iPhones and iPads (not the mini) have a device pixel ratio
     *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
     *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
     *  specified, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
     *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
     */
  Konva.Canvas = function(config) {
    this.init(config);
  };

  Konva.Canvas.prototype = {
    init: function(config) {
      var conf = config || {};

      var pixelRatio =
        conf.pixelRatio || Konva.pixelRatio || getDevicePixelRatio();

      this.pixelRatio = pixelRatio;
      this._canvas = Konva.Util.createCanvasElement();

      // set inline styles
      this._canvas.style.padding = 0;
      this._canvas.style.margin = 0;
      this._canvas.style.border = 0;
      this._canvas.style.background = 'transparent';
      this._canvas.style.position = 'absolute';
      this._canvas.style.top = 0;
      this._canvas.style.left = 0;
    },
    /**
         * get canvas context
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {CanvasContext} context
         */
    getContext: function() {
      return this.context;
    },
    /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} pixel ratio
         */
    getPixelRatio: function() {
      return this.pixelRatio;
    },
    /**
         * get pixel ratio
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} pixelRatio KonvaJS automatically handles pixel ratio adustments in order to render crisp drawings
         *  on all devices. Most desktops, low end tablets, and low end phones, have device pixel ratios
         *  of 1.  Some high end tablets and phones, like iPhones and iPads have a device pixel ratio
         *  of 2.  Some Macbook Pros, and iMacs also have a device pixel ratio of 2.  Some high end Android devices have pixel
         *  ratios of 2 or 3.  Some browsers like Firefox allow you to configure the pixel ratio of the viewport.  Unless otherwise
         *  specificed, the pixel ratio will be defaulted to the actual device pixel ratio.  You can override the device pixel
         *  ratio for special situations, or, if you don't want the pixel ratio to be taken into account, you can set it to 1.
         */
    setPixelRatio: function(pixelRatio) {
      var previousRatio = this.pixelRatio;
      this.pixelRatio = pixelRatio;
      this.setSize(
        this.getWidth() / previousRatio,
        this.getHeight() / previousRatio
      );
    },
    /**
         * set width
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         */
    setWidth: function(width) {
      // take into account pixel ratio
      this.width = this._canvas.width = width * this.pixelRatio;
      this._canvas.style.width = width + 'px';

      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
         * set height
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} height
         */
    setHeight: function(height) {
      // take into account pixel ratio
      this.height = this._canvas.height = height * this.pixelRatio;
      this._canvas.style.height = height + 'px';
      var pixelRatio = this.pixelRatio,
        _context = this.getContext()._context;
      _context.scale(pixelRatio, pixelRatio);
    },
    /**
         * get width
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} width
         */
    getWidth: function() {
      return this.width;
    },
    /**
         * get height
         * @method
         * @memberof Konva.Canvas.prototype
         * @returns {Number} height
         */
    getHeight: function() {
      return this.height;
    },
    /**
         * set size
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {Number} width
         * @param {Number} height
         */
    setSize: function(width, height) {
      this.setWidth(width);
      this.setHeight(height);
    },
    /**
         * to data url
         * @method
         * @memberof Konva.Canvas.prototype
         * @param {String} mimeType
         * @param {Number} quality between 0 and 1 for jpg mime types
         * @returns {String} data url string
         */
    toDataURL: function(mimeType, quality) {
      try {
        // If this call fails (due to browser bug, like in Firefox 3.6),
        // then revert to previous no-parameter image/png behavior
        return this._canvas.toDataURL(mimeType, quality);
      } catch (e) {
        try {
          return this._canvas.toDataURL();
        } catch (err) {
          Konva.Util.warn('Unable to get data URL. ' + err.message);
          return '';
        }
      }
    }
  };

  Konva.SceneCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.SceneContext(this);
    this.setSize(width, height);
  };

  Konva.Util.extend(Konva.SceneCanvas, Konva.Canvas);

  Konva.HitCanvas = function(config) {
    var conf = config || {};
    var width = conf.width || 0,
      height = conf.height || 0;

    Konva.Canvas.call(this, conf);
    this.context = new Konva.HitContext(this);
    this.setSize(width, height);
    this.hitCanvas = true;
  };
  Konva.Util.extend(Konva.HitCanvas, Konva.Canvas);
})();

(function() {
  'use strict';
  var COMMA = ',',
    OPEN_PAREN = '(',
    CLOSE_PAREN = ')',
    OPEN_PAREN_BRACKET = '([',
    CLOSE_BRACKET_PAREN = '])',
    SEMICOLON = ';',
    DOUBLE_PAREN = '()',
    // EMPTY_STRING = '',
    EQUALS = '=',
    // SET = 'set',
    CONTEXT_METHODS = [
      'arc',
      'arcTo',
      'beginPath',
      'bezierCurveTo',
      'clearRect',
      'clip',
      'closePath',
      'createLinearGradient',
      'createPattern',
      'createRadialGradient',
      'drawImage',
      'fill',
      'fillText',
      'getImageData',
      'createImageData',
      'lineTo',
      'moveTo',
      'putImageData',
      'quadraticCurveTo',
      'rect',
      'restore',
      'rotate',
      'save',
      'scale',
      'setLineDash',
      'setTransform',
      'stroke',
      'strokeText',
      'transform',
      'translate'
    ];

  var CONTEXT_PROPERTIES = [
    'fillStyle',
    'strokeStyle',
    'shadowColor',
    'shadowBlur',
    'shadowOffsetX',
    'shadowOffsetY',
    'lineCap',
    'lineDashOffset',
    'lineJoin',
    'lineWidth',
    'miterLimit',
    'font',
    'textAlign',
    'textBaseline',
    'globalAlpha',
    'globalCompositeOperation'
  ];

  /**
   * Canvas Context constructor
   * @constructor
   * @abstract
   * @memberof Konva
   */
  Konva.Context = function(canvas) {
    this.init(canvas);
  };

  Konva.Context.prototype = {
    init: function(canvas) {
      this.canvas = canvas;
      this._context = canvas._canvas.getContext('2d');

      if (Konva.enableTrace) {
        this.traceArr = [];
        this._enableTrace();
      }
    },
    /**
     * fill shape
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    fillShape: function(shape) {
      if (shape.getFillEnabled()) {
        this._fill(shape);
      }
    },
    /**
     * stroke shape
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    strokeShape: function(shape) {
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
     * fill then stroke
     * @method
     * @memberof Konva.Context.prototype
     * @param {Konva.Shape} shape
     */
    fillStrokeShape: function(shape) {
      var fillEnabled = shape.getFillEnabled();
      if (fillEnabled) {
        this._fill(shape);
      }
      if (shape.getStrokeEnabled()) {
        this._stroke(shape);
      }
    },
    /**
     * get context trace if trace is enabled
     * @method
     * @memberof Konva.Context.prototype
     * @param {Boolean} relaxed if false, return strict context trace, which includes method names, method parameters
     *  properties, and property values.  If true, return relaxed context trace, which only returns method names and
     *  properites.
     * @returns {String}
     */
    getTrace: function(relaxed) {
      var traceArr = this.traceArr,
        len = traceArr.length,
        str = '',
        n,
        trace,
        method,
        args;

      for (n = 0; n < len; n++) {
        trace = traceArr[n];
        method = trace.method;

        // methods
        if (method) {
          args = trace.args;
          str += method;
          if (relaxed) {
            str += DOUBLE_PAREN;
          } else {
            if (Konva.Util._isArray(args[0])) {
              str +=
                OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;
            } else {
              str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;
            }
          }
        } else {
          // properties
          str += trace.property;
          if (!relaxed) {
            str += EQUALS + trace.val;
          }
        }

        str += SEMICOLON;
      }

      return str;
    },
    /**
     * clear trace if trace is enabled
     * @method
     * @memberof Konva.Context.prototype
     */
    clearTrace: function() {
      this.traceArr = [];
    },
    _trace: function(str) {
      var traceArr = this.traceArr,
        len;

      traceArr.push(str);
      len = traceArr.length;

      if (len >= Konva.traceArrMax) {
        traceArr.shift();
      }
    },
    /**
     * reset canvas context transform
     * @method
     * @memberof Konva.Context.prototype
     */
    reset: function() {
      var pixelRatio = this.getCanvas().getPixelRatio();
      this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);
    },
    /**
     * get canvas
     * @method
     * @memberof Konva.Context.prototype
     * @returns {Konva.Canvas}
     */
    getCanvas: function() {
      return this.canvas;
    },
    /**
     * clear canvas
     * @method
     * @memberof Konva.Context.prototype
     * @param {Object} [bounds]
     * @param {Number} [bounds.x]
     * @param {Number} [bounds.y]
     * @param {Number} [bounds.width]
     * @param {Number} [bounds.height]
     */
    clear: function(bounds) {
      var canvas = this.getCanvas();

      if (bounds) {
        this.clearRect(
          bounds.x || 0,
          bounds.y || 0,
          bounds.width || 0,
          bounds.height || 0
        );
      } else {
        this.clearRect(
          0,
          0,
          canvas.getWidth() / canvas.pixelRatio,
          canvas.getHeight() / canvas.pixelRatio
        );
      }
    },
    _applyLineCap: function(shape) {
      var lineCap = shape.getLineCap();
      if (lineCap) {
        this.setAttr('lineCap', lineCap);
      }
    },
    _applyOpacity: function(shape) {
      var absOpacity = shape.getAbsoluteOpacity();
      if (absOpacity !== 1) {
        this.setAttr('globalAlpha', absOpacity);
      }
    },
    _applyLineJoin: function(shape) {
      var lineJoin = shape.getLineJoin();
      if (lineJoin) {
        this.setAttr('lineJoin', lineJoin);
      }
    },
    setAttr: function(attr, val) {
      this._context[attr] = val;
    },

    // context pass through methods
    arc: function() {
      var a = arguments;
      this._context.arc(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    beginPath: function() {
      this._context.beginPath();
    },
    bezierCurveTo: function() {
      var a = arguments;
      this._context.bezierCurveTo(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    clearRect: function() {
      var a = arguments;
      this._context.clearRect(a[0], a[1], a[2], a[3]);
    },
    clip: function() {
      this._context.clip();
    },
    closePath: function() {
      this._context.closePath();
    },
    createImageData: function() {
      var a = arguments;
      if (a.length === 2) {
        return this._context.createImageData(a[0], a[1]);
      } else if (a.length === 1) {
        return this._context.createImageData(a[0]);
      }
    },
    createLinearGradient: function() {
      var a = arguments;
      return this._context.createLinearGradient(a[0], a[1], a[2], a[3]);
    },
    createPattern: function() {
      var a = arguments;
      return this._context.createPattern(a[0], a[1]);
    },
    createRadialGradient: function() {
      var a = arguments;
      return this._context.createRadialGradient(
        a[0],
        a[1],
        a[2],
        a[3],
        a[4],
        a[5]
      );
    },
    drawImage: function() {
      var a = arguments,
        _context = this._context;

      if (a.length === 3) {
        _context.drawImage(a[0], a[1], a[2]);
      } else if (a.length === 5) {
        _context.drawImage(a[0], a[1], a[2], a[3], a[4]);
      } else if (a.length === 9) {
        _context.drawImage(
          a[0],
          a[1],
          a[2],
          a[3],
          a[4],
          a[5],
          a[6],
          a[7],
          a[8]
        );
      }
    },
    isPointInPath: function(x, y) {
      return this._context.isPointInPath(x, y);
    },
    fill: function() {
      this._context.fill();
    },
    fillRect: function(x, y, width, height) {
      this._context.fillRect(x, y, width, height);
    },
    strokeRect: function(x, y, width, height) {
      this._context.strokeRect(x, y, width, height);
    },
    fillText: function() {
      var a = arguments;
      this._context.fillText(a[0], a[1], a[2]);
    },
    measureText: function(text) {
      return this._context.measureText(text);
    },
    getImageData: function() {
      var a = arguments;
      return this._context.getImageData(a[0], a[1], a[2], a[3]);
    },
    lineTo: function() {
      var a = arguments;
      this._context.lineTo(a[0], a[1]);
    },
    moveTo: function() {
      var a = arguments;
      this._context.moveTo(a[0], a[1]);
    },
    rect: function() {
      var a = arguments;
      this._context.rect(a[0], a[1], a[2], a[3]);
    },
    putImageData: function() {
      var a = arguments;
      this._context.putImageData(a[0], a[1], a[2]);
    },
    quadraticCurveTo: function() {
      var a = arguments;
      this._context.quadraticCurveTo(a[0], a[1], a[2], a[3]);
    },
    restore: function() {
      this._context.restore();
    },
    rotate: function() {
      var a = arguments;
      this._context.rotate(a[0]);
    },
    save: function() {
      this._context.save();
    },
    scale: function() {
      var a = arguments;
      this._context.scale(a[0], a[1]);
    },
    setLineDash: function() {
      var a = arguments,
        _context = this._context;

      // works for Chrome and IE11
      if (this._context.setLineDash) {
        _context.setLineDash(a[0]);
      } else if ('mozDash' in _context) {
        // verified that this works in firefox
        _context.mozDash = a[0];
      } else if ('webkitLineDash' in _context) {
        // does not currently work for Safari
        _context.webkitLineDash = a[0];
      }

      // no support for IE9 and IE10
    },
    getLineDash: function() {
      return this._context.getLineDash();
    },
    setTransform: function() {
      var a = arguments;
      this._context.setTransform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    stroke: function() {
      this._context.stroke();
    },
    strokeText: function() {
      var a = arguments;
      this._context.strokeText(a[0], a[1], a[2]);
    },
    transform: function() {
      var a = arguments;
      this._context.transform(a[0], a[1], a[2], a[3], a[4], a[5]);
    },
    translate: function() {
      var a = arguments;
      this._context.translate(a[0], a[1]);
    },
    _enableTrace: function() {
      var that = this,
        len = CONTEXT_METHODS.length,
        _simplifyArray = Konva.Util._simplifyArray,
        origSetter = this.setAttr,
        n,
        args;

      // to prevent creating scope function at each loop
      var func = function(methodName) {
        var origMethod = that[methodName],
          ret;

        that[methodName] = function() {
          args = _simplifyArray(Array.prototype.slice.call(arguments, 0));
          ret = origMethod.apply(that, arguments);

          that._trace({
            method: methodName,
            args: args
          });

          return ret;
        };
      };
      // methods
      for (n = 0; n < len; n++) {
        func(CONTEXT_METHODS[n]);
      }

      // attrs
      that.setAttr = function() {
        origSetter.apply(that, arguments);
        var prop = arguments[0];
        var val = arguments[1];
        if (
          prop === 'shadowOffsetX' ||
          prop === 'shadowOffsetY' ||
          prop === 'shadowBlur'
        ) {
          val = val / this.canvas.getPixelRatio();
        }
        that._trace({
          property: prop,
          val: val
        });
      };
    }
  };

  CONTEXT_PROPERTIES.forEach(function(prop) {
    Object.defineProperty(Konva.Context.prototype, prop, {
      get: function() {
        return this._context[prop];
      },
      set: function(val) {
        this._context[prop] = val;
      }
    });
  });

  Konva.SceneContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.SceneContext.prototype = {
    _fillColor: function(shape) {
      var fill = shape.fill();

      this.setAttr('fillStyle', fill);
      shape._fillFunc(this);
    },
    _fillPattern: function(shape) {
      var fillPatternX = shape.getFillPatternX(),
        fillPatternY = shape.getFillPatternY(),
        fillPatternScale = shape.getFillPatternScale(),
        fillPatternRotation = Konva.getAngle(shape.getFillPatternRotation()),
        fillPatternOffset = shape.getFillPatternOffset();

      if (fillPatternX || fillPatternY) {
        this.translate(fillPatternX || 0, fillPatternY || 0);
      }
      if (fillPatternRotation) {
        this.rotate(fillPatternRotation);
      }
      if (fillPatternScale) {
        this.scale(fillPatternScale.x, fillPatternScale.y);
      }
      if (fillPatternOffset) {
        this.translate(-1 * fillPatternOffset.x, -1 * fillPatternOffset.y);
      }

      this.setAttr(
        'fillStyle',
        this.createPattern(
          shape.getFillPatternImage(),
          shape.getFillPatternRepeat() || 'repeat'
        )
      );
      this.fill();
    },
    _fillLinearGradient: function(shape) {
      var start = shape.getFillLinearGradientStartPoint(),
        end = shape.getFillLinearGradientEndPoint(),
        colorStops = shape.getFillLinearGradientColorStops(),
        grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

      if (colorStops) {
        // build color stops
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        this.setAttr('fillStyle', grd);
        shape._fillFunc(this);
      }
    },
    _fillRadialGradient: function(shape) {
      var start = shape.getFillRadialGradientStartPoint(),
        end = shape.getFillRadialGradientEndPoint(),
        startRadius = shape.getFillRadialGradientStartRadius(),
        endRadius = shape.getFillRadialGradientEndRadius(),
        colorStops = shape.getFillRadialGradientColorStops(),
        grd = this.createRadialGradient(
          start.x,
          start.y,
          startRadius,
          end.x,
          end.y,
          endRadius
        );

      // build color stops
      for (var n = 0; n < colorStops.length; n += 2) {
        grd.addColorStop(colorStops[n], colorStops[n + 1]);
      }
      this.setAttr('fillStyle', grd);
      this.fill();
    },
    _fill: function(shape) {
      var hasColor = shape.fill(),
        fillPriority = shape.getFillPriority();

      // priority fills
      if (hasColor && fillPriority === 'color') {
        this._fillColor(shape);
        return;
      }

      var hasPattern = shape.getFillPatternImage();
      if (hasPattern && fillPriority === 'pattern') {
        this._fillPattern(shape);
        return;
      }

      var hasLinearGradient = shape.getFillLinearGradientColorStops();
      if (hasLinearGradient && fillPriority === 'linear-gradient') {
        this._fillLinearGradient(shape);
        return;
      }

      var hasRadialGradient = shape.getFillRadialGradientColorStops();
      if (hasRadialGradient && fillPriority === 'radial-gradient') {
        this._fillRadialGradient(shape);
        return;
      }

      // now just try and fill with whatever is available
      if (hasColor) {
        this._fillColor(shape);
      } else if (hasPattern) {
        this._fillPattern(shape);
      } else if (hasLinearGradient) {
        this._fillLinearGradient(shape);
      } else if (hasRadialGradient) {
        this._fillRadialGradient(shape);
      }
    },
    _strokeLinearGradient: function(shape) {
      var start = shape.getStrokeLinearGradientStartPoint(),
        end = shape.getStrokeLinearGradientEndPoint(),
        colorStops = shape.getStrokeLinearGradientColorStops(),
        grd = this.createLinearGradient(start.x, start.y, end.x, end.y);

      if (colorStops) {
        // build color stops
        for (var n = 0; n < colorStops.length; n += 2) {
          grd.addColorStop(colorStops[n], colorStops[n + 1]);
        }
        this.setAttr('strokeStyle', grd);
      }
    },
    _stroke: function(shape) {
      var dash = shape.dash(),
        // ignore strokeScaleEnabled for Text
        strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;

      if (shape.hasStroke()) {
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }

        this._applyLineCap(shape);
        if (dash && shape.dashEnabled()) {
          this.setLineDash(dash);
          this.setAttr('lineDashOffset', shape.dashOffset());
        }

        this.setAttr('lineWidth', shape.strokeWidth());

        if (!shape.getShadowForStrokeEnabled()) {
          this.setAttr('shadowColor', 'rgba(0,0,0,0)');
        }

        // TODO - do we need to make like a fill function?

        var hasLinearGradient = shape.getStrokeLinearGradientColorStops();
        if (hasLinearGradient) {
          this._strokeLinearGradient(shape);
        } else {
          this.setAttr('strokeStyle', shape.stroke());
        }

        shape._strokeFunc(this);

        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    },
    _applyShadow: function(shape) {
      var util = Konva.Util,
        color = util.get(shape.getShadowRGBA(), 'black'),
        blur = util.get(shape.getShadowBlur(), 5),
        offset = util.get(shape.getShadowOffset(), {
          x: 0,
          y: 0
        }),
        // TODO: get this info from transform??
        scale = shape.getAbsoluteScale(),
        ratio = this.canvas.getPixelRatio(),
        scaleX = scale.x * ratio,
        scaleY = scale.y * ratio;

      this.setAttr('shadowColor', color);
      this.setAttr(
        'shadowBlur',
        blur * Math.min(Math.abs(scaleX), Math.abs(scaleY))
      );
      this.setAttr('shadowOffsetX', offset.x * scaleX);
      this.setAttr('shadowOffsetY', offset.y * scaleY);
    },
    _applyGlobalCompositeOperation: function(shape) {
      var globalCompositeOperation = shape.getGlobalCompositeOperation();
      if (globalCompositeOperation !== 'source-over') {
        this.setAttr('globalCompositeOperation', globalCompositeOperation);
      }
    }
  };
  Konva.Util.extend(Konva.SceneContext, Konva.Context);

  Konva.HitContext = function(canvas) {
    Konva.Context.call(this, canvas);
  };

  Konva.HitContext.prototype = {
    _fill: function(shape) {
      this.save();
      this.setAttr('fillStyle', shape.colorKey);
      shape._fillFuncHit(this);
      this.restore();
    },
    _stroke: function(shape) {
      if (shape.hasStroke() && shape.strokeHitEnabled()) {
        // ignore strokeScaleEnabled for Text
        var strokeScaleEnabled =
          shape.getStrokeScaleEnabled() || shape instanceof Konva.Text;
        if (!strokeScaleEnabled) {
          this.save();
          this.setTransform(1, 0, 0, 1, 0, 0);
        }
        this._applyLineCap(shape);
        this.setAttr('lineWidth', shape.strokeWidth());
        this.setAttr('strokeStyle', shape.colorKey);
        shape._strokeFuncHit(this);
        if (!strokeScaleEnabled) {
          this.restore();
        }
      }
    }
  };
  Konva.Util.extend(Konva.HitContext, Konva.Context);
})();

(function() {
  'use strict';
  // CONSTANTS
  var GET = 'get',
    SET = 'set';

  Konva.Factory = {
    addGetterSetter: function(constructor, attr, def, validator, after) {
      this.addGetter(constructor, attr, def);
      this.addSetter(constructor, attr, validator, after);
      this.addOverloadedGetterSetter(constructor, attr);
    },
    addGetter: function(constructor, attr, def) {
      var method = GET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function() {
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
    },
    addSetter: function(constructor, attr, validator, after) {
      var method = SET + Konva.Util._capitalize(attr);

      constructor.prototype[method] = function(val) {
        if (validator) {
          val = validator.call(this, val);
        }

        this._setAttr(attr, val);

        if (after) {
          after.call(this);
        }

        return this;
      };
    },
    addComponentsGetterSetter: function(
      constructor,
      attr,
      components,
      validator,
      after
    ) {
      var len = components.length,
        capitalize = Konva.Util._capitalize,
        getter = GET + capitalize(attr),
        setter = SET + capitalize(attr),
        n,
        component;

      // getter
      constructor.prototype[getter] = function() {
        var ret = {};

        for (n = 0; n < len; n++) {
          component = components[n];
          ret[component] = this.getAttr(attr + capitalize(component));
        }

        return ret;
      };

      // setter
      constructor.prototype[setter] = function(val) {
        var oldVal = this.attrs[attr],
          key;

        if (validator) {
          val = validator.call(this, val);
        }

        for (key in val) {
          if (!val.hasOwnProperty(key)) {
            continue;
          }
          this._setAttr(attr + capitalize(key), val[key]);
        }

        this._fireChangeEvent(attr, oldVal, val);

        if (after) {
          after.call(this);
        }

        return this;
      };

      this.addOverloadedGetterSetter(constructor, attr);
    },
    addOverloadedGetterSetter: function(constructor, attr) {
      var capitalizedAttr = Konva.Util._capitalize(attr),
        setter = SET + capitalizedAttr,
        getter = GET + capitalizedAttr;

      constructor.prototype[attr] = function() {
        // setting
        if (arguments.length) {
          this[setter](arguments[0]);
          return this;
        }
        // getting
        return this[getter]();
      };
    },
    addDeprecatedGetterSetter: function(constructor, attr, def, validator) {
      Konva.Util.error('Adding deprecated ' + attr);

      var method = GET + Konva.Util._capitalize(attr);

      var message =
        attr +
        ' property is deprecated and will be removed soon. Look at Konva change log for more information.';
      constructor.prototype[method] = function() {
        Konva.Util.error(message);
        var val = this.attrs[attr];
        return val === undefined ? def : val;
      };
      this.addSetter(constructor, attr, validator, function() {
        Konva.Util.error(message);
      });
      this.addOverloadedGetterSetter(constructor, attr);
    },
    backCompat: function(constructor, methods) {
      Konva.Util.each(methods, function(oldMethodName, newMethodName) {
        var method = constructor.prototype[newMethodName];
        constructor.prototype[oldMethodName] = function() {
          method.apply(this, arguments);
          Konva.Util.error(
            oldMethodName +
              ' method is deprecated and will be removed soon. Use ' +
              newMethodName +
              ' instead'
          );
        };
      });
    },
    afterSetFilter: function() {
      this._filterUpToDate = false;
    }
  };

  Konva.Validators = {
    /**
     * @return {number}
     */
    RGBComponent: function(val) {
      if (val > 255) {
        return 255;
      } else if (val < 0) {
        return 0;
      }
      return Math.round(val);
    },
    alphaComponent: function(val) {
      if (val > 1) {
        return 1;
      } else if (val < 0.0001) {
        // chrome does not honor alpha values of 0
        return 0.0001;
      }

      return val;
    }
  };
})();

(function(Konva) {
  'use strict';
  // CONSTANTS
  var ABSOLUTE_OPACITY = 'absoluteOpacity',
    ABSOLUTE_TRANSFORM = 'absoluteTransform',
    ABSOLUTE_SCALE = 'absoluteScale',
    CHANGE = 'Change',
    CHILDREN = 'children',
    DOT = '.',
    EMPTY_STRING = '',
    GET = 'get',
    ID = 'id',
    KONVA = 'konva',
    LISTENING = 'listening',
    MOUSEENTER = 'mouseenter',
    MOUSELEAVE = 'mouseleave',
    NAME = 'name',
    SET = 'set',
    SHAPE = 'Shape',
    SPACE = ' ',
    STAGE = 'stage',
    TRANSFORM = 'transform',
    UPPER_STAGE = 'Stage',
    VISIBLE = 'visible',
    CLONE_BLACK_LIST = ['id'],
    TRANSFORM_CHANGE_STR = [
      'xChange.konva',
      'yChange.konva',
      'scaleXChange.konva',
      'scaleYChange.konva',
      'skewXChange.konva',
      'skewYChange.konva',
      'rotationChange.konva',
      'offsetXChange.konva',
      'offsetYChange.konva',
      'transformsEnabledChange.konva'
    ].join(SPACE),
    SCALE_CHANGE_STR = ['scaleXChange.konva', 'scaleYChange.konva'].join(SPACE);

  /**
   * Node constructor. Nodes are entities that can be transformed, layered,
   * and have bound events. The stage, layers, groups, and shapes all extend Node.
   * @constructor
   * @memberof Konva
   * @abstract
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   */
  Konva.Node = function(config) {
    this._init(config);
  };

  Konva.Util.addMethods(Konva.Node, {
    _init: function(config) {
      this._id = Konva.idCounter++;
      this.eventListeners = {};
      this.attrs = {};
      this._cache = {};
      this._filterUpToDate = false;
      this._isUnderCache = false;
      this.setAttrs(config);

      // event bindings for cache handling
      this.on(TRANSFORM_CHANGE_STR, function() {
        this._clearCache(TRANSFORM);
        this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      });

      this.on(SCALE_CHANGE_STR, function() {
        this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);
      });

      this.on('visibleChange.konva', function() {
        this._clearSelfAndDescendantCache(VISIBLE);
      });
      this.on('listeningChange.konva', function() {
        this._clearSelfAndDescendantCache(LISTENING);
      });
      this.on('opacityChange.konva', function() {
        this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      });
    },
    _clearCache: function(attr) {
      if (attr) {
        delete this._cache[attr];
      } else {
        this._cache = {};
      }
    },
    _getCache: function(attr, privateGetter) {
      var cache = this._cache[attr];

      // if not cached, we need to set it using the private getter method.
      if (cache === undefined) {
        this._cache[attr] = privateGetter.call(this);
      }

      return this._cache[attr];
    },
    /*
         * when the logic for a cached result depends on ancestor propagation, use this
         * method to clear self and children cache
         */
    _clearSelfAndDescendantCache: function(attr) {
      this._clearCache(attr);

      if (this.children) {
        this.getChildren().each(function(node) {
          node._clearSelfAndDescendantCache(attr);
        });
      }
    },
    /**
     * clear cached canvas
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     * @example
     * node.clearCache();
     */
    clearCache: function() {
      delete this._cache.canvas;
      this._filterUpToDate = false;
      return this;
    },
    /**
     *  cache node to improve drawing performance, apply filters, or create more accurate
     *  hit regions. For all basic shapes size of cache canvas will be automatically detected.
     *  If you need to cache your custom `Konva.Shape` instance you have to pass shape's bounding box
     *  properties. Look at [https://konvajs.github.io/docs/performance/Shape_Caching.html](link to demo page) for more information.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} [config]
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Number} [config.offset]  increase canvas size by `offset` pixel in all directions.
     * @param {Boolean} [config.drawBorder] when set to true, a red border will be drawn around the cached
     *  region for debugging purposes
     * @param {Number} [config.pixelRatio] change quality (or pixel ratio) of cached image. pixelRatio = 2 will produce 2x sized cache.
     * @returns {Konva.Node}
     * @example
     * // cache a shape with the x,y position of the bounding box at the center and
     * // the width and height of the bounding box equal to the width and height of
     * // the shape obtained from shape.width() and shape.height()
     * image.cache();
     *
     * // cache a node and define the bounding box position and size
     * node.cache({
     *   x: -30,
     *   y: -30,
     *   width: 100,
     *   height: 200
     * });
     *
     * // cache a node and draw a red border around the bounding box
     * // for debugging purposes
     * node.cache({
     *   x: -30,
     *   y: -30,
     *   width: 100,
     *   height: 200,
     *   offset : 10,
     *   drawBorder: true
     * });
     */
    cache: function(config) {
      var conf = config || {},
        rect = this.getClientRect({
          skipTransform: true,
          relativeTo: this.getParent()
        }),
        width = conf.width || rect.width,
        height = conf.height || rect.height,
        pixelRatio = conf.pixelRatio,
        x = conf.x || rect.x,
        y = conf.y || rect.y,
        offset = conf.offset || 0,
        drawBorder = conf.drawBorder || false;

      if (!width || !height) {
        // make throw async, because we don't need to stop funcion
        setTimeout(function() {
          Konva.Util.throw(
            'Width or height of caching configuration equals 0. Caching is ignored.'
          );
        });
        return;
      }

      width += offset * 2;
      height += offset * 2;

      x -= offset;
      y -= offset;

      var cachedSceneCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedFilterCanvas = new Konva.SceneCanvas({
          pixelRatio: pixelRatio,
          width: width,
          height: height
        }),
        cachedHitCanvas = new Konva.HitCanvas({
          pixelRatio: 1,
          width: width,
          height: height
        }),
        sceneContext = cachedSceneCanvas.getContext(),
        hitContext = cachedHitCanvas.getContext();

      cachedHitCanvas.isCache = true;

      this.clearCache();

      sceneContext.save();
      hitContext.save();

      sceneContext.translate(-x, -y);
      hitContext.translate(-x, -y);

      // extra flag to skip on getAbsolute opacity calc
      this._isUnderCache = true;
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);
      this._clearSelfAndDescendantCache(ABSOLUTE_SCALE);

      this.drawScene(cachedSceneCanvas, this, true);
      this.drawHit(cachedHitCanvas, this, true);
      this._isUnderCache = false;

      sceneContext.restore();
      hitContext.restore();

      // this will draw a red border around the cached box for
      // debugging purposes
      if (drawBorder) {
        sceneContext.save();
        sceneContext.beginPath();
        sceneContext.rect(0, 0, width, height);
        sceneContext.closePath();
        sceneContext.setAttr('strokeStyle', 'red');
        sceneContext.setAttr('lineWidth', 5);
        sceneContext.stroke();
        sceneContext.restore();
      }

      this._cache.canvas = {
        scene: cachedSceneCanvas,
        filter: cachedFilterCanvas,
        hit: cachedHitCanvas,
        x: x,
        y: y
      };

      return this;
    },
    /**
     * Return client rectangle {x, y, width, height} of node. This rectangle also include all styling (strokes, shadows, etc).
     * The rectangle position is relative to parent container.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Boolean} [config.skipTransform] should we apply transform to node for calculating rect?
     * @param {Object} [config.relativeTo] calculate client rect relative to one of the parents
     * @returns {Object} rect with {x, y, width, height} properties
     * @example
     * var rect = new Konva.Rect({
     *      width : 100,
     *      height : 100,
     *      x : 50,
     *      y : 50,
     *      strokeWidth : 4,
     *      stroke : 'black',
     *      offsetX : 50,
     *      scaleY : 2
     * });
     *
     * // get client rect without think off transformations (position, rotation, scale, offset, etc)
     * rect.getClientRect({ skipTransform: true});
     * // returns {
     * //     x : -2,   // two pixels for stroke / 2
     * //     y : -2,
     * //     width : 104, // increased by 4 for stroke
     * //     height : 104
     * //}
     *
     * // get client rect with transformation applied
     * rect.getClientRect();
     * // returns Object {x: -2, y: 46, width: 104, height: 208}
     */
    getClientRect: function() {
      // abstract method
      // redefine in Container and Shape
      throw new Error('abstract "getClientRect" method call');
    },
    _transformedRect: function(rect, top) {
      var points = [
        { x: rect.x, y: rect.y },
        { x: rect.x + rect.width, y: rect.y },
        { x: rect.x + rect.width, y: rect.y + rect.height },
        { x: rect.x, y: rect.y + rect.height }
      ];
      var minX, minY, maxX, maxY;
      var trans = this.getAbsoluteTransform(top);
      points.forEach(function(point) {
        var transformed = trans.point(point);
        if (minX === undefined) {
          minX = maxX = transformed.x;
          minY = maxY = transformed.y;
        }
        minX = Math.min(minX, transformed.x);
        minY = Math.min(minY, transformed.y);
        maxX = Math.max(maxX, transformed.x);
        maxY = Math.max(maxY, transformed.y);
      });
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    },
    _drawCachedSceneCanvas: function(context) {
      context.save();
      context._applyOpacity(this);
      context._applyGlobalCompositeOperation(this);
      context.translate(this._cache.canvas.x, this._cache.canvas.y);

      var cacheCanvas = this._getCachedSceneCanvas();
      var ratio = cacheCanvas.pixelRatio;

      context.drawImage(
        cacheCanvas._canvas,
        0,
        0,
        cacheCanvas.width / ratio,
        cacheCanvas.height / ratio
      );
      context.restore();
    },
    _drawCachedHitCanvas: function(context) {
      var cachedCanvas = this._cache.canvas,
        hitCanvas = cachedCanvas.hit;
      context.save();
      context.translate(this._cache.canvas.x, this._cache.canvas.y);
      context.drawImage(hitCanvas._canvas, 0, 0);
      context.restore();
    },
    _getCachedSceneCanvas: function() {
      var filters = this.filters(),
        cachedCanvas = this._cache.canvas,
        sceneCanvas = cachedCanvas.scene,
        filterCanvas = cachedCanvas.filter,
        filterContext = filterCanvas.getContext(),
        len,
        imageData,
        n,
        filter;

      if (filters) {
        if (!this._filterUpToDate) {
          var ratio = sceneCanvas.pixelRatio;

          try {
            len = filters.length;
            filterContext.clear();

            // copy cached canvas onto filter context
            filterContext.drawImage(
              sceneCanvas._canvas,
              0,
              0,
              sceneCanvas.getWidth() / ratio,
              sceneCanvas.getHeight() / ratio
            );
            imageData = filterContext.getImageData(
              0,
              0,
              filterCanvas.getWidth(),
              filterCanvas.getHeight()
            );

            // apply filters to filter context
            for (n = 0; n < len; n++) {
              filter = filters[n];
              if (typeof filter !== 'function') {
                Konva.Util.error(
                  'Filter should be type of function, but got ' +
                    typeof filter +
                    ' insted. Please check correct filters'
                );
                continue;
              }
              filter.call(this, imageData);
              filterContext.putImageData(imageData, 0, 0);
            }
          } catch (e) {
            Konva.Util.error('Unable to apply filter. ' + e.message);
          }

          this._filterUpToDate = true;
        }

        return filterCanvas;
      }
      return sceneCanvas;
    },
    /**
     * bind events to the node. KonvaJS supports mouseover, mousemove,
     *  mouseout, mouseenter, mouseleave, mousedown, mouseup, wheel, contextmenu, click, dblclick, touchstart, touchmove,
     *  touchend, tap, dbltap, dragstart, dragmove, and dragend events. The Konva Stage supports
     *  contentMouseover, contentMousemove, contentMouseout, contentMousedown, contentMouseup, contentWheel, contentContextmenu
     *  contentClick, contentDblclick, contentTouchstart, contentTouchmove, contentTouchend, contentTap,
     *  and contentDblTap.  Pass in a string of events delimited by a space to bind multiple events at once
     *  such as 'mousedown mouseup mousemove'. Include a namespace to bind an
     *  event by name such as 'click.foobar'.
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', 'mousedown.foo touchstart.foo'
     * @param {Function} handler The handler function is passed an event object
     * @returns {Konva.Node}
     * @example
     * // add click listener
     * node.on('click', function() {
     *   console.log('you clicked me!');
     * });
     *
     * // get the target node
     * node.on('click', function(evt) {
     *   console.log(evt.target);
     * });
     *
     * // stop event propagation
     * node.on('click', function(evt) {
     *   evt.cancelBubble = true;
     * });
     *
     * // bind multiple listeners
     * node.on('click touchstart', function() {
     *   console.log('you clicked/touched me!');
     * });
     *
     * // namespace listener
     * node.on('click.foo', function() {
     *   console.log('you clicked/touched me!');
     * });
     *
     * // get the event type
     * node.on('click tap', function(evt) {
     *   var eventType = evt.type;
     * });
     *
     * // get native event object
     * node.on('click tap', function(evt) {
     *   var nativeEvent = evt.evt;
     * });
     *
     * // for change events, get the old and new val
     * node.on('xChange', function(evt) {
     *   var oldVal = evt.oldVal;
     *   var newVal = evt.newVal;
     * });
     *
     * // get event targets
     * // with event delegations
     * layer.on('click', 'Group', function(evt) {
     *   var shape = evt.target;
     *   var group = evtn.currentTarger;
     * });
     */
    on: function(evtStr, handler) {
      if (arguments.length === 3) {
        return this._delegate.apply(this, arguments);
      }
      var events = evtStr.split(SPACE),
        len = events.length,
        n,
        event,
        parts,
        baseEvent,
        name;

      /*
             * loop through types and attach event listeners to
             * each one.  eg. 'click mouseover.namespace mouseout'
             * will create three event bindings
             */
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1] || EMPTY_STRING;

        // create events array if it doesn't exist
        if (!this.eventListeners[baseEvent]) {
          this.eventListeners[baseEvent] = [];
        }

        this.eventListeners[baseEvent].push({
          name: name,
          handler: handler
        });
      }

      return this;
    },
    /**
     * remove event bindings from the node. Pass in a string of
     *  event types delimmited by a space to remove multiple event
     *  bindings at once such as 'mousedown mouseup mousemove'.
     *  include a namespace to remove an event binding by name
     *  such as 'click.foobar'. If you only give a name like '.foobar',
     *  all events in that namespace will be removed.
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} evtStr e.g. 'click', 'mousedown touchstart', '.foobar'
     * @returns {Konva.Node}
     * @example
     * // remove listener
     * node.off('click');
     *
     * // remove multiple listeners
     * node.off('click touchstart');
     *
     * // remove listener by name
     * node.off('click.foo');
     */
    off: function(evtStr, callback) {
      var events = (evtStr || '').split(SPACE),
        len = events.length,
        n,
        t,
        event,
        parts,
        baseEvent,
        name;

      if (!evtStr) {
        // remove all events
        for (t in this.eventListeners) {
          this._off(t);
        }
      }
      for (n = 0; n < len; n++) {
        event = events[n];
        parts = event.split(DOT);
        baseEvent = parts[0];
        name = parts[1];

        if (baseEvent) {
          if (this.eventListeners[baseEvent]) {
            this._off(baseEvent, name, callback);
          }
        } else {
          for (t in this.eventListeners) {
            this._off(t, name, callback);
          }
        }
      }
      return this;
    },
    // some event aliases for third party integration like HammerJS
    dispatchEvent: function(evt) {
      var e = {
        target: this,
        type: evt.type,
        evt: evt
      };
      this.fire(evt.type, e);
      return this;
    },
    addEventListener: function(type, handler) {
      // we have to pass native event to handler
      this.on(type, function(evt) {
        handler.call(this, evt.evt);
      });
      return this;
    },
    removeEventListener: function(type) {
      this.off(type);
      return this;
    },
    // like node.on
    _delegate: function(event, selector, handler) {
      var stopNode = this;
      this.on(event, function(evt) {
        var targets = evt.target.findAncestors(selector, true, stopNode);
        for (var i = 0; i < targets.length; i++) {
          evt = Konva.Util.cloneObject(evt);
          evt.currentTarget = targets[i];
          handler.call(targets[i], evt);
        }
      });
    },
    /**
     * remove self from parent, but don't destroy
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     * @example
     * node.remove();
     */
    remove: function() {
      var parent = this.getParent();

      if (parent && parent.children) {
        parent.children.splice(this.index, 1);
        parent._setChildrenIndices();
        delete this.parent;
      }

      // every cached attr that is calculated via node tree
      // traversal must be cleared when removing a node
      this._clearSelfAndDescendantCache(STAGE);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
      this._clearSelfAndDescendantCache(VISIBLE);
      this._clearSelfAndDescendantCache(LISTENING);
      this._clearSelfAndDescendantCache(ABSOLUTE_OPACITY);

      return this;
    },
    /**
     * remove and destroy self
     * @method
     * @memberof Konva.Node.prototype
     * @example
     * node.destroy();
     */
    destroy: function() {
      // remove from ids and names hashes
      Konva._removeId(this.getId());

      // remove all names
      var names = (this.getName() || '').split(/\s/g);
      for (var i = 0; i < names.length; i++) {
        var subname = names[i];
        Konva._removeName(subname, this._id);
      }

      this.remove();
      return this;
    },
    /**
     * get attr
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} attr
     * @returns {Integer|String|Object|Array}
     * @example
     * var x = node.getAttr('x');
     */
    getAttr: function(attr) {
      var method = GET + Konva.Util._capitalize(attr);
      if (Konva.Util._isFunction(this[method])) {
        return this[method]();
      }
      // otherwise get directly
      return this.attrs[attr];
    },
    /**
     * get ancestors
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Collection}
     * @example
     * shape.getAncestors().each(function(node) {
     *   console.log(node.getId());
     * })
     */
    getAncestors: function() {
      var parent = this.getParent(),
        ancestors = new Konva.Collection();

      while (parent) {
        ancestors.push(parent);
        parent = parent.getParent();
      }

      return ancestors;
    },
    /**
     * get attrs object literal
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    getAttrs: function() {
      return this.attrs || {};
    },
    /**
     * set multiple attrs at once using an object literal
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config object containing key value pairs
     * @returns {Konva.Node}
     * @example
     * node.setAttrs({
     *   x: 5,
     *   fill: 'red'
     * });
     */
    setAttrs: function(config) {
      var key, method;

      if (!config) {
        return this;
      }
      for (key in config) {
        if (key === CHILDREN) {
          continue;
        }
        method = SET + Konva.Util._capitalize(key);
        // use setter if available
        if (Konva.Util._isFunction(this[method])) {
          this[method](config[key]);
        } else {
          // otherwise set directly
          this._setAttr(key, config[key]);
        }
      }
      return this;
    },
    /**
     * determine if node is listening for events by taking into account ancestors.
     *
     * Parent    | Self      | isListening
     * listening | listening |
     * ----------+-----------+------------
     * T         | T         | T
     * T         | F         | F
     * F         | T         | T
     * F         | F         | F
     * ----------+-----------+------------
     * T         | I         | T
     * F         | I         | F
     * I         | I         | T
     *
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    isListening: function() {
      return this._getCache(LISTENING, this._isListening);
    },
    _isListening: function() {
      var listening = this.getListening(),
        parent = this.getParent();

      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (listening === 'inherit') {
        if (parent) {
          return parent.isListening();
        } else {
          return true;
        }
      } else {
        return listening;
      }
    },
    /**
     * determine if node is visible by taking into account ancestors.
     *
     * Parent    | Self      | isVisible
     * visible   | visible   |
     * ----------+-----------+------------
     * T         | T         | T
     * T         | F         | F
     * F         | T         | T
     * F         | F         | F
     * ----------+-----------+------------
     * T         | I         | T
     * F         | I         | F
     * I         | I         | T

      * @method
      * @memberof Konva.Node.prototype
      * @returns {Boolean}
      */
    isVisible: function() {
      return this._getCache(VISIBLE, this._isVisible);
    },
    _isVisible: function() {
      var visible = this.getVisible(),
        parent = this.getParent();

      // the following conditions are a simplification of the truth table above.
      // please modify carefully
      if (visible === 'inherit') {
        if (parent) {
          return parent.isVisible();
        } else {
          return true;
        }
      } else {
        return visible;
      }
    },
    /**
     * determine if listening is enabled by taking into account descendants.  If self or any children
     * have _isListeningEnabled set to true, then self also has listening enabled.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    shouldDrawHit: function(canvas) {
      var layer = this.getLayer();
      return (
        (canvas && canvas.isCache) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isListening() &&
          this.isVisible())
      );
    },
    /**
     * show node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    show: function() {
      this.setVisible(true);
      return this;
    },
    /**
     * hide node.  Hidden nodes are no longer detectable
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    hide: function() {
      this.setVisible(false);
      return this;
    },
    /**
     * get zIndex relative to the node's siblings who share the same parent
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getZIndex: function() {
      return this.index || 0;
    },
    /**
     * get absolute z-index which takes into account sibling
     *  and ancestor indices
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getAbsoluteZIndex: function() {
      var depth = this.getDepth(),
        that = this,
        index = 0,
        nodes,
        len,
        n,
        child;

      function addChildren(children) {
        nodes = [];
        len = children.length;
        for (n = 0; n < len; n++) {
          child = children[n];
          index++;

          if (child.nodeType !== SHAPE) {
            nodes = nodes.concat(child.getChildren().toArray());
          }

          if (child._id === that._id) {
            n = len;
          }
        }

        if (nodes.length > 0 && nodes[0].getDepth() <= depth) {
          addChildren(nodes);
        }
      }
      if (that.nodeType !== UPPER_STAGE) {
        addChildren(that.getStage().getChildren());
      }

      return index;
    },
    /**
     * get node depth in node tree.  Returns an integer.
     *  e.g. Stage depth will always be 0.  Layers will always be 1.  Groups and Shapes will always
     *  be >= 2
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Integer}
     */
    getDepth: function() {
      var depth = 0,
        parent = this.parent;

      while (parent) {
        depth++;
        parent = parent.parent;
      }
      return depth;
    },
    setPosition: function(pos) {
      this.setX(pos.x);
      this.setY(pos.y);
      return this;
    },
    getPosition: function() {
      return {
        x: this.getX(),
        y: this.getY()
      };
    },
    /**
     * get absolute position relative to the top left corner of the stage container div
     * or relative to passed node
     * @method
     * @param {Object} [top] optional parent node
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    getAbsolutePosition: function(top) {
      var absoluteMatrix = this.getAbsoluteTransform(top).getMatrix(),
        absoluteTransform = new Konva.Transform(),
        offset = this.offset();

      // clone the matrix array
      absoluteTransform.m = absoluteMatrix.slice();
      absoluteTransform.translate(offset.x, offset.y);

      return absoluteTransform.getTranslation();
    },
    /**
     * set absolute position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Konva.Node}
     */
    setAbsolutePosition: function(pos) {
      var origTrans = this._clearTransform(),
        it;

      // don't clear translation
      this.attrs.x = origTrans.x;
      this.attrs.y = origTrans.y;
      delete origTrans.x;
      delete origTrans.y;

      // unravel transform
      it = this.getAbsoluteTransform();

      it.invert();
      it.translate(pos.x, pos.y);
      pos = {
        x: this.attrs.x + it.getTranslation().x,
        y: this.attrs.y + it.getTranslation().y
      };

      this.setPosition({ x: pos.x, y: pos.y });
      this._setTransform(origTrans);

      return this;
    },
    _setTransform: function(trans) {
      var key;

      for (key in trans) {
        this.attrs[key] = trans[key];
      }

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);
    },
    _clearTransform: function() {
      var trans = {
        x: this.getX(),
        y: this.getY(),
        rotation: this.getRotation(),
        scaleX: this.getScaleX(),
        scaleY: this.getScaleY(),
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        skewX: this.getSkewX(),
        skewY: this.getSkewY()
      };

      this.attrs.x = 0;
      this.attrs.y = 0;
      this.attrs.rotation = 0;
      this.attrs.scaleX = 1;
      this.attrs.scaleY = 1;
      this.attrs.offsetX = 0;
      this.attrs.offsetY = 0;
      this.attrs.skewX = 0;
      this.attrs.skewY = 0;

      this._clearCache(TRANSFORM);
      this._clearSelfAndDescendantCache(ABSOLUTE_TRANSFORM);

      // return original transform
      return trans;
    },
    /**
     * move node by an amount relative to its current position
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} change
     * @param {Number} change.x
     * @param {Number} change.y
     * @returns {Konva.Node}
     * @example
     * // move node in x direction by 1px and y direction by 2px
     * node.move({
     *   x: 1,
     *   y: 2)
     * });
     */
    move: function(change) {
      var changeX = change.x,
        changeY = change.y,
        x = this.getX(),
        y = this.getY();

      if (changeX !== undefined) {
        x += changeX;
      }

      if (changeY !== undefined) {
        y += changeY;
      }

      this.setPosition({ x: x, y: y });
      return this;
    },
    _eachAncestorReverse: function(func, top) {
      var family = [],
        parent = this.getParent(),
        len,
        n;

      // if top node is defined, and this node is top node,
      // there's no need to build a family tree.  just execute
      // func with this because it will be the only node
      if (top && top._id === this._id) {
        func(this);
        return true;
      }

      family.unshift(this);

      while (parent && (!top || parent._id !== top._id)) {
        family.unshift(parent);
        parent = parent.parent;
      }

      len = family.length;
      for (n = 0; n < len; n++) {
        func(family[n]);
      }
    },
    /**
     * rotate node by an amount in degrees relative to its current rotation
     * @method
     * @memberof Konva.Node.prototype
     * @param {Number} theta
     * @returns {Konva.Node}
     */
    rotate: function(theta) {
      this.setRotation(this.getRotation() + theta);
      return this;
    },
    /**
     * move node to the top of its siblings
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveToTop: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveToTop function is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.push(this);
      this.parent._setChildrenIndices();
      return true;
    },
    /**
     * move node up
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean} flag is moved or not
     */
    moveUp: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveUp function is ignored.');
        return false;
      }
      var index = this.index,
        len = this.parent.getChildren().length;
      if (index < len - 1) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index + 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * move node down
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveDown: function() {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. moveDown function is ignored.');
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.splice(index - 1, 0, this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * move node to the bottom of its siblings
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Boolean}
     */
    moveToBottom: function() {
      if (!this.parent) {
        Konva.Util.warn(
          'Node has no parent. moveToBottom function is ignored.'
        );
        return false;
      }
      var index = this.index;
      if (index > 0) {
        this.parent.children.splice(index, 1);
        this.parent.children.unshift(this);
        this.parent._setChildrenIndices();
        return true;
      }
      return false;
    },
    /**
     * set zIndex relative to siblings
     * @method
     * @memberof Konva.Node.prototype
     * @param {Integer} zIndex
     * @returns {Konva.Node}
     */
    setZIndex: function(zIndex) {
      if (!this.parent) {
        Konva.Util.warn('Node has no parent. zIndex parameter is ignored.');
        return false;
      }
      var index = this.index;
      this.parent.children.splice(index, 1);
      this.parent.children.splice(zIndex, 0, this);
      this.parent._setChildrenIndices();
      return this;
    },
    /**
     * get absolute opacity
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Number}
     */
    getAbsoluteOpacity: function() {
      return this._getCache(ABSOLUTE_OPACITY, this._getAbsoluteOpacity);
    },
    _getAbsoluteOpacity: function() {
      var absOpacity = this.getOpacity();
      var parent = this.getParent();
      if (parent && !parent._isUnderCache) {
        absOpacity *= this.getParent().getAbsoluteOpacity();
      }
      return absOpacity;
    },
    /**
     * move node to another container
     * @method
     * @memberof Konva.Node.prototype
     * @param {Container} newContainer
     * @returns {Konva.Node}
     * @example
     * // move node from current layer into layer2
     * node.moveTo(layer2);
     */
    moveTo: function(newContainer) {
      // do nothing if new container is already parent
      if (this.getParent() !== newContainer) {
        // this.remove my be overrided by drag and drop
        // buy we need original
        (this.__originalRemove || this.remove).call(this);
        newContainer.add(this);
      }
      return this;
    },
    /**
     * convert Node into an object for serialization.  Returns an object.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Object}
     */
    toObject: function() {
      var obj = {},
        attrs = this.getAttrs(),
        key,
        val,
        getter,
        defaultValue;

      obj.attrs = {};

      for (key in attrs) {
        val = attrs[key];
        getter = this[key];
        // remove attr value so that we can extract the default value from the getter
        delete attrs[key];
        defaultValue = getter ? getter.call(this) : null;
        // restore attr value
        attrs[key] = val;
        if (defaultValue !== val) {
          obj.attrs[key] = val;
        }
      }

      obj.className = this.getClassName();
      return Konva.Util._prepareToStringify(obj);
    },
    /**
     * convert Node into a JSON string.  Returns a JSON string.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}}
     */
    toJSON: function() {
      return JSON.stringify(this.toObject());
    },
    /**
     * get parent container
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    getParent: function() {
      return this.parent;
    },
    /**
     * get all ancestros (parent then parent of the parent, etc) of the node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} [selector] selector for search
     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
     * @returns {Array} [ancestors]
     * @example
     * // get one of the parent group
     * var parentGroups = node.findAncestors('Group');
     */
    findAncestors: function(selector, includeSelf, stopNode) {
      var res = [];

      if (includeSelf && this._isMatch(selector)) {
        res.push(this);
      }
      var ancestor = this.parent;
      while (ancestor) {
        if (ancestor === stopNode) {
          return res;
        }
        if (ancestor._isMatch(selector)) {
          res.push(ancestor);
        }
        ancestor = ancestor.parent;
      }
      return res;
    },
    /**
     * get ancestor (parent or parent of the parent, etc) of the node that match passed selector
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} [selector] selector for search
     * @param {Boolean} [includeSelf] show we think that node is ancestro itself?
     * @param {Konva.Node} [stopNode] optional node where we need to stop searching (one of ancestors)
     * @returns {Konva.Node} ancestor
     * @example
     * // get one of the parent group
     * var group = node.findAncestors('.mygroup');
     */
    findAncestor: function(selector, includeSelf, stopNode) {
      return this.findAncestors(selector, includeSelf, stopNode)[0];
    },
    // is current node match passed selector?
    _isMatch: function(selector) {
      if (!selector) {
        return false;
      }
      var selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        sel;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          Konva.Util.warn(
            'Selector "' +
              sel +
              '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'
          );
          Konva.Util.warn(
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'
          );
          Konva.Util.warn('Konva is awesome, right?');
        }
        // id selector
        if (sel.charAt(0) === '#') {
          if (this.id() === sel.slice(1)) {
            return true;
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          if (this.hasName(sel.slice(1))) {
            return true;
          }
        } else if (this._get(sel).length !== 0) {
          return true;
        }
      }
      return false;
    },
    /**
     * get layer ancestor
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Layer}
     */
    getLayer: function() {
      var parent = this.getParent();
      return parent ? parent.getLayer() : null;
    },
    /**
     * get stage ancestor
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Stage}
     */
    getStage: function() {
      return this._getCache(STAGE, this._getStage);
    },
    _getStage: function() {
      var parent = this.getParent();
      if (parent) {
        return parent.getStage();
      } else {
        return undefined;
      }
    },
    /**
     * fire event
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} eventType event type.  can be a regular event, like click, mouseover, or mouseout, or it can be a custom event, like myCustomEvent
     * @param {Event} [evt] event object
     * @param {Boolean} [bubble] setting the value to false, or leaving it undefined, will result in the event
     *  not bubbling.  Setting the value to true will result in the event bubbling.
     * @returns {Konva.Node}
     * @example
     * // manually fire click event
     * node.fire('click');
     *
     * // fire custom event
     * node.fire('foo');
     *
     * // fire custom event with custom event object
     * node.fire('foo', {
     *   bar: 10
     * });
     *
     * // fire click event that bubbles
     * node.fire('click', null, true);
     */
    fire: function(eventType, evt, bubble) {
      evt = evt || {};
      evt.target = evt.target || this;
      // bubble
      if (bubble) {
        this._fireAndBubble(eventType, evt);
      } else {
        // no bubble
        this._fire(eventType, evt);
      }
      return this;
    },
    /**
     * get absolute transform of the node which takes into
     *  account its ancestor transforms
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getAbsoluteTransform: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteTransform(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_TRANSFORM, this._getAbsoluteTransform);
      }
    },
    _getAbsoluteTransform: function(top) {
      var at = new Konva.Transform(),
        transformsEnabled,
        trans;

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        transformsEnabled = node.transformsEnabled();
        trans = node.getTransform();

        if (transformsEnabled === 'all') {
          at.multiply(trans);
        } else if (transformsEnabled === 'position') {
          at.translate(node.x(), node.y());
        }
      }, top);
      return at;
    },
    /**
     * get absolute scale of the node which takes into
     *  account its ancestor scales
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getAbsoluteScale: function(top) {
      // if using an argument, we can't cache the result.
      if (top) {
        return this._getAbsoluteScale(top);
      } else {
        // if no argument, we can cache the result
        return this._getCache(ABSOLUTE_SCALE, this._getAbsoluteScale);
      }
    },
    _getAbsoluteScale: function(top) {
      // this is special logic for caching with some shapes with shadow
      var parent = this;
      while (parent) {
        if (parent._isUnderCache) {
          top = parent;
        }
        parent = parent.getParent();
      }

      var scaleX = 1,
        scaleY = 1;

      // start with stage and traverse downwards to self
      this._eachAncestorReverse(function(node) {
        scaleX *= node.scaleX();
        scaleY *= node.scaleY();
      }, top);
      return {
        x: scaleX,
        y: scaleY
      };
    },
    /**
     * get transform of the node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Transform}
     */
    getTransform: function() {
      return this._getCache(TRANSFORM, this._getTransform);
    },
    _getTransform: function() {
      var m = new Konva.Transform(),
        x = this.getX(),
        y = this.getY(),
        rotation = Konva.getAngle(this.getRotation()),
        scaleX = this.getScaleX(),
        scaleY = this.getScaleY(),
        skewX = this.getSkewX(),
        skewY = this.getSkewY(),
        offsetX = this.getOffsetX(),
        offsetY = this.getOffsetY();

      if (x !== 0 || y !== 0) {
        m.translate(x, y);
      }
      if (rotation !== 0) {
        m.rotate(rotation);
      }
      if (skewX !== 0 || skewY !== 0) {
        m.skew(skewX, skewY);
      }
      if (scaleX !== 1 || scaleY !== 1) {
        m.scale(scaleX, scaleY);
      }
      if (offsetX !== 0 || offsetY !== 0) {
        m.translate(-1 * offsetX, -1 * offsetY);
      }

      return m;
    },
    /**
     * clone node.  Returns a new Node instance with identical attributes.  You can also override
     *  the node properties with an object literal, enabling you to use an existing node as a template
     *  for another node
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} obj override attrs
     * @returns {Konva.Node}
     * @example
     * // simple clone
     * var clone = node.clone();
     *
     * // clone a node and override the x position
     * var clone = rect.clone({
     *   x: 5
     * });
     */
    clone: function(obj) {
      // instantiate new node
      var attrs = Konva.Util.cloneObject(this.attrs),
        key,
        allListeners,
        len,
        n,
        listener;
      // filter black attrs
      for (var i in CLONE_BLACK_LIST) {
        var blockAttr = CLONE_BLACK_LIST[i];
        delete attrs[blockAttr];
      }
      // apply attr overrides
      for (key in obj) {
        attrs[key] = obj[key];
      }

      var node = new this.constructor(attrs);
      // copy over listeners
      for (key in this.eventListeners) {
        allListeners = this.eventListeners[key];
        len = allListeners.length;
        for (n = 0; n < len; n++) {
          listener = allListeners[n];
          /*
                     * don't include konva namespaced listeners because
                     *  these are generated by the constructors
                     */
          if (listener.name.indexOf(KONVA) < 0) {
            // if listeners array doesn't exist, then create it
            if (!node.eventListeners[key]) {
              node.eventListeners[key] = [];
            }
            node.eventListeners[key].push(listener);
          }
        }
      }
      return node;
    },
    _toKonvaCanvas: function(config) {
      config = config || {};

      var stage = this.getStage(),
        x = config.x || 0,
        y = config.y || 0,
        pixelRatio = config.pixelRatio || 1,
        canvas = new Konva.SceneCanvas({
          width:
            config.width || this.getWidth() || (stage ? stage.getWidth() : 0),
          height:
            config.height ||
            this.getHeight() ||
            (stage ? stage.getHeight() : 0),
          pixelRatio: pixelRatio
        }),
        context = canvas.getContext();

      context.save();

      if (x || y) {
        context.translate(-1 * x, -1 * y);
      }

      this.drawScene(canvas);
      context.restore();

      return canvas;
    },
    /**
     * converts node into an canvas element.
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
     * @example
     * var canvas = node.toCanvas();
     */
    toCanvas: function(config) {
      return this._toKonvaCanvas(config)._canvas;
    },
    /**
     * Creates a composite data URL. If MIME type is not
     * specified, then "image/png" will result. For "image/jpeg", specify a quality
     * level as quality (range 0.0 - 1.0)
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     * @param {Number} [config.pixelRatio] pixelRatio of output image url. Default is 1
     * @returns {String}
     */
    toDataURL: function(config) {
      config = config || {};
      var mimeType = config.mimeType || null,
        quality = config.quality || null;
      return this._toKonvaCanvas(config).toDataURL(mimeType, quality);
    },
    /**
     * converts node into an image.  Since the toImage
     *  method is asynchronous, a callback is required.  toImage is most commonly used
     *  to cache complex drawings as an image so that they don't have to constantly be redrawn
     * @method
     * @memberof Konva.Node.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     * @paremt {Number} [config.pixelRatio] pixelRatio of ouput image.  Default is 1.
     * @example
     * var image = node.toImage({
     *   callback: function(img) {
     *     // do stuff with img
     *   }
     * });
     */
    toImage: function(config) {
      if (!config || !config.callback) {
        throw 'callback required for toImage method config argument';
      }
      Konva.Util._getImage(this.toDataURL(config), function(img) {
        config.callback(img);
      });
    },
    setSize: function(size) {
      this.setWidth(size.width);
      this.setHeight(size.height);
      return this;
    },
    getSize: function() {
      return {
        width: this.getWidth(),
        height: this.getHeight()
      };
    },
    getWidth: function() {
      return this.attrs.width || 0;
    },
    getHeight: function() {
      return this.attrs.height || 0;
    },
    /**
     * get class name, which may return Stage, Layer, Group, or shape class names like Rect, Circle, Text, etc.
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}
     */
    getClassName: function() {
      return this.className || this.nodeType;
    },
    /**
     * get the node type, which may return Stage, Layer, Group, or Node
     * @method
     * @memberof Konva.Node.prototype
     * @returns {String}
     */
    getType: function() {
      return this.nodeType;
    },
    getDragDistance: function() {
      // compare with undefined because we need to track 0 value
      if (this.attrs.dragDistance !== undefined) {
        return this.attrs.dragDistance;
      } else if (this.parent) {
        return this.parent.getDragDistance();
      } else {
        return Konva.dragDistance;
      }
    },
    _get: function(selector) {
      return this.className === selector || this.nodeType === selector
        ? [this]
        : [];
    },
    _off: function(type, name, callback) {
      var evtListeners = this.eventListeners[type],
        i,
        evtName,
        handler;

      for (i = 0; i < evtListeners.length; i++) {
        evtName = evtListeners[i].name;
        handler = evtListeners[i].handler;

        // the following two conditions must be true in order to remove a handler:
        // 1) the current event name cannot be konva unless the event name is konva
        //    this enables developers to force remove a konva specific listener for whatever reason
        // 2) an event name is not specified, or if one is specified, it matches the current event name
        if (
          (evtName !== 'konva' || name === 'konva') &&
          (!name || evtName === name) &&
          (!callback || callback === handler)
        ) {
          evtListeners.splice(i, 1);
          if (evtListeners.length === 0) {
            delete this.eventListeners[type];
            break;
          }
          i--;
        }
      }
    },
    _fireChangeEvent: function(attr, oldVal, newVal) {
      this._fire(attr + CHANGE, {
        oldVal: oldVal,
        newVal: newVal
      });
    },
    setId: function(id) {
      var oldId = this.getId();

      Konva._removeId(oldId);
      Konva._addId(this, id);
      this._setAttr(ID, id);
      return this;
    },
    setName: function(name) {
      var oldNames = (this.getName() || '').split(/\s/g);
      var newNames = (name || '').split(/\s/g);
      var subname, i;
      // remove all subnames
      for (i = 0; i < oldNames.length; i++) {
        subname = oldNames[i];
        if (newNames.indexOf(subname) === -1 && subname) {
          Konva._removeName(subname, this._id);
        }
      }

      // add new names
      for (i = 0; i < newNames.length; i++) {
        subname = newNames[i];
        if (oldNames.indexOf(subname) === -1 && subname) {
          Konva._addName(this, subname);
        }
      }

      this._setAttr(NAME, name);
      return this;
    },
    // naming methods
    /**
     * add name to node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Konva.Node}
     * @example
     * node.name('red');
     * node.addName('selected');
     * node.name(); // return 'red selected'
     */
    addName: function(name) {
      if (!this.hasName(name)) {
        var oldName = this.name();
        var newName = oldName ? oldName + ' ' + name : name;
        this.setName(newName);
      }
      return this;
    },
    /**
     * check is node has name
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Boolean}
     * @example
     * node.name('red');
     * node.hasName('red');   // return true
     * node.hasName('selected'); // return false
     */
    hasName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      return names.indexOf(name) !== -1;
    },
    /**
     * remove name from node
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} name
     * @returns {Konva.Node}
     * @example
     * node.name('red selected');
     * node.removeName('selected');
     * node.hasName('selected'); // return false
     * node.name(); // return 'red'
     */
    removeName: function(name) {
      var names = (this.name() || '').split(/\s/g);
      var index = names.indexOf(name);
      if (index !== -1) {
        names.splice(index, 1);
        this.setName(names.join(' '));
      }
      return this;
    },
    /**
     * set attr
     * @method
     * @memberof Konva.Node.prototype
     * @param {String} attr
     * @param {*} val
     * @returns {Konva.Node}
     * @example
     * node.setAttr('x', 5);
     */
    setAttr: function(attr, val) {
      var method = SET + Konva.Util._capitalize(attr),
        func = this[method];

      if (Konva.Util._isFunction(func)) {
        func.call(this, val);
      } else {
        // otherwise set directly
        this._setAttr(attr, val);
      }
      return this;
    },
    _setAttr: function(key, val) {
      var oldVal;
      oldVal = this.attrs[key];
      var same = oldVal === val;
      if (same && !Konva.Util.isObject(val)) {
        return;
      }
      if (val === undefined || val === null) {
        delete this.attrs[key];
      } else {
        this.attrs[key] = val;
      }
      this._fireChangeEvent(key, oldVal, val);
    },
    _setComponentAttr: function(key, component, val) {
      var oldVal;
      if (val !== undefined) {
        oldVal = this.attrs[key];

        if (!oldVal) {
          // set value to default value using getAttr
          this.attrs[key] = this.getAttr(key);
        }

        this.attrs[key][component] = val;
        this._fireChangeEvent(key, oldVal, val);
      }
    },
    _fireAndBubble: function(eventType, evt, compareShape) {
      var okayToRun = true;

      if (evt && this.nodeType === SHAPE) {
        evt.target = this;
      }

      if (
        eventType === MOUSEENTER &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      } else if (
        eventType === MOUSELEAVE &&
        compareShape &&
        (this._id === compareShape._id ||
          (this.isAncestorOf && this.isAncestorOf(compareShape)))
      ) {
        okayToRun = false;
      }
      if (okayToRun) {
        this._fire(eventType, evt);

        // simulate event bubbling
        var stopBubble =
          (eventType === MOUSEENTER || eventType === MOUSELEAVE) &&
          (compareShape &&
            compareShape.isAncestorOf &&
            compareShape.isAncestorOf(this) &&
            !compareShape.isAncestorOf(this.parent));
        if (
          ((evt && !evt.cancelBubble) || !evt) &&
          this.parent &&
          this.parent.isListening() &&
          !stopBubble
        ) {
          if (compareShape && compareShape.parent) {
            this._fireAndBubble.call(
              this.parent,
              eventType,
              evt,
              compareShape.parent
            );
          } else {
            this._fireAndBubble.call(this.parent, eventType, evt);
          }
        }
      }
    },
    _fire: function(eventType, evt) {
      var events = this.eventListeners[eventType],
        i;

      evt = evt || {};
      evt.currentTarget = this;
      evt.type = eventType;

      if (events) {
        for (i = 0; i < events.length; i++) {
          events[i].handler.call(this, evt);
        }
      }
    },
    /**
     * draw both scene and hit graphs.  If the node being drawn is the stage, all of the layers will be cleared and redrawn
     * @method
     * @memberof Konva.Node.prototype
     * @returns {Konva.Node}
     */
    draw: function() {
      this.drawScene();
      this.drawHit();
      return this;
    }
  });

  /**
   * create node with JSON string or an Object.  De-serializtion does not generate custom
   *  shape drawing functions, images, or event handlers (this would make the
   *  serialized object huge).  If your app uses custom shapes, images, and
   *  event handlers (it probably does), then you need to select the appropriate
   *  shapes after loading the stage and set these properties via on(), setDrawFunc(),
   *  and setImage() methods
   * @method
   * @memberof Konva.Node
   * @param {String|Object} json string or object
   * @param {Element} [container] optional container dom element used only if you're
   *  creating a stage node
   */
  Konva.Node.create = function(data, container) {
    if (Konva.Util._isString(data)) {
      data = JSON.parse(data);
    }
    return this._createNode(data, container);
  };
  Konva.Node._createNode = function(obj, container) {
    var className = Konva.Node.prototype.getClassName.call(obj),
      children = obj.children,
      no,
      len,
      n;

    // if container was passed in, add it to attrs
    if (container) {
      obj.attrs.container = container;
    }

    no = new Konva[className](obj.attrs);
    if (children) {
      len = children.length;
      for (n = 0; n < len; n++) {
        no.add(this._createNode(children[n]));
      }
    }

    return no;
  };

  // =========================== add getters setters ===========================

  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'position');
  /**
   * get/set node position relative to parent
   * @name position
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} pos
   * @param {Number} pos.x
   * @param {Number} pos.y
   * @returns {Object}
   * @example
   * // get position
   * var position = node.position();
   *
   * // set position
   * node.position({
   *   x: 5
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'x', 0);

  /**
   * get/set x position
   * @name x
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} x
   * @returns {Object}
   * @example
   * // get x
   * var x = node.x();
   *
   * // set x
   * node.x(5);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'y', 0);

  /**
   * get/set y position
   * @name y
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} y
   * @returns {Integer}
   * @example
   * // get y
   * var y = node.y();
   *
   * // set y
   * node.y(5);
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'globalCompositeOperation',
    'source-over'
  );

  /**
   * get/set globalCompositeOperation of a shape
   * @name globalCompositeOperation
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} type
   * @returns {String}
   * @example
   * // get globalCompositeOperation
   * var globalCompositeOperation = shape.globalCompositeOperation();
   *
   * // set globalCompositeOperation
   * shape.globalCompositeOperation('source-in');
   */
  Konva.Factory.addGetterSetter(Konva.Node, 'opacity', 1);

  /**
   * get/set opacity.  Opacity values range from 0 to 1.
   *  A node with an opacity of 0 is fully transparent, and a node
   *  with an opacity of 1 is fully opaque
   * @name opacity
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} opacity
   * @returns {Number}
   * @example
   * // get opacity
   * var opacity = node.opacity();
   *
   * // set opacity
   * node.opacity(0.5);
   */

  Konva.Factory.addGetter(Konva.Node, 'name');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'name');

  /**
   * get/set name
   * @name name
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} name
   * @returns {String}
   * @example
   * // get name
   * var name = node.name();
   *
   * // set name
   * node.name('foo');
   *
   * // also node may have multiple names (as css classes)
   * node.name('foo bar');
   */

  Konva.Factory.addGetter(Konva.Node, 'id');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'id');

  /**
   * get/set id. Id is global for whole page.
   * @name id
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} id
   * @returns {String}
   * @example
   * // get id
   * var name = node.id();
   *
   * // set id
   * node.id('foo');
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'rotation', 0);

  /**
   * get/set rotation in degrees
   * @name rotation
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} rotation
   * @returns {Number}
   * @example
   * // get rotation in degrees
   * var rotation = node.rotation();
   *
   * // set rotation in degrees
   * node.rotation(45);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'scale', ['x', 'y']);

  /**
   * get/set scale
   * @name scale
   * @param {Object} scale
   * @param {Number} scale.x
   * @param {Number} scale.y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Object}
   * @example
   * // get scale
   * var scale = node.scale();
   *
   * // set scale
   * shape.scale({
   *   x: 2
   *   y: 3
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'scaleX', 1);

  /**
   * get/set scale x
   * @name scaleX
   * @param {Number} x
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get scale x
   * var scaleX = node.scaleX();
   *
   * // set scale x
   * node.scaleX(2);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'scaleY', 1);

  /**
   * get/set scale y
   * @name scaleY
   * @param {Number} y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get scale y
   * var scaleY = node.scaleY();
   *
   * // set scale y
   * node.scaleY(2);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'skew', ['x', 'y']);

  /**
   * get/set skew
   * @name skew
   * @param {Object} skew
   * @param {Number} skew.x
   * @param {Number} skew.y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Object}
   * @example
   * // get skew
   * var skew = node.skew();
   *
   * // set skew
   * node.skew({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'skewX', 0);

  /**
   * get/set skew x
   * @name skewX
   * @param {Number} x
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get skew x
   * var skewX = node.skewX();
   *
   * // set skew x
   * node.skewX(3);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'skewY', 0);

  /**
   * get/set skew y
   * @name skewY
   * @param {Number} y
   * @method
   * @memberof Konva.Node.prototype
   * @returns {Number}
   * @example
   * // get skew y
   * var skewY = node.skewY();
   *
   * // set skew y
   * node.skewY(3);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Node, 'offset', ['x', 'y']);

  /**
   * get/set offset.  Offsets the default position and rotation point
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get offset
   * var offset = node.offset();
   *
   * // set offset
   * node.offset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'offsetX', 0);

  /**
   * get/set offset x
   * @name offsetX
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get offset x
   * var offsetX = node.offsetX();
   *
   * // set offset x
   * node.offsetX(3);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'offsetY', 0);

  /**
   * get/set offset y
   * @name offsetY
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get offset y
   * var offsetY = node.offsetY();
   *
   * // set offset y
   * node.offsetY(3);
   */

  Konva.Factory.addSetter(Konva.Node, 'dragDistance');
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'dragDistance');

  /**
   * get/set drag distance
   * @name dragDistance
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} distance
   * @returns {Number}
   * @example
   * // get drag distance
   * var dragDistance = node.dragDistance();
   *
   * // set distance
   * // node starts dragging only if pointer moved more then 3 pixels
   * node.dragDistance(3);
   * // or set globally
   * Konva.dragDistance = 3;
   */

  Konva.Factory.addSetter(Konva.Node, 'width', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'width');
  /**
   * get/set width
   * @name width
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} width
   * @returns {Number}
   * @example
   * // get width
   * var width = node.width();
   *
   * // set width
   * node.width(100);
   */

  Konva.Factory.addSetter(Konva.Node, 'height', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'height');
  /**
   * get/set height
   * @name height
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} height
   * @returns {Number}
   * @example
   * // get height
   * var height = node.height();
   *
   * // set height
   * node.height(100);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'listening', 'inherit');
  /**
   * get/set listenig attr.  If you need to determine if a node is listening or not
   *   by taking into account its parents, use the isListening() method
   * @name listening
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean|String} listening Can be "inherit", true, or false.  The default is "inherit".
   * @returns {Boolean|String}
   * @example
   * // get listening attr
   * var listening = node.listening();
   *
   * // stop listening for events
   * node.listening(false);
   *
   * // listen for events
   * node.listening(true);
   *
   * // listen to events according to the parent
   * node.listening('inherit');
   */

  /**
   * get/set preventDefault
   * By default all shapes will prevent default behaviour
   * of a browser on a pointer move or tap.
   * that will prevent native scrolling when you are trying to drag&drop a node
   * but sometimes you may need to enable default actions
   * in that case you can set the property to false
   * @name preventDefault
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} preventDefault
   * @returns {Number}
   * @example
   * // get preventDefault
   * var shouldPrevent = shape.preventDefault();
   *
   * // set preventDefault
   * shape.preventDefault(false);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'preventDefault', true);

  Konva.Factory.addGetterSetter(Konva.Node, 'filters', undefined, function(
    val
  ) {
    this._filterUpToDate = false;
    return val;
  });
  /**
   * get/set filters.  Filters are applied to cached canvases
   * @name filters
   * @method
   * @memberof Konva.Node.prototype
   * @param {Array} filters array of filters
   * @returns {Array}
   * @example
   * // get filters
   * var filters = node.filters();
   *
   * // set a single filter
   * node.cache();
   * node.filters([Konva.Filters.Blur]);
   *
   * // set multiple filters
   * node.cache();
   * node.filters([
   *   Konva.Filters.Blur,
   *   Konva.Filters.Sepia,
   *   Konva.Filters.Invert
   * ]);
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'visible', 'inherit');
  /**
   * get/set visible attr.  Can be "inherit", true, or false.  The default is "inherit".
   *   If you need to determine if a node is visible or not
   *   by taking into account its parents, use the isVisible() method
   * @name visible
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean|String} visible
   * @returns {Boolean|String}
   * @example
   * // get visible attr
   * var visible = node.visible();
   *
   * // make invisible
   * node.visible(false);
   *
   * // make visible
   * node.visible(true);
   *
   * // make visible according to the parent
   * node.visible('inherit');
   */

  Konva.Factory.addGetterSetter(Konva.Node, 'transformsEnabled', 'all');

  /**
   * get/set transforms that are enabled.  Can be "all", "none", or "position".  The default
   *  is "all"
   * @name transformsEnabled
   * @method
   * @memberof Konva.Node.prototype
   * @param {String} enabled
   * @returns {String}
   * @example
   * // enable position transform only to improve draw performance
   * node.transformsEnabled('position');
   *
   * // enable all transforms
   * node.transformsEnabled('all');
   */

  /**
   * get/set node size
   * @name size
   * @method
   * @memberof Konva.Node.prototype
   * @param {Object} size
   * @param {Number} size.width
   * @param {Number} size.height
   * @returns {Object}
   * @example
   * // get node size
   * var size = node.size();
   * var x = size.x;
   * var y = size.y;
   *
   * // set size
   * node.size({
   *   width: 100,
   *   height: 200
   * });
   */
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'size');

  Konva.Factory.backCompat(Konva.Node, {
    rotateDeg: 'rotate',
    setRotationDeg: 'setRotation',
    getRotationDeg: 'getRotation'
  });

  Konva.Collection.mapMethods(Konva.Node);
})(Konva);

(function() {
  'use strict';
  /**
   * Grayscale Filter
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Grayscale]);
   */
  Konva.Filters.Grayscale = function(imageData) {
    var data = imageData.data,
      len = data.length,
      i,
      brightness;

    for (i = 0; i < len; i += 4) {
      brightness = 0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2];
      // red
      data[i] = brightness;
      // green
      data[i + 1] = brightness;
      // blue
      data[i + 2] = brightness;
    }
  };
})();

(function(Konva) {
  'use strict';
  /**
     * Brighten Filter.
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Brighten]);
     * node.brightness(0.8);
     */
  Konva.Filters.Brighten = function(imageData) {
    var brightness = this.brightness() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] += brightness;
      // green
      data[i + 1] += brightness;
      // blue
      data[i + 2] += brightness;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'brightness',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter brightness.  The brightness is a number between -1 and 1.&nbsp; Positive values
    *  brighten the pixels and negative values darken them. Use with {@link Konva.Filters.Brighten} filter.
    * @name brightness
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} brightness value between -1 and 1
    * @returns {Number}
    */
})(Konva);

(function() {
  'use strict';
  /**
   * Invert Filter
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Invert]);
   */
  Konva.Filters.Invert = function(imageData) {
    var data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 4) {
      // red
      data[i] = 255 - data[i];
      // green
      data[i + 1] = 255 - data[i + 1];
      // blue
      data[i + 2] = 255 - data[i + 2];
    }
  };
})();

/*
 the Gauss filter
 master repo: https://github.com/pavelpower/kineticjsGaussFilter
*/
(function(Konva) {
  'use strict';
  /*

     StackBlur - a fast almost Gaussian Blur For Canvas

     Version:   0.5
     Author:    Mario Klingemann
     Contact:   mario@quasimondo.com
     Website:   http://www.quasimondo.com/StackBlurForCanvas
     Twitter:   @quasimondo

     In case you find this class useful - especially in commercial projects -
     I am not totally unhappy for a small donation to my PayPal account
     mario@quasimondo.de

     Or support me on flattr:
     https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

     Copyright (c) 2010 Mario Klingemann

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use,
     copy, modify, merge, publish, distribute, sublicense, and/or sell
     copies of the Software, and to permit persons to whom the
     Software is furnished to do so, subject to the following
     conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
     OTHER DEALINGS IN THE SOFTWARE.
     */

  function BlurStack() {
    this.r = 0;
    this.g = 0;
    this.b = 0;
    this.a = 0;
    this.next = null;
  }

  var mul_table = [
    512,
    512,
    456,
    512,
    328,
    456,
    335,
    512,
    405,
    328,
    271,
    456,
    388,
    335,
    292,
    512,
    454,
    405,
    364,
    328,
    298,
    271,
    496,
    456,
    420,
    388,
    360,
    335,
    312,
    292,
    273,
    512,
    482,
    454,
    428,
    405,
    383,
    364,
    345,
    328,
    312,
    298,
    284,
    271,
    259,
    496,
    475,
    456,
    437,
    420,
    404,
    388,
    374,
    360,
    347,
    335,
    323,
    312,
    302,
    292,
    282,
    273,
    265,
    512,
    497,
    482,
    468,
    454,
    441,
    428,
    417,
    405,
    394,
    383,
    373,
    364,
    354,
    345,
    337,
    328,
    320,
    312,
    305,
    298,
    291,
    284,
    278,
    271,
    265,
    259,
    507,
    496,
    485,
    475,
    465,
    456,
    446,
    437,
    428,
    420,
    412,
    404,
    396,
    388,
    381,
    374,
    367,
    360,
    354,
    347,
    341,
    335,
    329,
    323,
    318,
    312,
    307,
    302,
    297,
    292,
    287,
    282,
    278,
    273,
    269,
    265,
    261,
    512,
    505,
    497,
    489,
    482,
    475,
    468,
    461,
    454,
    447,
    441,
    435,
    428,
    422,
    417,
    411,
    405,
    399,
    394,
    389,
    383,
    378,
    373,
    368,
    364,
    359,
    354,
    350,
    345,
    341,
    337,
    332,
    328,
    324,
    320,
    316,
    312,
    309,
    305,
    301,
    298,
    294,
    291,
    287,
    284,
    281,
    278,
    274,
    271,
    268,
    265,
    262,
    259,
    257,
    507,
    501,
    496,
    491,
    485,
    480,
    475,
    470,
    465,
    460,
    456,
    451,
    446,
    442,
    437,
    433,
    428,
    424,
    420,
    416,
    412,
    408,
    404,
    400,
    396,
    392,
    388,
    385,
    381,
    377,
    374,
    370,
    367,
    363,
    360,
    357,
    354,
    350,
    347,
    344,
    341,
    338,
    335,
    332,
    329,
    326,
    323,
    320,
    318,
    315,
    312,
    310,
    307,
    304,
    302,
    299,
    297,
    294,
    292,
    289,
    287,
    285,
    282,
    280,
    278,
    275,
    273,
    271,
    269,
    267,
    265,
    263,
    261,
    259
  ];

  var shg_table = [
    9,
    11,
    12,
    13,
    13,
    14,
    14,
    15,
    15,
    15,
    15,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    21,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    22,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    23,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24,
    24
  ];

  function filterGaussBlurRGBA(imageData, radius) {
    var pixels = imageData.data,
      width = imageData.width,
      height = imageData.height;

    var x,
      y,
      i,
      p,
      yp,
      yi,
      yw,
      r_sum,
      g_sum,
      b_sum,
      a_sum,
      r_out_sum,
      g_out_sum,
      b_out_sum,
      a_out_sum,
      r_in_sum,
      g_in_sum,
      b_in_sum,
      a_in_sum,
      pr,
      pg,
      pb,
      pa,
      rbs;

    var div = radius + radius + 1,
      widthMinus1 = width - 1,
      heightMinus1 = height - 1,
      radiusPlus1 = radius + 1,
      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2,
      stackStart = new BlurStack(),
      stackEnd = null,
      stack = stackStart,
      stackIn = null,
      stackOut = null,
      mul_sum = mul_table[radius],
      shg_sum = shg_table[radius];

    for (i = 1; i < div; i++) {
      stack = stack.next = new BlurStack();
      if (i === radiusPlus1) {
        stackEnd = stack;
      }
    }

    stack.next = stackStart;

    yw = yi = 0;

    for (y = 0; y < height; y++) {
      r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;

      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      for (i = 1; i < radiusPlus1; i++) {
        p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
        r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[p + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;
      }

      stackIn = stackStart;
      stackOut = stackEnd;
      for (x = 0; x < width; x++) {
        pixels[yi + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa !== 0) {
          pa = 255 / pa;
          pixels[yi] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[yi + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;

        r_in_sum += stackIn.r = pixels[p];
        g_in_sum += stackIn.g = pixels[p + 1];
        b_in_sum += stackIn.b = pixels[p + 2];
        a_in_sum += stackIn.a = pixels[p + 3];

        r_sum += r_in_sum;
        g_sum += g_in_sum;
        b_sum += b_in_sum;
        a_sum += a_in_sum;

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += 4;
      }
      yw += width;
    }

    for (x = 0; x < width; x++) {
      g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;

      yi = x << 2;
      r_out_sum = radiusPlus1 * (pr = pixels[yi]);
      g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
      b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
      a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);

      r_sum += sumFactor * pr;
      g_sum += sumFactor * pg;
      b_sum += sumFactor * pb;
      a_sum += sumFactor * pa;

      stack = stackStart;

      for (i = 0; i < radiusPlus1; i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }

      yp = width;

      for (i = 1; i <= radius; i++) {
        yi = (yp + x) << 2;

        r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
        g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
        b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
        a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;

        r_in_sum += pr;
        g_in_sum += pg;
        b_in_sum += pb;
        a_in_sum += pa;

        stack = stack.next;

        if (i < heightMinus1) {
          yp += width;
        }
      }

      yi = x;
      stackIn = stackStart;
      stackOut = stackEnd;
      for (y = 0; y < height; y++) {
        p = yi << 2;
        pixels[p + 3] = pa = (a_sum * mul_sum) >> shg_sum;
        if (pa > 0) {
          pa = 255 / pa;
          pixels[p] = ((r_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 1] = ((g_sum * mul_sum) >> shg_sum) * pa;
          pixels[p + 2] = ((b_sum * mul_sum) >> shg_sum) * pa;
        } else {
          pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
        }

        r_sum -= r_out_sum;
        g_sum -= g_out_sum;
        b_sum -= b_out_sum;
        a_sum -= a_out_sum;

        r_out_sum -= stackIn.r;
        g_out_sum -= stackIn.g;
        b_out_sum -= stackIn.b;
        a_out_sum -= stackIn.a;

        p =
          (x +
            ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) *
              width) <<
          2;

        r_sum += r_in_sum += stackIn.r = pixels[p];
        g_sum += g_in_sum += stackIn.g = pixels[p + 1];
        b_sum += b_in_sum += stackIn.b = pixels[p + 2];
        a_sum += a_in_sum += stackIn.a = pixels[p + 3];

        stackIn = stackIn.next;

        r_out_sum += pr = stackOut.r;
        g_out_sum += pg = stackOut.g;
        b_out_sum += pb = stackOut.b;
        a_out_sum += pa = stackOut.a;

        r_in_sum -= pr;
        g_in_sum -= pg;
        b_in_sum -= pb;
        a_in_sum -= pa;

        stackOut = stackOut.next;

        yi += width;
      }
    }
  }

  /**
     * Blur Filter
     * @function
     * @name Blur
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Blur]);
     * node.blurRadius(10);
     */
  Konva.Filters.Blur = function Blur(imageData) {
    var radius = Math.round(this.blurRadius());

    if (radius > 0) {
      filterGaussBlurRGBA(imageData, radius);
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blurRadius',
    0,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set blur radius. Use with {@link Konva.Filters.Blur} filter
    * @name blurRadius
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} radius
    * @returns {Integer}
    */
})(Konva);

/*eslint-disable  max-depth */
(function() {
  'use strict';
  function pixelAt(idata, x, y) {
    var idx = (y * idata.width + x) * 4;
    var d = [];
    d.push(
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++],
      idata.data[idx++]
    );
    return d;
  }

  function rgbDistance(p1, p2) {
    return Math.sqrt(
      Math.pow(p1[0] - p2[0], 2) +
        Math.pow(p1[1] - p2[1], 2) +
        Math.pow(p1[2] - p2[2], 2)
    );
  }

  function rgbMean(pTab) {
    var m = [0, 0, 0];

    for (var i = 0; i < pTab.length; i++) {
      m[0] += pTab[i][0];
      m[1] += pTab[i][1];
      m[2] += pTab[i][2];
    }

    m[0] /= pTab.length;
    m[1] /= pTab.length;
    m[2] /= pTab.length;

    return m;
  }

  function backgroundMask(idata, threshold) {
    var rgbv_no = pixelAt(idata, 0, 0);
    var rgbv_ne = pixelAt(idata, idata.width - 1, 0);
    var rgbv_so = pixelAt(idata, 0, idata.height - 1);
    var rgbv_se = pixelAt(idata, idata.width - 1, idata.height - 1);

    var thres = threshold || 10;
    if (
      rgbDistance(rgbv_no, rgbv_ne) < thres &&
      rgbDistance(rgbv_ne, rgbv_se) < thres &&
      rgbDistance(rgbv_se, rgbv_so) < thres &&
      rgbDistance(rgbv_so, rgbv_no) < thres
    ) {
      // Mean color
      var mean = rgbMean([rgbv_ne, rgbv_no, rgbv_se, rgbv_so]);

      // Mask based on color distance
      var mask = [];
      for (var i = 0; i < idata.width * idata.height; i++) {
        var d = rgbDistance(mean, [
          idata.data[i * 4],
          idata.data[i * 4 + 1],
          idata.data[i * 4 + 2]
        ]);
        mask[i] = d < thres ? 0 : 255;
      }

      return mask;
    }
  }

  function applyMask(idata, mask) {
    for (var i = 0; i < idata.width * idata.height; i++) {
      idata.data[4 * i + 3] = mask[i];
    }
  }

  function erodeMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 0, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a === 255 * 8 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function dilateMask(mask, sw, sh) {
    var weights = [1, 1, 1, 1, 1, 1, 1, 1, 1];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a >= 255 * 4 ? 255 : 0;
      }
    }

    return maskResult;
  }

  function smoothEdgeMask(mask, sw, sh) {
    var weights = [
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9,
      1 / 9
    ];
    var side = Math.round(Math.sqrt(weights.length));
    var halfSide = Math.floor(side / 2);

    var maskResult = [];
    for (var y = 0; y < sh; y++) {
      for (var x = 0; x < sw; x++) {
        var so = y * sw + x;
        var a = 0;
        for (var cy = 0; cy < side; cy++) {
          for (var cx = 0; cx < side; cx++) {
            var scy = y + cy - halfSide;
            var scx = x + cx - halfSide;

            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
              var srcOff = scy * sw + scx;
              var wt = weights[cy * side + cx];

              a += mask[srcOff] * wt;
            }
          }
        }

        maskResult[so] = a;
      }
    }

    return maskResult;
  }

  /**
	 * Mask Filter
	 * @function
	 * @name Mask
	 * @memberof Konva.Filters
	 * @param {Object} imageData
	 * @example
     * node.cache();
     * node.filters([Konva.Filters.Mask]);
     * node.threshold(200);
	 */
  Konva.Filters.Mask = function(imageData) {
    // Detect pixels close to the background color
    var threshold = this.threshold(),
      mask = backgroundMask(imageData, threshold);
    if (mask) {
      // Erode
      mask = erodeMask(mask, imageData.width, imageData.height);

      // Dilate
      mask = dilateMask(mask, imageData.width, imageData.height);

      // Gradient
      mask = smoothEdgeMask(mask, imageData.width, imageData.height);

      // Apply mask
      applyMask(imageData, mask);

      // todo : Update hit region function according to mask
    }

    return imageData;
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
     * RGB Filter
     * @function
     * @name RGB
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author ippo615
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGB]);
     * node.blue(120);
     * node.green(200);
     */
  Konva.Filters.RGB = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      i,
      brightness;

    for (i = 0; i < nPixels; i += 4) {
      brightness =
        (0.34 * data[i] + 0.5 * data[i + 1] + 0.16 * data[i + 2]) / 255;
      data[i] = brightness * red; // r
      data[i + 1] = brightness * green; // g
      data[i + 2] = brightness * blue; // b
      data[i + 3] = data[i + 3]; // alpha
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter red value. Use with {@link Konva.Filters.RGB} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter green value. Use with {@link Konva.Filters.RGB} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGB} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */
})();

(function() {
  'use strict';
  /**
     * RGBA Filter
     * @function
     * @name RGBA
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author codefo
     * @example
     * node.cache();
     * node.filters([Konva.Filters.RGBA]);
     * node.blue(120);
     * node.green(200);
     * node.alpha(0.3);
     */
  Konva.Filters.RGBA = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      red = this.red(),
      green = this.green(),
      blue = this.blue(),
      alpha = this.alpha(),
      i,
      ia;

    for (i = 0; i < nPixels; i += 4) {
      ia = 1 - alpha;

      data[i] = red * alpha + data[i] * ia; // r
      data[i + 1] = green * alpha + data[i + 1] * ia; // g
      data[i + 2] = blue * alpha + data[i + 2] * ia; // b
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'red', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter red value. Use with {@link Konva.Filters.RGBA} filter.
    * @name red
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} red value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'green', 0, function(val) {
    this._filterUpToDate = false;
    if (val > 255) {
      return 255;
    } else if (val < 0) {
      return 0;
    } else {
      return Math.round(val);
    }
  });
  /**
    * get/set filter green value. Use with {@link Konva.Filters.RGBA} filter.
    * @name green
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} green value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'blue',
    0,
    Konva.Validators.RGBComponent,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set filter blue value. Use with {@link Konva.Filters.RGBA} filter.
    * @name blue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} blue value between 0 and 255
    * @returns {Integer}
    */

  Konva.Factory.addGetterSetter(Konva.Node, 'alpha', 1, function(val) {
    this._filterUpToDate = false;
    if (val > 1) {
      return 1;
    } else if (val < 0) {
      return 0;
    } else {
      return val;
    }
  });
  /**
     * get/set filter alpha value. Use with {@link Konva.Filters.RGBA} filter.
     * @name alpha
     * @method
     * @memberof Konva.Node.prototype
     * @param {Float} alpha value between 0 and 1
     * @returns {Float}
     */
})();

(function() {
  'use strict';
  /**
    * HSV Filter. Adjusts the hue, saturation and value
    * @function
    * @name HSV
    * @memberof Konva.Filters
    * @param {Object} imageData
    * @author ippo615
    * @example
    * image.filters([Konva.Filters.HSV]);
    * image.value(200);
    */

  Konva.Filters.HSV = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = Math.pow(2, this.value()),
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.330 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.300 * vsu + 1.250 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.050 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.200 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b;
      data[i + 1] = gr * r + gg * g + gb * b;
      data[i + 2] = br * r + bg * g + bb * b;
      data[i + 3] = a; // alpha
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name hue
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} hue value between 0 and 359
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
    * @name saturation
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'value',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set hsv value. Use with {@link Konva.Filters.HSV} filter.
    * @name value
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} value 0 is no change, -1.0 halves the value, 1.0 doubles, etc..
    * @returns {Number}
    */
})();

(function() {
  'use strict';
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'hue',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv hue in degrees. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name hue
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} hue value between 0 and 359
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'saturation',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsv saturation. Use with {@link Konva.Filters.HSV} or {@link Konva.Filters.HSL} filter.
   * @name saturation
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} saturation 0 is no change, -1.0 halves the saturation, 1.0 doubles, etc..
   * @returns {Number}
   */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'luminance',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set hsl luminance. Use with {@link Konva.Filters.HSL} filter.
   * @name value
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} value from -1 to 1
   * @returns {Number}
   */

  /**
   * HSL Filter. Adjusts the hue, saturation and luminance (or lightness)
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * image.filters([Konva.Filters.HSL]);
   * image.luminance(200);
   */

  Konva.Filters.HSL = function(imageData) {
    var data = imageData.data,
      nPixels = data.length,
      v = 1,
      s = Math.pow(2, this.saturation()),
      h = Math.abs(this.hue() + 360) % 360,
      l = this.luminance() * 127,
      i;

    // Basis for the technique used:
    // http://beesbuzz.biz/code/hsv_color_transforms.php
    // V is the value multiplier (1 for none, 2 for double, 0.5 for half)
    // S is the saturation multiplier (1 for none, 2 for double, 0.5 for half)
    // H is the hue shift in degrees (0 to 360)
    // vsu = V*S*cos(H*PI/180);
    // vsw = V*S*sin(H*PI/180);
    //[ .299V+.701vsu+.168vsw    .587V-.587vsu+.330vsw    .114V-.114vsu-.497vsw ] [R]
    //[ .299V-.299vsu-.328vsw    .587V+.413vsu+.035vsw    .114V-.114vsu+.292vsw ]*[G]
    //[ .299V-.300vsu+1.25vsw    .587V-.588vsu-1.05vsw    .114V+.886vsu-.203vsw ] [B]

    // Precompute the values in the matrix:
    var vsu = v * s * Math.cos(h * Math.PI / 180),
      vsw = v * s * Math.sin(h * Math.PI / 180);
    // (result spot)(source spot)
    var rr = 0.299 * v + 0.701 * vsu + 0.167 * vsw,
      rg = 0.587 * v - 0.587 * vsu + 0.33 * vsw,
      rb = 0.114 * v - 0.114 * vsu - 0.497 * vsw;
    var gr = 0.299 * v - 0.299 * vsu - 0.328 * vsw,
      gg = 0.587 * v + 0.413 * vsu + 0.035 * vsw,
      gb = 0.114 * v - 0.114 * vsu + 0.293 * vsw;
    var br = 0.299 * v - 0.3 * vsu + 1.25 * vsw,
      bg = 0.587 * v - 0.586 * vsu - 1.05 * vsw,
      bb = 0.114 * v + 0.886 * vsu - 0.2 * vsw;

    var r, g, b, a;

    for (i = 0; i < nPixels; i += 4) {
      r = data[i + 0];
      g = data[i + 1];
      b = data[i + 2];
      a = data[i + 3];

      data[i + 0] = rr * r + rg * g + rb * b + l;
      data[i + 1] = gr * r + gg * g + gb * b + l;
      data[i + 2] = br * r + bg * g + bb * b + l;
      data[i + 3] = a; // alpha
    }
  };
})();

(function() {
  'use strict';
  /**
     * Emboss Filter.
     * Pixastic Lib - Emboss filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Emboss]);
     * node.embossStrength(0.8);
     * node.embossWhiteLevel(0.3);
     * node.embossDirection('right');
     * node.embossBlend(true);
     */
  Konva.Filters.Emboss = function(imageData) {
    // pixastic strength is between 0 and 10.  I want it between 0 and 1
    // pixastic greyLevel is between 0 and 255.  I want it between 0 and 1.  Also,
    // a max value of greyLevel yields a white emboss, and the min value yields a black
    // emboss.  Therefore, I changed greyLevel to whiteLevel
    var strength = this.embossStrength() * 10,
      greyLevel = this.embossWhiteLevel() * 255,
      direction = this.embossDirection(),
      blend = this.embossBlend(),
      dirY = 0,
      dirX = 0,
      data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    switch (direction) {
      case 'top-left':
        dirY = -1;
        dirX = -1;
        break;
      case 'top':
        dirY = -1;
        dirX = 0;
        break;
      case 'top-right':
        dirY = -1;
        dirX = 1;
        break;
      case 'right':
        dirY = 0;
        dirX = 1;
        break;
      case 'bottom-right':
        dirY = 1;
        dirX = 1;
        break;
      case 'bottom':
        dirY = 1;
        dirX = 0;
        break;
      case 'bottom-left':
        dirY = 1;
        dirX = -1;
        break;
      case 'left':
        dirY = 0;
        dirX = -1;
        break;
      default:
        Konva.Util.error('Unknown emboss direction: ' + direction);
    }

    do {
      var offsetY = (y - 1) * w4;

      var otherY = dirY;
      if (y + otherY < 1) {
        otherY = 0;
      }
      if (y + otherY > h) {
        otherY = 0;
      }

      var offsetYOther = (y - 1 + otherY) * w * 4;

      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;

        var otherX = dirX;
        if (x + otherX < 1) {
          otherX = 0;
        }
        if (x + otherX > w) {
          otherX = 0;
        }

        var offsetOther = offsetYOther + (x - 1 + otherX) * 4;

        var dR = data[offset] - data[offsetOther];
        var dG = data[offset + 1] - data[offsetOther + 1];
        var dB = data[offset + 2] - data[offsetOther + 2];

        var dif = dR;
        var absDif = dif > 0 ? dif : -dif;

        var absG = dG > 0 ? dG : -dG;
        var absB = dB > 0 ? dB : -dB;

        if (absG > absDif) {
          dif = dG;
        }
        if (absB > absDif) {
          dif = dB;
        }

        dif *= strength;

        if (blend) {
          var r = data[offset] + dif;
          var g = data[offset + 1] + dif;
          var b = data[offset + 2] + dif;

          data[offset] = r > 255 ? 255 : r < 0 ? 0 : r;
          data[offset + 1] = g > 255 ? 255 : g < 0 ? 0 : g;
          data[offset + 2] = b > 255 ? 255 : b < 0 ? 0 : b;
        } else {
          var grey = greyLevel - dif;
          if (grey < 0) {
            grey = 0;
          } else if (grey > 255) {
            grey = 255;
          }

          data[offset] = data[offset + 1] = data[offset + 2] = grey;
        }
      } while (--x);
    } while (--y);
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossStrength',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss strength. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossStrength
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossWhiteLevel',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss white level. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossWhiteLevel
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} embossWhiteLevel between 0 and 1.  Default is 0.5
    * @returns {Number}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossDirection',
    'top-left',
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss direction. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossDirection
    * @method
    * @memberof Konva.Node.prototype
    * @param {String} embossDirection can be top-left, top, top-right, right, bottom-right, bottom, bottom-left or left
    *   The default is top-left
    * @returns {String}
    */

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'embossBlend',
    false,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
    * get/set emboss blend. Use with {@link Konva.Filters.Emboss} filter.
    * @name embossBlend
    * @method
    * @memberof Konva.Node.prototype
    * @param {Boolean} embossBlend
    * @returns {Boolean}
    */
})();

(function() {
  'use strict';
  function remap(fromValue, fromMin, fromMax, toMin, toMax) {
    // Compute the range of the data
    var fromRange = fromMax - fromMin,
      toRange = toMax - toMin,
      toValue;

    // If either range is 0, then the value can only be mapped to 1 value
    if (fromRange === 0) {
      return toMin + toRange / 2;
    }
    if (toRange === 0) {
      return toMin;
    }

    // (1) untranslate, (2) unscale, (3) rescale, (4) retranslate
    toValue = (fromValue - fromMin) / fromRange;
    toValue = toRange * toValue + toMin;

    return toValue;
  }

  /**
   * Enhance Filter. Adjusts the colors so that they span the widest
   *  possible range (ie 0-255). Performs w*h pixel reads and w*h pixel
   *  writes.
   * @function
   * @name Enhance
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Enhance]);
   * node.enhance(0.4);
   */
  Konva.Filters.Enhance = function(imageData) {
    var data = imageData.data,
      nSubPixels = data.length,
      rMin = data[0],
      rMax = rMin,
      r,
      gMin = data[1],
      gMax = gMin,
      g,
      bMin = data[2],
      bMax = bMin,
      b,
      i;

    // If we are not enhancing anything - don't do any computation
    var enhanceAmount = this.enhance();
    if (enhanceAmount === 0) {
      return;
    }

    // 1st Pass - find the min and max for each channel:
    for (i = 0; i < nSubPixels; i += 4) {
      r = data[i + 0];
      if (r < rMin) {
        rMin = r;
      } else if (r > rMax) {
        rMax = r;
      }
      g = data[i + 1];
      if (g < gMin) {
        gMin = g;
      } else if (g > gMax) {
        gMax = g;
      }
      b = data[i + 2];
      if (b < bMin) {
        bMin = b;
      } else if (b > bMax) {
        bMax = b;
      }
      //a = data[i + 3];
      //if (a < aMin) { aMin = a; } else
      //if (a > aMax) { aMax = a; }
    }

    // If there is only 1 level - don't remap
    if (rMax === rMin) {
      rMax = 255;
      rMin = 0;
    }
    if (gMax === gMin) {
      gMax = 255;
      gMin = 0;
    }
    if (bMax === bMin) {
      bMax = 255;
      bMin = 0;
    }

    var rMid,
      rGoalMax,
      rGoalMin,
      gMid,
      gGoalMax,
      gGoalMin,
      bMid,
      bGoalMax,
      bGoalMin;

    // If the enhancement is positive - stretch the histogram
    if (enhanceAmount > 0) {
      rGoalMax = rMax + enhanceAmount * (255 - rMax);
      rGoalMin = rMin - enhanceAmount * (rMin - 0);
      gGoalMax = gMax + enhanceAmount * (255 - gMax);
      gGoalMin = gMin - enhanceAmount * (gMin - 0);
      bGoalMax = bMax + enhanceAmount * (255 - bMax);
      bGoalMin = bMin - enhanceAmount * (bMin - 0);
      // If the enhancement is negative -   compress the histogram
    } else {
      rMid = (rMax + rMin) * 0.5;
      rGoalMax = rMax + enhanceAmount * (rMax - rMid);
      rGoalMin = rMin + enhanceAmount * (rMin - rMid);
      gMid = (gMax + gMin) * 0.5;
      gGoalMax = gMax + enhanceAmount * (gMax - gMid);
      gGoalMin = gMin + enhanceAmount * (gMin - gMid);
      bMid = (bMax + bMin) * 0.5;
      bGoalMax = bMax + enhanceAmount * (bMax - bMid);
      bGoalMin = bMin + enhanceAmount * (bMin - bMid);
    }

    // Pass 2 - remap everything, except the alpha
    for (i = 0; i < nSubPixels; i += 4) {
      data[i + 0] = remap(data[i + 0], rMin, rMax, rGoalMin, rGoalMax);
      data[i + 1] = remap(data[i + 1], gMin, gMax, gGoalMin, gGoalMax);
      data[i + 2] = remap(data[i + 2], bMin, bMax, bGoalMin, bGoalMax);
      //data[i + 3] = remap(data[i + 3], aMin, aMax, aGoalMin, aGoalMax);
    }
  };

  /**
   * get/set enhance. Use with {@link Konva.Filters.Enhance} filter. -1 to 1 values
   * @name enhance
   * @method
   * @memberof Konva.Node.prototype
   * @param {Float} amount
   * @returns {Float}
   */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'enhance',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
})();

(function() {
  'use strict';
  /**
     * Posterize Filter. Adjusts the channels so that there are no more
     *  than n different values for that channel. This is also applied
     *  to the alpha channel.
     * @function
     * @name Posterize
     * @author ippo615
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Posterize]);
     * node.levels(0.8); // between 0 and 1
     */

  Konva.Filters.Posterize = function(imageData) {
    // level must be between 1 and 255
    var levels = Math.round(this.levels() * 254) + 1,
      data = imageData.data,
      len = data.length,
      scale = 255 / levels,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = Math.floor(data[i] / scale) * scale;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'levels',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set levels.  Must be a number between 0 and 1.  Use with {@link Konva.Filters.Posterize} filter.
    * @name levels
    * @method
    * @memberof Konva.Node.prototype
    * @param {Number} level between 0 and 1
    * @returns {Number}
    */
})();

(function() {
  'use strict';
  /**
   * Noise Filter. Randomly adds or substracts to the color channels
   * @function
   * @name Noise
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Noise]);
   * node.noise(0.8);
   */
  Konva.Filters.Noise = function(imageData) {
    var amount = this.noise() * 255,
      data = imageData.data,
      nPixels = data.length,
      half = amount / 2,
      i;

    for (i = 0; i < nPixels; i += 4) {
      data[i + 0] += half - 2 * half * Math.random();
      data[i + 1] += half - 2 * half * Math.random();
      data[i + 2] += half - 2 * half * Math.random();
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'noise',
    0.2,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set noise amount.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Noise} filter.
   * @name noise
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} noise
   * @returns {Number}
   */
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  /**
   * Pixelate Filter. Averages groups of pixels and redraws
   *  them as larger pixels
   * @function
   * @name Pixelate
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Pixelate]);
   * node.pixelSize(10);
   */

  Konva.Filters.Pixelate = function(imageData) {
    var pixelSize = Math.ceil(this.pixelSize()),
      width = imageData.width,
      height = imageData.height,
      x,
      y,
      i,
      //pixelsPerBin = pixelSize * pixelSize,
      red,
      green,
      blue,
      alpha,
      nBinsX = Math.ceil(width / pixelSize),
      nBinsY = Math.ceil(height / pixelSize),
      xBinStart,
      xBinEnd,
      yBinStart,
      yBinEnd,
      xBin,
      yBin,
      pixelsInBin;
    imageData = imageData.data;

    if (pixelSize <= 0) {
      Konva.Util.error('pixelSize value can not be <= 0');
      return;
    }

    for (xBin = 0; xBin < nBinsX; xBin += 1) {
      for (yBin = 0; yBin < nBinsY; yBin += 1) {
        // Initialize the color accumlators to 0
        red = 0;
        green = 0;
        blue = 0;
        alpha = 0;

        // Determine which pixels are included in this bin
        xBinStart = xBin * pixelSize;
        xBinEnd = xBinStart + pixelSize;
        yBinStart = yBin * pixelSize;
        yBinEnd = yBinStart + pixelSize;

        // Add all of the pixels to this bin!
        pixelsInBin = 0;
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            red += imageData[i + 0];
            green += imageData[i + 1];
            blue += imageData[i + 2];
            alpha += imageData[i + 3];
            pixelsInBin += 1;
          }
        }

        // Make sure the channels are between 0-255
        red = red / pixelsInBin;
        green = green / pixelsInBin;
        blue = blue / pixelsInBin;
        alpha = alpha / pixelsInBin;

        // Draw this bin
        for (x = xBinStart; x < xBinEnd; x += 1) {
          if (x >= width) {
            continue;
          }
          for (y = yBinStart; y < yBinEnd; y += 1) {
            if (y >= height) {
              continue;
            }
            i = (width * y + x) * 4;
            imageData[i + 0] = red;
            imageData[i + 1] = green;
            imageData[i + 2] = blue;
            imageData[i + 3] = alpha;
          }
        }
      }
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'pixelSize',
    8,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set pixel size. Use with {@link Konva.Filters.Pixelate} filter.
   * @name pixelSize
   * @method
   * @memberof Konva.Node.prototype
   * @param {Integer} pixelSize
   * @returns {Integer}
   */
})();

(function() {
  'use strict';
  /**
   * Threshold Filter. Pushes any value above the mid point to
   *  the max and any value below the mid point to the min.
   *  This affects the alpha channel.
   * @function
   * @name Threshold
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @author ippo615
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Threshold]);
   * node.threshold(0.1);
   */

  Konva.Filters.Threshold = function(imageData) {
    var level = this.threshold() * 255,
      data = imageData.data,
      len = data.length,
      i;

    for (i = 0; i < len; i += 1) {
      data[i] = data[i] < level ? 0 : 255;
    }
  };

  Konva.Factory.addGetterSetter(
    Konva.Node,
    'threshold',
    0.5,
    null,
    Konva.Factory.afterSetFilter
  );
  /**
   * get/set threshold.  Must be a value between 0 and 1. Use with {@link Konva.Filters.Threshold} or {@link Konva.Filters.Mask} filter.
   * @name threshold
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} threshold
   * @returns {Number}
   */
})();

(function() {
  'use strict';
  /**
     * Sepia Filter
     * Based on: Pixastic Lib - Sepia filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * @function
     * @name Sepia
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @author Jacob Seidelin <jseidelin@nihilogic.dk>
     * @license MPL v1.1 [http://www.pixastic.com/lib/license.txt]
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Sepia]);
     */
  Konva.Filters.Sepia = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      y = imageData.height,
      w4 = w * 4,
      offsetY,
      x,
      offset,
      or,
      og,
      ob,
      r,
      g,
      b;

    do {
      offsetY = (y - 1) * w4;
      x = w;
      do {
        offset = offsetY + (x - 1) * 4;

        or = data[offset];
        og = data[offset + 1];
        ob = data[offset + 2];

        r = or * 0.393 + og * 0.769 + ob * 0.189;
        g = or * 0.349 + og * 0.686 + ob * 0.168;
        b = or * 0.272 + og * 0.534 + ob * 0.131;

        data[offset] = r > 255 ? 255 : r;
        data[offset + 1] = g > 255 ? 255 : g;
        data[offset + 2] = b > 255 ? 255 : b;
        data[offset + 3] = data[offset + 3];
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /**
     * Solarize Filter
     * Pixastic Lib - Solarize filter - v0.1.0
     * Copyright (c) 2008 Jacob Seidelin, jseidelin@nihilogic.dk, http://blog.nihilogic.dk/
     * License: [http://www.pixastic.com/lib/license.txt]
     * @function
     * @name Solarize
     * @memberof Konva.Filters
     * @param {Object} imageData
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Solarize]);
     */
  Konva.Filters.Solarize = function(imageData) {
    var data = imageData.data,
      w = imageData.width,
      h = imageData.height,
      w4 = w * 4,
      y = h;

    do {
      var offsetY = (y - 1) * w4;
      var x = w;
      do {
        var offset = offsetY + (x - 1) * 4;
        var r = data[offset];
        var g = data[offset + 1];
        var b = data[offset + 2];

        if (r > 127) {
          r = 255 - r;
        }
        if (g > 127) {
          g = 255 - g;
        }
        if (b > 127) {
          b = 255 - b;
        }

        data[offset] = r;
        data[offset + 1] = g;
        data[offset + 2] = b;
      } while (--x);
    } while (--y);
  };
})();

(function() {
  'use strict';
  /*
   * ToPolar Filter. Converts image data to polar coordinates. Performs
   *  w*h*4 pixel reads and w*h pixel writes. The r axis is placed along
   *  what would be the y axis and the theta axis along the x axis.
   * @function
   * @author ippo615
   * @memberof Konva.Filters
   * @param {ImageData} src, the source image data (what will be transformed)
   * @param {ImageData} dst, the destination image data (where it will be saved)
   * @param {Object} opt
   * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
   *  default is in the middle
   * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
   *  default is in the middle
   */

  var ToPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng y as the radius, and x as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta;

    // We want to cover all angles (0-360) and we need to convert to
    // radians (*PI/180)
    var conversion = 360 / tSize * Math.PI / 180,
      sin,
      cos;

    // var x1, x2, x1i, x2i, y1, y2, y1i, y2i, scale;

    for (theta = 0; theta < tSize; theta += 1) {
      sin = Math.sin(theta * conversion);
      cos = Math.cos(theta * conversion);
      for (radius = 0; radius < rSize; radius += 1) {
        x = Math.floor(xMid + rMax * radius / rSize * cos);
        y = Math.floor(yMid + rMax * radius / rSize * sin);
        i = (y * xSize + x) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        //i = (theta * xSize  +  radius) * 4;
        i = (theta + radius * xSize) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  /*
     * FromPolar Filter. Converts image data from polar coordinates back to rectangular.
     *  Performs w*h*4 pixel reads and w*h pixel writes.
     * @function
     * @author ippo615
     * @memberof Konva.Filters
     * @param {ImageData} src, the source image data (what will be transformed)
     * @param {ImageData} dst, the destination image data (where it will be saved)
     * @param {Object} opt
     * @param {Number} [opt.polarCenterX] horizontal location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarCenterY] vertical location for the center of the circle,
     *  default is in the middle
     * @param {Number} [opt.polarRotation] amount to rotate the image counterclockwis,
     *  0 is no rotation, 360 degrees is a full rotation
     */

  var FromPolar = function(src, dst, opt) {
    var srcPixels = src.data,
      dstPixels = dst.data,
      xSize = src.width,
      ySize = src.height,
      xMid = opt.polarCenterX || xSize / 2,
      yMid = opt.polarCenterY || ySize / 2,
      i,
      x,
      y,
      dx,
      dy,
      r = 0,
      g = 0,
      b = 0,
      a = 0;

    // Find the largest radius
    var rad,
      rMax = Math.sqrt(xMid * xMid + yMid * yMid);
    x = xSize - xMid;
    y = ySize - yMid;
    rad = Math.sqrt(x * x + y * y);
    rMax = rad > rMax ? rad : rMax;

    // We'll be uisng x as the radius, and y as the angle (theta=t)
    var rSize = ySize,
      tSize = xSize,
      radius,
      theta,
      phaseShift = opt.polarRotation || 0;

    // We need to convert to degrees and we need to make sure
    // it's between (0-360)
    // var conversion = tSize/360*180/Math.PI;
    //var conversion = tSize/360*180/Math.PI;

    var x1, y1;

    for (x = 0; x < xSize; x += 1) {
      for (y = 0; y < ySize; y += 1) {
        dx = x - xMid;
        dy = y - yMid;
        radius = Math.sqrt(dx * dx + dy * dy) * rSize / rMax;
        theta = (Math.atan2(dy, dx) * 180 / Math.PI + 360 + phaseShift) % 360;
        theta = theta * tSize / 360;
        x1 = Math.floor(theta);
        y1 = Math.floor(radius);
        i = (y1 * xSize + x1) * 4;
        r = srcPixels[i + 0];
        g = srcPixels[i + 1];
        b = srcPixels[i + 2];
        a = srcPixels[i + 3];

        // Store it
        i = (y * xSize + x) * 4;
        dstPixels[i + 0] = r;
        dstPixels[i + 1] = g;
        dstPixels[i + 2] = b;
        dstPixels[i + 3] = a;
      }
    }
  };

  //Konva.Filters.ToPolar = Konva.Util._FilterWrapDoubleBuffer(ToPolar);
  //Konva.Filters.FromPolar = Konva.Util._FilterWrapDoubleBuffer(FromPolar);

  // create a temporary canvas for working - shared between multiple calls

  /*
     * Kaleidoscope Filter.
     * @function
     * @name Kaleidoscope
     * @author ippo615
     * @memberof Konva.Filters
     * @example
     * node.cache();
     * node.filters([Konva.Filters.Kaleidoscope]);
     * node.kaleidoscopePower(3);
     * node.kaleidoscopeAngle(45);
     */
  Konva.Filters.Kaleidoscope = function(imageData) {
    var xSize = imageData.width,
      ySize = imageData.height;

    var x, y, xoff, i, r, g, b, a, srcPos, dstPos;
    var power = Math.round(this.kaleidoscopePower());
    var angle = Math.round(this.kaleidoscopeAngle());
    var offset = Math.floor(xSize * (angle % 360) / 360);

    if (power < 1) {
      return;
    }

    // Work with our shared buffer canvas
    var tempCanvas = Konva.Util.createCanvasElement();
    tempCanvas.width = xSize;
    tempCanvas.height = ySize;
    var scratchData = tempCanvas
      .getContext('2d')
      .getImageData(0, 0, xSize, ySize);

    // Convert thhe original to polar coordinates
    ToPolar(imageData, scratchData, {
      polarCenterX: xSize / 2,
      polarCenterY: ySize / 2
    });

    // Determine how big each section will be, if it's too small
    // make it bigger
    var minSectionSize = xSize / Math.pow(2, power);
    while (minSectionSize <= 8) {
      minSectionSize = minSectionSize * 2;
      power -= 1;
    }
    minSectionSize = Math.ceil(minSectionSize);
    var sectionSize = minSectionSize;

    // Copy the offset region to 0
    // Depending on the size of filter and location of the offset we may need
    // to copy the section backwards to prevent it from rewriting itself
    var xStart = 0,
      xEnd = sectionSize,
      xDelta = 1;
    if (offset + minSectionSize > xSize) {
      xStart = sectionSize;
      xEnd = 0;
      xDelta = -1;
    }
    for (y = 0; y < ySize; y += 1) {
      for (x = xStart; x !== xEnd; x += xDelta) {
        xoff = Math.round(x + offset) % xSize;
        srcPos = (xSize * y + xoff) * 4;
        r = scratchData.data[srcPos + 0];
        g = scratchData.data[srcPos + 1];
        b = scratchData.data[srcPos + 2];
        a = scratchData.data[srcPos + 3];
        dstPos = (xSize * y + x) * 4;
        scratchData.data[dstPos + 0] = r;
        scratchData.data[dstPos + 1] = g;
        scratchData.data[dstPos + 2] = b;
        scratchData.data[dstPos + 3] = a;
      }
    }

    // Perform the actual effect
    for (y = 0; y < ySize; y += 1) {
      sectionSize = Math.floor(minSectionSize);
      for (i = 0; i < power; i += 1) {
        for (x = 0; x < sectionSize + 1; x += 1) {
          srcPos = (xSize * y + x) * 4;
          r = scratchData.data[srcPos + 0];
          g = scratchData.data[srcPos + 1];
          b = scratchData.data[srcPos + 2];
          a = scratchData.data[srcPos + 3];
          dstPos = (xSize * y + sectionSize * 2 - x - 1) * 4;
          scratchData.data[dstPos + 0] = r;
          scratchData.data[dstPos + 1] = g;
          scratchData.data[dstPos + 2] = b;
          scratchData.data[dstPos + 3] = a;
        }
        sectionSize *= 2;
      }
    }

    // Convert back from polar coordinates
    FromPolar(scratchData, imageData, { polarRotation: 0 });
  };

  /**
    * get/set kaleidoscope power. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopePower
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} power of kaleidoscope
    * @returns {Integer}
    */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopePower',
    2,
    null,
    Konva.Factory.afterSetFilter
  );

  /**
    * get/set kaleidoscope angle. Use with {@link Konva.Filters.Kaleidoscope} filter.
    * @name kaleidoscopeAngle
    * @method
    * @memberof Konva.Node.prototype
    * @param {Integer} degrees
    * @returns {Integer}
    */
  Konva.Factory.addGetterSetter(
    Konva.Node,
    'kaleidoscopeAngle',
    0,
    null,
    Konva.Factory.afterSetFilter
  );
})();

(function (Konva) {
  'use strict';
  /**
   * Contrast Filter.
   * @function
   * @memberof Konva.Filters
   * @param {Object} imageData
   * @example
   * node.cache();
   * node.filters([Konva.Filters.Contrast]);
   * node.contrast(10);
   */

  Konva.Filters.Contrast = function (imageData) {
    var adjust = Math.pow((parseInt(this.contrast()) + 100) / 100, 2);

    var data = imageData.data,
      nPixels = data.length,
      red = 150,
      green = 150,
      blue = 150,
      i;

    for (i = 0; i < nPixels; i += 4) {
      red = data[i];
      green = data[i + 1];
      blue = data[i + 2];

      //Red channel
      red /= 255;
      red -= 0.5;
      red *= adjust;
      red += 0.5;
      red *= 255;

      //Green channel
      green /= 255;
      green -= 0.5;
      green *= adjust;
      green += 0.5;
      green *= 255;

      //Blue channel
      blue /= 255;
      blue -= 0.5;
      blue *= adjust;
      blue += 0.5;
      blue *= 255;

      red = (red < 0 ? 0 : (red > 255 ? 255 : red));
      green = (green < 0 ? 0 : (green > 255 ? 255 : green));
      blue = (blue < 0 ? 0 : (blue > 255 ? 255 : blue));

      data[i] = red;
      data[i + 1] = green;
      data[i + 2] = blue;
    }
  };

  /**
   * get/set filter contrast.  The contrast is a number between -100 and 100.
   * Use with {@link Konva.Filters.Contrast} filter.
   * @name contrast
   * @method
   * @memberof Konva.Node.prototype
   * @param {Number} contrast value between -100 and 100
   * @returns {Number}
   */
  Konva.Factory.addGetterSetter(Konva.Node, 'contrast', 0, null, Konva.Factory.afterSetFilter);
})(Konva);

(function() {
  'use strict';
  /**
   * Container constructor.&nbsp; Containers are used to contain nodes or other containers
   * @constructor
   * @memberof Konva
   * @augments Konva.Node
   * @abstract
   * @param {Object} config
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   */
  Konva.Container = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Container, {
    __init: function(config) {
      this.children = new Konva.Collection();
      Konva.Node.call(this, config);
    },
    /**
     * returns a {@link Konva.Collection} of direct descendant nodes
     * @method
     * @memberof Konva.Container.prototype
     * @param {Function} [filterFunc] filter function
     * @returns {Konva.Collection}
     * @example
     * // get all children
     * var children = layer.getChildren();
     *
     * // get only circles
     * var circles = layer.getChildren(function(node){
     *    return node.getClassName() === 'Circle';
     * });
     */
    getChildren: function(filterFunc) {
      if (!filterFunc) {
        return this.children;
      }

      var results = new Konva.Collection();
      this.children.each(function(child) {
        if (filterFunc(child)) {
          results.push(child);
        }
      });
      return results;
    },
    /**
     * determine if node has children
     * @method
     * @memberof Konva.Container.prototype
     * @returns {Boolean}
     */
    hasChildren: function() {
      return this.getChildren().length > 0;
    },
    /**
     * remove all children
     * @method
     * @memberof Konva.Container.prototype
     */
    removeChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.remove();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
     * destroy all children
     * @method
     * @memberof Konva.Container.prototype
     */
    destroyChildren: function() {
      var children = Konva.Collection.toCollection(this.children);
      var child;
      for (var i = 0; i < children.length; i++) {
        child = children[i];
        // reset parent to prevent many _setChildrenIndices calls
        delete child.parent;
        child.index = 0;
        child.destroy();
      }
      children = null;
      this.children = new Konva.Collection();
      return this;
    },
    /**
     * Add node or nodes to container.
     * @method
     * @memberof Konva.Container.prototype
     * @param {...Konva.Node} child
     * @returns {Container}
     * @example
     * layer.add(shape1, shape2, shape3);
     */
    add: function(child) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (child.getParent()) {
        child.moveTo(this);
        return this;
      }
      var children = this.children;
      this._validateAdd(child);
      child.index = children.length;
      child.parent = this;
      children.push(child);
      this._fire('add', {
        child: child
      });

      // if node under drag we need to update drag animation
      if (Konva.DD && child.isDragging()) {
        Konva.DD.anim.setLayers(child.getLayer());
      }

      // chainable
      return this;
    },
    destroy: function() {
      // destroy children
      if (this.hasChildren()) {
        this.destroyChildren();
      }
      // then destroy self
      Konva.Node.prototype.destroy.call(this);
      return this;
    },
    /**
     * return a {@link Konva.Collection} of nodes that match the selector.
     * You can provide a string with '#' for id selections and '.' for name selections.
     * Or a function that will return true/false when a node is passed through.  See example below.
     * With strings you can also select by type or class name. Pass multiple selectors
     * separated by a space.
     * @method
     * @memberof Konva.Container.prototype
     * @param {String | Function} selector
     * @returns {Collection}
     * @example
     *
     * Passing a string as a selector
     * // select node with id foo
     * var node = stage.find('#foo');
     *
     * // select nodes with name bar inside layer
     * var nodes = layer.find('.bar');
     *
     * // select all groups inside layer
     * var nodes = layer.find('Group');
     *
     * // select all rectangles inside layer
     * var nodes = layer.find('Rect');
     *
     * // select node with an id of foo or a name of bar inside layer
     * var nodes = layer.find('#foo, .bar');
     *
     * Passing a function as a selector
     *
     * // get all Groups
     * var groups = stage.find(node => {
     *  return node.getType() === 'Group';
     * });
     *
     * // get only Nodes with partial opacity
     * var alphaNodes = layer.find(node => {
     *  return node.getType() === 'Node' && node.getAbsoluteOpacity() < 1;
     * });
     */
    find: function(selector) {
      // protecting _generalFind to prevent user from accidentally adding
      // second argument and getting unexpected `findOne` result
      return this._generalFind(selector, false);
    },
    /**
     * return a first node from `find` method
     * @method
     * @memberof Konva.Container.prototype
     * @param {String | Function} selector
     * @returns {Konva.Node | Undefined}
     * @example
     * // select node with id foo
     * var node = stage.findOne('#foo');
     *
     * // select node with name bar inside layer
     * var nodes = layer.findOne('.bar');
     *
     * // select the first node to return true in a function
     * var node = stage.findOne(node => {
     *  return node.getType() === 'Shape'
     * })
     */
    findOne: function(selector) {
      var result = this._generalFind(selector, true);
      return result.length > 0 ? result[0] : undefined;
    },
    _generalFind: function(selector, findOne) {
      var retArr = [];

      if (typeof selector === 'string') {
        retArr = this._findByString(selector, findOne);
      } else if (typeof selector === 'function') {
        retArr = this._findByFunction(selector, findOne);
      }

      return Konva.Collection.toCollection(retArr);
    },
    _findByString: function(selector) {
      var retArr = [],
        selectorArr = selector.replace(/ /g, '').split(','),
        len = selectorArr.length,
        n,
        i,
        sel,
        arr,
        node,
        children,
        clen;

      for (n = 0; n < len; n++) {
        sel = selectorArr[n];
        if (!Konva.Util.isValidSelector(sel)) {
          Konva.Util.warn(
            'Selector "' +
              sel +
              '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'
          );
          Konva.Util.warn(
            'If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'
          );
          Konva.Util.warn('Konva is awesome, right?');
        }
        // id selector
        if (sel.charAt(0) === '#') {
          node = this._getNodeById(sel.slice(1));
          if (node) {
            retArr.push(node);
          }
        } else if (sel.charAt(0) === '.') {
          // name selector
          arr = this._getNodesByName(sel.slice(1));
          retArr = retArr.concat(arr);
        } else {
          // unrecognized selector, pass to children
          children = this.getChildren();
          clen = children.length;
          for (i = 0; i < clen; i++) {
            retArr = retArr.concat(children[i]._get(sel));
          }
        }
      }

      return retArr;
    },
    // (fn: ((Node) => boolean, findOne?: boolean)
    _findByFunction: function(fn, findOne) {
      var retArr = [];

      var addItems = function(el) {
        // escape function if we've already found one.
        if (findOne && retArr.length > 0) {
          return;
        }

        var children = el.getChildren();
        var clen = children.length;

        if (fn(el)) {
          retArr = retArr.concat(el);
        }

        for (var i = 0; i < clen; i++) {
          addItems(children[i]);
        }
      };

      addItems(this);

      return retArr;
    },
    _getNodeById: function(key) {
      var node = Konva.ids[key];

      if (node !== undefined && this.isAncestorOf(node)) {
        return node;
      }
      return null;
    },
    _getNodesByName: function(key) {
      var arr = Konva.names[key] || [];
      return this._getDescendants(arr);
    },
    _get: function(selector) {
      var retArr = Konva.Node.prototype._get.call(this, selector);
      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        retArr = retArr.concat(children[n]._get(selector));
      }
      return retArr;
    },
    // extenders
    toObject: function() {
      var obj = Konva.Node.prototype.toObject.call(this);

      obj.children = [];

      var children = this.getChildren();
      var len = children.length;
      for (var n = 0; n < len; n++) {
        var child = children[n];
        obj.children.push(child.toObject());
      }

      return obj;
    },
    _getDescendants: function(arr) {
      var retArr = [];
      var len = arr.length;
      for (var n = 0; n < len; n++) {
        var node = arr[n];
        if (this.isAncestorOf(node)) {
          retArr.push(node);
        }
      }

      return retArr;
    },
    /**
     * determine if node is an ancestor
     * of descendant
     * @method
     * @memberof Konva.Container.prototype
     * @param {Konva.Node} node
     */
    isAncestorOf: function(node) {
      var parent = node.getParent();
      while (parent) {
        if (parent._id === this._id) {
          return true;
        }
        parent = parent.getParent();
      }

      return false;
    },
    clone: function(obj) {
      // call super method
      var node = Konva.Node.prototype.clone.call(this, obj);

      this.getChildren().each(function(no) {
        node.add(no.clone());
      });
      return node;
    },
    /**
     * get all shapes that intersect a point.  Note: because this method must clear a temporary
     * canvas and redraw every shape inside the container, it should only be used for special sitations
     * because it performs very poorly.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
     * because it performs much better
     * @method
     * @memberof Konva.Container.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @returns {Array} array of shapes
     */
    getAllIntersections: function(pos) {
      var arr = [];

      this.find('Shape').each(function(shape) {
        if (shape.isVisible() && shape.intersects(pos)) {
          arr.push(shape);
        }
      });

      return arr;
    },
    _setChildrenIndices: function() {
      this.children.each(function(child, n) {
        child.index = n;
      });
    },
    drawScene: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.getCanvas()),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedSceneCanvas = cachedCanvas && cachedCanvas.scene;

      if (this.isVisible() || caching) {
        if (!caching && cachedSceneCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedSceneCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawScene', top, false, caching);
        }
      }
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || (layer && layer.hitCanvas),
        context = canvas && canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (this.shouldDrawHit(canvas) || caching) {
        if (layer) {
          layer.clearHitCache();
        }
        if (!caching && cachedHitCanvas) {
          context.save();
          layer._applyTransform(this, context, top);
          this._drawCachedHitCanvas(context);
          context.restore();
        } else {
          this._drawChildren(canvas, 'drawHit', top);
        }
      }
      return this;
    },
    _drawChildren: function(canvas, drawMethod, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        context = canvas && canvas.getContext(),
        clipWidth = this.getClipWidth(),
        clipHeight = this.getClipHeight(),
        clipFunc = this.getClipFunc(),
        hasClip = (clipWidth && clipHeight) || clipFunc,
        clipX,
        clipY;

      if (hasClip && layer) {
        context.save();
        var transform = this.getAbsoluteTransform(top);
        var m = transform.getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        context.beginPath();
        if (clipFunc) {
          clipFunc.call(this, context, this);
        } else {
          clipX = this.getClipX();
          clipY = this.getClipY();
          context.rect(clipX, clipY, clipWidth, clipHeight);
        }
        context.clip();
        m = transform
          .copy()
          .invert()
          .getMatrix();
        context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      }

      this.children.each(function(child) {
        child[drawMethod](canvas, top, caching, skipBuffer);
      });

      if (hasClip) {
        context.restore();
      }
    },
    shouldDrawHit: function(canvas) {
      var layer = this.getLayer();
      var dd = Konva.DD;
      var layerUnderDrag =
        dd &&
        Konva.isDragging() &&
        Konva.DD.anim.getLayers().indexOf(layer) !== -1;
      return (
        (canvas && canvas.isCache) ||
        (layer &&
          layer.hitGraphEnabled() &&
          this.isVisible() &&
          !layerUnderDrag)
      );
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;
      var relativeTo = attrs.relativeTo;

      var minX, minY, maxX, maxY;
      var selfRect = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
      };
      var that = this;
      this.children.each(function(child) {
        // skip invisible children
        if (!child.getVisible()) {
          return;
        }

        var rect = child.getClientRect({ relativeTo: that });

        // skip invisible children (like empty groups)
        // or don't skip... hmmm...
        // if (rect.width === 0 && rect.height === 0) {
        //     return;
        // }

        if (minX === undefined) {
          // initial value for first child
          minX = rect.x;
          minY = rect.y;
          maxX = rect.x + rect.width;
          maxY = rect.y + rect.height;
        } else {
          minX = Math.min(minX, rect.x);
          minY = Math.min(minY, rect.y);
          maxX = Math.max(maxX, rect.x + rect.width);
          maxY = Math.max(maxY, rect.y + rect.height);
        }
      });

      // if child is group we need to make sure it has visible shapes inside
      var shapes = this.find('Shape');
      var hasVisible = false;
      for (var i = 0; i < shapes.length; i++) {
        var shape = shapes[i];
        if (shape.getVisible()) {
          hasVisible = true;
          break;
        }
      }

      if (hasVisible) {
        selfRect = {
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY - minY
        };
      }

      if (!skipTransform) {
        return this._transformedRect(selfRect, relativeTo);
      }
      return selfRect;
    }
  });

  Konva.Util.extend(Konva.Container, Konva.Node);
  // deprecated methods
  Konva.Container.prototype.get = Konva.Container.prototype.find;

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Container, 'clip', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
   * get/set clip
   * @method
   * @name clip
   * @memberof Konva.Container.prototype
   * @param {Object} clip
   * @param {Number} clip.x
   * @param {Number} clip.y
   * @param {Number} clip.width
   * @param {Number} clip.height
   * @returns {Object}
   * @example
   * // get clip
   * var clip = container.clip();
   *
   * // set clip
   * container.setClip({
   *   x: 20,
   *   y: 20,
   *   width: 20,
   *   height: 20
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipX');
  /**
   * get/set clip x
   * @name clipX
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get clip x
   * var clipX = container.clipX();
   *
   * // set clip x
   * container.clipX(10);
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipY');
  /**
   * get/set clip y
   * @name clipY
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get clip y
   * var clipY = container.clipY();
   *
   * // set clip y
   * container.clipY(10);
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipWidth');
  /**
   * get/set clip width
   * @name clipWidth
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} width
   * @returns {Number}
   * @example
   * // get clip width
   * var clipWidth = container.clipWidth();
   *
   * // set clip width
   * container.clipWidth(100);
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipHeight');
  /**
   * get/set clip height
   * @name clipHeight
   * @method
   * @memberof Konva.Container.prototype
   * @param {Number} height
   * @returns {Number}
   * @example
   * // get clip height
   * var clipHeight = container.clipHeight();
   *
   * // set clip height
   * container.clipHeight(100);
   */

  Konva.Factory.addGetterSetter(Konva.Container, 'clipFunc');
  /**
   * get/set clip function
   * @name clipFunc
   * @method
   * @memberof Konva.Container.prototype
   * @param {Function} function
   * @returns {Function}
   * @example
   * // get clip function
   * var clipFunction = container.clipFunc();
   *
   * // set clip height
   * container.clipFunc(function(ctx) {
   *   ctx.rect(0, 0, 100, 100);
   * });
   */

  Konva.Collection.mapMethods(Konva.Container);
})();

(function(Konva) {
  'use strict';
  var HAS_SHADOW = 'hasShadow';
  var SHADOW_RGBA = 'shadowRGBA';

  function _fillFunc(context) {
    context.fill();
  }
  function _strokeFunc(context) {
    context.stroke();
  }
  function _fillFuncHit(context) {
    context.fill();
  }
  function _strokeFuncHit(context) {
    context.stroke();
  }

  function _clearHasShadowCache() {
    this._clearCache(HAS_SHADOW);
  }

  function _clearGetShadowRGBACache() {
    this._clearCache(SHADOW_RGBA);
  }

  /**
   * Shape constructor.  Shapes are primitive objects such as rectangles,
   *  circles, text, lines, etc.
   * @constructor
   * @memberof Konva
   * @augments Konva.Node
   * @param {Object} config
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var customShape = new Konva.Shape({
   *   x: 5,
   *   y: 10,
   *   fill: 'red',
   *   // a Konva.Canvas renderer is passed into the drawFunc function
   *   drawFunc: function(context) {
   *     context.beginPath();
   *     context.moveTo(200, 50);
   *     context.lineTo(420, 80);
   *     context.quadraticCurveTo(300, 100, 260, 170);
   *     context.closePath();
   *     context.fillStrokeShape(this);
   *   }
   *});
   */
  Konva.Shape = function(config) {
    this.__init(config);
  };

  Konva.Util.addMethods(Konva.Shape, {
    __init: function(config) {
      this.nodeType = 'Shape';
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFuncHit;
      this._strokeFuncHit = _strokeFuncHit;

      // set colorKey
      var shapes = Konva.shapes;
      var key;

      while (true) {
        key = Konva.Util.getRandomColor();
        if (key && !(key in shapes)) {
          break;
        }
      }

      this.colorKey = key;
      shapes[key] = this;

      // call super constructor
      Konva.Node.call(this, config);

      this.on(
        'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearHasShadowCache
      );

      this.on(
        'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva',
        _clearGetShadowRGBACache
      );
    },
    hasChildren: function() {
      return false;
    },
    getChildren: function() {
      return [];
    },
    /**
     * get canvas context tied to the layer
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Konva.Context}
     */
    getContext: function() {
      return this.getLayer().getContext();
    },
    /**
     * get canvas renderer tied to the layer.  Note that this returns a canvas renderer, not a canvas element
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Konva.Canvas}
     */
    getCanvas: function() {
      return this.getLayer().getCanvas();
    },
    /**
     * returns whether or not a shadow will be rendered
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasShadow: function() {
      return this._getCache(HAS_SHADOW, this._hasShadow);
    },
    _hasShadow: function() {
      return (
        this.getShadowEnabled() &&
        (this.getShadowOpacity() !== 0 &&
          !!(
            this.getShadowColor() ||
            this.getShadowBlur() ||
            this.getShadowOffsetX() ||
            this.getShadowOffsetY()
          ))
      );
    },
    getShadowRGBA: function() {
      return this._getCache(SHADOW_RGBA, this._getShadowRGBA);
    },
    _getShadowRGBA: function() {
      if (this.hasShadow()) {
        var rgba = Konva.Util.colorToRGBA(this.shadowColor());
        return (
          'rgba(' +
          rgba.r +
          ',' +
          rgba.g +
          ',' +
          rgba.b +
          ',' +
          rgba.a * (this.getShadowOpacity() || 1) +
          ')'
        );
      }
    },
    /**
     * returns whether or not the shape will be filled
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasFill: function() {
      return !!(
        this.getFill() ||
        this.getFillPatternImage() ||
        this.getFillLinearGradientColorStops() ||
        this.getFillRadialGradientColorStops()
      );
    },
    /**
     * returns whether or not the shape will be stroked
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Boolean}
     */
    hasStroke: function() {
      return (
        this.strokeEnabled() &&
        !!(this.stroke() || this.getStrokeLinearGradientColorStops())
        // TODO: do we need radial gradient
        // this.getStrokeRadialGradientColorStops()
      );
    },
    /**
     * determines if point is in the shape, regardless if other shapes are on top of it.  Note: because
     *  this method clears a temporary canvas and then redraws the shape, it performs very poorly if executed many times
     *  consecutively.  Please use the {@link Konva.Stage#getIntersection} method if at all possible
     *  because it performs much better
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Object} point
     * @param {Number} point.x
     * @param {Number} point.y
     * @returns {Boolean}
     */
    intersects: function(point) {
      var stage = this.getStage(),
        bufferHitCanvas = stage.bufferHitCanvas,
        p;

      bufferHitCanvas.getContext().clear();
      this.drawHit(bufferHitCanvas);
      p = bufferHitCanvas.context.getImageData(
        Math.round(point.x),
        Math.round(point.y),
        1,
        1
      ).data;
      return p[3] > 0;
    },
    // extends Node.prototype.destroy
    destroy: function() {
      Konva.Node.prototype.destroy.call(this);
      delete Konva.shapes[this.colorKey];
      return this;
    },
    _useBufferCanvas: function(caching) {
      return (
        (!caching &&
          (this.perfectDrawEnabled() &&
            this.getAbsoluteOpacity() !== 1 &&
            this.hasFill() &&
            this.hasStroke() &&
            this.getStage())) ||
        (this.perfectDrawEnabled() &&
          this.hasShadow() &&
          this.getAbsoluteOpacity() !== 1 &&
          this.hasFill() &&
          this.hasStroke() &&
          this.getStage())
      );
    },
    /**
     * return self rectangle (x, y, width, height) of shape.
     * This method are not taken into account transformation and styles.
     * @method
     * @memberof Konva.Shape.prototype
     * @returns {Object} rect with {x, y, width, height} properties
     * @example
     *
     * rect.getSelfRect();  // return {x:0, y:0, width:rect.width(), height:rect.height()}
     * circle.getSelfRect();  // return {x: - circle.width() / 2, y: - circle.height() / 2, width:circle.width(), height:circle.height()}
     *
     */
    getSelfRect: function() {
      var size = this.getSize();
      return {
        x: this._centroid ? Math.round(-size.width / 2) : 0,
        y: this._centroid ? Math.round(-size.height / 2) : 0,
        width: size.width,
        height: size.height
      };
    },
    getClientRect: function(attrs) {
      attrs = attrs || {};
      var skipTransform = attrs.skipTransform;
      var relativeTo = attrs.relativeTo;

      var fillRect = this.getSelfRect();

      var strokeWidth = (this.hasStroke() && this.strokeWidth()) || 0;
      var fillAndStrokeWidth = fillRect.width + strokeWidth;
      var fillAndStrokeHeight = fillRect.height + strokeWidth;

      var shadowOffsetX = this.hasShadow() ? this.shadowOffsetX() : 0;
      var shadowOffsetY = this.hasShadow() ? this.shadowOffsetY() : 0;

      var preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);
      var preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);

      var blurRadius = (this.hasShadow() && this.shadowBlur()) || 0;

      var width = preWidth + blurRadius * 2;
      var height = preHeight + blurRadius * 2;

      // if stroke, for example = 3
      // we need to set x to 1.5, but after Math.round it will be 2
      // as we have additional offset we need to increase width and height by 1 pixel
      var roundingOffset = 0;
      if (Math.round(strokeWidth / 2) !== strokeWidth / 2) {
        roundingOffset = 1;
      }
      var rect = {
        width: width + roundingOffset,
        height: height + roundingOffset,
        x:
          -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetX, 0) +
          fillRect.x,
        y:
          -Math.round(strokeWidth / 2 + blurRadius) +
          Math.min(shadowOffsetY, 0) +
          fillRect.y
      };
      if (!skipTransform) {
        return this._transformedRect(rect, relativeTo);
      }
      return rect;
    },
    drawScene: function(can, top, caching, skipBuffer) {
      var layer = this.getLayer(),
        canvas = can || layer.getCanvas(),
        context = canvas.getContext(),
        cachedCanvas = this._cache.canvas,
        drawFunc = this.sceneFunc(),
        hasShadow = this.hasShadow(),
        hasStroke = this.hasStroke(),
        stage,
        bufferCanvas,
        bufferContext;

      if (!this.isVisible() && !caching) {
        return this;
      }
      if (cachedCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedSceneCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      // if buffer canvas is needed
      if (this._useBufferCanvas(caching) && !skipBuffer) {
        stage = this.getStage();
        bufferCanvas = stage.bufferCanvas;
        bufferContext = bufferCanvas.getContext();
        bufferContext.clear();
        bufferContext.save();
        bufferContext._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, bufferContext, top);
          } else {
            var m = this.getAbsoluteTransform(top).getMatrix();
            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
          }
        }

        drawFunc.call(this, bufferContext);
        bufferContext.restore();

        var ratio = bufferCanvas.pixelRatio;
        if (hasShadow && !canvas.hitCanvas) {
          context.save();

          context._applyShadow(this);
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
          context.restore();
        } else {
          context._applyOpacity(this);
          context._applyGlobalCompositeOperation(this);
          context.drawImage(
            bufferCanvas._canvas,
            0,
            0,
            bufferCanvas.width / ratio,
            bufferCanvas.height / ratio
          );
        }
      } else {
        // if buffer canvas is not needed
        context._applyLineJoin(this);
        // layer might be undefined if we are using cache before adding to layer
        if (!caching) {
          if (layer) {
            layer._applyTransform(this, context, top);
          } else {
            var o = this.getAbsoluteTransform(top).getMatrix();
            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
          }
        }

        if (hasShadow && hasStroke && !canvas.hitCanvas) {
          context.save();
          // apply shadow
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);

          drawFunc.call(this, context);
          context.restore();
          // if shape has stroke we need to redraw shape
          // otherwise we will see a shadow under stroke (and over fill)
          // but I think this is unexpected behavior
          if (this.hasFill() && this.getShadowForStrokeEnabled()) {
            drawFunc.call(this, context);
          }
        } else if (hasShadow && !canvas.hitCanvas) {
          context.save();
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          context._applyShadow(this);
          drawFunc.call(this, context);
          context.restore();
        } else {
          if (!caching) {
            context._applyOpacity(this);
            context._applyGlobalCompositeOperation(this);
          }
          drawFunc.call(this, context);
        }
      }
      context.restore();
      return this;
    },
    drawHit: function(can, top, caching) {
      var layer = this.getLayer(),
        canvas = can || layer.hitCanvas,
        context = canvas.getContext(),
        drawFunc = this.hitFunc() || this.sceneFunc(),
        cachedCanvas = this._cache.canvas,
        cachedHitCanvas = cachedCanvas && cachedCanvas.hit;

      if (!this.shouldDrawHit(canvas) && !caching) {
        return this;
      }
      if (layer) {
        layer.clearHitCache();
      }
      if (cachedHitCanvas) {
        context.save();
        layer._applyTransform(this, context, top);
        this._drawCachedHitCanvas(context);
        context.restore();
        return this;
      }
      if (!drawFunc) {
        return this;
      }
      context.save();
      context._applyLineJoin(this);
      if (!caching) {
        if (layer) {
          layer._applyTransform(this, context, top);
        } else {
          var o = this.getAbsoluteTransform(top).getMatrix();
          context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);
        }
      }
      drawFunc.call(this, context);
      context.restore();
      return this;
    },
    /**
     * draw hit graph using the cached scene canvas
     * @method
     * @memberof Konva.Shape.prototype
     * @param {Integer} alphaThreshold alpha channel threshold that determines whether or not
     *  a pixel should be drawn onto the hit graph.  Must be a value between 0 and 255.
     *  The default is 0
     * @returns {Konva.Shape}
     * @example
     * shape.cache();
     * shape.drawHitFromCache();
     */
    drawHitFromCache: function(alphaThreshold) {
      var threshold = alphaThreshold || 0,
        cachedCanvas = this._cache.canvas,
        sceneCanvas = this._getCachedSceneCanvas(),
        hitCanvas = cachedCanvas.hit,
        hitContext = hitCanvas.getContext(),
        hitWidth = hitCanvas.getWidth(),
        hitHeight = hitCanvas.getHeight(),
        hitImageData,
        hitData,
        len,
        rgbColorKey,
        i,
        alpha;

      hitContext.clear();
      hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);

      try {
        hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);
        hitData = hitImageData.data;
        len = hitData.length;
        rgbColorKey = Konva.Util._hexToRgb(this.colorKey);

        // replace non transparent pixels with color key
        for (i = 0; i < len; i += 4) {
          alpha = hitData[i + 3];
          if (alpha > threshold) {
            hitData[i] = rgbColorKey.r;
            hitData[i + 1] = rgbColorKey.g;
            hitData[i + 2] = rgbColorKey.b;
            hitData[i + 3] = 255;
          } else {
            hitData[i + 3] = 0;
          }
        }
        hitContext.putImageData(hitImageData, 0, 0);
      } catch (e) {
        Konva.Util.error(
          'Unable to draw hit graph from cached scene canvas. ' + e.message
        );
      }

      return this;
    }
  });
  Konva.Util.extend(Konva.Shape, Konva.Node);

  // add getters and setters
  Konva.Factory.addGetterSetter(Konva.Shape, 'stroke');

  /**
   * get/set stroke color
   * @name stroke
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get stroke color
   * var stroke = shape.stroke();
   *
   * // set stroke color with color string
   * shape.stroke('green');
   *
   * // set stroke color with hex
   * shape.stroke('#00ff00');
   *
   * // set stroke color with rgb
   * shape.stroke('rgb(0,255,0)');
   *
   * // set stroke color with rgba and make it 50% opaque
   * shape.stroke('rgba(0,255,0,0.5');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeWidth', 2);

  /**
   * get/set stroke width
   * @name strokeWidth
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} strokeWidth
   * @returns {Number}
   * @example
   * // get stroke width
   * var strokeWidth = shape.strokeWidth();
   *
   * // set stroke width
   * shape.strokeWidth();
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeHitEnabled', true);

  /**
   * get/set strokeHitEnabled property. Useful for performance optimization.
   * You may set `shape.strokeHitEnabled(false)`. In this case stroke will be no draw on hit canvas, so hit area
   * of shape will be decreased (by lineWidth / 2). Remember that non closed line with `strokeHitEnabled = false`
   * will be not drawn on hit canvas, that is mean line will no trigger pointer events (like mouseover)
   * Default value is true
   * @name strokeHitEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} strokeHitEnabled
   * @returns {Boolean}
   * @example
   * // get strokeHitEnabled
   * var strokeHitEnabled = shape.strokeHitEnabled();
   *
   * // set strokeHitEnabled
   * shape.strokeHitEnabled();
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'perfectDrawEnabled', true);

  /**
   * get/set perfectDrawEnabled. If a shape has fill, stroke and opacity you may set `perfectDrawEnabled` to false to improve performance.
   * See http://konvajs.github.io/docs/performance/Disable_Perfect_Draw.html for more information.
   * Default value is true
   * @name perfectDrawEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} perfectDrawEnabled
   * @returns {Boolean}
   * @example
   * // get perfectDrawEnabled
   * var perfectDrawEnabled = shape.perfectDrawEnabled();
   *
   * // set perfectDrawEnabled
   * shape.perfectDrawEnabled();
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowForStrokeEnabled', true);

  /**
   * get/set shadowForStrokeEnabled. Useful for performance optimization.
   * You may set `shape.shadowForStrokeEnabled(false)`. In this case stroke will be no draw shadow for stroke.
   * Remember if you set `shadowForStrokeEnabled = false` for non closed line - that line with have no shadow!.
   * Default value is true
   * @name shadowForStrokeEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} shadowForStrokeEnabled
   * @returns {Boolean}
   * @example
   * // get shadowForStrokeEnabled
   * var shadowForStrokeEnabled = shape.shadowForStrokeEnabled();
   *
   * // set shadowForStrokeEnabled
   * shape.shadowForStrokeEnabled();
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineJoin');

  /**
   * get/set line join.  Can be miter, round, or bevel.  The
   *  default is miter
   * @name lineJoin
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} lineJoin
   * @returns {String}
   * @example
   * // get line join
   * var lineJoin = shape.lineJoin();
   *
   * // set line join
   * shape.lineJoin('round');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'lineCap');

  /**
   * get/set line cap.  Can be butt, round, or square
   * @name lineCap
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} lineCap
   * @returns {String}
   * @example
   * // get line cap
   * var lineCap = shape.lineCap();
   *
   * // set line cap
   * shape.lineCap('round');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'sceneFunc');

  /**
   * get/set scene draw function
   * @name sceneFunc
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Function} drawFunc drawing function
   * @returns {Function}
   * @example
   * // get scene draw function
   * var sceneFunc = shape.sceneFunc();
   *
   * // set scene draw function
   * shape.sceneFunc(function(context) {
   *   context.beginPath();
   *   context.rect(0, 0, this.width(), this.height());
   *   context.closePath();
   *   context.fillStrokeShape(this);
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'hitFunc');

  /**
   * get/set hit draw function
   * @name hitFunc
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Function} drawFunc drawing function
   * @returns {Function}
   * @example
   * // get hit draw function
   * var hitFunc = shape.hitFunc();
   *
   * // set hit draw function
   * shape.hitFunc(function(context) {
   *   context.beginPath();
   *   context.rect(0, 0, this.width(), this.height());
   *   context.closePath();
   *   context.fillStrokeShape(this);
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dash');

  /**
   * get/set dash array for stroke.
   * @name dash
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} dash
   * @returns {Array}
   * @example
   *  // apply dashed stroke that is 10px long and 5 pixels apart
   *  line.dash([10, 5]);
   *  // apply dashed stroke that is made up of alternating dashed
   *  // lines that are 10px long and 20px apart, and dots that have
   *  // a radius of 5px and are 20px apart
   *  line.dash([10, 20, 0.001, 20]);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dashOffset', 0);

  /**
   * get/set dash offset for stroke.
   * @name dash
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} dash offset
   * @returns {Number}
   * @example
   *  // apply dashed stroke that is 10px long and 5 pixels apart with an offset of 5px
   *  line.dash([10, 5]);
   *  line.dashOffset(5);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowColor');

  /**
   * get/set shadow color
   * @name shadowColor
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get shadow color
   * var shadow = shape.shadowColor();
   *
   * // set shadow color with color string
   * shape.shadowColor('green');
   *
   * // set shadow color with hex
   * shape.shadowColor('#00ff00');
   *
   * // set shadow color with rgb
   * shape.shadowColor('rgb(0,255,0)');
   *
   * // set shadow color with rgba and make it 50% opaque
   * shape.shadowColor('rgba(0,255,0,0.5');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowBlur');

  /**
   * get/set shadow blur
   * @name shadowBlur
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} blur
   * @returns {Number}
   * @example
   * // get shadow blur
   * var shadowBlur = shape.shadowBlur();
   *
   * // set shadow blur
   * shape.shadowBlur(10);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOpacity');

  /**
   * get/set shadow opacity.  must be a value between 0 and 1
   * @name shadowOpacity
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} opacity
   * @returns {Number}
   * @example
   * // get shadow opacity
   * var shadowOpacity = shape.shadowOpacity();
   *
   * // set shadow opacity
   * shape.shadowOpacity(0.5);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'shadowOffset', [
    'x',
    'y'
  ]);

  /**
   * get/set shadow offset
   * @name shadowOffset
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get shadow offset
   * var shadowOffset = shape.shadowOffset();
   *
   * // set shadow offset
   * shape.shadowOffset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetX', 0);

  /**
   * get/set shadow offset x
   * @name shadowOffsetX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get shadow offset x
   * var shadowOffsetX = shape.shadowOffsetX();
   *
   * // set shadow offset x
   * shape.shadowOffsetX(5);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowOffsetY', 0);

  /**
   * get/set shadow offset y
   * @name shadowOffsetY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get shadow offset y
   * var shadowOffsetY = shape.shadowOffsetY();
   *
   * // set shadow offset y
   * shape.shadowOffsetY(5);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternImage');

  /**
   * get/set fill pattern image
   * @name fillPatternImage
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Image} image object
   * @returns {Image}
   * @example
   * // get fill pattern image
   * var fillPatternImage = shape.fillPatternImage();
   *
   * // set fill pattern image
   * var imageObj = new Image();
   * imageObj.onload = function() {
   *   shape.fillPatternImage(imageObj);
   * };
   * imageObj.src = 'path/to/image/jpg';
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fill');

  /**
   * get/set fill color
   * @name fill
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} color
   * @returns {String}
   * @example
   * // get fill color
   * var fill = shape.fill();
   *
   * // set fill color with color string
   * shape.fill('green');
   *
   * // set fill color with hex
   * shape.fill('#00ff00');
   *
   * // set fill color with rgb
   * shape.fill('rgb(0,255,0)');
   *
   * // set fill color with rgba and make it 50% opaque
   * shape.fill('rgba(0,255,0,0.5');
   *
   * // shape without fill
   * shape.fill(null);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternX', 0);

  /**
   * get/set fill pattern x
   * @name fillPatternX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern x
   * var fillPatternX = shape.fillPatternX();
   * // set fill pattern x
   * shape.fillPatternX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternY', 0);

  /**
   * get/set fill pattern y
   * @name fillPatternY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern y
   * var fillPatternY = shape.fillPatternY();
   * // set fill pattern y
   * shape.fillPatternY(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientColorStops');

  /**
   * get/set fill linear gradient color stops
   * @name fillLinearGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} colorStops
   * @returns {Array} colorStops
   * @example
   * // get fill linear gradient color stops
   * var colorStops = shape.fillLinearGradientColorStops();
   *
   * // create a linear gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.fillLinearGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeLinearGradientColorStops');

  /**
   * get/set stroke linear gradient color stops
   * @name strokeLinearGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Array} colorStops
   * @returns {Array} colorStops
   * @example
   * // get stroke linear gradient color stops
   * var colorStops = shape.strokeLinearGradientColorStops();
   *
   * // create a linear gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.strokeLinearGradientColorStops([0, 'red', 0.5, 'blue', 1, 'green']);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartRadius',
    0
  );

  /**
   * get/set fill radial gradient start radius
   * @name fillRadialGradientStartRadius
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radial gradient start radius
   * var startRadius = shape.fillRadialGradientStartRadius();
   *
   * // set radial gradient start radius
   * shape.fillRadialGradientStartRadius(0);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndRadius', 0);

  /**
   * get/set fill radial gradient end radius
   * @name fillRadialGradientEndRadius
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} radius
   * @returns {Number}
   * @example
   * // get radial gradient end radius
   * var endRadius = shape.fillRadialGradientEndRadius();
   *
   * // set radial gradient end radius
   * shape.fillRadialGradientEndRadius(100);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientColorStops');

  /**
   * get/set fill radial gradient color stops
   * @name fillRadialGradientColorStops
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} colorStops
   * @returns {Array}
   * @example
   * // get fill radial gradient color stops
   * var colorStops = shape.fillRadialGradientColorStops();
   *
   * // create a radial gradient that starts with red, changes to blue
   * // halfway through, and then changes to green
   * shape.fillRadialGradientColorStops(0, 'red', 0.5, 'blue', 1, 'green');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRepeat', 'repeat');

  /**
   * get/set fill pattern repeat.  Can be 'repeat', 'repeat-x', 'repeat-y', or 'no-repeat'.  The default is 'repeat'
   * @name fillPatternRepeat
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} repeat
   * @returns {String}
   * @example
   * // get fill pattern repeat
   * var repeat = shape.fillPatternRepeat();
   *
   * // repeat pattern in x direction only
   * shape.fillPatternRepeat('repeat-x');
   *
   * // do not repeat the pattern
   * shape.fillPatternRepeat('no repeat');
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillEnabled', true);

  /**
   * get/set fill enabled flag
   * @name fillEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get fill enabled flag
   * var fillEnabled = shape.fillEnabled();
   *
   * // disable fill
   * shape.fillEnabled(false);
   *
   * // enable fill
   * shape.fillEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeEnabled', true);

  /**
   * get/set stroke enabled flag
   * @name strokeEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get stroke enabled flag
   * var strokeEnabled = shape.strokeEnabled();
   *
   * // disable stroke
   * shape.strokeEnabled(false);
   *
   * // enable stroke
   * shape.strokeEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'shadowEnabled', true);

  /**
   * get/set shadow enabled flag
   * @name shadowEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get shadow enabled flag
   * var shadowEnabled = shape.shadowEnabled();
   *
   * // disable shadow
   * shape.shadowEnabled(false);
   *
   * // enable shadow
   * shape.shadowEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'dashEnabled', true);

  /**
   * get/set dash enabled flag
   * @name dashEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get dash enabled flag
   * var dashEnabled = shape.dashEnabled();
   *
   * // disable dash
   * shape.dashEnabled(false);
   *
   * // enable dash
   * shape.dashEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'strokeScaleEnabled', true);

  /**
   * get/set strokeScale enabled flag
   * @name strokeScaleEnabled
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Boolean} enabled
   * @returns {Boolean}
   * @example
   * // get stroke scale enabled flag
   * var strokeScaleEnabled = shape.strokeScaleEnabled();
   *
   * // disable stroke scale
   * shape.strokeScaleEnabled(false);
   *
   * // enable stroke scale
   * shape.strokeScaleEnabled(true);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPriority', 'color');

  /**
   * get/set fill priority.  can be color, pattern, linear-gradient, or radial-gradient.  The default is color.
   *   This is handy if you want to toggle between different fill types.
   * @name fillPriority
   * @method
   * @memberof Konva.Shape.prototype
   * @param {String} priority
   * @returns {String}
   * @example
   * // get fill priority
   * var fillPriority = shape.fillPriority();
   *
   * // set fill priority
   * shape.fillPriority('linear-gradient');
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternOffset', [
    'x',
    'y'
  ]);

  /**
   * get/set fill pattern offset
   * @name fillPatternOffset
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} offset
   * @param {Number} offset.x
   * @param {Number} offset.y
   * @returns {Object}
   * @example
   * // get fill pattern offset
   * var patternOffset = shape.fillPatternOffset();
   *
   * // set fill pattern offset
   * shape.fillPatternOffset({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetX', 0);

  /**
   * get/set fill pattern offset x
   * @name fillPatternOffsetX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern offset x
   * var patternOffsetX = shape.fillPatternOffsetX();
   *
   * // set fill pattern offset x
   * shape.fillPatternOffsetX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternOffsetY', 0);

  /**
   * get/set fill pattern offset y
   * @name fillPatternOffsetY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern offset y
   * var patternOffsetY = shape.fillPatternOffsetY();
   *
   * // set fill pattern offset y
   * shape.fillPatternOffsetY(10);
   */

  Konva.Factory.addComponentsGetterSetter(Konva.Shape, 'fillPatternScale', [
    'x',
    'y'
  ]);

  /**
   * get/set fill pattern scale
   * @name fillPatternScale
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} scale
   * @param {Number} scale.x
   * @param {Number} scale.y
   * @returns {Object}
   * @example
   * // get fill pattern scale
   * var patternScale = shape.fillPatternScale();
   *
   * // set fill pattern scale
   * shape.fillPatternScale({
   *   x: 2
   *   y: 2
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleX', 1);

  /**
   * get/set fill pattern scale x
   * @name fillPatternScaleX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill pattern scale x
   * var patternScaleX = shape.fillPatternScaleX();
   *
   * // set fill pattern scale x
   * shape.fillPatternScaleX(2);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternScaleY', 1);

  /**
   * get/set fill pattern scale y
   * @name fillPatternScaleY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill pattern scale y
   * var patternScaleY = shape.fillPatternScaleY();
   *
   * // set fill pattern scale y
   * shape.fillPatternScaleY(2);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set fill linear gradient start point
   * @name fillLinearGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get fill linear gradient start point
   * var startPoint = shape.fillLinearGradientStartPoint();
   *
   * // set fill linear gradient start point
   * shape.fillLinearGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set stroke linear gradient start point
   * @name strokeLinearGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get stroke linear gradient start point
   * var startPoint = shape.strokeLinearGradientStartPoint();
   *
   * // set stroke linear gradient start point
   * shape.strokeLinearGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointX',
    0
  );

  /**
   * get/set fill linear gradient start point x
   * @name fillLinearGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill linear gradient start point x
   * var startPointX = shape.fillLinearGradientStartPointX();
   *
   * // set fill linear gradient start point x
   * shape.fillLinearGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPointX',
    0
  );

  /**
   * get/set stroke linear gradient start point x
   * @name linearLinearGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get stroke linear gradient start point x
   * var startPointX = shape.strokeLinearGradientStartPointX();
   *
   * // set stroke linear gradient start point x
   * shape.strokeLinearGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillLinearGradientStartPointY',
    0
  );

  /**
   * get/set fill linear gradient start point y
   * @name fillLinearGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill linear gradient start point y
   * var startPointY = shape.fillLinearGradientStartPointY();
   *
   * // set fill linear gradient start point y
   * shape.fillLinearGradientStartPointY(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientStartPointY',
    0
  );
  /**
   * get/set stroke linear gradient start point y
   * @name strokeLinearGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get stroke linear gradient start point y
   * var startPointY = shape.strokeLinearGradientStartPointY();
   *
   * // set stroke linear gradient start point y
   * shape.strokeLinearGradientStartPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillLinearGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set fill linear gradient end point
   * @name fillLinearGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get fill linear gradient end point
   * var endPoint = shape.fillLinearGradientEndPoint();
   *
   * // set fill linear gradient end point
   * shape.fillLinearGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set stroke linear gradient end point
   * @name strokeLinearGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get stroke linear gradient end point
   * var endPoint = shape.strokeLinearGradientEndPoint();
   *
   * // set stroke linear gradient end point
   * shape.strokeLinearGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointX', 0);
  /**
   * get/set fill linear gradient end point x
   * @name fillLinearGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill linear gradient end point x
   * var endPointX = shape.fillLinearGradientEndPointX();
   *
   * // set fill linear gradient end point x
   * shape.fillLinearGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPointX',
    0
  );
  /**
   * get/set fill linear gradient end point x
   * @name strokeLinearGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get stroke linear gradient end point x
   * var endPointX = shape.strokeLinearGradientEndPointX();
   *
   * // set stroke linear gradient end point x
   * shape.strokeLinearGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillLinearGradientEndPointY', 0);
  /**
   * get/set fill linear gradient end point y
   * @name fillLinearGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill linear gradient end point y
   * var endPointY = shape.fillLinearGradientEndPointY();
   *
   * // set fill linear gradient end point y
   * shape.fillLinearGradientEndPointY(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'strokeLinearGradientEndPointY',
    0
  );
  /**
   * get/set stroke linear gradient end point y
   * @name strokeLinearGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get stroke linear gradient end point y
   * var endPointY = shape.strokeLinearGradientEndPointY();
   *
   * // set stroke linear gradient end point y
   * shape.strokeLinearGradientEndPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPoint',
    ['x', 'y']
  );

  /**
   * get/set fill radial gradient start point
   * @name fillRadialGradientStartPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} startPoint
   * @param {Number} startPoint.x
   * @param {Number} startPoint.y
   * @returns {Object}
   * @example
   * // get fill radial gradient start point
   * var startPoint = shape.fillRadialGradientStartPoint();
   *
   * // set fill radial gradient start point
   * shape.fillRadialGradientStartPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointX',
    0
  );
  /**
   * get/set fill radial gradient start point x
   * @name fillRadialGradientStartPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill radial gradient start point x
   * var startPointX = shape.fillRadialGradientStartPointX();
   *
   * // set fill radial gradient start point x
   * shape.fillRadialGradientStartPointX(20);
   */

  Konva.Factory.addGetterSetter(
    Konva.Shape,
    'fillRadialGradientStartPointY',
    0
  );
  /**
   * get/set fill radial gradient start point y
   * @name fillRadialGradientStartPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill radial gradient start point y
   * var startPointY = shape.fillRadialGradientStartPointY();
   *
   * // set fill radial gradient start point y
   * shape.fillRadialGradientStartPointY(20);
   */

  Konva.Factory.addComponentsGetterSetter(
    Konva.Shape,
    'fillRadialGradientEndPoint',
    ['x', 'y']
  );

  /**
   * get/set fill radial gradient end point
   * @name fillRadialGradientEndPoint
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Object} endPoint
   * @param {Number} endPoint.x
   * @param {Number} endPoint.y
   * @returns {Object}
   * @example
   * // get fill radial gradient end point
   * var endPoint = shape.fillRadialGradientEndPoint();
   *
   * // set fill radial gradient end point
   * shape.fillRadialGradientEndPoint({
   *   x: 20
   *   y: 10
   * });
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointX', 0);
  /**
   * get/set fill radial gradient end point x
   * @name fillRadialGradientEndPointX
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} x
   * @returns {Number}
   * @example
   * // get fill radial gradient end point x
   * var endPointX = shape.fillRadialGradientEndPointX();
   *
   * // set fill radial gradient end point x
   * shape.fillRadialGradientEndPointX(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillRadialGradientEndPointY', 0);
  /**
   * get/set fill radial gradient end point y
   * @name fillRadialGradientEndPointY
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} y
   * @returns {Number}
   * @example
   * // get fill radial gradient end point y
   * var endPointY = shape.fillRadialGradientEndPointY();
   *
   * // set fill radial gradient end point y
   * shape.fillRadialGradientEndPointY(20);
   */

  Konva.Factory.addGetterSetter(Konva.Shape, 'fillPatternRotation', 0);

  /**
   * get/set fill pattern rotation in degrees
   * @name fillPatternRotation
   * @method
   * @memberof Konva.Shape.prototype
   * @param {Number} rotation
   * @returns {Konva.Shape}
   * @example
   * // get fill pattern rotation
   * var patternRotation = shape.fillPatternRotation();
   *
   * // set fill pattern rotation
   * shape.fillPatternRotation(20);
   */

  Konva.Factory.backCompat(Konva.Shape, {
    dashArray: 'dash',
    getDashArray: 'getDash',
    setDashArray: 'getDash',

    drawFunc: 'sceneFunc',
    getDrawFunc: 'getSceneFunc',
    setDrawFunc: 'setSceneFunc',

    drawHitFunc: 'hitFunc',
    getDrawHitFunc: 'getHitFunc',
    setDrawHitFunc: 'setHitFunc'
  });

  Konva.Collection.mapMethods(Konva.Shape);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var STAGE = 'Stage',
    STRING = 'string',
    PX = 'px',
    MOUSEOUT = 'mouseout',
    MOUSELEAVE = 'mouseleave',
    MOUSEOVER = 'mouseover',
    MOUSEENTER = 'mouseenter',
    MOUSEMOVE = 'mousemove',
    MOUSEDOWN = 'mousedown',
    MOUSEUP = 'mouseup',
    CONTEXTMENU = 'contextmenu',
    CLICK = 'click',
    DBL_CLICK = 'dblclick',
    TOUCHSTART = 'touchstart',
    TOUCHEND = 'touchend',
    TAP = 'tap',
    DBL_TAP = 'dbltap',
    TOUCHMOVE = 'touchmove',
    WHEEL = 'wheel',
    CONTENT_MOUSEOUT = 'contentMouseout',
    CONTENT_MOUSEOVER = 'contentMouseover',
    CONTENT_MOUSEMOVE = 'contentMousemove',
    CONTENT_MOUSEDOWN = 'contentMousedown',
    CONTENT_MOUSEUP = 'contentMouseup',
    CONTENT_CONTEXTMENU = 'contentContextmenu',
    CONTENT_CLICK = 'contentClick',
    CONTENT_DBL_CLICK = 'contentDblclick',
    CONTENT_TOUCHSTART = 'contentTouchstart',
    CONTENT_TOUCHEND = 'contentTouchend',
    CONTENT_DBL_TAP = 'contentDbltap',
    CONTENT_TAP = 'contentTap',
    CONTENT_TOUCHMOVE = 'contentTouchmove',
    CONTENT_WHEEL = 'contentWheel',
    DIV = 'div',
    RELATIVE = 'relative',
    KONVA_CONTENT = 'konvajs-content',
    SPACE = ' ',
    UNDERSCORE = '_',
    CONTAINER = 'container',
    EMPTY_STRING = '',
    EVENTS = [
      MOUSEDOWN,
      MOUSEMOVE,
      MOUSEUP,
      MOUSEOUT,
      TOUCHSTART,
      TOUCHMOVE,
      TOUCHEND,
      MOUSEOVER,
      WHEEL,
      CONTEXTMENU
    ],
    // cached variables
    eventsLength = EVENTS.length;

  function addEvent(ctx, eventName) {
    ctx.content.addEventListener(
      eventName,
      function(evt) {
        ctx[UNDERSCORE + eventName](evt);
      },
      false
    );
  }

  /**
   * Stage constructor.  A stage is used to contain multiple layers
   * @constructor
   * @memberof Konva
   * @augments Konva.Container
   * @param {Object} config
   * @param {String|Element} config.container Container selector or DOM element
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var stage = new Konva.Stage({
   *   width: 500,
   *   height: 800,
   *   container: 'containerId' // or "#containerId" or ".containerClass"
   * });
   */
  Konva.Stage = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Stage, {
    ___init: function(config) {
      this.nodeType = STAGE;
      // call super constructor
      Konva.Container.call(this, config);
      this._id = Konva.idCounter++;
      this._buildDOM();
      this._bindContentEvents();
      this._enableNestedTransforms = false;
      Konva.stages.push(this);
    },
    _validateAdd: function(child) {
      if (child.getType() !== 'Layer') {
        Konva.Util.throw('You may only add layers to the stage.');
      }
    },
    /**
     * set container dom element which contains the stage wrapper div element
     * @method
     * @memberof Konva.Stage.prototype
     * @param {DomElement} container can pass in a dom element or id string
     */
    setContainer: function(container) {
      if (typeof container === STRING) {
        if (container.charAt(0) === '.') {
          var className = container.slice(1);
          container = Konva.document.getElementsByClassName(className)[0];
        } else {
          var id;
          if (container.charAt(0) !== '#') {
            id = container;
          } else {
            id = container.slice(1);
          }
          container = Konva.document.getElementById(id);
        }
        if (!container) {
          throw 'Can not find container in document with id ' + id;
        }
      }
      this._setAttr(CONTAINER, container);
      return this;
    },
    shouldDrawHit: function() {
      return true;
    },
    draw: function() {
      Konva.Node.prototype.draw.call(this);
      return this;
    },
    /**
     * draw layer scene graphs
     * @name draw
     * @method
     * @memberof Konva.Stage.prototype
     */

    /**
     * draw layer hit graphs
     * @name drawHit
     * @method
     * @memberof Konva.Stage.prototype
     */

    /**
     * set height
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Number} height
     */
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this._resizeDOM();
      return this;
    },
    /**
     * set width
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Number} width
     */
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this._resizeDOM();
      return this;
    },
    /**
     * clear all layers
     * @method
     * @memberof Konva.Stage.prototype
     */
    clear: function() {
      var layers = this.children,
        len = layers.length,
        n;

      for (n = 0; n < len; n++) {
        layers[n].clear();
      }
      return this;
    },
    clone: function(obj) {
      if (!obj) {
        obj = {};
      }
      obj.container = Konva.document.createElement(DIV);
      return Konva.Container.prototype.clone.call(this, obj);
    },
    /**
     * destroy stage
     * @method
     * @memberof Konva.Stage.prototype
     */
    destroy: function() {
      var content = this.content;
      Konva.Container.prototype.destroy.call(this);

      if (content && Konva.Util._isInDocument(content)) {
        this.getContainer().removeChild(content);
      }
      var index = Konva.stages.indexOf(this);
      if (index > -1) {
        Konva.stages.splice(index, 1);
      }
      return this;
    },
    /**
     * get pointer position which can be a touch position or mouse position
     * @method
     * @memberof Konva.Stage.prototype
     * @returns {Object}
     */
    getPointerPosition: function() {
      return this.pointerPos;
    },
    getStage: function() {
      return this;
    },
    /**
     * get stage content div element which has the
     *  the class name "konvajs-content"
     * @method
     * @memberof Konva.Stage.prototype
     */
    getContent: function() {
      return this.content;
    },
    toDataURL: function(config) {
      config = config || {};

      var mimeType = config.mimeType || null,
        quality = config.quality || null,
        x = config.x || 0,
        y = config.y || 0,
        canvas = new Konva.SceneCanvas({
          width: config.width || this.getWidth(),
          height: config.height || this.getHeight(),
          pixelRatio: config.pixelRatio || 1
        }),
        _context = canvas.getContext()._context,
        layers = this.children;

      if (x || y) {
        _context.translate(-1 * x, -1 * y);
      }

      layers.each(function(layer) {
        var width = layer.getCanvas().getWidth();
        var height = layer.getCanvas().getHeight();
        var ratio = layer.getCanvas().getPixelRatio();
        _context.drawImage(
          layer.getCanvas()._canvas,
          0,
          0,
          width / ratio,
          height / ratio
        );
      });
      var src = canvas.toDataURL(mimeType, quality);

      if (config.callback) {
        config.callback(src);
      }

      return src;
    },
    /**
     * converts stage into an image.
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Object} config
     * @param {Function} config.callback function executed when the composite has completed
     * @param {String} [config.mimeType] can be "image/png" or "image/jpeg".
     *  "image/png" is the default
     * @param {Number} [config.x] x position of canvas section
     * @param {Number} [config.y] y position of canvas section
     * @param {Number} [config.width] width of canvas section
     * @param {Number} [config.height] height of canvas section
     * @param {Number} [config.quality] jpeg quality.  If using an "image/jpeg" mimeType,
     *  you can specify the quality from 0 to 1, where 0 is very poor quality and 1
     *  is very high quality
     */
    toImage: function(config) {
      var cb = config.callback;

      config.callback = function(dataUrl) {
        Konva.Util._getImage(dataUrl, function(img) {
          cb(img);
        });
      };
      this.toDataURL(config);
    },
    /**
     * get visible intersection shape. This is the preferred
     *  method for determining if a point intersects a shape or not
     * @method
     * @memberof Konva.Stage.prototype
     * @param {Object} pos
     * @param {Number} pos.x
     * @param {Number} pos.y
     * @param {String} [selector]
     * @returns {Konva.Node}
     * @example
     * var shape = stage.getIntersection({x: 50, y: 50});
     * // or if you interested in shape parent:
     * var group = stage.getIntersection({x: 50, y: 50}, 'Group');
     */
    getIntersection: function(pos, selector) {
      var layers = this.getChildren(),
        len = layers.length,
        end = len - 1,
        n,
        shape;

      for (n = end; n >= 0; n--) {
        shape = layers[n].getIntersection(pos, selector);
        if (shape) {
          return shape;
        }
      }

      return null;
    },
    _resizeDOM: function() {
      if (this.content) {
        var width = this.getWidth(),
          height = this.getHeight(),
          layers = this.getChildren(),
          len = layers.length,
          n,
          layer;

        // set content dimensions
        this.content.style.width = width + PX;
        this.content.style.height = height + PX;

        this.bufferCanvas.setSize(width, height);
        this.bufferHitCanvas.setSize(width, height);

        // set layer dimensions
        for (n = 0; n < len; n++) {
          layer = layers[n];
          layer.setSize(width, height);
          layer.draw();
        }
      }
    },
    /**
     * add layer or layers to stage
     * @method
     * @memberof Konva.Stage.prototype
     * @param {...Konva.Layer} layer
     * @example
     * stage.add(layer1, layer2, layer3);
     */
    add: function(layer) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      Konva.Container.prototype.add.call(this, layer);
      layer._setCanvasSize(this.width(), this.height());

      // draw layer and append canvas to container
      layer.draw();

      if (Konva.isBrowser) {
        this.content.appendChild(layer.canvas._canvas);
      }

      // chainable
      return this;
    },
    getParent: function() {
      return null;
    },
    getLayer: function() {
      return null;
    },
    /**
     * returns a {@link Konva.Collection} of layers
     * @method
     * @memberof Konva.Stage.prototype
     */
    getLayers: function() {
      return this.getChildren();
    },
    _bindContentEvents: function() {
      if (!Konva.isBrowser) {
        return;
      }
      for (var n = 0; n < eventsLength; n++) {
        addEvent(this, EVENTS[n]);
      }
    },
    _mouseover: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        this._fire(CONTENT_MOUSEOVER, { evt: evt });
      }
    },
    _mouseout: function(evt) {
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var targetShape = this.targetShape;

        if (targetShape && !Konva.isDragging()) {
          targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
          targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
          this.targetShape = null;
        }
        this.pointerPos = undefined;

        this._fire(CONTENT_MOUSEOUT, { evt: evt });
      }
    },
    _mousemove: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchmove(evt);
      }
      // workaround fake mousemove event in chrome browser https://code.google.com/p/chromium/issues/detail?id=161464
      if (
        (typeof evt.movementX !== 'undefined' ||
          typeof evt.movementY !== 'undefined') &&
        evt.movementY === 0 &&
        evt.movementX === 0
      ) {
        return null;
      }
      if (Konva.UA.mobile) {
        return null;
      }
      this._setPointerPosition(evt);
      var shape;

      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          if (
            !Konva.isDragging() &&
            (!this.targetShape || this.targetShape._id !== shape._id)
          ) {
            if (this.targetShape) {
              this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt }, shape);
              this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt }, shape);
            }
            shape._fireAndBubble(MOUSEOVER, { evt: evt }, this.targetShape);
            shape._fireAndBubble(MOUSEENTER, { evt: evt }, this.targetShape);
            this.targetShape = shape;
          } else {
            shape._fireAndBubble(MOUSEMOVE, { evt: evt });
          }
        } else {
          /*
                 * if no shape was detected, clear target shape and try
                 * to run mouseout from previous target shape
                 */
          if (this.targetShape && !Konva.isDragging()) {
            this.targetShape._fireAndBubble(MOUSEOUT, { evt: evt });
            this.targetShape._fireAndBubble(MOUSELEAVE, { evt: evt });
            this.targetShape = null;
          }
          this._fire(MOUSEMOVE, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }

        // content event
        this._fire(CONTENT_MOUSEMOVE, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.cancelable) {
        evt.preventDefault();
      }
    },
    _mousedown: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchstart(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition());

        Konva.listenClickTap = true;

        if (shape && shape.isListening()) {
          this.clickStartShape = shape;
          shape._fireAndBubble(MOUSEDOWN, { evt: evt });
        } else {
          this._fire(MOUSEDOWN, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }

        // content event
        this._fire(CONTENT_MOUSEDOWN, { evt: evt });
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.cancelable) {
        evt.preventDefault();
      }
    },
    _mouseup: function(evt) {
      // workaround for mobile IE to force touch event when unhandled pointer event elevates into a mouse event
      if (Konva.UA.ieMobile) {
        return this._touchend(evt);
      }
      if (!Konva.UA.mobile) {
        this._setPointerPosition(evt);
        var shape = this.getIntersection(this.getPointerPosition()),
          clickStartShape = this.clickStartShape,
          clickEndShape = this.clickEndShape,
          fireDblClick = false,
          dd = Konva.DD;

        if (Konva.inDblClickWindow) {
          fireDblClick = true;
          clearTimeout(this.dblTimeout);
          // Konva.inDblClickWindow = false;
        } else if (!dd || !dd.justDragged) {
          // don't set inDblClickWindow after dragging
          Konva.inDblClickWindow = true;
          clearTimeout(this.dblTimeout);
        } else if (dd) {
          dd.justDragged = false;
        }

        this.dblTimeout = setTimeout(function() {
          Konva.inDblClickWindow = false;
        }, Konva.dblClickWindow);

        if (shape && shape.isListening()) {
          this.clickEndShape = shape;
          shape._fireAndBubble(MOUSEUP, { evt: evt });

          // detect if click or double click occurred
          if (
            Konva.listenClickTap &&
            clickStartShape &&
            clickStartShape._id === shape._id
          ) {
            shape._fireAndBubble(CLICK, { evt: evt });

            if (
              fireDblClick &&
              clickEndShape &&
              clickEndShape._id === shape._id
            ) {
              shape._fireAndBubble(DBL_CLICK, { evt: evt });
            }
          }
        } else {
          this._fire(MOUSEUP, { evt: evt, target: this, currentTarget: this });
          this._fire(CLICK, { evt: evt, target: this, currentTarget: this });
          if (fireDblClick) {
            this._fire(DBL_CLICK, {
              evt: evt,
              target: this,
              currentTarget: this
            });
          }
        }
        // content events
        this._fire(CONTENT_MOUSEUP, { evt: evt });
        if (Konva.listenClickTap) {
          this._fire(CONTENT_CLICK, { evt: evt });
          if (fireDblClick) {
            this._fire(CONTENT_DBL_CLICK, { evt: evt });
          }
        }

        Konva.listenClickTap = false;
      }

      // always call preventDefault for desktop events because some browsers
      // try to drag and drop the canvas element
      if (evt.cancelable) {
        evt.preventDefault();
      }
    },
    _contextmenu: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      if (shape && shape.isListening()) {
        shape._fireAndBubble(CONTEXTMENU, { evt: evt });
      } else {
        this._fire(CONTEXTMENU, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      this._fire(CONTENT_CONTEXTMENU, { evt: evt });
    },
    _touchstart: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      Konva.listenClickTap = true;

      if (shape && shape.isListening()) {
        this.tapStartShape = shape;
        shape._fireAndBubble(TOUCHSTART, { evt: evt });

        // only call preventDefault if the shape is listening for events
        if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
          evt.preventDefault();
        }
      } else {
        this._fire(TOUCHSTART, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      // content event
      this._fire(CONTENT_TOUCHSTART, { evt: evt });
    },
    _touchend: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition()),
        fireDblClick = false;

      if (Konva.inDblClickWindow) {
        fireDblClick = true;
        clearTimeout(this.dblTimeout);
        // Konva.inDblClickWindow = false;
      } else {
        Konva.inDblClickWindow = true;
        clearTimeout(this.dblTimeout);
      }

      this.dblTimeout = setTimeout(function() {
        Konva.inDblClickWindow = false;
      }, Konva.dblClickWindow);

      if (shape && shape.isListening()) {
        shape._fireAndBubble(TOUCHEND, { evt: evt });

        // detect if tap or double tap occurred
        if (
          Konva.listenClickTap &&
          this.tapStartShape &&
          shape._id === this.tapStartShape._id
        ) {
          shape._fireAndBubble(TAP, { evt: evt });

          if (fireDblClick) {
            shape._fireAndBubble(DBL_TAP, { evt: evt });
          }
        }
        // only call preventDefault if the shape is listening for events
        if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
          evt.preventDefault();
        }
      } else {
        this._fire(TOUCHEND, { evt: evt, target: this, currentTarget: this });
        this._fire(TAP, { evt: evt, target: this, currentTarget: this });
        if (fireDblClick) {
          this._fire(DBL_TAP, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }
      }
      // content events
      this._fire(CONTENT_TOUCHEND, { evt: evt });
      if (Konva.listenClickTap) {
        this._fire(CONTENT_TAP, { evt: evt });
        if (fireDblClick) {
          this._fire(CONTENT_DBL_TAP, { evt: evt });
        }
      }

      Konva.listenClickTap = false;
    },
    _touchmove: function(evt) {
      this._setPointerPosition(evt);
      var dd = Konva.DD,
        shape;
      if (!Konva.isDragging()) {
        shape = this.getIntersection(this.getPointerPosition());
        if (shape && shape.isListening()) {
          shape._fireAndBubble(TOUCHMOVE, { evt: evt });
          // only call preventDefault if the shape is listening for events
          if (shape.isListening() && shape.preventDefault() && evt.cancelable) {
            evt.preventDefault();
          }
        } else {
          this._fire(TOUCHMOVE, {
            evt: evt,
            target: this,
            currentTarget: this
          });
        }
        this._fire(CONTENT_TOUCHMOVE, { evt: evt });
      }
      if (dd) {
        if (
          Konva.isDragging() &&
          Konva.DD.node.preventDefault() &&
          evt.cancelable
        ) {
          evt.preventDefault();
        }
      }
    },
    _wheel: function(evt) {
      this._setPointerPosition(evt);
      var shape = this.getIntersection(this.getPointerPosition());

      if (shape && shape.isListening()) {
        shape._fireAndBubble(WHEEL, { evt: evt });
      } else {
        this._fire(WHEEL, {
          evt: evt,
          target: this,
          currentTarget: this
        });
      }
      this._fire(CONTENT_WHEEL, { evt: evt });
    },
    _setPointerPosition: function(evt) {
      var contentPosition = this._getContentPosition(),
        x = null,
        y = null;
      evt = evt ? evt : window.event;

      // touch events
      if (evt.touches !== undefined) {
        // currently, only handle one finger
        if (evt.touches.length > 0) {
          var touch = evt.touches[0];
          // get the information for finger #1
          x = touch.clientX - contentPosition.left;
          y = touch.clientY - contentPosition.top;
        }
      } else {
        // mouse events
        x = evt.clientX - contentPosition.left;
        y = evt.clientY - contentPosition.top;
      }
      if (x !== null && y !== null) {
        this.pointerPos = {
          x: x,
          y: y
        };
      }
    },
    _getContentPosition: function() {
      var rect = this.content.getBoundingClientRect
        ? this.content.getBoundingClientRect()
        : { top: 0, left: 0 };
      return {
        top: rect.top,
        left: rect.left
      };
    },
    _buildDOM: function() {
      // the buffer canvas pixel ratio must be 1 because it is used as an
      // intermediate canvas before copying the result onto a scene canvas.
      // not setting it to 1 will result in an over compensation
      this.bufferCanvas = new Konva.SceneCanvas();
      this.bufferHitCanvas = new Konva.HitCanvas({ pixelRatio: 1 });

      if (!Konva.isBrowser) {
        return;
      }
      var container = this.getContainer();
      if (!container) {
        throw 'Stage has no container. A container is required.';
      }
      // clear content inside container
      container.innerHTML = EMPTY_STRING;

      // content
      this.content = Konva.document.createElement(DIV);
      this.content.style.position = RELATIVE;
      this.content.className = KONVA_CONTENT;
      this.content.setAttribute('role', 'presentation');

      container.appendChild(this.content);

      this._resizeDOM();
    },
    _onContent: function(typesStr, handler) {
      var types = typesStr.split(SPACE),
        len = types.length,
        n,
        baseEvent;

      for (n = 0; n < len; n++) {
        baseEvent = types[n];
        this.content.addEventListener(baseEvent, handler, false);
      }
    },
    // currently cache function is now working for stage, because stage has no its own canvas element
    // TODO: may be it is better to cache all children layers?
    cache: function() {
      Konva.Util.warn(
        'Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.'
      );
    },
    clearCache: function() {}
  });
  Konva.Util.extend(Konva.Stage, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetter(Konva.Stage, 'container');
  Konva.Factory.addOverloadedGetterSetter(Konva.Stage, 'container');

  /**
   * get container DOM element
   * @name container
   * @method
   * @memberof Konva.Stage.prototype
   * @returns {DomElement} container
   * @example
   * // get container
   * var container = stage.container();
   * // set container
   * var container = document.createElement('div');
   * body.appendChild(container);
   * stage.container(container);
   */
})();

(function(Konva) {
  'use strict';
  /**
   * BaseLayer constructor.
   * @constructor
   * @memberof Konva
   * @augments Konva.Container
   * @param {Object} config
   * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
   * to clear the canvas before each layer draw.  The default value is true.
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

   */
  Konva.BaseLayer = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.BaseLayer, {
    ___init: function(config) {
      this.nodeType = 'Layer';
      Konva.Container.call(this, config);
    },
    createPNGStream: function() {
      return this.canvas._canvas.createPNGStream();
    },
    /**
     * get layer canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getCanvas: function() {
      return this.canvas;
    },
    /**
     * get layer hit canvas
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getHitCanvas: function() {
      return this.hitCanvas;
    },
    /**
     * get layer canvas context
     * @method
     * @memberof Konva.BaseLayer.prototype
     */
    getContext: function() {
      return this.getCanvas().getContext();
    },
    /**
     * clear scene and hit canvas contexts tied to the layer
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @param {Object} [bounds]
     * @param {Number} [bounds.x]
     * @param {Number} [bounds.y]
     * @param {Number} [bounds.width]
     * @param {Number} [bounds.height]
     * @example
     * layer.clear();
     * layer.clear({
     *   x : 0,
     *   y : 0,
     *   width : 100,
     *   height : 100
     * });
     */
    clear: function(bounds) {
      this.getContext().clear(bounds);
      return this;
    },
    clearHitCache: function() {
      this._hitImageData = undefined;
    },
    // extend Node.prototype.setZIndex
    setZIndex: function(index) {
      Konva.Node.prototype.setZIndex.call(this, index);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);

        if (index < stage.getChildren().length - 1) {
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            stage.getChildren()[index + 1].getCanvas()._canvas
          );
        } else {
          stage.content.appendChild(this.getCanvas()._canvas);
        }
      }
      return this;
    },
    // extend Node.prototype.moveToTop
    moveToTop: function() {
      Konva.Node.prototype.moveToTop.call(this);
      var stage = this.getStage();
      if (stage) {
        stage.content.removeChild(this.getCanvas()._canvas);
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveUp
    moveUp: function() {
      var moved = Konva.Node.prototype.moveUp.call(this);
      if (!moved) {
        return this;
      }
      var stage = this.getStage();
      if (!stage) {
        return this;
      }
      stage.content.removeChild(this.getCanvas()._canvas);

      if (this.index < stage.getChildren().length - 1) {
        stage.content.insertBefore(
          this.getCanvas()._canvas,
          stage.getChildren()[this.index + 1].getCanvas()._canvas
        );
      } else {
        stage.content.appendChild(this.getCanvas()._canvas);
      }
      return this;
    },
    // extend Node.prototype.moveDown
    moveDown: function() {
      if (Konva.Node.prototype.moveDown.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[this.index + 1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    // extend Node.prototype.moveToBottom
    moveToBottom: function() {
      if (Konva.Node.prototype.moveToBottom.call(this)) {
        var stage = this.getStage();
        if (stage) {
          var children = stage.getChildren();
          stage.content.removeChild(this.getCanvas()._canvas);
          stage.content.insertBefore(
            this.getCanvas()._canvas,
            children[1].getCanvas()._canvas
          );
        }
      }
      return this;
    },
    getLayer: function() {
      return this;
    },
    remove: function() {
      var _canvas = this.getCanvas()._canvas;

      Konva.Node.prototype.remove.call(this);

      if (_canvas && _canvas.parentNode && Konva.Util._isInDocument(_canvas)) {
        _canvas.parentNode.removeChild(_canvas);
      }
      return this;
    },
    getStage: function() {
      return this.parent;
    },
    setSize: function(width, height) {
      this.canvas.setSize(width, height);
      return this;
    },
    /**
     * get/set width of layer.getter return width of stage. setter doing nothing.
     * if you want change width use `stage.width(value);`
     * @name width
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var width = layer.width();
     */
    getWidth: function() {
      if (this.parent) {
        return this.parent.getWidth();
      }
    },
    setWidth: function() {
      Konva.Util.warn(
        'Can not change width of layer. Use "stage.width(value)" function instead.'
      );
    },
    /**
     * get/set height of layer.getter return height of stage. setter doing nothing.
     * if you want change height use `stage.height(value);`
     * @name height
     * @method
     * @memberof Konva.BaseLayer.prototype
     * @returns {Number}
     * @example
     * var height = layer.height();
     */
    getHeight: function() {
      if (this.parent) {
        return this.parent.getHeight();
      }
    },
    setHeight: function() {
      Konva.Util.warn(
        'Can not change height of layer. Use "stage.height(value)" function instead.'
      );
    },
    // the apply transform method is handled by the Layer and FastLayer class
    // because it is up to the layer to decide if an absolute or relative transform
    // should be used
    _applyTransform: function(shape, context, top) {
      var m = shape.getAbsoluteTransform(top).getMatrix();
      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    }
  });
  Konva.Util.extend(Konva.BaseLayer, Konva.Container);

  // add getters and setters
  Konva.Factory.addGetterSetter(Konva.BaseLayer, 'clearBeforeDraw', true);
  /**
   * get/set clearBeforeDraw flag which determines if the layer is cleared or not
   *  before drawing
   * @name clearBeforeDraw
   * @method
   * @memberof Konva.BaseLayer.prototype
   * @param {Boolean} clearBeforeDraw
   * @returns {Boolean}
   * @example
   * // get clearBeforeDraw flag
   * var clearBeforeDraw = layer.clearBeforeDraw();
   *
   * // disable clear before draw
   * layer.clearBeforeDraw(false);
   *
   * // enable clear before draw
   * layer.clearBeforeDraw(true);
   */

  Konva.Collection.mapMethods(Konva.BaseLayer);
})(Konva);

(function() {
  'use strict';
  // constants
  var HASH = '#',
    BEFORE_DRAW = 'beforeDraw',
    DRAW = 'draw',
    /*
         * 2 - 3 - 4
         * |       |
         * 1 - 0   5
         *         |
         * 8 - 7 - 6
         */
    INTERSECTION_OFFSETS = [
      { x: 0, y: 0 }, // 0
      { x: -1, y: 0 }, // 1
      { x: -1, y: -1 }, // 2
      { x: 0, y: -1 }, // 3
      { x: 1, y: -1 }, // 4
      { x: 1, y: 0 }, // 5
      { x: 1, y: 1 }, // 6
      { x: 0, y: 1 }, // 7
      { x: -1, y: 1 } // 8
    ],
    INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;

  /**
     * Layer constructor.  Layers are tied to their own canvas element and are used
     * to contain groups or shapes.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var layer = new Konva.Layer();
     */
  Konva.Layer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.Layer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      this.hitCanvas = new Konva.HitCanvas({
        pixelRatio: 1
      });
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
      this.hitCanvas.setSize(width, height);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to a layer.');
      }
    },
    /**
         * get visible intersection shape. This is the preferred
         * method for determining if a point intersects a shape or not
         * also you may pass optional selector parametr to return ancestor of intersected shape
         * @method
         * @memberof Konva.Layer.prototype
         * @param {Object} pos
         * @param {Number} pos.x
         * @param {Number} pos.y
         * @param {String} [selector]
         * @returns {Konva.Node}
         * @example
         * var shape = layer.getIntersection({x: 50, y: 50});
         * // or if you interested in shape parent:
         * var group = layer.getIntersection({x: 50, y: 50}, 'Group');
         */
    getIntersection: function(pos, selector) {
      var obj, i, intersectionOffset, shape;

      if (!this.hitGraphEnabled() || !this.isVisible()) {
        return null;
      }
      // in some cases antialiased area may be bigger than 1px
      // it is possible if we will cache node, then scale it a lot
      // TODO: check { 0; 0 } point before loop, and remove it from INTERSECTION_OFFSETS.
      var spiralSearchDistance = 1;
      var continueSearch = false;
      while (true) {
        for (i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {
          intersectionOffset = INTERSECTION_OFFSETS[i];
          obj = this._getIntersection({
            x: pos.x + intersectionOffset.x * spiralSearchDistance,
            y: pos.y + intersectionOffset.y * spiralSearchDistance
          });
          shape = obj.shape;
          if (shape && selector) {
            return shape.findAncestor(selector, true);
          } else if (shape) {
            return shape;
          }
          // we should continue search if we found antialiased pixel
          // that means our node somewhere very close
          continueSearch = !!obj.antialiased;
          // stop search if found empty pixel
          if (!obj.antialiased) {
            break;
          }
        }
        // if no shape, and no antialiased pixel, we should end searching
        if (continueSearch) {
          spiralSearchDistance += 1;
        } else {
          return null;
        }
      }
    },
    _getImageData: function(x, y) {
      var width = this.hitCanvas.width || 1,
        height = this.hitCanvas.height || 1,
        index = Math.round(y) * width + Math.round(x);

      if (!this._hitImageData) {
        this._hitImageData = this.hitCanvas.context.getImageData(
          0,
          0,
          width,
          height
        );
      }

      return [
        this._hitImageData.data[4 * index + 0], // Red
        this._hitImageData.data[4 * index + 1], // Green
        this._hitImageData.data[4 * index + 2], // Blue
        this._hitImageData.data[4 * index + 3] // Alpha
      ];
    },
    _getIntersection: function(pos) {
      var ratio = this.hitCanvas.pixelRatio;
      var p = this.hitCanvas.context.getImageData(
        Math.round(pos.x * ratio),
        Math.round(pos.y * ratio),
        1,
        1
      ).data,
        p3 = p[3],
        colorKey,
        shape;
      // fully opaque pixel
      if (p3 === 255) {
        colorKey = Konva.Util._rgbToHex(p[0], p[1], p[2]);
        shape = Konva.shapes[HASH + colorKey];
        if (shape) {
          return {
            shape: shape
          };
        }
        return {
          antialiased: true
        };
      } else if (p3 > 0) {
        // antialiased pixel
        return {
          antialiased: true
        };
      }
      // empty pixel
      return {};
    },
    drawScene: function(can, top) {
      var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());

      this._fire(BEFORE_DRAW, {
        node: this
      });

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas, top);

      this._fire(DRAW, {
        node: this
      });

      return this;
    },
    drawHit: function(can, top) {
      var layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);

      if (layer && layer.getClearBeforeDraw()) {
        layer.getHitCanvas().getContext().clear();
      }

      Konva.Container.prototype.drawHit.call(this, canvas, top);
      this.imageData = null; // Clear imageData cache
      return this;
    },
    clear: function(bounds) {
      Konva.BaseLayer.prototype.clear.call(this, bounds);
      this.getHitCanvas().getContext().clear(bounds);
      this.imageData = null; // Clear getImageData cache
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
        this.hitCanvas._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
        this.hitCanvas._canvas.style.display = 'none';
      }
      return this;
    },
    /**
         * enable hit graph
         * @name enableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
    enableHitGraph: function() {
      this.setHitGraphEnabled(true);
      return this;
    },
    /**
         * disable hit graph
         * @name disableHitGraph
         * @method
         * @memberof Konva.Layer.prototype
         * @returns {Layer}
         */
    disableHitGraph: function() {
      this.setHitGraphEnabled(false);
      return this;
    },
    setSize: function(width, height) {
      Konva.BaseLayer.prototype.setSize.call(this, width, height);
      this.hitCanvas.setSize(width, height);
      return this;
    }
  });
  Konva.Util.extend(Konva.Layer, Konva.BaseLayer);

  Konva.Factory.addGetterSetter(Konva.Layer, 'hitGraphEnabled', true);
  /**
     * get/set hitGraphEnabled flag.  Disabling the hit graph will greatly increase
     *  draw performance because the hit graph will not be redrawn each time the layer is
     *  drawn.  This, however, also disables mouse/touch event detection
     * @name hitGraphEnabled
     * @method
     * @memberof Konva.Layer.prototype
     * @param {Boolean} enabled
     * @returns {Boolean}
     * @example
     * // get hitGraphEnabled flag
     * var hitGraphEnabled = layer.hitGraphEnabled();
     *
     * // disable hit graph
     * layer.hitGraphEnabled(false);
     *
     * // enable hit graph
     * layer.hitGraphEnabled(true);
     */
  Konva.Collection.mapMethods(Konva.Layer);
})();

(function() {
  'use strict';
  /**
     * FastLayer constructor. Layers are tied to their own canvas element and are used
     * to contain shapes only.  If you don't need node nesting, mouse and touch interactions,
     * or event pub/sub, you should use FastLayer instead of Layer to create your layers.
     * It renders about 2x faster than normal layers.
     * @constructor
     * @memberof Konva
     * @augments Konva.BaseLayer
     * @param {Object} config
     * @param {Boolean} [config.clearBeforeDraw] set this property to false if you don't want
     * to clear the canvas before each layer draw.  The default value is true.
     * @param {Boolean} [config.visible]
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var layer = new Konva.FastLayer();
     */
  Konva.FastLayer = function(config) {
    this.____init(config);
  };

  Konva.Util.addMethods(Konva.FastLayer, {
    ____init: function(config) {
      this.nodeType = 'Layer';
      this.canvas = new Konva.SceneCanvas();
      // call super constructor
      Konva.BaseLayer.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Shape') {
        Konva.Util.throw('You may only add shapes to a fast layer.');
      }
    },
    _setCanvasSize: function(width, height) {
      this.canvas.setSize(width, height);
    },
    hitGraphEnabled: function() {
      return false;
    },
    getIntersection: function() {
      return null;
    },
    drawScene: function(can) {
      var layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());

      if (this.getClearBeforeDraw()) {
        canvas.getContext().clear();
      }

      Konva.Container.prototype.drawScene.call(this, canvas);

      return this;
    },
    draw: function() {
      this.drawScene();
      return this;
    },
    // extend Node.prototype.setVisible
    setVisible: function(visible) {
      Konva.Node.prototype.setVisible.call(this, visible);
      if (visible) {
        this.getCanvas()._canvas.style.display = 'block';
      } else {
        this.getCanvas()._canvas.style.display = 'none';
      }
      return this;
    }
  });
  Konva.Util.extend(Konva.FastLayer, Konva.BaseLayer);

  Konva.Collection.mapMethods(Konva.FastLayer);
})();

(function() {
  'use strict';
  /**
     * Group constructor.  Groups are used to contain shapes or other groups.
     * @constructor
     * @memberof Konva
     * @augments Konva.Container
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * * @param {Object} [config.clip] set clip
     * @param {Number} [config.clipX] set clip x
     * @param {Number} [config.clipY] set clip y
     * @param {Number} [config.clipWidth] set clip width
     * @param {Number} [config.clipHeight] set clip height
     * @param {Function} [config.clipFunc] set clip func

     * @example
     * var group = new Konva.Group();
     */
  Konva.Group = function(config) {
    this.___init(config);
  };

  Konva.Util.addMethods(Konva.Group, {
    ___init: function(config) {
      this.nodeType = 'Group';
      // call super constructor
      Konva.Container.call(this, config);
    },
    _validateAdd: function(child) {
      var type = child.getType();
      if (type !== 'Group' && type !== 'Shape') {
        Konva.Util.throw('You may only add groups and shapes to groups.');
      }
    }
  });
  Konva.Util.extend(Konva.Group, Konva.Container);

  Konva.Collection.mapMethods(Konva.Group);
})();

(function(Konva) {
  'use strict';
  var now = (function() {
    if (Konva.global.performance && Konva.global.performance.now) {
      return function() {
        return Konva.global.performance.now();
      };
    }

    return function() {
      return new Date().getTime();
    };
  })();

  function FRAF(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var RAF = (function() {
    return (
      Konva.global.requestAnimationFrame ||
      Konva.global.webkitRequestAnimationFrame ||
      Konva.global.mozRequestAnimationFrame ||
      Konva.global.oRequestAnimationFrame ||
      Konva.global.msRequestAnimationFrame ||
      FRAF
    );
  })();

  function requestAnimFrame() {
    return RAF.apply(Konva.global, arguments);
  }

  /**
     * Animation constructor.  A stage is used to contain multiple layers and handle
     * @constructor
     * @memberof Konva
     * @param {Function} func function executed on each animation frame.  The function is passed a frame object, which contains
     *  timeDiff, lastTime, time, and frameRate properties.  The timeDiff property is the number of milliseconds that have passed
     *  since the last animation frame.  The lastTime property is time in milliseconds that elapsed from the moment the animation started
     *  to the last animation frame.  The time property is the time in milliseconds that ellapsed from the moment the animation started
     *  to the current animation frame.  The frameRate property is the current frame rate in frames / second. Return false from function,
     *  if you don't need to redraw layer/layers on some frames.
     * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn on each animation frame. Can be a layer, an array of layers, or null.
     *  Not specifying a node will result in no redraw.
     * @example
     * // move a node to the right at 50 pixels / second
     * var velocity = 50;
     *
     * var anim = new Konva.Animation(function(frame) {
     *   var dist = velocity * (frame.timeDiff / 1000);
     *   node.move(dist, 0);
     * }, layer);
     *
     * anim.start();
     */
  Konva.Animation = function(func, layers) {
    var Anim = Konva.Animation;
    this.func = func;
    this.setLayers(layers);
    this.id = Anim.animIdCounter++;
    this.frame = {
      time: 0,
      timeDiff: 0,
      lastTime: now()
    };
  };
  /*
     * Animation methods
     */
  Konva.Animation.prototype = {
    /**
         * set layers to be redrawn on each animation frame
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer|Array} [layers] layer(s) to be redrawn.&nbsp; Can be a layer, an array of layers, or null.  Not specifying a node will result in no redraw.
         * @return {Konva.Animation} this
         */
    setLayers: function(layers) {
      var lays = [];
      // if passing in no layers
      if (!layers) {
        lays = [];
      } else if (layers.length > 0) {
        // if passing in an array of Layers
        // NOTE: layers could be an array or Konva.Collection.  for simplicity, I'm just inspecting
        // the length property to check for both cases
        lays = layers;
      } else {
        // if passing in a Layer
        lays = [layers];
      }

      this.layers = lays;
      return this;
    },
    /**
         * get layers
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Array} Array of Konva.Layer
         */
    getLayers: function() {
      return this.layers;
    },
    /**
         * add layer.  Returns true if the layer was added, and false if it was not
         * @method
         * @memberof Konva.Animation.prototype
         * @param {Konva.Layer} layer to add
         * @return {Bool} true if layer is added to animation, otherwise false
         */
    addLayer: function(layer) {
      var layers = this.layers, len = layers.length, n;

      // don't add the layer if it already exists
      for (n = 0; n < len; n++) {
        if (layers[n]._id === layer._id) {
          return false;
        }
      }

      this.layers.push(layer);
      return true;
    },
    /**
         * determine if animation is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Bool} is animation running?
         */
    isRunning: function() {
      var a = Konva.Animation,
        animations = a.animations,
        len = animations.length,
        n;

      for (n = 0; n < len; n++) {
        if (animations[n].id === this.id) {
          return true;
        }
      }
      return false;
    },
    /**
         * start animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
    start: function() {
      var Anim = Konva.Animation;
      this.stop();
      this.frame.timeDiff = 0;
      this.frame.lastTime = now();
      Anim._addAnimation(this);
      return this;
    },
    /**
         * stop animation
         * @method
         * @memberof Konva.Animation.prototype
         * @return {Konva.Animation} this
         */
    stop: function() {
      Konva.Animation._removeAnimation(this);
      return this;
    },
    _updateFrameObject: function(time) {
      this.frame.timeDiff = time - this.frame.lastTime;
      this.frame.lastTime = time;
      this.frame.time += this.frame.timeDiff;
      this.frame.frameRate = 1000 / this.frame.timeDiff;
    }
  };
  Konva.Animation.animations = [];
  Konva.Animation.animIdCounter = 0;
  Konva.Animation.animRunning = false;

  Konva.Animation._addAnimation = function(anim) {
    this.animations.push(anim);
    this._handleAnimation();
  };
  Konva.Animation._removeAnimation = function(anim) {
    var id = anim.id, animations = this.animations, len = animations.length, n;

    for (n = 0; n < len; n++) {
      if (animations[n].id === id) {
        this.animations.splice(n, 1);
        break;
      }
    }
  };

  Konva.Animation._runFrames = function() {
    var layerHash = {},
      animations = this.animations,
      anim,
      layers,
      func,
      n,
      i,
      layersLen,
      layer,
      key,
      needRedraw;
    /*
         * loop through all animations and execute animation
         *  function.  if the animation object has specified node,
         *  we can add the node to the nodes hash to eliminate
         *  drawing the same node multiple times.  The node property
         *  can be the stage itself or a layer
         */
    /*
         * WARNING: don't cache animations.length because it could change while
         * the for loop is running, causing a JS error
         */

    for (n = 0; n < animations.length; n++) {
      anim = animations[n];
      layers = anim.layers;
      func = anim.func;

      anim._updateFrameObject(now());
      layersLen = layers.length;

      // if animation object has a function, execute it
      if (func) {
        // allow anim bypassing drawing
        needRedraw = func.call(anim, anim.frame) !== false;
      } else {
        needRedraw = true;
      }
      if (!needRedraw) {
        continue;
      }
      for (i = 0; i < layersLen; i++) {
        layer = layers[i];

        if (layer._id !== undefined) {
          layerHash[layer._id] = layer;
        }
      }
    }

    for (key in layerHash) {
      if (!layerHash.hasOwnProperty(key)) {
        continue;
      }
      layerHash[key].draw();
    }
  };
  Konva.Animation._animationLoop = function() {
    var Anim = Konva.Animation;
    if (Anim.animations.length) {
      Anim._runFrames();
      requestAnimFrame(Anim._animationLoop);
    } else {
      Anim.animRunning = false;
    }
  };
  Konva.Animation._handleAnimation = function() {
    if (!this.animRunning) {
      this.animRunning = true;
      requestAnimFrame(this._animationLoop);
    }
  };

  /**
     * batch draw. this function will not do immediate draw
     * but it will schedule drawing to next tick (requestAnimFrame)
     * @method
     * @return {Konva.Layer} this
     * @memberof Konva.Base.prototype
     */
  Konva.BaseLayer.prototype.batchDraw = function() {
    var that = this, Anim = Konva.Animation;

    if (!this.batchAnim) {
      this.batchAnim = new Anim(function() {
        // stop animation after first tick
        that.batchAnim.stop();
      }, this);
    }

    if (!this.batchAnim.isRunning()) {
      this.batchAnim.start();
    }
    return this;
  };

  /**
     * batch draw
     * @method
     * @return {Konva.Stage} this
     * @memberof Konva.Stage.prototype
     */
  Konva.Stage.prototype.batchDraw = function() {
    this.getChildren().each(function(layer) {
      layer.batchDraw();
    });
    return this;
  };
})(Konva);

(function() {
  'use strict';
  var blacklist = {
    node: 1,
    duration: 1,
    easing: 1,
    onFinish: 1,
    yoyo: 1
  },
    PAUSED = 1,
    PLAYING = 2,
    REVERSING = 3,
    idCounter = 0,
    colorAttrs = ['fill', 'stroke', 'shadowColor'];

  var Tween = function(prop, propFunc, func, begin, finish, duration, yoyo) {
    this.prop = prop;
    this.propFunc = propFunc;
    this.begin = begin;
    this._pos = begin;
    this.duration = duration;
    this._change = 0;
    this.prevPos = 0;
    this.yoyo = yoyo;
    this._time = 0;
    this._position = 0;
    this._startTime = 0;
    this._finish = 0;
    this.func = func;
    this._change = finish - this.begin;
    this.pause();
  };
  /*
     * Tween methods
     */
  Tween.prototype = {
    fire: function(str) {
      var handler = this[str];
      if (handler) {
        handler();
      }
    },
    setTime: function(t) {
      if (t > this.duration) {
        if (this.yoyo) {
          this._time = this.duration;
          this.reverse();
        } else {
          this.finish();
        }
      } else if (t < 0) {
        if (this.yoyo) {
          this._time = 0;
          this.play();
        } else {
          this.reset();
        }
      } else {
        this._time = t;
        this.update();
      }
    },
    getTime: function() {
      return this._time;
    },
    setPosition: function(p) {
      this.prevPos = this._pos;
      this.propFunc(p);
      this._pos = p;
    },
    getPosition: function(t) {
      if (t === undefined) {
        t = this._time;
      }
      return this.func(t, this.begin, this._change, this.duration);
    },
    play: function() {
      this.state = PLAYING;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onPlay');
    },
    reverse: function() {
      this.state = REVERSING;
      this._time = this.duration - this._time;
      this._startTime = this.getTimer() - this._time;
      this.onEnterFrame();
      this.fire('onReverse');
    },
    seek: function(t) {
      this.pause();
      this._time = t;
      this.update();
      this.fire('onSeek');
    },
    reset: function() {
      this.pause();
      this._time = 0;
      this.update();
      this.fire('onReset');
    },
    finish: function() {
      this.pause();
      this._time = this.duration;
      this.update();
      this.fire('onFinish');
    },
    update: function() {
      this.setPosition(this.getPosition(this._time));
    },
    onEnterFrame: function() {
      var t = this.getTimer() - this._startTime;
      if (this.state === PLAYING) {
        this.setTime(t);
      } else if (this.state === REVERSING) {
        this.setTime(this.duration - t);
      }
    },
    pause: function() {
      this.state = PAUSED;
      this.fire('onPause');
    },
    getTimer: function() {
      return new Date().getTime();
    }
  };

  /**
     * Tween constructor.  Tweens enable you to animate a node between the current state and a new state.
     *  You can play, pause, reverse, seek, reset, and finish tweens.  By default, tweens are animated using
     *  a linear easing.  For more tweening options, check out {@link Konva.Easings}
     * @constructor
     * @memberof Konva
     * @example
     * // instantiate new tween which fully rotates a node in 1 second
     * var tween = new Konva.Tween({
     *   node: node,
     *   rotationDeg: 360,
     *   duration: 1,
     *   easing: Konva.Easings.EaseInOut
     * });
     *
     * // play tween
     * tween.play();
     *
     * // pause tween
     * tween.pause();
     */
  Konva.Tween = function(config) {
    var that = this,
      node = config.node,
      nodeId = node._id,
      duration,
      easing = config.easing || Konva.Easings.Linear,
      yoyo = !!config.yoyo,
      key;

    if (typeof config.duration === 'undefined') {
      duration = 1;
    } else if (config.duration === 0) {
      // zero is bad value for duration
      duration = 0.001;
    } else {
      duration = config.duration;
    }
    this.node = node;
    this._id = idCounter++;

    var layers =
      node.getLayer() ||
      (node instanceof Konva.Stage ? node.getLayers() : null);
    if (!layers) {
      Konva.Util.error(
        'Tween constructor have `node` that is not in a layer. Please add node into layer first.'
      );
    }
    this.anim = new Konva.Animation(function() {
      that.tween.onEnterFrame();
    }, layers);

    this.tween = new Tween(
      key,
      function(i) {
        that._tweenFunc(i);
      },
      easing,
      0,
      1,
      duration * 1000,
      yoyo
    );

    this._addListeners();

    // init attrs map
    if (!Konva.Tween.attrs[nodeId]) {
      Konva.Tween.attrs[nodeId] = {};
    }
    if (!Konva.Tween.attrs[nodeId][this._id]) {
      Konva.Tween.attrs[nodeId][this._id] = {};
    }
    // init tweens map
    if (!Konva.Tween.tweens[nodeId]) {
      Konva.Tween.tweens[nodeId] = {};
    }

    for (key in config) {
      if (blacklist[key] === undefined) {
        this._addAttr(key, config[key]);
      }
    }

    this.reset();

    // callbacks
    this.onFinish = config.onFinish;
    this.onReset = config.onReset;
  };

  // start/diff object = attrs.nodeId.tweenId.attr
  Konva.Tween.attrs = {};
  // tweenId = tweens.nodeId.attr
  Konva.Tween.tweens = {};

  Konva.Tween.prototype = {
    _addAttr: function(key, end) {
      var node = this.node,
        nodeId = node._id,
        start,
        diff,
        tweenId,
        n,
        len,
        trueEnd,
        trueStart;

      // remove conflict from tween map if it exists
      tweenId = Konva.Tween.tweens[nodeId][key];

      if (tweenId) {
        delete Konva.Tween.attrs[nodeId][tweenId][key];
      }

      // add to tween map
      start = node.getAttr(key);

      if (Konva.Util._isArray(end)) {
        diff = [];
        len = Math.max(end.length, start.length);

        if (key === 'points' && end.length !== start.length) {
          // before tweening points we need to make sure that start.length === end.length
          // Konva.Util._prepareArrayForTween thinking that end.length > start.length

          if (end.length > start.length) {
            // so in this case we will increase number of starting points
            trueStart = start;
            start = Konva.Util._prepareArrayForTween(start, end, node.closed());
          } else {
            // in this case we will increase number of eding points
            trueEnd = end;
            end = Konva.Util._prepareArrayForTween(end, start, node.closed());
          }
        }

        for (n = 0; n < len; n++) {
          diff.push(end[n] - start[n]);
        }
      } else if (colorAttrs.indexOf(key) !== -1) {
        start = Konva.Util.colorToRGBA(start);
        var endRGBA = Konva.Util.colorToRGBA(end);
        diff = {
          r: endRGBA.r - start.r,
          g: endRGBA.g - start.g,
          b: endRGBA.b - start.b,
          a: endRGBA.a - start.a
        };
      } else {
        diff = end - start;
      }

      Konva.Tween.attrs[nodeId][this._id][key] = {
        start: start,
        diff: diff,
        end: end,
        trueEnd: trueEnd,
        trueStart: trueStart
      };
      Konva.Tween.tweens[nodeId][key] = this._id;
    },
    _tweenFunc: function(i) {
      var node = this.node,
        attrs = Konva.Tween.attrs[node._id][this._id],
        key,
        attr,
        start,
        diff,
        newVal,
        n,
        len,
        end;

      for (key in attrs) {
        attr = attrs[key];
        start = attr.start;
        diff = attr.diff;
        end = attr.end;

        if (Konva.Util._isArray(start)) {
          newVal = [];
          len = Math.max(start.length, end.length);
          for (n = 0; n < len; n++) {
            newVal.push((start[n] || 0) + diff[n] * i);
          }
        } else if (colorAttrs.indexOf(key) !== -1) {
          newVal =
            'rgba(' +
            Math.round(start.r + diff.r * i) +
            ',' +
            Math.round(start.g + diff.g * i) +
            ',' +
            Math.round(start.b + diff.b * i) +
            ',' +
            (start.a + diff.a * i) +
            ')';
        } else {
          newVal = start + diff * i;
        }

        node.setAttr(key, newVal);
      }
    },
    _addListeners: function() {
      var that = this;

      // start listeners
      this.tween.onPlay = function() {
        that.anim.start();
      };
      this.tween.onReverse = function() {
        that.anim.start();
      };

      // stop listeners
      this.tween.onPause = function() {
        that.anim.stop();
      };
      this.tween.onFinish = function() {
        var node = that.node;

        // after tweening  points of line we need to set original end
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueEnd) {
          node.points(attrs.points.trueEnd);
        }

        if (that.onFinish) {
          that.onFinish.call(that);
        }
      };
      this.tween.onReset = function() {
        var node = that.node;
        // after tweening  points of line we need to set original start
        var attrs = Konva.Tween.attrs[node._id][that._id];
        if (attrs.points && attrs.points.trueStart) {
          node.points(attrs.points.trueStart);
        }

        if (that.onReset) {
          that.onReset();
        }
      };
    },
    /**
         * play
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    play: function() {
      this.tween.play();
      return this;
    },
    /**
         * reverse
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    reverse: function() {
      this.tween.reverse();
      return this;
    },
    /**
         * reset
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    reset: function() {
      this.tween.reset();
      return this;
    },
    /**
         * seek
         * @method
         * @memberof Konva.Tween.prototype
         * @param {Integer} t time in seconds between 0 and the duration
         * @returns {Tween}
         */
    seek: function(t) {
      this.tween.seek(t * 1000);
      return this;
    },
    /**
         * pause
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    pause: function() {
      this.tween.pause();
      return this;
    },
    /**
         * finish
         * @method
         * @memberof Konva.Tween.prototype
         * @returns {Tween}
         */
    finish: function() {
      this.tween.finish();
      return this;
    },
    /**
         * destroy
         * @method
         * @memberof Konva.Tween.prototype
         */
    destroy: function() {
      var nodeId = this.node._id,
        thisId = this._id,
        attrs = Konva.Tween.tweens[nodeId],
        key;

      this.pause();

      for (key in attrs) {
        delete Konva.Tween.tweens[nodeId][key];
      }

      delete Konva.Tween.attrs[nodeId][thisId];
    }
  };

  /**
     * Tween node properties. Shorter usage of {@link Konva.Tween} object.
     *
     * @method Konva.Node#to
     * @memberof Konva.Node
     * @param {Object} [params] tween params
     * @example
     *
     * circle.to({
     *  x : 50,
     *  duration : 0.5
     * });
     */
  Konva.Node.prototype.to = function(params) {
    var onFinish = params.onFinish;
    params.node = this;
    params.onFinish = function() {
      this.destroy();
      if (onFinish) {
        onFinish();
      }
    };
    var tween = new Konva.Tween(params);
    tween.play();
  };

  /*
    * These eases were ported from an Adobe Flash tweening library to JavaScript
    * by Xaric
    */

  /**
     * @namespace Easings
     * @memberof Konva
     */
  Konva.Easings = {
    /**
        * back ease in
        * @function
        * @memberof Konva.Easings
        */
    BackEaseIn: function(t, b, c, d) {
      var s = 1.70158;
      return c * (t /= d) * t * ((s + 1) * t - s) + b;
    },
    /**
        * back ease out
        * @function
        * @memberof Konva.Easings
        */
    BackEaseOut: function(t, b, c, d) {
      var s = 1.70158;
      return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
    },
    /**
        * back ease in out
        * @function
        * @memberof Konva.Easings
        */
    BackEaseInOut: function(t, b, c, d) {
      var s = 1.70158;
      if ((t /= d / 2) < 1) {
        return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
      }
      return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
    },
    /**
        * elastic ease in
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseIn: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        -(a *
          Math.pow(2, 10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p)) + b
      );
    },
    /**
        * elastic ease out
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d) === 1) {
        return b + c;
      }
      if (!p) {
        p = d * 0.3;
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      return (
        a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) +
        c +
        b
      );
    },
    /**
        * elastic ease in out
        * @function
        * @memberof Konva.Easings
        */
    ElasticEaseInOut: function(t, b, c, d, a, p) {
      // added s = 0
      var s = 0;
      if (t === 0) {
        return b;
      }
      if ((t /= d / 2) === 2) {
        return b + c;
      }
      if (!p) {
        p = d * (0.3 * 1.5);
      }
      if (!a || a < Math.abs(c)) {
        a = c;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
      if (t < 1) {
        return (
          -0.5 *
            (a *
              Math.pow(2, 10 * (t -= 1)) *
              Math.sin((t * d - s) * (2 * Math.PI) / p)) +
          b
        );
      }
      return (
        a *
          Math.pow(2, -10 * (t -= 1)) *
          Math.sin((t * d - s) * (2 * Math.PI) / p) *
          0.5 +
        c +
        b
      );
    },
    /**
        * bounce ease out
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseOut: function(t, b, c, d) {
      if ((t /= d) < 1 / 2.75) {
        return c * (7.5625 * t * t) + b;
      } else if (t < 2 / 2.75) {
        return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
      } else if (t < 2.5 / 2.75) {
        return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
      } else {
        return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
      }
    },
    /**
        * bounce ease in
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseIn: function(t, b, c, d) {
      return c - Konva.Easings.BounceEaseOut(d - t, 0, c, d) + b;
    },
    /**
        * bounce ease in out
        * @function
        * @memberof Konva.Easings
        */
    BounceEaseInOut: function(t, b, c, d) {
      if (t < d / 2) {
        return Konva.Easings.BounceEaseIn(t * 2, 0, c, d) * 0.5 + b;
      } else {
        return (
          Konva.Easings.BounceEaseOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b
        );
      }
    },
    /**
        * ease in
        * @function
        * @memberof Konva.Easings
        */
    EaseIn: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },
    /**
        * ease out
        * @function
        * @memberof Konva.Easings
        */
    EaseOut: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },
    /**
        * ease in out
        * @function
        * @memberof Konva.Easings
        */
    EaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * (--t * (t - 2) - 1) + b;
    },
    /**
        * strong ease in
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseIn: function(t, b, c, d) {
      return c * (t /= d) * t * t * t * t + b;
    },
    /**
        * strong ease out
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseOut: function(t, b, c, d) {
      return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
    },
    /**
        * strong ease in out
        * @function
        * @memberof Konva.Easings
        */
    StrongEaseInOut: function(t, b, c, d) {
      if ((t /= d / 2) < 1) {
        return c / 2 * t * t * t * t * t + b;
      }
      return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
    },
    /**
        * linear
        * @function
        * @memberof Konva.Easings
        */
    Linear: function(t, b, c, d) {
      return c * t / d + b;
    }
  };
})();

(function() {
  'use strict';
  Konva.DD = {
    // properties
    anim: new Konva.Animation(function() {
      var b = this.dirty;
      this.dirty = false;
      return b;
    }),
    isDragging: false,
    justDragged: false,
    offset: {
      x: 0,
      y: 0
    },
    node: null,

    // methods
    _drag: function(evt) {
      var dd = Konva.DD,
        node = dd.node;
      if (node) {
        if (!dd.isDragging) {
          var pos = node.getStage().getPointerPosition();
          // it is possible that pos is undefined
          // reattach it
          if (!pos) {
            node.getStage()._setPointerPosition(evt);
            pos = node.getStage().getPointerPosition();
          }
          var dragDistance = node.dragDistance();
          var distance = Math.max(
            Math.abs(pos.x - dd.startPointerPos.x),
            Math.abs(pos.y - dd.startPointerPos.y)
          );
          if (distance < dragDistance) {
            return;
          }
        }

        node.getStage()._setPointerPosition(evt);
        node._setDragPosition(evt);
        if (!dd.isDragging) {
          dd.isDragging = true;
          node.fire(
            'dragstart',
            {
              type: 'dragstart',
              target: node,
              evt: evt
            },
            true
          );
        }

        // execute ondragmove if defined
        node.fire(
          'dragmove',
          {
            type: 'dragmove',
            target: node,
            evt: evt
          },
          true
        );
      }
    },
    _endDragBefore: function(evt) {
      var dd = Konva.DD,
        node = dd.node,
        layer;

      if (node) {
        layer = node.getLayer();
        dd.anim.stop();

        // only fire dragend event if the drag and drop
        // operation actually started.
        if (dd.isDragging) {
          dd.isDragging = false;
          dd.justDragged = true;
          Konva.listenClickTap = false;

          if (evt) {
            evt.dragEndNode = node;
          }
        }

        delete dd.node;

        if (node.getLayer() || layer || node instanceof Konva.Stage) {
          (layer || node).draw();
        }
      }
    },
    _endDragAfter: function(evt) {
      evt = evt || {};
      var dragEndNode = evt.dragEndNode;

      if (evt && dragEndNode) {
        dragEndNode.fire(
          'dragend',
          {
            type: 'dragend',
            target: dragEndNode,
            evt: evt
          },
          true
        );
      }
    }
  };

  // Node extenders

  /**
   * initiate drag and drop
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.startDrag = function() {
    var dd = Konva.DD,
      stage = this.getStage(),
      layer = this.getLayer(),
      pos = stage.getPointerPosition(),
      ap = this.getAbsolutePosition();

    if (pos) {
      if (dd.node) {
        dd.node.stopDrag();
      }

      dd.node = this;
      dd.startPointerPos = pos;
      dd.offset.x = pos.x - ap.x;
      dd.offset.y = pos.y - ap.y;
      dd.anim.setLayers(layer || this.getLayers());
      dd.anim.start();

      this._setDragPosition();
    }
  };

  Konva.Node.prototype._setDragPosition = function(evt) {
    var dd = Konva.DD,
      pos = this.getStage().getPointerPosition(),
      dbf = this.getDragBoundFunc();
    if (!pos) {
      return;
    }
    var newNodePos = {
      x: pos.x - dd.offset.x,
      y: pos.y - dd.offset.y
    };

    if (dbf !== undefined) {
      newNodePos = dbf.call(this, newNodePos, evt);
    }
    this.setAbsolutePosition(newNodePos);

    if (
      !this._lastPos ||
      this._lastPos.x !== newNodePos.x ||
      this._lastPos.y !== newNodePos.y
    ) {
      dd.anim.dirty = true;
    }

    this._lastPos = newNodePos;
  };

  /**
   * stop drag and drop
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.stopDrag = function() {
    var dd = Konva.DD,
      evt = {};
    dd._endDragBefore(evt);
    dd._endDragAfter(evt);
  };

  Konva.Node.prototype.setDraggable = function(draggable) {
    this._setAttr('draggable', draggable);
    this._dragChange();
  };

  var origRemove = Konva.Node.prototype.remove;

  Konva.Node.prototype.__originalRemove = origRemove;
  Konva.Node.prototype.remove = function() {
    var dd = Konva.DD;

    // stop DD
    if (dd.node && dd.node._id === this._id) {
      this.stopDrag();
    }

    origRemove.call(this);
  };

  /**
   * determine if node is currently in drag and drop mode
   * @method
   * @memberof Konva.Node.prototype
   */
  Konva.Node.prototype.isDragging = function() {
    var dd = Konva.DD;
    return !!(dd.node && dd.node._id === this._id && dd.isDragging);
  };

  Konva.Node.prototype._listenDrag = function() {
    var that = this;

    this._dragCleanup();

    if (this.getClassName() === 'Stage') {
      this.on('contentMousedown.konva contentTouchstart.konva', function(evt) {
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    } else {
      this.on('mousedown.konva touchstart.konva', function(evt) {
        // ignore right and middle buttons
        if (evt.evt.button === 1 || evt.evt.button === 2) {
          return;
        }
        if (!Konva.DD.node) {
          that.startDrag(evt);
        }
      });
    }

    // listening is required for drag and drop
    /*
        this._listeningEnabled = true;
        this._clearSelfAndAncestorCache('listeningEnabled');
        */
  };

  Konva.Node.prototype._dragChange = function() {
    if (this.attrs.draggable) {
      this._listenDrag();
    } else {
      // remove event listeners
      this._dragCleanup();

      /*
             * force drag and drop to end
             * if this node is currently in
             * drag and drop mode
             */
      var stage = this.getStage();
      var dd = Konva.DD;
      if (stage && dd.node && dd.node._id === this._id) {
        dd.node.stopDrag();
      }
    }
  };

  Konva.Node.prototype._dragCleanup = function() {
    if (this.getClassName() === 'Stage') {
      this.off('contentMousedown.konva');
      this.off('contentTouchstart.konva');
    } else {
      this.off('mousedown.konva');
      this.off('touchstart.konva');
    }
  };

  Konva.Factory.addGetterSetter(Konva.Node, 'dragBoundFunc');

  /**
   * get/set drag bound function.  This is used to override the default
   *  drag and drop position.
   * @name dragBoundFunc
   * @method
   * @memberof Konva.Node.prototype
   * @param {Function} dragBoundFunc
   * @returns {Function}
   * @example
   * // get drag bound function
   * var dragBoundFunc = node.dragBoundFunc();
   *
   * // create vertical drag and drop
   * node.dragBoundFunc(function(pos){
   *   // important pos - is absolute position of the node
   *   // you should return absolute position too
   *   return {
   *     x: this.getAbsolutePosition().x,
   *     y: pos.y
   *   };
   * });
   */

  Konva.Factory.addGetter(Konva.Node, 'draggable', false);
  Konva.Factory.addOverloadedGetterSetter(Konva.Node, 'draggable');

  /**
   * get/set draggable flag
   * @name draggable
   * @method
   * @memberof Konva.Node.prototype
   * @param {Boolean} draggable
   * @returns {Boolean}
   * @example
   * // get draggable flag
   * var draggable = node.draggable();
   *
   * // enable drag and drop
   * node.draggable(true);
   *
   * // disable drag and drop
   * node.draggable(false);
   */

  if (Konva.isBrowser) {
    var html = Konva.document.documentElement;
    html.addEventListener('mouseup', Konva.DD._endDragBefore, true);
    html.addEventListener('touchend', Konva.DD._endDragBefore, true);

    html.addEventListener('mousemove', Konva.DD._drag);
    html.addEventListener('touchmove', Konva.DD._drag);

    html.addEventListener('mouseup', Konva.DD._endDragAfter, false);
    html.addEventListener('touchend', Konva.DD._endDragAfter, false);
  }
})();

(function() {
  'use strict';
  /**
     * Rect constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} [config.cornerRadius]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var rect = new Konva.Rect({
     *   width: 100,
     *   height: 50,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
  Konva.Rect = function(config) {
    this.___init(config);
  };

  Konva.Rect.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Rect';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var cornerRadius = this.getCornerRadius(),
        width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();

      if (!cornerRadius) {
        // simple rect - don't bother doing all that complicated maths stuff.
        context.rect(0, 0, width, height);
      } else {
        // arcTo would be nicer, but browser support is patchy (Opera)
        cornerRadius = Math.min(cornerRadius, width / 2, height / 2);
        context.moveTo(cornerRadius, 0);
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }
      context.closePath();
      context.fillStrokeShape(this);
    }
  };

  Konva.Util.extend(Konva.Rect, Konva.Shape);

  Konva.Factory.addGetterSetter(Konva.Rect, 'cornerRadius', 0);
  /**
     * get/set corner radius
     * @name cornerRadius
     * @method
     * @memberof Konva.Rect.prototype
     * @param {Number} cornerRadius
     * @returns {Number}
     * @example
     * // get corner radius
     * var cornerRadius = rect.cornerRadius();
     *
     * // set corner radius
     * rect.cornerRadius(10);
     */

  Konva.Collection.mapMethods(Konva.Rect);
})();

(function(Konva) {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001, CIRCLE = 'Circle';

  /**
     * Circle constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create circle
     * var circle = new Konva.Circle({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5
     * });
     */
  Konva.Circle = function(config) {
    this.___init(config);
  };

  Konva.Circle.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = CIRCLE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getRadius(), 0, PIx2, false);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Circle, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Circle, 'radius', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Circle, 'radius');

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Circle.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = circle.radius();
     *
     * // set radius
     * circle.radius(10);
     */

  Konva.Collection.mapMethods(Konva.Circle);
})(Konva);

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001, ELLIPSE = 'Ellipse';

  /**
     * Ellipse constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Object} config.radius defines x and y radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ellipse = new Konva.Ellipse({
     *   radius : {
     *     x : 50,
     *     y : 50
     *   },
     *   fill: 'red'
     * });
     */
  Konva.Ellipse = function(config) {
    this.___init(config);
  };

  Konva.Ellipse.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = ELLIPSE;
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var rx = this.getRadiusX(), ry = this.getRadiusY();

      context.beginPath();
      context.save();
      if (rx !== ry) {
        context.scale(1, ry / rx);
      }
      context.arc(0, 0, rx, 0, PIx2, false);
      context.restore();
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadiusX() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadiusY() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      this.setRadius({
        x: width / 2
      });
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      this.setRadius({
        y: height / 2
      });
    }
  };
  Konva.Util.extend(Konva.Ellipse, Konva.Shape);

  // add getters setters
  Konva.Factory.addComponentsGetterSetter(Konva.Ellipse, 'radius', ['x', 'y']);

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Object} radius
     * @param {Number} radius.x
     * @param {Number} radius.y
     * @returns {Object}
     * @example
     * // get radius
     * var radius = ellipse.radius();
     *
     * // set radius
     * ellipse.radius({
     *   x: 200,
     *   y: 100
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusX', 0);
  /**
     * get/set radius x
     * @name radiusX
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get radius x
     * var radiusX = ellipse.radiusX();
     *
     * // set radius x
     * ellipse.radiusX(200);
     */

  Konva.Factory.addGetterSetter(Konva.Ellipse, 'radiusY', 0);
  /**
     * get/set radius y
     * @name radiusY
     * @method
     * @memberof Konva.Ellipse.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get radius y
     * var radiusY = ellipse.radiusY();
     *
     * // set radius y
     * ellipse.radiusY(200);
     */

  Konva.Collection.mapMethods(Konva.Ellipse);
})();

(function() {
  'use strict';
  // the 0.0001 offset fixes a bug in Chrome 27
  var PIx2 = Math.PI * 2 - 0.0001;
  /**
     * Ring constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var ring = new Konva.Ring({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 5
     * });
     */
  Konva.Ring = function(config) {
    this.___init(config);
  };

  Konva.Ring.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Ring';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(0, 0, this.getInnerRadius(), 0, PIx2, false);
      context.moveTo(this.getOuterRadius(), 0);
      context.arc(0, 0, this.getOuterRadius(), PIx2, 0, true);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    },
    setOuterRadius: function(val) {
      this._setAttr('outerRadius', val);
      this.setWidth(val * 2);
      this.setHeight(val * 2);
    }
  };
  Konva.Util.extend(Konva.Ring, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Ring, 'innerRadius', 0);

  /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = ring.innerRadius();
     *
     * // set inner radius
     * ring.innerRadius(20);
     */
  Konva.Factory.addGetter(Konva.Ring, 'outerRadius', 0);
  Konva.Factory.addOverloadedGetterSetter(Konva.Ring, 'outerRadius');

  /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Ring.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = ring.outerRadius();
     *
     * // set outer radius
     * ring.outerRadius(20);
     */

  Konva.Collection.mapMethods(Konva.Ring);
})();

(function() {
  'use strict';
  /**
     * Wedge constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.radius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a wedge that's pointing downwards
     * var wedge = new Konva.Wedge({
     *   radius: 40,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angleDeg: 60,
     *   rotationDeg: -120
     * });
     */
  Konva.Wedge = function(config) {
    this.___init(config);
  };

  Konva.Wedge.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Wedge';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      context.beginPath();
      context.arc(
        0,
        0,
        this.getRadius(),
        0,
        Konva.getAngle(this.getAngle()),
        this.getClockwise()
      );
      context.lineTo(0, 0);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Wedge, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Wedge, 'radius', 0);

  /**
     * get/set radius
     * @name radius
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} radius
     * @returns {Number}
     * @example
     * // get radius
     * var radius = wedge.radius();
     *
     * // set radius
     * wedge.radius(10);
     */

  Konva.Factory.addGetterSetter(Konva.Wedge, 'angle', 0);

  /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = wedge.angle();
     *
     * // set angle
     * wedge.angle(20);
     */

  Konva.Factory.addGetterSetter(Konva.Wedge, 'clockwise', false);

  /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Wedge.prototype
     * @param {Number} clockwise
     * @returns {Number}
     * @example
     * // get clockwise flag
     * var clockwise = wedge.clockwise();
     *
     * // draw wedge counter-clockwise
     * wedge.clockwise(false);
     *
     * // draw wedge clockwise
     * wedge.clockwise(true);
     */

  Konva.Factory.backCompat(Konva.Wedge, {
    angleDeg: 'angle',
    getAngleDeg: 'getAngle',
    setAngleDeg: 'setAngle'
  });

  Konva.Collection.mapMethods(Konva.Wedge);
})();

(function(Konva) {
  'use strict';
  /**
     * Arc constructor
     * @constructor
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.angle in degrees
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {Boolean} [config.clockwise]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // draw a Arc that's pointing downwards
     * var arc = new Konva.Arc({
     *   innerRadius: 40,
     *   outerRadius: 80,
     *   fill: 'red',
     *   stroke: 'black'
     *   strokeWidth: 5,
     *   angle: 60,
     *   rotationDeg: -120
     * });
     */
  Konva.Arc = function(config) {
    this.___init(config);
  };

  Konva.Arc.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Arc';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var angle = Konva.getAngle(this.angle()), clockwise = this.clockwise();

      context.beginPath();
      context.arc(0, 0, this.getOuterRadius(), 0, angle, clockwise);
      context.arc(0, 0, this.getInnerRadius(), angle, 0, !clockwise);
      context.closePath();
      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.getOuterRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.getOuterRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Arc, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Arc, 'innerRadius', 0);

  /**
     * get/set innerRadius
     * @name innerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} innerRadius
     * @returns {Number}
     * @example
     * // get inner radius
     * var innerRadius = arc.innerRadius();
     *
     * // set inner radius
     * arc.innerRadius(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'outerRadius', 0);

  /**
     * get/set outerRadius
     * @name outerRadius
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} outerRadius
     * @returns {Number}
     * @example
     * // get outer radius
     * var outerRadius = arc.outerRadius();
     *
     * // set outer radius
     * arc.outerRadius(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'angle', 0);

  /**
     * get/set angle in degrees
     * @name angle
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Number} angle
     * @returns {Number}
     * @example
     * // get angle
     * var angle = arc.angle();
     *
     * // set angle
     * arc.angle(20);
     */

  Konva.Factory.addGetterSetter(Konva.Arc, 'clockwise', false);

  /**
     * get/set clockwise flag
     * @name clockwise
     * @method
     * @memberof Konva.Arc.prototype
     * @param {Boolean} clockwise
     * @returns {Boolean}
     * @example
     * // get clockwise flag
     * var clockwise = arc.clockwise();
     *
     * // draw arc counter-clockwise
     * arc.clockwise(false);
     *
     * // draw arc clockwise
     * arc.clockwise(true);
     */

  Konva.Collection.mapMethods(Konva.Arc);
})(Konva);

(function() {
  'use strict';
  // CONSTANTS
  var IMAGE = 'Image';

  /**
     * Image constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Image} config.image
     * @param {Object} [config.crop]
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var image = new Konva.Image({
     *     x: 200,
     *     y: 50,
     *     image: imageObj,
     *     width: 100,
     *     height: 100
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
  Konva.Image = function(config) {
    this.___init(config);
  };

  Konva.Image.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = IMAGE;
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke() &&
        this.getStage()
      );
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        image = this.getImage(),
        cropWidth,
        cropHeight,
        params;

      if (image) {
        cropWidth = this.getCropWidth();
        cropHeight = this.getCropHeight();
        if (cropWidth && cropHeight) {
          params = [
            image,
            this.getCropX(),
            this.getCropY(),
            cropWidth,
            cropHeight,
            0,
            0,
            width,
            height
          ];
        } else {
          params = [image, 0, 0, width, height];
        }
      }

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        context.drawImage.apply(context, params);
      }
    },
    _hitFunc: function(context) {
      var width = this.getWidth(), height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      var image = this.getImage();
      return this.attrs.width || (image ? image.width : 0);
    },
    getHeight: function() {
      var image = this.getImage();
      return this.attrs.height || (image ? image.height : 0);
    }
  };
  Konva.Util.extend(Konva.Image, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Image, 'image');

  /**
     * set image
     * @name setImage
     * @method
     * @memberof Konva.Image.prototype
     * @param {Image} image
     */

  /**
     * get image
     * @name getImage
     * @method
     * @memberof Konva.Image.prototype
     * @returns {Image}
     */

  Konva.Factory.addComponentsGetterSetter(Konva.Image, 'crop', [
    'x',
    'y',
    'width',
    'height'
  ]);
  /**
     * get/set crop
     * @method
     * @name crop
     * @memberof Konva.Image.prototype
     * @param {Object} crop
     * @param {Number} crop.x
     * @param {Number} crop.y
     * @param {Number} crop.width
     * @param {Number} crop.height
     * @returns {Object}
     * @example
     * // get crop
     * var crop = image.crop();
     *
     * // set crop
     * image.crop({
     *   x: 20,
     *   y: 20,
     *   width: 20,
     *   height: 20
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropX', 0);
  /**
     * get/set crop x
     * @method
     * @name cropX
     * @memberof Konva.Image.prototype
     * @param {Number} x
     * @returns {Number}
     * @example
     * // get crop x
     * var cropX = image.cropX();
     *
     * // set crop x
     * image.cropX(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropY', 0);
  /**
     * get/set crop y
     * @name cropY
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} y
     * @returns {Number}
     * @example
     * // get crop y
     * var cropY = image.cropY();
     *
     * // set crop y
     * image.cropY(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropWidth', 0);
  /**
     * get/set crop width
     * @name cropWidth
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} width
     * @returns {Number}
     * @example
     * // get crop width
     * var cropWidth = image.cropWidth();
     *
     * // set crop width
     * image.cropWidth(20);
     */

  Konva.Factory.addGetterSetter(Konva.Image, 'cropHeight', 0);
  /**
     * get/set crop height
     * @name cropHeight
     * @method
     * @memberof Konva.Image.prototype
     * @param {Number} height
     * @returns {Number}
     * @example
     * // get crop height
     * var cropHeight = image.cropHeight();
     *
     * // set crop height
     * image.cropHeight(20);
     */

  Konva.Collection.mapMethods(Konva.Image);

  /**
     * load image from given url and create `Konva.Image` instance
     * @method
     * @memberof Konva.Image
     * @param {String} url image source
     * @param {Function} callback with Konva.Image instance as first argument
     * @example
     *  Konva.Image.fromURL(imageURL, function(image){
     *    // image is Konva.Image instance
     *    layer.add(image);
     *    layer.draw();
     *  });
     */
  Konva.Image.fromURL = function(url, callback) {
    var img = new Image();
    img.onload = function() {
      var image = new Konva.Image({
        image: img
      });
      callback(image);
    };
    img.crossOrigin = 'Anonymous';
    img.src = url;
  };
})();

/*eslint-disable max-depth */
(function() {
  'use strict';
  // var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
  // constants
  var AUTO = 'auto',
    //CANVAS = 'canvas',
    CENTER = 'center',
    JUSTIFY = 'justify',
    CHANGE_KONVA = 'Change.konva',
    CONTEXT_2D = '2d',
    DASH = '-',
    EMPTY_STRING = '',
    LEFT = 'left',
    TEXT = 'text',
    TEXT_UPPER = 'Text',
    MIDDLE = 'middle',
    NORMAL = 'normal',
    PX_SPACE = 'px ',
    SPACE = ' ',
    RIGHT = 'right',
    WORD = 'word',
    CHAR = 'char',
    NONE = 'none',
    ELLIPSIS = '',
    ATTR_CHANGE_LIST = [
      'fontFamily',
      'fontSize',
      'fontStyle',
      'fontVariant',
      'padding',
      'align',
      'lineHeight',
      'text',
      'width',
      'height',
      'wrap',
      'ellipsis',
      'letterSpacing'
    ],
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;
  var dummyContext;
  function getDummyContext() {
    if (dummyContext) {
      return dummyContext;
    }
    dummyContext = Konva.Util.createCanvasElement().getContext(CONTEXT_2D);
    return dummyContext;
  }

  /**
   * Text constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} [config.fontFamily] default is Arial
   * @param {Number} [config.fontSize] in pixels.  Default is 12
   * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
   * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
   * @param {String} config.text
   * @param {String} [config.align] can be left, center, or right
   * @param {Number} [config.padding]
   * @param {Number} [config.lineHeight] default is 1
   * @param {String} [config.wrap] can be word, char, or none. Default is word
   * @param {Boolean} [config.ellipsis] can be true or false. Default is false. if Konva.Text config is set to wrap="none" and ellipsis=true, then it will add "..." to the end
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var text = new Konva.Text({
   *   x: 10,
   *   y: 15,
   *   text: 'Simple Text',
   *   fontSize: 30,
   *   fontFamily: 'Calibri',
   *   fill: 'green'
   * });
   */
  Konva.Text = function(config) {
    this.___init(config);
  };
  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.Text.prototype = {
    ___init: function(config) {
      config = config || {};

      // set default color to black
      if (
        !config.fillLinearGradientColorStops &&
        !config.fillRadialGradientColorStops
      ) {
        config.fill = config.fill || 'black';
      }
      //
      // if (config.width === undefined) {
      //     config.width = AUTO;
      // }
      // if (config.height === undefined) {
      //     config.height = AUTO;
      // }

      // call super constructor
      Konva.Shape.call(this, config);

      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this.className = TEXT_UPPER;

      // update text data for certain attr changes
      for (var n = 0; n < attrChangeListLen; n++) {
        this.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, this._setTextData);
      }

      this._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var padding = this.getPadding(),
        textHeight = this.getTextHeight(),
        lineHeightPx = this.getLineHeight() * textHeight,
        textArr = this.textArr,
        textArrLen = textArr.length,
        align = this.getAlign(),
        totalWidth = this.getWidth(),
        letterSpacing = this.getLetterSpacing(),
        textDecoration = this.textDecoration(),
        fill = this.fill(),
        fontSize = this.fontSize(),
        n;

      context.setAttr('font', this._getContextFont());

      context.setAttr('textBaseline', MIDDLE);
      context.setAttr('textAlign', LEFT);
      if (padding) {
        context.translate(padding, 0);
        context.translate(0, padding + lineHeightPx / 2);
      } else {
        context.translate(0, lineHeightPx / 2);
      }

      // draw text lines
      for (n = 0; n < textArrLen; n++) {
        var obj = textArr[n],
          text = obj.text,
          width = obj.width;

        // horizontal alignment
        context.save();
        if (align === RIGHT) {
          context.translate(totalWidth - width - padding * 2, 0);
        } else if (align === CENTER) {
          context.translate((totalWidth - width - padding * 2) / 2, 0);
        }

        if (textDecoration.indexOf('underline') !== -1) {
          context.save();
          context.beginPath();
          context.moveTo(0, Math.round(lineHeightPx / 2));
          context.lineTo(Math.round(width), Math.round(lineHeightPx / 2));
          // TODO: I have no idea what is real ratio
          // just /15 looks good enough
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (textDecoration.indexOf('line-through') !== -1) {
          context.save();
          context.beginPath();
          context.moveTo(0, 0);
          context.lineTo(Math.round(width), 0);
          context.lineWidth = fontSize / 15;
          context.strokeStyle = fill;
          context.stroke();
          context.restore();
        }
        if (letterSpacing !== 0 || align === JUSTIFY) {
          //   var words = text.split(' ');
          var spacesNumber = text.split(' ').length - 1;
          for (var li = 0; li < text.length; li++) {
            var letter = text[li];
            // skip justify for the last line
            if (letter === ' ' && n !== textArrLen - 1 && align === JUSTIFY) {
              context.translate(
                Math.floor((totalWidth - width) / spacesNumber),
                0
              );
            }
            this.partialText = letter;
            context.fillStrokeShape(this);
            context.translate(
              Math.round(this._getTextSize(letter).width) + letterSpacing,
              0
            );
          }
        } else {
          this.partialText = text;

          context.fillStrokeShape(this);
        }
        context.restore();
        if (textArrLen > 1) {
          context.translate(0, lineHeightPx);
        }
      }
    },
    _hitFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight();

      context.beginPath();
      context.rect(0, 0, width, height);
      context.closePath();
      context.fillStrokeShape(this);
    },
    setText: function(text) {
      var str = Konva.Util._isString(text) ? text : (text || '').toString();
      this._setAttr(TEXT, str);
      return this;
    },
    /**
     * get width of text area, which includes padding
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getWidth: function() {
      var isAuto = this.attrs.width === AUTO || this.attrs.width === undefined;
      return isAuto
        ? this.getTextWidth() + this.getPadding() * 2
        : this.attrs.width;
    },
    /**
     * get the height of the text area, which takes into account multi-line text, line heights, and padding
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getHeight: function() {
      var isAuto =
        this.attrs.height === AUTO || this.attrs.height === undefined;
      return isAuto
        ? this.getTextHeight() * this.textArr.length * this.getLineHeight() +
            this.getPadding() * 2
        : this.attrs.height;
    },
    /**
     * get text width
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
     * get text height
     * @method
     * @memberof Konva.Text.prototype
     * @returns {Number}
     */
    getTextHeight: function() {
      return this.textHeight;
    },
    _getTextSize: function(text) {
      var _context = getDummyContext(),
        fontSize = this.getFontSize(),
        metrics;

      _context.save();
      _context.font = this._getContextFont();

      metrics = _context.measureText(text);
      _context.restore();
      return {
        width: metrics.width,
        height: parseInt(fontSize, 10)
      };
    },
    _getContextFont: function() {
      // IE don't want to work with usual font style
      // bold was not working
      // removing font variant will solve
      // fix for: https://github.com/konvajs/konva/issues/94
      if (Konva.UA.isIE) {
        return (
          this.getFontStyle() +
          SPACE +
          this.getFontSize() +
          PX_SPACE +
          this.getFontFamily()
        );
      }
      return (
        this.getFontStyle() +
        SPACE +
        this.getFontVariant() +
        SPACE +
        this.getFontSize() +
        PX_SPACE +
        this.getFontFamily()
      );
    },
    _addTextLine: function(line) {
      if (this.align() === JUSTIFY) {
        line = line.trim();
      }
      var width = this._getTextWidth(line);
      return this.textArr.push({ text: line, width: width });
    },
    _getTextWidth: function(text) {
      var latterSpacing = this.getLetterSpacing();
      var length = text.length;
      return (
        getDummyContext().measureText(text).width +
        (length ? latterSpacing * (length - 1) : 0)
      );
    },
    _setTextData: function() {
      var lines = this.getText().split('\n'),
        fontSize = +this.getFontSize(),
        textWidth = 0,
        lineHeightPx = this.getLineHeight() * fontSize,
        width = this.attrs.width,
        height = this.attrs.height,
        fixedWidth = width !== AUTO,
        fixedHeight = height !== AUTO,
        padding = this.getPadding(),
        maxWidth = width - padding * 2,
        maxHeightPx = height - padding * 2,
        currentHeightPx = 0,
        wrap = this.getWrap(),
        shouldWrap = wrap !== NONE,
        wrapAtWord = wrap !== CHAR && shouldWrap,
        shouldAddEllipsis = this.getEllipsis() && !shouldWrap;

      this.textArr = [];
      getDummyContext().font = this._getContextFont();
      for (var i = 0, max = lines.length; i < max; ++i) {
        var line = lines[i];
        var additionalWidth = shouldAddEllipsis
          ? this._getTextWidth(ELLIPSIS)
          : 0;

        var lineWidth = this._getTextWidth(line);
        if (fixedWidth && lineWidth > maxWidth) {
          /*
          * if width is fixed and line does not fit entirely
          * break the line into multiple fitting lines
          */
          while (line.length > 0) {
            /*
            * use binary search to find the longest substring that
            * that would fit in the specified width
            */
            var low = 0,
              high = line.length,
              match = '',
              matchWidth = 0;
            while (low < high) {
              var mid = (low + high) >>> 1,
                substr = line.slice(0, mid + 1),
                substrWidth = this._getTextWidth(substr) + additionalWidth;
              if (substrWidth <= maxWidth) {
                low = mid + 1;
                match = substr + (shouldAddEllipsis ? ELLIPSIS : '');
                matchWidth = substrWidth;
              } else {
                high = mid;
              }
            }
            /*
            * 'low' is now the index of the substring end
            * 'match' is the substring
            * 'matchWidth' is the substring width in px
            */
            if (match) {
              // a fitting substring was found
              if (wrapAtWord) {
                // try to find a space or dash where wrapping could be done
                var wrapIndex;
                var nextChar = line[match.length];
                var nextIsSpaceOrDash = nextChar === SPACE || nextChar === DASH;
                if (nextIsSpaceOrDash && matchWidth <= maxWidth) {
                  wrapIndex = match.length;
                } else {
                  wrapIndex =
                    Math.max(
                      match.lastIndexOf(SPACE),
                      match.lastIndexOf(DASH)
                    ) + 1;
                }
                if (wrapIndex > 0) {
                  // re-cut the substring found at the space/dash position
                  low = wrapIndex;
                  match = match.slice(0, low);
                  matchWidth = this._getTextWidth(match);
                }
              }
              this._addTextLine(match);
              textWidth = Math.max(textWidth, matchWidth);
              currentHeightPx += lineHeightPx;
              if (
                !shouldWrap ||
                (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx)
              ) {
                /*
                * stop wrapping if wrapping is disabled or if adding
                * one more line would overflow the fixed height
                */
                break;
              }
              line = line.slice(low);
              if (line.length > 0) {
                // Check if the remaining text would fit on one line
                lineWidth = this._getTextWidth(line);
                if (lineWidth <= maxWidth) {
                  // if it does, add the line and break out of the loop
                  this._addTextLine(line);
                  currentHeightPx += lineHeightPx;
                  textWidth = Math.max(textWidth, lineWidth);
                  break;
                }
              }
            } else {
              // not even one character could fit in the element, abort
              break;
            }
          }
        } else {
          // element width is automatically adjusted to max line width
          this._addTextLine(line);
          currentHeightPx += lineHeightPx;
          textWidth = Math.max(textWidth, lineWidth);
        }
        // if element height is fixed, abort if adding one more line would overflow
        if (fixedHeight && currentHeightPx + lineHeightPx > maxHeightPx) {
          break;
        }
      }
      this.textHeight = fontSize;
      // var maxTextWidth = 0;
      // for(var j = 0; j < this.textArr.length; j++) {
      //     maxTextWidth = Math.max(maxTextWidth, this.textArr[j].width);
      // }
      this.textWidth = textWidth;
    }
  };
  Konva.Util.extend(Konva.Text, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Text, 'fontFamily', 'Arial');

  /**
   * get/set font family
   * @name fontFamily
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontFamily
   * @returns {String}
   * @example
   * // get font family
   * var fontFamily = text.fontFamily();
   *
   * // set font family
   * text.fontFamily('Arial');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontSize', 12);

  /**
   * get/set font size in pixels
   * @name fontSize
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} fontSize
   * @returns {Number}
   * @example
   * // get font size
   * var fontSize = text.fontSize();
   *
   * // set font size to 22px
   * text.fontSize(22);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontStyle', NORMAL);

  /**
   * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
   * @name fontStyle
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontStyle
   * @returns {String}
   * @example
   * // get font style
   * var fontStyle = text.fontStyle();
   *
   * // set font style
   * text.fontStyle('bold');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'fontVariant', NORMAL);

  /**
   * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
   * @name fontVariant
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} fontVariant
   * @returns {String}
   * @example
   * // get font variant
   * var fontVariant = text.fontVariant();
   *
   * // set font variant
   * text.fontVariant('small-caps');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'padding', 0);

  /**
   * set padding
   * @name padding
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} padding
   * @returns {Number}
   * @example
   * // get padding
   * var padding = text.padding();
   *
   * // set padding to 10 pixels
   * text.padding(10);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'align', LEFT);

  /**
   * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
   * @name align
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} align
   * @returns {String}
   * @example
   * // get text align
   * var align = text.align();
   *
   * // center text
   * text.align('center');
   *
   * // align text to right
   * text.align('right');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'lineHeight', 1);

  /**
   * get/set line height.  The default is 1.
   * @name lineHeight
   * @method
   * @memberof Konva.Text.prototype
   * @param {Number} lineHeight
   * @returns {Number}
   * @example
   * // get line height
   * var lineHeight = text.lineHeight();
   *
   * // set the line height
   * text.lineHeight(2);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'wrap', WORD);

  /**
   * get/set wrap.  Can be word, char, or none. Default is word.
   * @name wrap
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} wrap
   * @returns {String}
   * @example
   * // get wrap
   * var wrap = text.wrap();
   *
   * // set wrap
   * text.wrap('word');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'ellipsis', false);

  /**
   * get/set ellipsis.  Can be true or false. Default is false.
   * if Konva.Text config is set to wrap="none" and ellipsis=true, then it will add "..." to the end
   * @name ellipsis
   * @method
   * @memberof Konva.Text.prototype
   * @param {Boolean} ellipsis
   * @returns {Boolean}
   * @example
   * // get ellipsis
   * var ellipsis = text.ellipsis();
   *
   * // set ellipsis
   * text.ellipsis(true);
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'letterSpacing', 0);

  /**
   * set letter spacing property. Default value is 0.
   * @name letterSpacing
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} letterSpacing
   */

  Konva.Factory.addGetter(Konva.Text, 'text', EMPTY_STRING);
  Konva.Factory.addOverloadedGetterSetter(Konva.Text, 'text');

  /**
   * get/set text
   * @name getText
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} text
   * @returns {String}
   * @example
   * // get text
   * var text = text.text();
   *
   * // set text
   * text.text('Hello world!');
   */

  Konva.Factory.addGetterSetter(Konva.Text, 'textDecoration', EMPTY_STRING);

  /**
   * get/set text decoration of a text.  Possible values are 'underline', 'line-through' or combination of these values separated by space
   * @name textDecoration
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} textDecoration
   * @returns {String}
   * @example
   * // get text decoration
   * var textDecoration = text.textDecoration();
   *
   * // underline text
   * text.textDecoration('underline');
   *
   * // strike text
   * text.textDecoration('line-through');
   *
   * // underline and strike text
   * text.textDecoration('underline line-through');
   */

  Konva.Collection.mapMethods(Konva.Text);
})();

(function() {
  'use strict';
  /**
   * Line constructor.&nbsp; Lines are defined by an array of points and
   *  a tension
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].
   * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @param {Boolean} [config.closed] defines whether or not the line shape is closed, creating a polygon or blob
   * @param {Boolean} [config.bezier] if no tension is provided but bezier=true, we draw the line as a bezier using the passed points
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var line = new Konva.Line({
   *   x: 100,
   *   y: 50,
   *   points: [73, 70, 340, 23, 450, 60, 500, 20],
   *   stroke: 'red',
   *   tension: 1
   * });
   */
  Konva.Line = function(config) {
    this.___init(config);
  };

  Konva.Line.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Line';

      this.on(
        'pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva',
        function() {
          this._clearCache('tensionPoints');
        }
      );

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var points = this.getPoints(),
        length = points.length,
        tension = this.getTension(),
        closed = this.getClosed(),
        bezier = this.getBezier(),
        tp,
        len,
        n;

      if (!length) {
        return;
      }

      context.beginPath();
      context.moveTo(points[0], points[1]);

      // tension
      if (tension !== 0 && length > 4) {
        tp = this.getTensionPoints();
        len = tp.length;
        n = closed ? 0 : 4;

        if (!closed) {
          context.quadraticCurveTo(tp[0], tp[1], tp[2], tp[3]);
        }

        while (n < len - 2) {
          context.bezierCurveTo(
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++],
            tp[n++]
          );
        }

        if (!closed) {
          context.quadraticCurveTo(
            tp[len - 2],
            tp[len - 1],
            points[length - 2],
            points[length - 1]
          );
        }
      } else if (bezier) {
        // no tension but bezier
        n = 2;

        while (n < length) {
          context.bezierCurveTo(
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++],
            points[n++]
          );
        }
      } else {
        // no tension
        for (n = 2; n < length; n += 2) {
          context.lineTo(points[n], points[n + 1]);
        }
      }

      // closed e.g. polygons and blobs
      if (closed) {
        context.closePath();
        context.fillStrokeShape(this);
      } else {
        // open e.g. lines and splines
        context.strokeShape(this);
      }
    },
    getTensionPoints: function() {
      return this._getCache('tensionPoints', this._getTensionPoints);
    },
    _getTensionPoints: function() {
      if (this.getClosed()) {
        return this._getTensionPointsClosed();
      } else {
        return Konva.Util._expandPoints(this.getPoints(), this.getTension());
      }
    },
    _getTensionPointsClosed: function() {
      var p = this.getPoints(),
        len = p.length,
        tension = this.getTension(),
        util = Konva.Util,
        firstControlPoints = util._getControlPoints(
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          p[2],
          p[3],
          tension
        ),
        lastControlPoints = util._getControlPoints(
          p[len - 4],
          p[len - 3],
          p[len - 2],
          p[len - 1],
          p[0],
          p[1],
          tension
        ),
        middle = Konva.Util._expandPoints(p, tension),
        tp = [firstControlPoints[2], firstControlPoints[3]]
          .concat(middle)
          .concat([
            lastControlPoints[0],
            lastControlPoints[1],
            p[len - 2],
            p[len - 1],
            lastControlPoints[2],
            lastControlPoints[3],
            firstControlPoints[0],
            firstControlPoints[1],
            p[0],
            p[1]
          ]);

      return tp;
    },
    getWidth: function() {
      return this.getSelfRect().width;
    },
    getHeight: function() {
      return this.getSelfRect().height;
    },
    // overload size detection
    getSelfRect: function() {
      var points;
      if (this.getTension() !== 0) {
        points = this._getTensionPoints();
      } else {
        points = this.getPoints();
      }
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    }
  };
  Konva.Util.extend(Konva.Line, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Line, 'closed', false);

  /**
   * get/set closed flag.  The default is false
   * @name closed
   * @method
   * @memberof Konva.Line.prototype
   * @param {Boolean} closed
   * @returns {Boolean}
   * @example
   * // get closed flag
   * var closed = line.closed();
   *
   * // close the shape
   * line.closed(true);
   *
   * // open the shape
   * line.closed(false);
   */

  Konva.Factory.addGetterSetter(Konva.Line, 'bezier', false);

  /**
   * get/set bezier flag.  The default is false
   * @name bezier
   * @method
   * @memberof Konva.Line.prototype
   * @param {Boolean} bezier
   * @returns {Boolean}
   * @example
   * // get whether the line is a bezier
   * var isBezier = line.bezier();
   *
   * // set whether the line is a bezier
   * line.bezier(true);
   */

  Konva.Factory.addGetterSetter(Konva.Line, 'tension', 0);

  /**
   * get/set tension
   * @name tension
   * @method
   * @memberof Konva.Line.prototype
   * @param {Number} Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @returns {Number}
   * @example
   * // get tension
   * var tension = line.tension();
   *
   * // set tension
   * line.tension(3);
   */

  Konva.Factory.addGetterSetter(Konva.Line, 'points', []);
  /**
   * get/set points array
   * @name points
   * @method
   * @memberof Konva.Line.prototype
   * @param {Array} points
   * @returns {Array}
   * @example
   * // get points
   * var points = line.points();
   *
   * // set points
   * line.points([10, 20, 30, 40, 50, 60]);
   *
   * // push a new point
   * line.points(line.points().concat([70, 80]));
   */

  Konva.Collection.mapMethods(Konva.Line);
})();

(function() {
  'use strict';
  /**
     * Sprite constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {String} config.animation animation key
     * @param {Object} config.animations animation map
     * @param {Integer} [config.frameIndex] animation frame index
     * @param {Image} config.image image object
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var imageObj = new Image();
     * imageObj.onload = function() {
     *   var sprite = new Konva.Sprite({
     *     x: 200,
     *     y: 100,
     *     image: imageObj,
     *     animation: 'standing',
     *     animations: {
     *       standing: [
     *         // x, y, width, height (6 frames)
     *         0, 0, 49, 109,
     *         52, 0, 49, 109,
     *         105, 0, 49, 109,
     *         158, 0, 49, 109,
     *         210, 0, 49, 109,
     *         262, 0, 49, 109
     *       ],
     *       kicking: [
     *         // x, y, width, height (6 frames)
     *         0, 109, 45, 98,
     *         45, 109, 45, 98,
     *         95, 109, 63, 98,
     *         156, 109, 70, 98,
     *         229, 109, 60, 98,
     *         287, 109, 41, 98
     *       ]
     *     },
     *     frameRate: 7,
     *     frameIndex: 0
     *   });
     * };
     * imageObj.src = '/path/to/image.jpg'
     */
  Konva.Sprite = function(config) {
    this.___init(config);
  };

  Konva.Sprite.prototype = {
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Sprite';

      this._updated = true;
      var that = this;
      this.anim = new Konva.Animation(function() {
        // if we don't need to redraw layer we should return false
        var updated = that._updated;
        that._updated = false;
        return updated;
      });
      this.on('animationChange.konva', function() {
        // reset index when animation changes
        this.frameIndex(0);
      });
      this.on('frameIndexChange.konva', function() {
        this._updated = true;
      });
      // smooth change for frameRate
      this.on('frameRateChange.konva', function() {
        if (!this.anim.isRunning()) {
          return;
        }
        clearInterval(this.interval);
        this._setInterval();
      });

      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        x = set[ix4 + 0],
        y = set[ix4 + 1],
        width = set[ix4 + 2],
        height = set[ix4 + 3],
        image = this.getImage();

      if (this.hasFill() || this.hasStroke()) {
        context.beginPath();
        context.rect(0, 0, width, height);
        context.closePath();
        context.fillStrokeShape(this);
      }

      if (image) {
        if (offsets) {
          var offset = offsets[anim], ix2 = index * 2;
          context.drawImage(
            image,
            x,
            y,
            width,
            height,
            offset[ix2 + 0],
            offset[ix2 + 1],
            width,
            height
          );
        } else {
          context.drawImage(image, x, y, width, height, 0, 0, width, height);
        }
      }
    },
    _hitFunc: function(context) {
      var anim = this.getAnimation(),
        index = this.frameIndex(),
        ix4 = index * 4,
        set = this.getAnimations()[anim],
        offsets = this.frameOffsets(),
        width = set[ix4 + 2],
        height = set[ix4 + 3];

      context.beginPath();
      if (offsets) {
        var offset = offsets[anim];
        var ix2 = index * 2;
        context.rect(offset[ix2 + 0], offset[ix2 + 1], width, height);
      } else {
        context.rect(0, 0, width, height);
      }
      context.closePath();
      context.fillShape(this);
    },
    _useBufferCanvas: function() {
      return (
        (this.hasShadow() || this.getAbsoluteOpacity() !== 1) &&
        this.hasStroke()
      );
    },
    _setInterval: function() {
      var that = this;
      this.interval = setInterval(function() {
        that._updateIndex();
      }, 1000 / this.getFrameRate());
    },
    /**
         * start sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
    start: function() {
      var layer = this.getLayer();

      /*
             * animation object has no executable function because
             *  the updates are done with a fixed FPS with the setInterval
             *  below.  The anim object only needs the layer reference for
             *  redraw
             */
      this.anim.setLayers(layer);
      this._setInterval();
      this.anim.start();
    },
    /**
         * stop sprite animation
         * @method
         * @memberof Konva.Sprite.prototype
         */
    stop: function() {
      this.anim.stop();
      clearInterval(this.interval);
    },
    /**
         * determine if animation of sprite is running or not.  returns true or false
         * @method
         * @memberof Konva.Animation.prototype
         * @returns {Boolean}
         */
    isRunning: function() {
      return this.anim.isRunning();
    },
    _updateIndex: function() {
      var index = this.frameIndex(),
        animation = this.getAnimation(),
        animations = this.getAnimations(),
        anim = animations[animation],
        len = anim.length / 4;

      if (index < len - 1) {
        this.frameIndex(index + 1);
      } else {
        this.frameIndex(0);
      }
    }
  };
  Konva.Util.extend(Konva.Sprite, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Sprite, 'animation');

  /**
     * get/set animation key
     * @name animation
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {String} anim animation key
     * @returns {String}
     * @example
     * // get animation key
     * var animation = sprite.animation();
     *
     * // set animation key
     * sprite.animation('kicking');
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'animations');

  /**
     * get/set animations map
     * @name animations
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Object} animations
     * @returns {Object}
     * @example
     * // get animations map
     * var animations = sprite.animations();
     *
     * // set animations map
     * sprite.animations({
     *   standing: [
     *     // x, y, width, height (6 frames)
     *     0, 0, 49, 109,
     *     52, 0, 49, 109,
     *     105, 0, 49, 109,
     *     158, 0, 49, 109,
     *     210, 0, 49, 109,
     *     262, 0, 49, 109
     *   ],
     *   kicking: [
     *     // x, y, width, height (6 frames)
     *     0, 109, 45, 98,
     *     45, 109, 45, 98,
     *     95, 109, 63, 98,
     *     156, 109, 70, 98,
     *     229, 109, 60, 98,
     *     287, 109, 41, 98
     *   ]
     * });
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameOffsets');

  /**
    * get/set offsets map
    * @name offsets
    * @method
    * @memberof Konva.Sprite.prototype
    * @param {Object} offsets
    * @returns {Object}
    * @example
    * // get offsets map
    * var offsets = sprite.offsets();
    *
    * // set offsets map
    * sprite.offsets({
    *   standing: [
    *     // x, y (6 frames)
    *     0, 0,
    *     0, 0,
    *     5, 0,
    *     0, 0,
    *     0, 3,
    *     2, 0
    *   ],
    *   kicking: [
    *     // x, y (6 frames)
    *     0, 5,
    *     5, 0,
    *     10, 0,
    *     0, 0,
    *     2, 1,
    *     0, 0
    *   ]
    * });
    */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'image');

  /**
     * get/set image
     * @name image
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Image} image
     * @returns {Image}
     * @example
     * // get image
     * var image = sprite.image();
     *
     * // set image
     * sprite.image(imageObj);
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameIndex', 0);

  /**
     * set/set animation frame index
     * @name frameIndex
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameIndex
     * @returns {Integer}
     * @example
     * // get animation frame index
     * var frameIndex = sprite.frameIndex();
     *
     * // set animation frame index
     * sprite.frameIndex(3);
     */

  Konva.Factory.addGetterSetter(Konva.Sprite, 'frameRate', 17);

  /**
     * get/set frame rate in frames per second.  Increase this number to make the sprite
     *  animation run faster, and decrease the number to make the sprite animation run slower
     *  The default is 17 frames per second
     * @name frameRate
     * @method
     * @memberof Konva.Sprite.prototype
     * @param {Integer} frameRate
     * @returns {Integer}
     * @example
     * // get frame rate
     * var frameRate = sprite.frameRate();
     *
     * // set frame rate to 2 frames per second
     * sprite.frameRate(2);
     */

  Konva.Factory.backCompat(Konva.Sprite, {
    index: 'frameIndex',
    getIndex: 'getFrameIndex',
    setIndex: 'setFrameIndex'
  });

  Konva.Collection.mapMethods(Konva.Sprite);
})();

/*eslint-disable  no-shadow, max-len, max-depth */
(function() {
  'use strict';
  /**
   * Path constructor.
   * @author Jason Follas
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} config.data SVG data string
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var path = new Konva.Path({
   *   x: 240,
   *   y: 40,
   *   data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
   *   fill: 'green',
   *   scale: 2
   * });
   */
  Konva.Path = function(config) {
    this.___init(config);
  };

  Konva.Path.prototype = {
    ___init: function(config) {
      this.dataArray = [];
      var that = this;

      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Path';

      this.dataArray = Konva.Path.parsePathData(this.getData());
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.getData());
      });

      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var ca = this.dataArray;

      // context position
      context.beginPath();
      for (var n = 0; n < ca.length; n++) {
        var c = ca[n].command;
        var p = ca[n].points;
        switch (c) {
          case 'L':
            context.lineTo(p[0], p[1]);
            break;
          case 'M':
            context.moveTo(p[0], p[1]);
            break;
          case 'C':
            context.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
            break;
          case 'Q':
            context.quadraticCurveTo(p[0], p[1], p[2], p[3]);
            break;
          case 'A':
            var cx = p[0],
              cy = p[1],
              rx = p[2],
              ry = p[3],
              theta = p[4],
              dTheta = p[5],
              psi = p[6],
              fs = p[7];

            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;

            context.translate(cx, cy);
            context.rotate(psi);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-psi);
            context.translate(-cx, -cy);

            break;
          case 'z':
            context.closePath();
            break;
        }
      }

      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var points = [];
      this.dataArray.forEach(function(data) {
        points = points.concat(data.points);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[1];
      var maxY = points[1];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      return {
        x: Math.round(minX),
        y: Math.round(minY),
        width: Math.round(maxX - minX),
        height: Math.round(maxY - minY)
      };
    }
  };
  Konva.Util.extend(Konva.Path, Konva.Shape);

  Konva.Path.getLineLength = function(x1, y1, x2, y2) {
    return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  };
  Konva.Path.getPointOnLine = function(dist, P1x, P1y, P2x, P2y, fromX, fromY) {
    if (fromX === undefined) {
      fromX = P1x;
    }
    if (fromY === undefined) {
      fromY = P1y;
    }

    var m = (P2y - P1y) / (P2x - P1x + 0.00000001);
    var run = Math.sqrt(dist * dist / (1 + m * m));
    if (P2x < P1x) {
      run *= -1;
    }
    var rise = m * run;
    var pt;

    if (P2x === P1x) {
      // vertical line
      pt = {
        x: fromX,
        y: fromY + rise
      };
    } else if ((fromY - P1y) / (fromX - P1x + 0.00000001) === m) {
      pt = {
        x: fromX + run,
        y: fromY + rise
      };
    } else {
      var ix, iy;

      var len = this.getLineLength(P1x, P1y, P2x, P2y);
      if (len < 0.00000001) {
        return undefined;
      }
      var u = (fromX - P1x) * (P2x - P1x) + (fromY - P1y) * (P2y - P1y);
      u = u / (len * len);
      ix = P1x + u * (P2x - P1x);
      iy = P1y + u * (P2y - P1y);

      var pRise = this.getLineLength(fromX, fromY, ix, iy);
      var pRun = Math.sqrt(dist * dist - pRise * pRise);
      run = Math.sqrt(pRun * pRun / (1 + m * m));
      if (P2x < P1x) {
        run *= -1;
      }
      rise = m * run;
      pt = {
        x: ix + run,
        y: iy + rise
      };
    }

    return pt;
  };

  Konva.Path.getPointOnCubicBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y,
    P4x,
    P4y
  ) {
    function CB1(t) {
      return t * t * t;
    }
    function CB2(t) {
      return 3 * t * t * (1 - t);
    }
    function CB3(t) {
      return 3 * t * (1 - t) * (1 - t);
    }
    function CB4(t) {
      return (1 - t) * (1 - t) * (1 - t);
    }
    var x = P4x * CB1(pct) + P3x * CB2(pct) + P2x * CB3(pct) + P1x * CB4(pct);
    var y = P4y * CB1(pct) + P3y * CB2(pct) + P2y * CB3(pct) + P1y * CB4(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnQuadraticBezier = function(
    pct,
    P1x,
    P1y,
    P2x,
    P2y,
    P3x,
    P3y
  ) {
    function QB1(t) {
      return t * t;
    }
    function QB2(t) {
      return 2 * t * (1 - t);
    }
    function QB3(t) {
      return (1 - t) * (1 - t);
    }
    var x = P3x * QB1(pct) + P2x * QB2(pct) + P1x * QB3(pct);
    var y = P3y * QB1(pct) + P2y * QB2(pct) + P1y * QB3(pct);

    return {
      x: x,
      y: y
    };
  };
  Konva.Path.getPointOnEllipticalArc = function(cx, cy, rx, ry, theta, psi) {
    var cosPsi = Math.cos(psi),
      sinPsi = Math.sin(psi);
    var pt = {
      x: rx * Math.cos(theta),
      y: ry * Math.sin(theta)
    };
    return {
      x: cx + (pt.x * cosPsi - pt.y * sinPsi),
      y: cy + (pt.x * sinPsi + pt.y * cosPsi)
    };
  };
  /*
     * get parsed data array from the data
     *  string.  V, v, H, h, and l data are converted to
     *  L data for the purpose of high performance Path
     *  rendering
     */
  Konva.Path.parsePathData = function(data) {
    // Path Data Segment must begin with a moveTo
    //m (x y)+  Relative moveTo (subsequent points are treated as lineTo)
    //M (x y)+  Absolute moveTo (subsequent points are treated as lineTo)
    //l (x y)+  Relative lineTo
    //L (x y)+  Absolute LineTo
    //h (x)+    Relative horizontal lineTo
    //H (x)+    Absolute horizontal lineTo
    //v (y)+    Relative vertical lineTo
    //V (y)+    Absolute vertical lineTo
    //z (closepath)
    //Z (closepath)
    //c (x1 y1 x2 y2 x y)+ Relative Bezier curve
    //C (x1 y1 x2 y2 x y)+ Absolute Bezier curve
    //q (x1 y1 x y)+       Relative Quadratic Bezier
    //Q (x1 y1 x y)+       Absolute Quadratic Bezier
    //t (x y)+    Shorthand/Smooth Relative Quadratic Bezier
    //T (x y)+    Shorthand/Smooth Absolute Quadratic Bezier
    //s (x2 y2 x y)+       Shorthand/Smooth Relative Bezier curve
    //S (x2 y2 x y)+       Shorthand/Smooth Absolute Bezier curve
    //a (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+     Relative Elliptical Arc
    //A (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+  Absolute Elliptical Arc

    // return early if data is not defined
    if (!data) {
      return [];
    }

    // command string
    var cs = data;

    // command chars
    var cc = [
      'm',
      'M',
      'l',
      'L',
      'v',
      'V',
      'h',
      'H',
      'z',
      'Z',
      'c',
      'C',
      'q',
      'Q',
      't',
      'T',
      's',
      'S',
      'a',
      'A'
    ];
    // convert white spaces to commas
    cs = cs.replace(new RegExp(' ', 'g'), ',');
    // create pipes so that we can split the data
    for (var n = 0; n < cc.length; n++) {
      cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
    }
    // create array
    var arr = cs.split('|');
    var ca = [];
    var coords = [];
    // init context point
    var cpx = 0;
    var cpy = 0;

    var re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi;
    var match;
    for (n = 1; n < arr.length; n++) {
      var str = arr[n];
      var c = str.charAt(0);
      str = str.slice(1);

      coords.length = 0;
      while ((match = re.exec(str))) {
        coords.push(match[0]);
      }

      // while ((match = re.exec(str))) {
      //   coords.push(match[0]);
      // }
      var p = [];

      for (var j = 0, jlen = coords.length; j < jlen; j++) {
        var parsed = parseFloat(coords[j]);
        if (!isNaN(parsed)) {
          p.push(parsed);
        }
      }

      while (p.length > 0) {
        if (isNaN(p[0])) {
          // case for a trailing comma before next command
          break;
        }

        var cmd = null;
        var points = [];
        var startX = cpx,
          startY = cpy;
        // Move var from within the switch to up here (jshint)
        var prevCmd, ctlPtx, ctlPty; // Ss, Tt
        var rx, ry, psi, fa, fs, x1, y1; // Aa

        // convert l, H, h, V, and v to L
        switch (c) {
          // Note: Keep the lineTo's above the moveTo's in this switch
          case 'l':
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'L':
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          // Note: lineTo handlers need to be above this point
          case 'm':
            var dx = p.shift();
            var dy = p.shift();
            cpx += dx;
            cpy += dy;
            cmd = 'M';
            // After closing the path move the current position
            // to the the first point of the path (if any).
            if (ca.length > 2 && ca[ca.length - 1].command === 'z') {
              for (var idx = ca.length - 2; idx >= 0; idx--) {
                if (ca[idx].command === 'M') {
                  cpx = ca[idx].points[0] + dx;
                  cpy = ca[idx].points[1] + dy;
                  break;
                }
              }
            }
            points.push(cpx, cpy);
            c = 'l';
            // subsequent points are treated as relative lineTo
            break;
          case 'M':
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'M';
            points.push(cpx, cpy);
            c = 'L';
            // subsequent points are treated as absolute lineTo
            break;

          case 'h':
            cpx += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'H':
            cpx = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'v':
            cpy += p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'V':
            cpy = p.shift();
            cmd = 'L';
            points.push(cpx, cpy);
            break;
          case 'C':
            points.push(p.shift(), p.shift(), p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'c':
            points.push(
              cpx + p.shift(),
              cpy + p.shift(),
              cpx + p.shift(),
              cpy + p.shift()
            );
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'S':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 's':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'C') {
              ctlPtx = cpx + (cpx - prevCmd.points[2]);
              ctlPty = cpy + (cpy - prevCmd.points[3]);
            }
            points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'C';
            points.push(cpx, cpy);
            break;
          case 'Q':
            points.push(p.shift(), p.shift());
            cpx = p.shift();
            cpy = p.shift();
            points.push(cpx, cpy);
            break;
          case 'q':
            points.push(cpx + p.shift(), cpy + p.shift());
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(cpx, cpy);
            break;
          case 'T':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 't':
            ctlPtx = cpx;
            ctlPty = cpy;
            prevCmd = ca[ca.length - 1];
            if (prevCmd.command === 'Q') {
              ctlPtx = cpx + (cpx - prevCmd.points[0]);
              ctlPty = cpy + (cpy - prevCmd.points[1]);
            }
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'Q';
            points.push(ctlPtx, ctlPty, cpx, cpy);
            break;
          case 'A':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx = p.shift();
            cpy = p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
          case 'a':
            rx = p.shift();
            ry = p.shift();
            psi = p.shift();
            fa = p.shift();
            fs = p.shift();
            x1 = cpx;
            y1 = cpy;
            cpx += p.shift();
            cpy += p.shift();
            cmd = 'A';
            points = this.convertEndpointToCenterParameterization(
              x1,
              y1,
              cpx,
              cpy,
              fa,
              fs,
              rx,
              ry,
              psi
            );
            break;
        }

        ca.push({
          command: cmd || c,
          points: points,
          start: {
            x: startX,
            y: startY
          },
          pathLength: this.calcLength(startX, startY, cmd || c, points)
        });
      }

      if (c === 'z' || c === 'Z') {
        ca.push({
          command: 'z',
          points: [],
          start: undefined,
          pathLength: 0
        });
      }
    }

    return ca;
  };
  Konva.Path.calcLength = function(x, y, cmd, points) {
    var len, p1, p2, t;
    var path = Konva.Path;

    switch (cmd) {
      case 'L':
        return path.getLineLength(x, y, points[0], points[1]);
      case 'C':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnCubicBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3],
          points[4],
          points[5]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnCubicBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3],
            points[4],
            points[5]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'Q':
        // Approximates by breaking curve into 100 line segments
        len = 0.0;
        p1 = path.getPointOnQuadraticBezier(
          0,
          x,
          y,
          points[0],
          points[1],
          points[2],
          points[3]
        );
        for (t = 0.01; t <= 1; t += 0.01) {
          p2 = path.getPointOnQuadraticBezier(
            t,
            x,
            y,
            points[0],
            points[1],
            points[2],
            points[3]
          );
          len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
          p1 = p2;
        }
        return len;
      case 'A':
        // Approximates by breaking curve into line segments
        len = 0.0;
        var start = points[4];
        // 4 = theta
        var dTheta = points[5];
        // 5 = dTheta
        var end = points[4] + dTheta;
        var inc = Math.PI / 180.0;
        // 1 degree resolution
        if (Math.abs(start - end) < inc) {
          inc = Math.abs(start - end);
        }
        // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi
        p1 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          start,
          0
        );
        if (dTheta < 0) {
          // clockwise
          for (t = start - inc; t > end; t -= inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        } else {
          // counter-clockwise
          for (t = start + inc; t < end; t += inc) {
            p2 = path.getPointOnEllipticalArc(
              points[0],
              points[1],
              points[2],
              points[3],
              t,
              0
            );
            len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
        }
        p2 = path.getPointOnEllipticalArc(
          points[0],
          points[1],
          points[2],
          points[3],
          end,
          0
        );
        len += path.getLineLength(p1.x, p1.y, p2.x, p2.y);

        return len;
    }

    return 0;
  };
  Konva.Path.convertEndpointToCenterParameterization = function(
    x1,
    y1,
    x2,
    y2,
    fa,
    fs,
    rx,
    ry,
    psiDeg
  ) {
    // Derived from: http://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes
    var psi = psiDeg * (Math.PI / 180.0);
    var xp = Math.cos(psi) * (x1 - x2) / 2.0 + Math.sin(psi) * (y1 - y2) / 2.0;
    var yp =
      -1 * Math.sin(psi) * (x1 - x2) / 2.0 + Math.cos(psi) * (y1 - y2) / 2.0;

    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);

    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }

    var f = Math.sqrt(
      (rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) /
        (rx * rx * (yp * yp) + ry * ry * (xp * xp))
    );

    if (fa === fs) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }

    var cxp = f * rx * yp / ry;
    var cyp = f * -ry * xp / rx;

    var cx = (x1 + x2) / 2.0 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
    var cy = (y1 + y2) / 2.0 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;

    var vMag = function(v) {
      return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function(u, v) {
      return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function(u, v) {
      return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var dTheta = vAngle(u, v);

    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (fs === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (fs === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return [cx, cy, rx, ry, theta, dTheta, psi, fs];
  };
  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Path, 'data');

  /**
   * set SVG path data string.  This method
   *  also automatically parses the data string
   *  into a data array.  Currently supported SVG data:
   *  M, m, L, l, H, h, V, v, Q, q, T, t, C, c, S, s, A, a, Z, z
   * @name setData
   * @method
   * @memberof Konva.Path.prototype
   * @param {String} SVG path command string
   */

  /**
   * get SVG path data string
   * @name getData
   * @method
   * @memberof Konva.Path.prototype
   */

  Konva.Collection.mapMethods(Konva.Path);
})();

(function() {
  'use strict';
  var EMPTY_STRING = '',
    //CALIBRI = 'Calibri',
    NORMAL = 'normal';

  /**
   * Path constructor.
   * @author Jason Follas
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {String} [config.fontFamily] default is Calibri
   * @param {Number} [config.fontSize] default is 12
   * @param {String} [config.fontStyle] can be normal, bold, or italic.  Default is normal
   * @param {String} [config.fontVariant] can be normal or small-caps.  Default is normal
   * @param {String} config.text
   * @param {String} config.data SVG data string
   * @param {Function} config.getKerning a getter for kerning values for the specified characters
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var kerningPairs = {
   *   'A': {
   *     ' ': -0.05517578125,
   *     'T': -0.07421875,
   *     'V': -0.07421875,
   *   },
   *   'V': {
   *     ',': -0.091796875,
   *     ":": -0.037109375,
   *     ";": -0.037109375,
   *     "A": -0.07421875,
   *   }
   * }
   * var textpath = new Konva.TextPath({
   *   x: 100,
   *   y: 50,
   *   fill: '#333',
   *   fontSize: '24',
   *   fontFamily: 'Arial',
   *   text: 'All the world\'s a stage, and all the men and women merely players.',
   *   data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50',
   *   getKerning: function(leftChar, rightChar) {
   *     return kerningPairs.hasOwnProperty(leftChar) ? pairs[leftChar][rightChar] || 0 : 0
   *   }
   * });
   */
  Konva.TextPath = function(config) {
    this.___init(config);
  };

  function _fillFunc(context) {
    context.fillText(this.partialText, 0, 0);
  }
  function _strokeFunc(context) {
    context.strokeText(this.partialText, 0, 0);
  }

  Konva.TextPath.prototype = {
    ___init: function(config) {
      var that = this;
      this.dummyCanvas = Konva.Util.createCanvasElement();
      this.dataArray = [];
      this.getKerning = config && config.getKerning;

      // call super constructor
      Konva.Shape.call(this, config);

      // overrides
      // TODO: shouldn't this be on the prototype?
      this._fillFunc = _fillFunc;
      this._strokeFunc = _strokeFunc;
      this._fillFuncHit = _fillFunc;
      this._strokeFuncHit = _strokeFunc;

      this.className = 'TextPath';

      this.dataArray = Konva.Path.parsePathData(this.attrs.data);
      this.on('dataChange.konva', function() {
        that.dataArray = Konva.Path.parsePathData(this.attrs.data);
        that._setTextData();
      });

      // update text data for certain attr changes
      this.on(
        'textChange.konva alignChange.konva letterSpacingChange.konva',
        that._setTextData
      );
      that._setTextData();
      this.sceneFunc(this._sceneFunc);
      this.hitFunc(this._hitFunc);
    },
    _sceneFunc: function(context) {
      context.setAttr('font', this._getContextFont());
      context.setAttr('textBaseline', this.getTextBaseline());
      context.setAttr('textAlign', 'left');
      context.save();

      var textDecoration = this.textDecoration();
      var fill = this.fill();
      var fontSize = this.fontSize();

      var glyphInfo = this.glyphInfo;
      if (textDecoration === 'underline') {
        context.beginPath();
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        context.save();

        var p0 = glyphInfo[i].p0;

        context.translate(p0.x, p0.y);
        context.rotate(glyphInfo[i].rotation);
        this.partialText = glyphInfo[i].text;

        context.fillStrokeShape(this);
        if (textDecoration === 'underline') {
          if (i === 0) {
            context.moveTo(0, fontSize / 2 + 1);
          }

          context.lineTo(fontSize, fontSize / 2 + 1);
        }
        context.restore();

        //// To assist with debugging visually, uncomment following
        //
        // if (i % 2)
        // context.strokeStyle = 'cyan';
        // else
        // context.strokeStyle = 'green';
        // var p1 = glyphInfo[i].p1;
        // context.moveTo(p0.x, p0.y);
        // context.lineTo(p1.x, p1.y);
        // context.stroke();
      }
      if (textDecoration === 'underline') {
        context.strokeStyle = fill;
        context.lineWidth = fontSize / 20;
        context.stroke();
      }

      context.restore();
    },
    _hitFunc: function(context) {
      context.beginPath();

      var glyphInfo = this.glyphInfo;
      if (glyphInfo.length >= 1) {
        var p0 = glyphInfo[0].p0;
        context.moveTo(p0.x, p0.y);
      }
      for (var i = 0; i < glyphInfo.length; i++) {
        var p1 = glyphInfo[i].p1;
        context.lineTo(p1.x, p1.y);
      }
      context.setAttr('lineWidth', this.getFontSize());
      context.setAttr('strokeStyle', this.colorKey);
      context.stroke();
    },
    /**
     * get text width in pixels
     * @method
     * @memberof Konva.TextPath.prototype
     */
    getTextWidth: function() {
      return this.textWidth;
    },
    /**
     * get text height in pixels
     * @method
     * @memberof Konva.TextPath.prototype
     */
    getTextHeight: function() {
      return this.textHeight;
    },
    /**
     * set text
     * @method
     * @memberof Konva.TextPath.prototype
     * @param {String} text
     */
    setText: function(text) {
      Konva.Text.prototype.setText.call(this, text);
    },
    _getTextSize: function(text) {
      var dummyCanvas = this.dummyCanvas;
      var _context = dummyCanvas.getContext('2d');

      _context.save();

      _context.font = this._getContextFont();
      var metrics = _context.measureText(text);

      _context.restore();

      return {
        width: metrics.width,
        height: parseInt(this.attrs.fontSize, 10)
      };
    },
    _setTextData: function() {
      var that = this;
      var size = this._getTextSize(this.attrs.text);
      var letterSpacing = this.getLetterSpacing();
      var align = this.align();

      this.textWidth = size.width;
      this.textHeight = size.height;

      var textFullWidth = Math.max(
        this.textWidth + ((this.attrs.text || '').length - 1) * letterSpacing,
        0
      );

      this.glyphInfo = [];

      var fullPathWidth = 0;
      for (var l = 0; l < that.dataArray.length; l++) {
        if (that.dataArray[l].pathLength > 0) {
          fullPathWidth += that.dataArray[l].pathLength;
        }
      }

      var offset = 0;
      if (align === 'center') {
        offset = Math.max(0, fullPathWidth / 2 - textFullWidth / 2);
      }
      if (align === 'right') {
        offset = Math.max(0, fullPathWidth - textFullWidth);
      }

      var charArr = this.getText().split('');
      var spacesNumber = this.getText().split(' ').length - 1;

      var p0, p1, pathCmd;

      var pIndex = -1;
      var currentT = 0;
      // var sumLength = 0;
      // for(var j = 0; j < that.dataArray.length; j++) {
      //   if(that.dataArray[j].pathLength > 0) {
      //
      //     if (sumLength + that.dataArray[j].pathLength > offset) {}
      //       fullPathWidth += that.dataArray[j].pathLength;
      //   }
      // }

      var getNextPathSegment = function() {
        currentT = 0;
        var pathData = that.dataArray;

        for (var j = pIndex + 1; j < pathData.length; j++) {
          if (pathData[j].pathLength > 0) {
            pIndex = j;

            return pathData[j];
          } else if (pathData[j].command === 'M') {
            p0 = {
              x: pathData[j].points[0],
              y: pathData[j].points[1]
            };
          }
        }

        return {};
      };

      var findSegmentToFitCharacter = function(c) {
        var glyphWidth = that._getTextSize(c).width + letterSpacing;

        if (c === ' ' && align === 'justify') {
          glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
        }

        var currLen = 0;
        var attempts = 0;

        p1 = undefined;
        while (
          Math.abs(glyphWidth - currLen) / glyphWidth > 0.01 &&
          attempts < 25
        ) {
          attempts++;
          var cumulativePathLength = currLen;
          while (pathCmd === undefined) {
            pathCmd = getNextPathSegment();

            if (
              pathCmd &&
              cumulativePathLength + pathCmd.pathLength < glyphWidth
            ) {
              cumulativePathLength += pathCmd.pathLength;
              pathCmd = undefined;
            }
          }

          if (pathCmd === {} || p0 === undefined) {
            return undefined;
          }

          var needNewSegment = false;

          switch (pathCmd.command) {
            case 'L':
              if (
                Konva.Path.getLineLength(
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1]
                ) > glyphWidth
              ) {
                p1 = Konva.Path.getPointOnLine(
                  glyphWidth,
                  p0.x,
                  p0.y,
                  pathCmd.points[0],
                  pathCmd.points[1],
                  p0.x,
                  p0.y
                );
              } else {
                pathCmd = undefined;
              }
              break;
            case 'A':
              var start = pathCmd.points[4];
              // 4 = theta
              var dTheta = pathCmd.points[5];
              // 5 = dTheta
              var end = pathCmd.points[4] + dTheta;

              if (currentT === 0) {
                currentT = start + 0.00000001;
              } else if (glyphWidth > currLen) {
                // Just in case start is 0
                currentT += Math.PI / 180.0 * dTheta / Math.abs(dTheta);
              } else {
                currentT -= Math.PI / 360.0 * dTheta / Math.abs(dTheta);
              }

              // Credit for bug fix: @therth https://github.com/ericdrowell/KonvaJS/issues/249
              // Old code failed to render text along arc of this path: "M 50 50 a 150 50 0 0 1 250 50 l 50 0"
              if (
                (dTheta < 0 && currentT < end) ||
                (dTheta >= 0 && currentT > end)
              ) {
                currentT = end;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnEllipticalArc(
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                currentT,
                pathCmd.points[6]
              );
              break;
            case 'C':
              if (currentT === 0) {
                if (glyphWidth > pathCmd.pathLength) {
                  currentT = 0.00000001;
                } else {
                  currentT = glyphWidth / pathCmd.pathLength;
                }
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnCubicBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3],
                pathCmd.points[4],
                pathCmd.points[5]
              );
              break;
            case 'Q':
              if (currentT === 0) {
                currentT = glyphWidth / pathCmd.pathLength;
              } else if (glyphWidth > currLen) {
                currentT += (glyphWidth - currLen) / pathCmd.pathLength;
              } else {
                currentT -= (currLen - glyphWidth) / pathCmd.pathLength;
              }

              if (currentT > 1.0) {
                currentT = 1.0;
                needNewSegment = true;
              }
              p1 = Konva.Path.getPointOnQuadraticBezier(
                currentT,
                pathCmd.start.x,
                pathCmd.start.y,
                pathCmd.points[0],
                pathCmd.points[1],
                pathCmd.points[2],
                pathCmd.points[3]
              );
              break;
          }

          if (p1 !== undefined) {
            currLen = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);
          }

          if (needNewSegment) {
            needNewSegment = false;
            pathCmd = undefined;
          }
        }
      };

      // fake search for offset, this is very bad approach
      // TODO: find other way to add offset from start (for align)
      var testChar = 'C';
      var glyphWidth = that._getTextSize(testChar).width + letterSpacing;
      for (var k = 0; k < offset / glyphWidth; k++) {
        findSegmentToFitCharacter(testChar);
        if (p0 === undefined || p1 === undefined) {
          break;
        }
        p0 = p1;
      }

      for (var i = 0; i < charArr.length; i++) {
        // Find p1 such that line segment between p0 and p1 is approx. width of glyph
        findSegmentToFitCharacter(charArr[i]);

        if (p0 === undefined || p1 === undefined) {
          break;
        }

        var width = Konva.Path.getLineLength(p0.x, p0.y, p1.x, p1.y);

        var kern = 0;
        if (this.getKerning) {
          try {
            // getKerning is a user provided getter. Make sure it never breaks our logic
            kern =
              this.getKerning(charArr[i - 1], charArr[i]) * this.fontSize();
          } catch (e) {
            kern = 0;
          }
        }

        p0.x += kern;
        p1.x += kern;
        this.textWidth += kern;

        var midpoint = Konva.Path.getPointOnLine(
          kern + width / 2.0,
          p0.x,
          p0.y,
          p1.x,
          p1.y
        );

        var rotation = Math.atan2(p1.y - p0.y, p1.x - p0.x);
        this.glyphInfo.push({
          transposeX: midpoint.x,
          transposeY: midpoint.y,
          text: charArr[i],
          rotation: rotation,
          p0: p0,
          p1: p1
        });
        p0 = p1;
      }
    },
    getSelfRect: function() {
      var points = [];

      this.glyphInfo.forEach(function(info) {
        points.push(info.p0.x);
        points.push(info.p0.y);
        points.push(info.p1.x);
        points.push(info.p1.y);
      });
      var minX = points[0];
      var maxX = points[0];
      var minY = points[0];
      var maxY = points[0];
      var x, y;
      for (var i = 0; i < points.length / 2; i++) {
        x = points[i * 2];
        y = points[i * 2 + 1];
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      }
      var fontSize = this.fontSize();
      return {
        x: Math.round(minX) - fontSize / 2,
        y: Math.round(minY) - fontSize / 2,
        width: Math.round(maxX - minX) + fontSize,
        height: Math.round(maxY - minY) + fontSize
      };
    }
  };

  // map TextPath methods to Text
  Konva.TextPath.prototype._getContextFont =
    Konva.Text.prototype._getContextFont;

  Konva.Util.extend(Konva.TextPath, Konva.Shape);

  // add setters and getters
  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontFamily', 'Arial');

  /**
   * set font family
   * @name setFontFamily
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontFamily
   */

  /**
   * get font family
   * @name getFontFamily
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontSize', 12);

  /**
   * set font size
   * @name setFontSize
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {int} fontSize
   */

  /**
   * get font size
   * @name getFontSize
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontStyle', NORMAL);

  /**
   * set font style.  Can be 'normal', 'italic', or 'bold'.  'normal' is the default.
   * @name setFontStyle
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontStyle
   */
  Konva.Factory.addGetterSetter(Konva.TextPath, 'align', 'left');

  /**
   * get/set horizontal align of text.  Can be 'left', 'center', 'right' or 'justify'
   * @name align
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} align
   * @returns {String}
   * @example
   * // get text align
   * var align = text.align();
   *
   * // center text
   * text.align('center');
   *
   * // align text to right
   * text.align('right');
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'letterSpacing', 0);

  /**
   * set letter spacing property. Default value is 0.
   * @name letterSpacing
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} letterSpacing
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textBaseline', 'middle');

  /**
   * set textBaseline property. Default value is 'middle'.
   * Can be 'top', 'bottom', 'middle', 'alphabetic', 'hanging'
   * @name textBaseline
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {Number} textBaseline
   */

  /**
   * get font style
   * @name getFontStyle
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'fontVariant', NORMAL);

  /**
   * set font variant.  Can be 'normal' or 'small-caps'.  'normal' is the default.
   * @name setFontVariant
   * @method
   * @memberof Konva.TextPath.prototype
   * @param {String} fontVariant
   */

  /**
   * @get font variant
   * @name getFontVariant
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetter(Konva.TextPath, 'text', EMPTY_STRING);

  /**
   * get text
   * @name getText
   * @method
   * @memberof Konva.TextPath.prototype
   */

  Konva.Factory.addGetterSetter(Konva.TextPath, 'textDecoration', null);

  /**
   * get/set text decoration of a text.  Can be '' or 'underline'
   * @name textDecoration
   * @method
   * @memberof Konva.Text.prototype
   * @param {String} textDecoration
   * @returns {String}
   * @example
   * // get text decoration
   * var textDecoration = text.textDecoration();
   *
   * // center text
   * text.textDecoration('underline');
   */

  Konva.Collection.mapMethods(Konva.TextPath);
})();

(function() {
  'use strict';
  /**
     * RegularPolygon constructor.&nbsp; Examples include triangles, squares, pentagons, hexagons, etc.
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Number} config.sides
     * @param {Number} config.radius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var hexagon = new Konva.RegularPolygon({
     *   x: 100,
     *   y: 200,
     *   sides: 6,
     *   radius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
  Konva.RegularPolygon = function(config) {
    this.___init(config);
  };

  Konva.RegularPolygon.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'RegularPolygon';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var sides = this.attrs.sides, radius = this.attrs.radius, n, x, y;

      context.beginPath();
      context.moveTo(0, 0 - radius);

      for (n = 1; n < sides; n++) {
        x = radius * Math.sin(n * 2 * Math.PI / sides);
        y = -1 * radius * Math.cos(n * 2 * Math.PI / sides);
        context.lineTo(x, y);
      }
      context.closePath();
      context.fillStrokeShape(this);
    },
    getWidth: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.radius() !== width / 2) {
        this.setRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.radius() !== height / 2) {
        this.setRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.RegularPolygon, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'radius', 0);

  /**
     * set radius
     * @name setRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {Number} radius
     */

  /**
     * get radius
     * @name getRadius
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

  Konva.Factory.addGetterSetter(Konva.RegularPolygon, 'sides', 0);

  /**
     * set number of sides
     * @name setSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     * @param {int} sides
     */

  /**
     * get number of sides
     * @name getSides
     * @method
     * @memberof Konva.RegularPolygon.prototype
     */

  Konva.Collection.mapMethods(Konva.RegularPolygon);
})();

(function() {
  'use strict';
  /**
     * Star constructor
     * @constructor
     * @memberof Konva
     * @augments Konva.Shape
     * @param {Object} config
     * @param {Integer} config.numPoints
     * @param {Number} config.innerRadius
     * @param {Number} config.outerRadius
     * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * var star = new Konva.Star({
     *   x: 100,
     *   y: 200,
     *   numPoints: 5,
     *   innerRadius: 70,
     *   outerRadius: 70,
     *   fill: 'red',
     *   stroke: 'black',
     *   strokeWidth: 4
     * });
     */
  Konva.Star = function(config) {
    this.___init(config);
  };

  Konva.Star.prototype = {
    _centroid: true,
    ___init: function(config) {
      // call super constructor
      Konva.Shape.call(this, config);
      this.className = 'Star';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var innerRadius = this.innerRadius(),
        outerRadius = this.outerRadius(),
        numPoints = this.numPoints();

      context.beginPath();
      context.moveTo(0, 0 - outerRadius);

      for (var n = 1; n < numPoints * 2; n++) {
        var radius = n % 2 === 0 ? outerRadius : innerRadius;
        var x = radius * Math.sin(n * Math.PI / numPoints);
        var y = -1 * radius * Math.cos(n * Math.PI / numPoints);
        context.lineTo(x, y);
      }
      context.closePath();

      context.fillStrokeShape(this);
    },
    // implements Shape.prototype.getWidth()
    getWidth: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.getHeight()
    getHeight: function() {
      return this.getOuterRadius() * 2;
    },
    // implements Shape.prototype.setWidth()
    setWidth: function(width) {
      Konva.Node.prototype.setWidth.call(this, width);
      if (this.outerRadius() !== width / 2) {
        this.setOuterRadius(width / 2);
      }
    },
    // implements Shape.prototype.setHeight()
    setHeight: function(height) {
      Konva.Node.prototype.setHeight.call(this, height);
      if (this.outerRadius() !== height / 2) {
        this.setOuterRadius(height / 2);
      }
    }
  };
  Konva.Util.extend(Konva.Star, Konva.Shape);

  // add getters setters
  Konva.Factory.addGetterSetter(Konva.Star, 'numPoints', 5);

  /**
     * set number of points
     * @name setNumPoints
     * @method
     * @memberof Konva.Star.prototype
     * @param {Integer} points
     */

  /**
     * get number of points
     * @name getNumPoints
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Star, 'innerRadius', 0);

  /**
     * set inner radius
     * @name setInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

  /**
     * get inner radius
     * @name getInnerRadius
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Star, 'outerRadius', 0);

  /**
     * set outer radius
     * @name setOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     * @param {Number} radius
     */

  /**
     * get outer radius
     * @name getOuterRadius
     * @method
     * @memberof Konva.Star.prototype
     */

  Konva.Collection.mapMethods(Konva.Star);
})();

(function() {
  'use strict';
  // constants
  var ATTR_CHANGE_LIST = [
    'fontFamily',
    'fontSize',
    'fontStyle',
    'padding',
    'lineHeight',
    'text',
    'width'
  ],
    CHANGE_KONVA = 'Change.konva',
    NONE = 'none',
    UP = 'up',
    RIGHT = 'right',
    DOWN = 'down',
    LEFT = 'left',
    LABEL = 'Label',
    // cached variables
    attrChangeListLen = ATTR_CHANGE_LIST.length;

  /**
     * Label constructor.&nbsp; Labels are groups that contain a Text and Tag shape
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
     * @example
     * // create label
     * var label = new Konva.Label({
     *   x: 100,
     *   y: 100,
     *   draggable: true
     * });
     *
     * // add a tag to the label
     * label.add(new Konva.Tag({
     *   fill: '#bbb',
     *   stroke: '#333',
     *   shadowColor: 'black',
     *   shadowBlur: 10,
     *   shadowOffset: [10, 10],
     *   shadowOpacity: 0.2,
     *   lineJoin: 'round',
     *   pointerDirection: 'up',
     *   pointerWidth: 20,
     *   pointerHeight: 20,
     *   cornerRadius: 5
     * }));
     *
     * // add text to the label
     * label.add(new Konva.Text({
     *   text: 'Hello World!',
     *   fontSize: 50,
     *   lineHeight: 1.2,
     *   padding: 10,
     *   fill: 'green'
     *  }));
     */
  Konva.Label = function(config) {
    this.____init(config);
  };

  Konva.Label.prototype = {
    ____init: function(config) {
      var that = this;

      Konva.Group.call(this, config);
      this.className = LABEL;

      this.on('add.konva', function(evt) {
        that._addListeners(evt.child);
        that._sync();
      });
    },
    /**
         * get Text shape for the label.  You need to access the Text shape in order to update
         * the text properties
         * @name getText
         * @method
         * @memberof Konva.Label.prototype
         */
    getText: function() {
      return this.find('Text')[0];
    },
    /**
         * get Tag shape for the label.  You need to access the Tag shape in order to update
         * the pointer properties and the corner radius
         * @name getTag
         * @method
         * @memberof Konva.Label.prototype
         */
    getTag: function() {
      return this.find('Tag')[0];
    },
    _addListeners: function(text) {
      var that = this, n;
      var func = function() {
        that._sync();
      };

      // update text data for certain attr changes
      for (n = 0; n < attrChangeListLen; n++) {
        text.on(ATTR_CHANGE_LIST[n] + CHANGE_KONVA, func);
      }
    },
    getWidth: function() {
      return this.getText().getWidth();
    },
    getHeight: function() {
      return this.getText().getHeight();
    },
    _sync: function() {
      var text = this.getText(),
        tag = this.getTag(),
        width,
        height,
        pointerDirection,
        pointerWidth,
        x,
        y,
        pointerHeight;

      if (text && tag) {
        width = text.getWidth();
        height = text.getHeight();
        pointerDirection = tag.getPointerDirection();
        pointerWidth = tag.getPointerWidth();
        pointerHeight = tag.getPointerHeight();
        x = 0;
        y = 0;

        switch (pointerDirection) {
          case UP:
            x = width / 2;
            y = -1 * pointerHeight;
            break;
          case RIGHT:
            x = width + pointerWidth;
            y = height / 2;
            break;
          case DOWN:
            x = width / 2;
            y = height + pointerHeight;
            break;
          case LEFT:
            x = -1 * pointerWidth;
            y = height / 2;
            break;
        }

        tag.setAttrs({
          x: -1 * x,
          y: -1 * y,
          width: width,
          height: height
        });

        text.setAttrs({
          x: -1 * x,
          y: -1 * y
        });
      }
    }
  };

  Konva.Util.extend(Konva.Label, Konva.Group);

  Konva.Collection.mapMethods(Konva.Label);

  /**
     * Tag constructor.&nbsp; A Tag can be configured
     *  to have a pointer element that points up, right, down, or left
     * @constructor
     * @memberof Konva
     * @param {Object} config
     * @param {String} [config.pointerDirection] can be up, right, down, left, or none; the default
     *  is none.  When a pointer is present, the positioning of the label is relative to the tip of the pointer.
     * @param {Number} [config.pointerWidth]
     * @param {Number} [config.pointerHeight]
     * @param {Number} [config.cornerRadius]
     */
  Konva.Tag = function(config) {
    this.___init(config);
  };

  Konva.Tag.prototype = {
    ___init: function(config) {
      Konva.Shape.call(this, config);
      this.className = 'Tag';
      this.sceneFunc(this._sceneFunc);
    },
    _sceneFunc: function(context) {
      var width = this.getWidth(),
        height = this.getHeight(),
        pointerDirection = this.getPointerDirection(),
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        cornerRadius = Math.min(this.getCornerRadius(), width / 2, height / 2);

      context.beginPath();
      if (!cornerRadius) {
        context.moveTo(0, 0);
      } else {
        context.moveTo(cornerRadius, 0);
      }

      if (pointerDirection === UP) {
        context.lineTo((width - pointerWidth) / 2, 0);
        context.lineTo(width / 2, -1 * pointerHeight);
        context.lineTo((width + pointerWidth) / 2, 0);
      }

      if (!cornerRadius) {
        context.lineTo(width, 0);
      } else {
        context.lineTo(width - cornerRadius, 0);
        context.arc(
          width - cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI * 3 / 2,
          0,
          false
        );
      }

      if (pointerDirection === RIGHT) {
        context.lineTo(width, (height - pointerHeight) / 2);
        context.lineTo(width + pointerWidth, height / 2);
        context.lineTo(width, (height + pointerHeight) / 2);
      }

      if (!cornerRadius) {
        context.lineTo(width, height);
      } else {
        context.lineTo(width, height - cornerRadius);
        context.arc(
          width - cornerRadius,
          height - cornerRadius,
          cornerRadius,
          0,
          Math.PI / 2,
          false
        );
      }

      if (pointerDirection === DOWN) {
        context.lineTo((width + pointerWidth) / 2, height);
        context.lineTo(width / 2, height + pointerHeight);
        context.lineTo((width - pointerWidth) / 2, height);
      }

      if (!cornerRadius) {
        context.lineTo(0, height);
      } else {
        context.lineTo(cornerRadius, height);
        context.arc(
          cornerRadius,
          height - cornerRadius,
          cornerRadius,
          Math.PI / 2,
          Math.PI,
          false
        );
      }

      if (pointerDirection === LEFT) {
        context.lineTo(0, (height + pointerHeight) / 2);
        context.lineTo(-1 * pointerWidth, height / 2);
        context.lineTo(0, (height - pointerHeight) / 2);
      }

      if (cornerRadius) {
        context.lineTo(0, cornerRadius);
        context.arc(
          cornerRadius,
          cornerRadius,
          cornerRadius,
          Math.PI,
          Math.PI * 3 / 2,
          false
        );
      }

      context.closePath();
      context.fillStrokeShape(this);
    },
    getSelfRect: function() {
      var x = 0,
        y = 0,
        pointerWidth = this.getPointerWidth(),
        pointerHeight = this.getPointerHeight(),
        direction = this.pointerDirection(),
        width = this.getWidth(),
        height = this.getHeight();

      if (direction === UP) {
        y -= pointerHeight;
        height += pointerHeight;
      } else if (direction === DOWN) {
        height += pointerHeight;
      } else if (direction === LEFT) {
        // ARGH!!! I have no idea why should I used magic 1.5!!!!!!!!!
        x -= pointerWidth * 1.5;
        width += pointerWidth;
      } else if (direction === RIGHT) {
        width += pointerWidth * 1.5;
      }
      return {
        x: x,
        y: y,
        width: width,
        height: height
      };
    }
  };

  Konva.Util.extend(Konva.Tag, Konva.Shape);
  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerDirection', NONE);

  /**
     * set pointer Direction
     * @name setPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     * @param {String} pointerDirection can be up, right, down, left, or none.  The
     *  default is none
     */

  /**
     * get pointer Direction
     * @name getPointerDirection
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerWidth', 0);

  /**
     * set pointer width
     * @name setPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerWidth
     */

  /**
     * get pointer width
     * @name getPointerWidth
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'pointerHeight', 0);

  /**
     * set pointer height
     * @name setPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} pointerHeight
     */

  /**
     * get pointer height
     * @name getPointerHeight
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Factory.addGetterSetter(Konva.Tag, 'cornerRadius', 0);

  /**
     * set corner radius
     * @name setCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     * @param {Number} corner radius
     */

  /**
     * get corner radius
     * @name getCornerRadius
     * @method
     * @memberof Konva.Tag.prototype
     */

  Konva.Collection.mapMethods(Konva.Tag);
})();

(function(Konva) {
  'use strict';
  /**
   * Arrow constructor
   * @constructor
   * @memberof Konva
   * @augments Konva.Shape
   * @param {Object} config
   * @param {Array} config.points Flat array of points coordinates. You should define them as [x1, y1, x2, y2, x3, y3].
   * @param {Number} [config.tension] Higher values will result in a more curvy line.  A value of 0 will result in no interpolation.
   *   The default is 0
   * @param {Number} config.pointerLength Arrow pointer length. Default value is 10.
   * @param {Number} config.pointerWidth Arrow pointer width. Default value is 10.
   * @param {Boolean} config.pointerAtBeginning Do we need to draw pointer on both sides?. Default false.
   * @param {String} [config.fill] fill color
     * @param {Image} [config.fillPatternImage] fill pattern image
     * @param {Number} [config.fillPatternX]
     * @param {Number} [config.fillPatternY]
     * @param {Object} [config.fillPatternOffset] object with x and y component
     * @param {Number} [config.fillPatternOffsetX] 
     * @param {Number} [config.fillPatternOffsetY] 
     * @param {Object} [config.fillPatternScale] object with x and y component
     * @param {Number} [config.fillPatternScaleX]
     * @param {Number} [config.fillPatternScaleY]
     * @param {Number} [config.fillPatternRotation]
     * @param {String} [config.fillPatternRepeat] can be "repeat", "repeat-x", "repeat-y", or "no-repeat".  The default is "no-repeat"
     * @param {Object} [config.fillLinearGradientStartPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientStartPointX]
     * @param {Number} [config.fillLinearGradientStartPointY]
     * @param {Object} [config.fillLinearGradientEndPoint] object with x and y component
     * @param {Number} [config.fillLinearGradientEndPointX]
     * @param {Number} [config.fillLinearGradientEndPointY]
     * @param {Array} [config.fillLinearGradientColorStops] array of color stops
     * @param {Object} [config.fillRadialGradientStartPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientStartPointX]
     * @param {Number} [config.fillRadialGradientStartPointY]
     * @param {Object} [config.fillRadialGradientEndPoint] object with x and y component
     * @param {Number} [config.fillRadialGradientEndPointX] 
     * @param {Number} [config.fillRadialGradientEndPointY] 
     * @param {Number} [config.fillRadialGradientStartRadius]
     * @param {Number} [config.fillRadialGradientEndRadius]
     * @param {Array} [config.fillRadialGradientColorStops] array of color stops
     * @param {Boolean} [config.fillEnabled] flag which enables or disables the fill.  The default value is true
     * @param {String} [config.fillPriority] can be color, linear-gradient, radial-graident, or pattern.  The default value is color.  The fillPriority property makes it really easy to toggle between different fill types.  For example, if you want to toggle between a fill color style and a fill pattern style, simply set the fill property and the fillPattern properties, and then use setFillPriority('color') to render the shape with a color fill, or use setFillPriority('pattern') to render the shape with the pattern fill configuration
     * @param {String} [config.stroke] stroke color
     * @param {Number} [config.strokeWidth] stroke width
     * @param {Boolean} [config.strokeHitEnabled] flag which enables or disables stroke hit region.  The default is true
     * @param {Boolean} [config.perfectDrawEnabled] flag which enables or disables using buffer canvas.  The default is true
     * @param {Boolean} [config.shadowForStrokeEnabled] flag which enables or disables shasow for stroke.  The default is true
     * @param {Boolean} [config.strokeScaleEnabled] flag which enables or disables stroke scale.  The default is true
     * @param {Boolean} [config.strokeEnabled] flag which enables or disables the stroke.  The default value is true
     * @param {String} [config.lineJoin] can be miter, round, or bevel.  The default
     *  is miter
     * @param {String} [config.lineCap] can be butt, round, or sqare.  The default
     *  is butt
     * @param {String} [config.shadowColor]
     * @param {Number} [config.shadowBlur]
     * @param {Object} [config.shadowOffset] object with x and y component
     * @param {Number} [config.shadowOffsetX]
     * @param {Number} [config.shadowOffsetY]
     * @param {Number} [config.shadowOpacity] shadow opacity.  Can be any real number
     *  between 0 and 1
     * @param {Boolean} [config.shadowEnabled] flag which enables or disables the shadow.  The default value is true
     * @param {Array} [config.dash]
     * @param {Boolean} [config.dashEnabled] flag which enables or disables the dashArray.  The default value is true
   * @param {Number} [config.x]
     * @param {Number} [config.y]
     * @param {Number} [config.width]
     * @param {Number} [config.height]
     * @param {Boolean} [config.visible]
     * @param {Boolean} [config.listening] whether or not the node is listening for events
     * @param {String} [config.id] unique id
     * @param {String} [config.name] non-unique name
     * @param {Number} [config.opacity] determines node opacity.  Can be any number between 0 and 1
     * @param {Object} [config.scale] set scale
     * @param {Number} [config.scaleX] set scale x
     * @param {Number} [config.scaleY] set scale y
     * @param {Number} [config.rotation] rotation in degrees
     * @param {Object} [config.offset] offset from center point and rotation point
     * @param {Number} [config.offsetX] set offset x
     * @param {Number} [config.offsetY] set offset y
     * @param {Boolean} [config.draggable] makes the node draggable.  When stages are draggable, you can drag and drop
     *  the entire stage by dragging any portion of the stage
     * @param {Number} [config.dragDistance]
     * @param {Function} [config.dragBoundFunc]
   * @example
   * var line = new Konva.Line({
   *   points: [73, 70, 340, 23, 450, 60, 500, 20],
   *   stroke: 'red',
   *   tension: 1,
   *   pointerLength : 10,
   *   pointerWidth : 12
   * });
   */
  Konva.Arrow = function(config) {
    this.____init(config);
  };

  Konva.Arrow.prototype = {
    ____init: function(config) {
      // call super constructor
      Konva.Line.call(this, config);
      this.className = 'Arrow';
    },
    _sceneFunc: function(ctx) {
      Konva.Line.prototype._sceneFunc.apply(this, arguments);
      var PI2 = Math.PI * 2;
      var points = this.points();

      var tp = points;
      var fromTension = this.getTension() !== 0 && points.length > 4;
      if (fromTension) {
        tp = this.getTensionPoints();
      }

      var n = points.length;

      var dx, dy;
      if (fromTension) {
        dx = points[n - 2] - tp[n - 2];
        dy = points[n - 1] - tp[n - 1];
      } else {
        dx = points[n - 2] - points[n - 4];
        dy = points[n - 1] - points[n - 3];
      }

      var radians = (Math.atan2(dy, dx) + PI2) % PI2;
      var length = this.pointerLength();
      var width = this.pointerWidth();

      ctx.save();
      ctx.beginPath();
      ctx.translate(points[n - 2], points[n - 1]);
      ctx.rotate(radians);
      ctx.moveTo(0, 0);
      ctx.lineTo(-length, width / 2);
      ctx.lineTo(-length, -width / 2);
      ctx.closePath();
      ctx.restore();

      if (this.pointerAtBeginning()) {
        ctx.save();
        ctx.translate(points[0], points[1]);
        if (fromTension) {
          dx = tp[0] - points[0];
          dy = tp[1] - points[1];
        } else {
          dx = points[2] - points[0];
          dy = points[3] - points[1];
        }

        ctx.rotate((Math.atan2(-dy, -dx) + PI2) % PI2);
        ctx.moveTo(0, 0);
        ctx.lineTo(-length, width / 2);
        ctx.lineTo(-length, -width / 2);
        ctx.closePath();
        ctx.restore();
      }

      // here is a tricky part
      // we need to disable dash for arrow pointers
      var isDashEnabled = this.dashEnabled();
      if (isDashEnabled) {
        // manually disable dash for head
        // it is better not to use setter here,
        // because it will trigger attr change event
        this.attrs.dashEnabled = false;
        ctx.setLineDash([]);
      }

      ctx.fillStrokeShape(this);

      // restore old value
      if (isDashEnabled) {
        this.attrs.dashEnabled = true;
      }
    }
  };

  Konva.Util.extend(Konva.Arrow, Konva.Line);
  /**
   * get/set pointerLength
   * @name pointerLength
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Length of pointer of arrow.
   *   The default is 10.
   * @returns {Number}
   * @example
   * // get tension
   * var pointerLength = line.pointerLength();
   *
   * // set tension
   * line.pointerLength(15);
   */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerLength', 10);
  /**
   * get/set pointerWidth
   * @name pointerWidth
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Width of pointer of arrow.
   *   The default is 10.
   * @returns {Number}
   * @example
   * // get tension
   * var pointerWidth = line.pointerWidth();
   *
   * // set tension
   * line.pointerWidth(15);
   */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerWidth', 10);
  /**
   * get/set pointerAtBeginning
   * @name pointerAtBeginning
   * @method
   * @memberof Konva.Arrow.prototype
   * @param {Number} Should pointer displayed at beginning of arrow.
   *   The default is false.
   * @returns {Boolean}
   * @example
   * // get tension
   * var pointerAtBeginning = line.pointerAtBeginning();
   *
   * // set tension
   * line.pointerAtBeginning(true);
   */

  Konva.Factory.addGetterSetter(Konva.Arrow, 'pointerAtBeginning', false);
  Konva.Collection.mapMethods(Konva.Arrow);
})(Konva);

(function(Konva) {
  'use strict';

  var ATTR_CHANGE_LIST = [
    'resizeEnabledChange',
    'rotateHandlerOffsetChange'
  ].join(' ');

  var NODE_RECT = 'nodeRect';

  var TRANSFORM_CHANGE_STR = [
    'xChange.resizer',
    'yChange.resizer',
    'widthChange.resizer',
    'heightChange.resizer',
    'scaleXChange.resizer',
    'scaleYChange.resizer',
    'skewXChange.resizer',
    'skewYChange.resizer',
    'rotationChange.resizer',
    'offsetXChange.resizer',
    'offsetYChange.resizer',
    'transformsEnabledChange.resizer'
  ].join(' ');

  var REDRAW_CHANGE_STR = [
    'widthChange.resizer',
    'heightChange.resizer',
    'scaleXChange.resizer',
    'scaleYChange.resizer',
    'skewXChange.resizer',
    'skewYChange.resizer',
    'rotationChange.resizer',
    'offsetXChange.resizer',
    'offsetYChange.resizer'
  ].join(' ');

  var ANGLES = {
    'top-left': -45,
    'top-center': 0,
    'top-right': 45,
    'middle-right': -90,
    'middle-left': 90,
    'bottom-left': -135,
    'bottom-center': 180,
    'bottom-right': 135
  };

  function getCursor(anchorName, rad) {
    if (anchorName === 'rotater') {
      return 'crosshair';
    }

    rad += Konva.Util._degToRad(ANGLES[anchorName] || 0);
    var angle = (Konva.Util._radToDeg(rad) % 360 + 360) % 360;

    if (
      Konva.Util._inRange(angle, 315 + 22.5, 360) ||
      Konva.Util._inRange(angle, 0, 22.5)
    ) {
      // TOP
      return 'ns-resize';
    } else if (Konva.Util._inRange(angle, 45 - 22.5, 45 + 22.5)) {
      // TOP - RIGHT
      return 'nesw-resize';
    } else if (Konva.Util._inRange(angle, 90 - 22.5, 90 + 22.5)) {
      // RIGHT
      return 'ew-resize';
    } else if (Konva.Util._inRange(angle, 135 - 22.5, 135 + 22.5)) {
      // BOTTOM - RIGHT
      return 'nwse-resize';
    } else if (Konva.Util._inRange(angle, 180 - 22.5, 180 + 22.5)) {
      // BOTTOM
      return 'ns-resize';
    } else if (Konva.Util._inRange(angle, 225 - 22.5, 225 + 22.5)) {
      // BOTTOM - LEFT
      return 'nesw-resize';
    } else if (Konva.Util._inRange(angle, 270 - 22.5, 270 + 22.5)) {
      // RIGHT
      return 'ew-resize';
    } else if (Konva.Util._inRange(angle, 315 - 22.5, 315 + 22.5)) {
      // BOTTOM - RIGHT
      return 'nwse-resize';
    } else {
      // how can we can there?
      // TODO: throw error
      Konva.Util.error(
        'Transformer has unknown angle for cursor detection: ' + angle
      );
      return 'pointer';
    }
  }

  /**
   * Transformer constructor.  Transformer is a special type of group that allow you transform Konva
   * primitives and shapes.
   * @constructor
   * @memberof Konva
   * @param {Object} config
   * @param {Boolean} [config.resizeEnabled] Default is true
   * @param {Boolean} [config.rotateEnabled] Default is true
   * @param {Array} [config.rotationSnaps] Array of angles for rotation snaps. Default is []
   * @param {Number} [config.rotateHandlerOffset] Default is 50
   * @param {Number} [config.padding] Default is 0
   * @param {Number} [config.lineEnabled] Should we draw border? Default is true
   * @param {Boolean} [config.keepRatio] Should we keep ratio when we are moving edges? Default is true
   * @param {Array} [config.enabledHandlers] Array of names of enabled handles
   * @example
   * var transformer = new Konva.Transformer({
   *   node: rectangle,
   *   rotateHandlerOffset: 60,
   *   enabledHandlers: ['top-left', 'top-right', 'bottom-left', 'bottom-right']
   * });
   * layer.add(transformer);
   */

  Konva.Transformer = function(config) {
    this.____init(config);
  };

  var RESIZERS_NAMES = [
    'top-left',
    'top-center',
    'top-right',
    'middle-right',
    'middle-left',
    'bottom-left',
    'bottom-center',
    'bottom-right'
  ];

  var warningShowed = false;

  Konva.Transformer.prototype = {
    _centroid: false,
    ____init: function(config) {
      // call super constructor
      Konva.Group.call(this, config);
      this.className = 'Transformer';
      this._createElements();

      // bindings
      this._handleMouseMove = this._handleMouseMove.bind(this);
      this._handleMouseUp = this._handleMouseUp.bind(this);
      this.update = this.update.bind(this);

      // update transformer data for certain attr changes
      this.on(ATTR_CHANGE_LIST, this.update);

      if (!warningShowed) {
        Konva.Util.warn(
          'Konva.Transformer is currently experimental and may have bugs. Please report any issues to GitHub repo.'
        );
        warningShowed = true;
      }

      if (this.getNode()) {
        this.update();
      }
    },

    attachTo: function(node) {
      this.setNode(node);
    },

    /**
     * attach transformer to a Konva.Node. Transformer will adapt it its size and listed events
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Konva.Transformer}
     * @example
     * transformer.attachTo(shape);
     */
    setNode: function(node) {
      if (this._node) {
        this.detach();
      }
      this._node = node;
      this._clearCache(NODE_RECT);

      node.on(TRANSFORM_CHANGE_STR, this._resetTransformCache.bind(this));
      node.on(
        REDRAW_CHANGE_STR,
        function() {
          if (!this._transforming) {
            this.update();
          }
        }.bind(this)
      );

      // TODO: why do we need this?
      var elementsCreated = !!this.findOne('.top-left');
      if (elementsCreated) {
        this.update();
      }
      return this;
    },

    getNode: function() {
      return this._node;
    },

    /**
     * detach transformer from a attached node
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Konva.Transformer}
     * @example
     * transformer.detach();
     */
    detach: function() {
      if (this.getNode()) {
        this.getNode().off('.resizer');
        this._node = undefined;
      }
      this._resetTransformCache();
    },

    _resetTransformCache: function() {
      this._clearCache(NODE_RECT);
      this._clearCache('transform');
      this._clearSelfAndDescendantCache('absoluteTransform');
    },

    _getNodeRect: function() {
      return this._getCache(NODE_RECT, this.__getNodeRect);
    },

    __getNodeRect: function() {
      var node = this.getNode();
      if (!node) {
        return {
          x: -Number.MAX_SAFE_INTEGER,
          y: -Number.MAX_SAFE_INTEGER,
          width: 0,
          height: 0,
          rotation: 0
        };
      }
      var rect = node.getClientRect({ skipTransform: true });
      var rotation = Konva.getAngle(node.rotation());

      var dx = rect.x * node.scaleX() - node.offsetX() * node.scaleX();
      var dy = rect.y * node.scaleY() - node.offsetY() * node.scaleY();

      return {
        x: node.x() + dx * Math.cos(rotation) + dy * Math.sin(-rotation),
        y: node.y() + dy * Math.cos(rotation) + dx * Math.sin(rotation),
        width: rect.width * node.scaleX(),
        height: rect.height * node.scaleY(),
        rotation: node.rotation()
      };
    },

    getX: function() {
      return this._getNodeRect().x;
    },

    getY: function() {
      return this._getNodeRect().y;
    },

    getRotation: function() {
      return this._getNodeRect().rotation;
    },

    getWidth: function() {
      return this._getNodeRect().width;
    },

    getHeight: function() {
      return this._getNodeRect().height;
    },

    _createElements: function() {
      this._createBack();

      RESIZERS_NAMES.forEach(
        function(name) {
          this._createAnchor(name);
        }.bind(this)
      );

      this._createAnchor('rotater');
    },

    _createAnchor: function(name) {
      var anchor = new Konva.Rect({
        stroke: 'rgb(0, 161, 255)',
        fill: 'white',
        strokeWidth: 1,
        name: name,
        width: 10,
        height: 10,
        offsetX: 5,
        offsetY: 5,
        dragDistance: 0
      });
      var self = this;
      anchor.on('mousedown touchstart', function(e) {
        self._handleMouseDown(e);
      });

      // add hover styling
      anchor.on('mouseenter', function() {
        var layer = this.getLayer();
        var tr = this.getParent();

        // TODO: I guess there are some ways to simplify that calculations
        // the basic idea is to find "angle" of handler
        var rad = Konva.getAngle(tr.rotation());

        // var cdx = tr.getWidth() / 2;
        // var cdy = tr.getHeight() / 2;

        // var parentPos = tr.getAbsolutePosition(tr.getParent());
        // var center = {
        //   x: parentPos.x + (cdx * Math.cos(rad) + cdy * Math.sin(-rad)),
        //   y: parentPos.y + (cdy * Math.cos(rad) + cdx * Math.sin(rad))
        // };

        // var pos = this.getAbsolutePosition(tr.getParent());

        // var dx = -pos.x + center.x;
        // var dy = -pos.y + center.y;

        // var angle = -Math.atan2(-dy, dx) - Math.PI / 2;

        var cursor = getCursor(name, rad);
        anchor.getStage().content.style.cursor = cursor;
        layer.batchDraw();
      });
      anchor.on('mouseout', function() {
        var layer = this.getLayer();
        if (!layer) {
          return;
        }
        anchor.getStage().content.style.cursor = '';
        layer.batchDraw();
      });
      this.add(anchor);
    },

    _createBack: function() {
      var back = new Konva.Shape({
        stroke: 'rgb(0, 161, 255)',
        name: 'back',
        width: 0,
        height: 0,
        listening: false,
        sceneFunc: function(ctx) {
          var tr = this.getParent();
          var padding = tr.getPadding();
          ctx.beginPath();
          ctx.rect(
            -padding,
            -padding,
            this.width() + padding * 2,
            this.height() + padding * 2
          );
          ctx.moveTo(this.width() / 2, -padding);
          if (tr.rotateEnabled()) {
            ctx.lineTo(
              this.width() / 2,
              -tr.rotateHandlerOffset() * Konva.Util._sign(this.height())
            );
          }

          ctx.fillStrokeShape(this);
        }
      });
      this.add(back);
    },

    _handleMouseDown: function(e) {
      this.movingResizer = e.target.name();

      // var node = this.getNode();
      var attrs = this._getNodeRect();
      var width = attrs.width;
      var height = attrs.height;
      var hypotenuse = Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2));
      this.sin = height / hypotenuse;
      this.cos = width / hypotenuse;

      window.addEventListener('mousemove', this._handleMouseMove);
      window.addEventListener('touchmove', this._handleMouseMove);
      window.addEventListener('mouseup', this._handleMouseUp, true);
      window.addEventListener('touchend', this._handleMouseUp, true);

      this._transforming = true;

      this.fire('transformstart');
      this.getNode().fire('transformstart');
    },

    _handleMouseMove: function(e) {
      var x, y, newHypotenuse;
      var resizerNode = this.findOne('.' + this.movingResizer);
      var stage = resizerNode.getStage();

      var box = stage.getContent().getBoundingClientRect();
      var zeroPoint = {
        x: box.left,
        y: box.top
      };
      var pointerPos = {
        left: e.clientX !== undefined ? e.clientX : e.touches[0].clientX,
        top: e.clientX !== undefined ? e.clientY : e.touches[0].clientY
      };
      var newAbsPos = {
        x: pointerPos.left - zeroPoint.x,
        y: pointerPos.top - zeroPoint.y
      };

      resizerNode.setAbsolutePosition(newAbsPos);

      var keepProportion = this.keepRatio() || e.shiftKey;

      if (this.movingResizer === 'top-left') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-right').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.bottom-right').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.top-left').x(this.findOne('.bottom-right').x() - x);
          this.findOne('.top-left').y(this.findOne('.bottom-right').y() - y);
        }
      } else if (this.movingResizer === 'top-center') {
        this.findOne('.top-left').y(resizerNode.y());
      } else if (this.movingResizer === 'top-right') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-left').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.bottom-left').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.top-right').x(x);
          this.findOne('.top-right').y(this.findOne('.bottom-left').y() - y);
        }
        var pos = resizerNode.position();

        this.findOne('.top-left').y(pos.y);
        this.findOne('.bottom-right').x(pos.x);
      } else if (this.movingResizer === 'middle-left') {
        this.findOne('.top-left').x(resizerNode.x());
      } else if (this.movingResizer === 'middle-right') {
        this.findOne('.bottom-right').x(resizerNode.x());
      } else if (this.movingResizer === 'bottom-left') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.top-right').x() - resizerNode.x(), 2) +
              Math.pow(this.findOne('.top-right').y() - resizerNode.y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.bottom-left').x(this.findOne('.top-right').x() - x);
          this.findOne('.bottom-left').y(y);
        }

        pos = resizerNode.position();

        this.findOne('.top-left').x(pos.x);
        this.findOne('.bottom-right').y(pos.y);
      } else if (this.movingResizer === 'bottom-center') {
        this.findOne('.bottom-right').y(resizerNode.y());
      } else if (this.movingResizer === 'bottom-right') {
        if (keepProportion) {
          newHypotenuse = Math.sqrt(
            Math.pow(this.findOne('.bottom-right').x(), 2) +
              Math.pow(this.findOne('.bottom-right').y(), 2)
          );

          x = newHypotenuse * this.cos;
          y = newHypotenuse * this.sin;

          this.findOne('.bottom-right').x(x);
          this.findOne('.bottom-right').y(y);
        }
      } else if (this.movingResizer === 'rotater') {
        var padding = this.getPadding();
        var attrs = this._getNodeRect();
        x = resizerNode.x() - attrs.width / 2;
        y = -resizerNode.y() + attrs.height / 2;

        var dAlpha = Math.atan2(-y, x) + Math.PI / 2;

        if (attrs.height < 0) {
          dAlpha -= Math.PI;
        }

        var rot = Konva.getAngle(this.rotation());

        var newRotation =
          Konva.Util._radToDeg(rot) + Konva.Util._radToDeg(dAlpha);

        var alpha = Konva.getAngle(this.getNode().rotation());
        var newAlpha = Konva.Util._degToRad(newRotation);

        var snaps = this.rotationSnaps();
        var offset = 0.1;
        for (var i = 0; i < snaps.length; i++) {
          var angle = Konva.getAngle(snaps[i]);

          var dif =
            Math.abs(angle - Konva.Util._degToRad(newRotation)) % (Math.PI * 2);

          if (dif < offset) {
            newRotation = Konva.Util._radToDeg(angle);
            newAlpha = Konva.Util._degToRad(newRotation);
          }
        }

        var dx = padding;
        var dy = padding;

        this._fitNodeInto({
          rotation: Konva.angleDeg
            ? newRotation
            : Konva.Util._degToRad(newRotation),
          x:
            attrs.x +
            (attrs.width / 2 + padding) *
              (Math.cos(alpha) - Math.cos(newAlpha)) +
            (attrs.height / 2 + padding) *
              (Math.sin(-alpha) - Math.sin(-newAlpha)) -
            (dx * Math.cos(rot) + dy * Math.sin(-rot)),
          y:
            attrs.y +
            (attrs.height / 2 + padding) *
              (Math.cos(alpha) - Math.cos(newAlpha)) +
            (attrs.width / 2 + padding) *
              (Math.sin(alpha) - Math.sin(newAlpha)) -
            (dy * Math.cos(rot) + dx * Math.sin(rot)),
          width: attrs.width + padding * 2,
          height: attrs.height + padding * 2
        });
      } else {
        console.error(
          new Error(
            'Wrong position argument of selection resizer: ',
            this.movingResizer
          )
        );
      }

      if (this.movingResizer === 'rotater') {
        return;
      }

      var absPos = this.findOne('.top-left').getAbsolutePosition(
        this.getParent()
      );

      x = absPos.x;
      y = absPos.y;
      var width =
        this.findOne('.bottom-right').x() - this.findOne('.top-left').x();

      var height =
        this.findOne('.bottom-right').y() - this.findOne('.top-left').y();

      this._fitNodeInto({
        x: x + this.offsetX(),
        y: y + this.offsetY(),
        width: width,
        height: height
      });
    },

    _handleMouseUp: function() {
      this._removeEvents();
    },

    _removeEvents: function() {
      if (this._transforming) {
        this._transforming = false;
        window.removeEventListener('mousemove', this._handleMouseMove);
        window.removeEventListener('touchmove', this._handleMouseMove);
        window.removeEventListener('mouseup', this._handleMouseUp, true);
        window.removeEventListener('touchend', this._handleMouseUp, true);
        this.fire('transformend');
        this.getNode().fire('transformend');
      }
    },

    _fitNodeInto: function(newAttrs) {
      // waring! in this attrs padding may be included
      var boundBoxFunc = this.getBoundBoxFunc();
      if (boundBoxFunc) {
        var oldAttrs = this._getNodeRect();
        newAttrs = boundBoxFunc.call(this, oldAttrs, newAttrs);
      }
      this._settings = true;
      var node = this.getNode();
      if (newAttrs.rotation !== undefined) {
        this.getNode().rotation(newAttrs.rotation);
      }
      var pure = node.getClientRect({ skipTransform: true });
      var padding = this.getPadding();
      var scaleX = (newAttrs.width - padding * 2) / pure.width;
      var scaleY = (newAttrs.height - padding * 2) / pure.height;

      var rotation = Konva.getAngle(node.getRotation());
      var dx = pure.x * scaleX - padding - node.offsetX() * scaleX;
      var dy = pure.y * scaleY - padding - node.offsetY() * scaleY;

      this.getNode().setAttrs({
        scaleX: scaleX,
        scaleY: scaleY,
        x: newAttrs.x - (dx * Math.cos(rotation) + dy * Math.sin(-rotation)),
        y: newAttrs.y - (dy * Math.cos(rotation) + dx * Math.sin(rotation))
      });
      this._settings = false;

      this.fire('transform');
      this.getNode().fire('transform');
      this.update();
      this.getLayer().batchDraw();
    },
    /**
     * force update of Konva.Transformer.
     * Use it when you updated attached Konva.Group and now you need to reset transformer size
     * @method
     * @memberof Konva.Transformer.prototype
     */
    forceUpdate: function() {
      this._resetTransformCache();
      this.update();
    },
    update: function() {
      var attrs = this._getNodeRect();
      var width = attrs.width;
      var height = attrs.height;

      var enabledHandlers = this.enabledHandlers();
      var resizeEnabled = this.resizeEnabled();
      var padding = this.getPadding();

      this.findOne('.top-left').setAttrs({
        x: -padding,
        y: -padding,
        visible: resizeEnabled && enabledHandlers.indexOf('top-left') >= 0
      });
      this.findOne('.top-center').setAttrs({
        x: width / 2,
        y: -padding,
        visible: resizeEnabled && enabledHandlers.indexOf('top-center') >= 0
      });
      this.findOne('.top-right').setAttrs({
        x: width + padding,
        y: -padding,
        visible: resizeEnabled && enabledHandlers.indexOf('top-right') >= 0
      });
      this.findOne('.middle-left').setAttrs({
        x: -padding,
        y: height / 2,
        visible: resizeEnabled && enabledHandlers.indexOf('middle-left') >= 0
      });
      this.findOne('.middle-right').setAttrs({
        x: width + padding,
        y: height / 2,
        visible: resizeEnabled && enabledHandlers.indexOf('middle-right') >= 0
      });
      this.findOne('.bottom-left').setAttrs({
        x: -padding,
        y: height + padding,
        visible: resizeEnabled && enabledHandlers.indexOf('bottom-left') >= 0
      });
      this.findOne('.bottom-center').setAttrs({
        x: width / 2,
        y: height + padding,
        visible: resizeEnabled && enabledHandlers.indexOf('bottom-center') >= 0
      });
      this.findOne('.bottom-right').setAttrs({
        x: width + padding,
        y: height + padding,
        visible: resizeEnabled && enabledHandlers.indexOf('bottom-right') >= 0
      });

      this.findOne('.rotater').setAttrs({
        x: width / 2,
        y: -this.rotateHandlerOffset() * Konva.Util._sign(height),
        visible: this.rotateEnabled()
      });

      this.findOne('.back').setAttrs({
        width: width,
        height: height,
        visible: this.lineEnabled()
      });
    },
    /**
     * determine if transformer is in active transform
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Boolean}
     */
    isTransforming: function() {
      return this._transforming;
    },
    /**
     * Stop active transform action
     * @method
     * @memberof Konva.Transformer.prototype
     * @returns {Boolean}
     */
    stopTransform: function() {
      if (this._transforming) {
        this._removeEvents();
      }
    },
    destroy: function() {
      Konva.Group.prototype.destroy.call(this);
      this.detach();
      this._removeEvents();
    },
    // do not work as a container
    // we will recreate inner nodes manually
    toObject: function() {
      return Konva.Node.prototype.toObject.call(this);
    }
  };
  Konva.Util.extend(Konva.Transformer, Konva.Group);

  function validateResizers(val) {
    if (!(val instanceof Array)) {
      Konva.Util.warn('enabledHandlers value should be an array');
    }
    if (val instanceof Array) {
      val.forEach(function(name) {
        if (RESIZERS_NAMES.indexOf(name) === -1) {
          Konva.Util.warn(
            'Unknown resizer name: ' +
              name +
              '. Available names are: ' +
              RESIZERS_NAMES.join(', ')
          );
        }
      });
    }
    return val || [];
  }

  /**
   * get/set enabled handlers
   * @name enabledHandlers
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get list of handlers
   * var enabledHandlers = shape.enabledHandlers();
   *
   * // set handlers
   * shape.enabledHandlers(['top-left', 'top-center', 'top-right', 'middle-right', 'middle-left', 'bottom-left', 'bottom-center', 'bottom-right']);
   */
  Konva.Factory.addGetterSetter(
    Konva.Transformer,
    'enabledHandlers',
    RESIZERS_NAMES,
    validateResizers
  );

  /**
   * get/set resize ability. If false it will automatically hide resizing handlers
   * @name resizeEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var resizeEnabled = shape.resizeEnabled();
   *
   * // set
   * shape.resizeEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'resizeEnabled', true);

  /**
   * get/set ability to rotate.
   * @name rotateEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var rotateEnabled = shape.rotateEnabled();
   *
   * // set
   * shape.rotateEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'rotateEnabled', true);

  /**
   * get/set rotation snaps angles.
   * @name rotationSnaps
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var rotationSnaps = shape.rotationSnaps();
   *
   * // set
   * shape.rotationSnaps([0, 90, 180, 270]);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'rotationSnaps', []);

  /**
   * get/set distance for rotation handler
   * @name rotateHandlerOffset
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var rotateHandlerOffset = shape.rotateHandlerOffset();
   *
   * // set
   * shape.rotateHandlerOffset(100);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'rotateHandlerOffset', 50);

  /**
   * get/set visibility of border
   * @name lineEnabled
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var lineEnabled = shape.lineEnabled();
   *
   * // set
   * shape.lineEnabled(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'lineEnabled', true);

  /**
   * get/set should we keep ration of resize?
   * @name keepRatio
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var keepRatio = shape.keepRatio();
   *
   * // set
   * shape.keepRatio(false);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'keepRatio', true);

  /**
   * get/set padding
   * @name padding
   * @method
   * @memberof Konva.Transformer.prototype
   * @param {Array} array
   * @returns {Array}
   * @example
   * // get
   * var padding = shape.padding();
   *
   * // set
   * shape.padding(10);
   */
  Konva.Factory.addGetterSetter(Konva.Transformer, 'padding', 0);

  Konva.Factory.addOverloadedGetterSetter(Konva.Transformer, 'node');

  Konva.Factory.addGetterSetter(Konva.Transformer, 'boundBoxFunc');

  Konva.Collection.mapMethods(Konva.Transformer);
})(Konva);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],2:[function(require,module,exports){
class Edge {
    /**
     * Add edge to source and target.
     * @param {SseqClass} source
     * @param {SseqClass} target
     */
    constructor(source, target){
        this.source = source;
        this.target = target;
        this.page = infinity;
        this.page_min = 0;
        this.color = "#000";
    }

    /**
     * Determine whether the edge is drawn on the given page. Overridden in subclasses.
     * @param page
     * @returns {boolean}
     * @package
     */
    _drawOnPageQ(page){
        return page <= this.page && this.page_min <= page;
    }
}
exports.Edge = Edge;


/**
 * The structline class is just a renamed version of Edge. So far no methods here...
 */
class Structline extends Edge {
    constructor(source, target){
        super(source, target);
        source._addStructline(this);
        target._addStructline(this);
    }

}
exports.Structline = Structline;

/**
 * Only difference between a vanilla edge and an Extension is that Extensions are only drawn on the Einfty page.
 */
class Extension extends Edge {
    _drawOnPageQ(page){
        return page === infinity;
    }
}
exports.Extension = Extension;


/**
 * Differentials are a bit more complicated.
 */
class Differential extends Edge {
    constructor(source, target, page){
        super(source, target);
        this.page = page;
        this.color = "#00F";
        source._addOutgoingDifferential(this);
        target._addIncomingDifferential(this);
        this.source_name = this.source.toString();
        this.target_name = this.target.toString();
    }

    /**
     * Draw the differential on "page 0" or on the page corresponding to the differential.
     * @param page
     * @returns {boolean}
     * @package
     */
    _drawOnPageQ(page){
        return page === 0 || this.page === page;
    }

    /**
     * By default, source of differential disappears after the page the differential occurs on. Instead, from now on
     * display the source using `node`.
     * @param {Node} node Specifies any changes in the display of source that occur after this page.
     * @returns {Differential} Chainable
     */
    setKernel(node){
        this.source.replace(node);
        return this;
    }

    /**
     * Synonym for setKernel.
     * @param {Node} node
     * @returns {Differential} Chainable
     */
    replaceSource(node){
        this.setKernel(node);
        return this;
    }

    /**
     * By default, target of differential disappears after the page the differential occurs on. Instead, from now on
     * display the target using `node`.
     * @param {Node} node Specifies any changes in the display of target that occur after this page.
     * @returns {Differential} Chainable
     */
    setCokernel(node){
        this.target.replace(node);
        return this;
    }

    /**
     * Synonym for setCokernel.
     * @param {Node} node
     * @returns {Differential} Chainable
     */
    replaceTarget(node){
        this.setCokernel(node);
        return this;
    }


    /**
     * Sets the name of the target for use in determining the name of the differential. By default the target_name
     * is the name of the target class, but particularly if there is a cokernel it should potentially be something else
     * for instance, if the differential is multiplication by p, the target class might be named `x` but the target
     * should be `px`.
     * @param name
     * @returns {Differential} chainable
     */
    setTargetName(name){
        this.target_name = name;
        return this;
    }

    /**
     * I don't know if this is useful, just included for symmetry with setTargetName.
     * @param name
     * @returns {Differential} chainable
     */
    setSourceName(name){
        this.source_name = name;
        return this;
    }


//    hitMessage(){
//        return "hit on page %d by class %r" % (this.page, this.source);
//    }
//
//    supportedMessage(){
//        return "supported a differential on page %d hitting class %r" % (this.page, this.target);
//    }


    /**
     * Adds the name of this differntial to the extra_info for the source and target class (so that it gets displayed
     * in a tooltip). Maybe we should do this by default?
     * @returns {Differential} chainable
     */
    addInfoToSourceAndTarget(){
        this.source.addExtraInfo(this);
        this.target.addExtraInfo(this);
        return this;
    }

    /**
     * By default, if we use "replace" on the source class (or replaceSource, setKernel), any structlines will continue to be drawn.
     * If that's inappropriate, call this to kill the structlines connecting to the source after this page.
     * @returns {Differential} chainable
     */
    setSourceStructlinePages(){
        this.source.setStructlinePages(this.page);
        return this;
    }


    /**
     * By default, if we use "replace" on the target class (or replaceTarget, setCokernel), any structlines will continue to be drawn.
     * If that's inappropriate, call this to kill the structlines connecting to the target after this page.
     * @returns {Differential} chainable
     */
    setTargetStructlinePages(){
        this.target.setStructlinePages(this.page);
        return this;
    }

    /**
     * Does both setSourceStructlinePages and setTargetStructlinePages
     * @returns {Differential} chainable
     */
    setStructlinePages(){
        this.source.setStructlinePages(this.page);
        this.target.setStructlinePages(this.page);
        return this;
    }

    toString(){
        return `\\(d_{${this.page}}(${this.source_name}) = ${this.target_name}\\)`;
    }
}
exports.Differential = Differential;
},{}],3:[function(require,module,exports){
exports.circle = {
    draw : function(context) {
        context.beginPath();
        context.arc(0, 0, this.size(), 0, 2 * Math.PI, false);
        context.closePath();
        context.fillStrokeShape(this);
    }
}


exports.square = {
    draw : function(context) {
        let size = this.size();
        context.beginPath();
        context.rect(-size, -size, 2*size, 2*size);
        context.closePath();
        context.fillStrokeShape(this);
    }
}
},{}],4:[function(require,module,exports){
"use strict";
let Shapes = require("./Shape.js");
let SseqClassjs = require("./SseqClass.js");
let SseqClass = SseqClassjs.SseqClass;
let Node = SseqClassjs.Node;
let Edges = require("./Edges.js");
let Edge = Edges.Edge;
let Structline = Edges.Structline;
let Extension = Edges.Extension;
let Differential = Edges.Differential;

const StringifyingMap = require("./StringifyingMap.js");

/**
 * Map method get with default.
 * @param key
 * @param value
 * @returns {*}
 */
Map.prototype.getOrElse = function(key, value) {
  return this.has(key) ? this.get(key) : value;
};

/**
 * Adds an entry to a map keys ==> lists.
 * If the current key isn't present in the map, add an empty list first.
 * @param dictionary The dictionary of lists to add the entry to
 * @param key
 * @param value
 */
function addToDictionaryOfLists(dictionary, key,value){
    if(!dictionary.has(key)){
        dictionary.set(key, []);
    }
    dictionary.get(key).push(value);
}

/**
 * Make a string from a list of variable names and a list of exponents.
 * @param {Array|string} vars The list of variable names
 * @param {Array|int} exponents
 * @returns {string} The name of the monomial
 */
function monomialString(vars, exponents){
    let out = [];
    for(let i = 0; i < vars.length; i++){
        if(exponents[i] === 0){
            out[i] = "";
        } else if(exponents[i]===1){
            out[i] = vars[i];
        } else {
            out[i] = `${vars[i]}^{${exponents[i]}}`;
        }
    }
    let outStr = out.filter(s =>  s !== "").join(" ");
    if( outStr === "" ){
        outStr = "1";
    }
    return outStr;
}


class Sseq {
    /**
     * Make a spectral sequence object.
     * Key properties:
     *
     */
    constructor(){
        this.total_classes = 0;
        this.classes_by_degree = new StringifyingMap();
        this.num_classes_by_degree = new StringifyingMap();
        this.classes_by_stem = new Map();
        this.classes = [];
        this.structlines = [];
        this.differentials = [];
        this.edges = [];
        this.display_classes = [];        
        this.display_structlines = [];
        this.display_differentials = [];
        this.xshift = 0;
        this.yshift = 0;        
        this.offset_size = 10;
        this.page_list = [0,infinity];
        this.default_node = new Node();
        this.default_node.fill = true;
        this.default_node.stroke = true;
        this.default_node.shape = Shapes.circle;
        this.default_node.size = 6;
        this.projection = function(ssclass){
            return [ssclass.degree.x, ssclass.degree.y];
        }
    }

    set_shift(x, y){
        this.xshift = x;
        this.yshift = y;
        return this;
   }

   add_to_shift(x, y){
        this.xshift += x;
        this.yshift += y;
        return this;
    }

    /**
     * Add a class in position (x,y) and return the class. Uses sseq.default_node for display.
     *
     * @param x The x position
     * @param y
     * @returns {SseqClass} The new class
     */
    addClass(x, y){
        let degree;
        if(y === undefined){
            degree = x;
        } else {
            x = x + this.xshift;
            y = y + this.yshift;
            degree = {x: x, y: y};
        }
        let c = new SseqClass(this, degree);
        let idx  = this.num_classes_by_degree.getOrElse(c.projection, 0);
        this.num_classes_by_degree.set(c.projection, idx + 1);
        c.idx = idx;
        this.classes.push(c);
        addToDictionaryOfLists(this.classes_by_degree, degree, c);
        addToDictionaryOfLists(this.classes_by_stem, c.x , c);
        this.total_classes ++;
        return c;
    }


    /**
     * This is an internal method used by display to calculate the set of features to be displayed on the current page.
     * @param page
     * @param xmin
     * @param xmax
     * @param ymin
     * @param ymax
     * @package
     */
    _calculateDrawnElements(page, xmin, xmax, ymin, ymax){
        this.display_classes = this.classes.filter(c => {c.in_range = c._inRangeQ(xmin, xmax, ymin, ymax); return c.in_range && c._drawOnPageQ(page);});
        this.display_edges = this.edges.filter(e => 
             e._drawOnPageQ(page)
          && e.source._drawOnPageQ(page) && e.target._drawOnPageQ(page)
          && ( e.source.in_range || e.target.in_range )
        );
        
        for(let i = 0; i < this.display_edges.length; i++){
            let e = this.display_edges[i];
            if(!e.source.in_range){
                this.display_classes.push(e.source);
            }
            if(!e.target.in_range){
                this.display_classes.push(e.target);
            }            
        }      
    }


    /**
     * Gets recalculated by _calculateDrawnElements.
     * @returns {Array|SseqClass} The list of classes currently being displayed.
     */
    getClassesToDisplay(){
        return this.display_classes;
    }


    /**
     * Gets recalculated by _calculateDrawnElements.
     * @returns {Array|Edge} The list of edges currently being displayed.
     */
    getEdgesToDisplay(){
        return this.display_edges;
    }

    /**
     * Adds a structline from source to target.
     * @param source
     * @param target
     * @returns {Structline} the structline object
     */
    addStructline(source, target){
//        if(source == undefined){
//            source = this.last_classes[0]
//            target = this.last_classes[1]
//        } else if(target == undefined){
//            target = this.last_classes[0]
//        }
        if(!source || !target){
            return null;
        }
        let struct = new Structline(source,target);
        this.structlines.push(struct);
        this.edges.push(struct);
        return struct;
    }

    /**
     * Adds a differential.
     * @param source
     * @param target
     * @param page
     * @returns {Differential}
     */
   addDifferential(source, target, page){
        if(page <= 0){
            console.log("No page <= 0 differentials allowed.");
            return null;
        }
        if(!source || !target){
            return null;
        }        
        let differential = new Differential(source, target, page);
        this.differentials.push(differential);
        this.edges.push(differential);
        this.addPageToPageList(page);
        return differential;
    }

    /**
     * Adds an extension.
     * @param source
     * @param target
     * @returns {Extension}
     */
   addExtension(source, target){
        if(!source || !target){
            return null;
        }
        let ext = new Extension(source, target);
        this.edges.push(ext);
        return ext;
    }

    /**
     * For display purposes, a Sseq object maintains a list of pages on which something changes in the spectral sequence.
     * Currently this list always contains 0, infinity, and the set of pages on which differentials live.
     * @param page
     * @returns {Sseq} chainable
     */
   addPageToPageList(page){
        for(let i = 0; i < this.page_list.length; i++){
            if(this.page_list[i] > page){
                this.page_list.splice(i, 0, page);
            }
            if(this.page_list[i] >= page){
                return this;
            }
        }
   }

    /**
     *
     * @param var_degree_dict -- Object with bidegrees of the generators, of the form `"var_name" : [stem, filtration]`
     * @param var_spec_list -- List of range specifications. Each range specification is a list of the form
     *  `["var_name", min, max, step]` where `min` defaults to 0 and `step` defaults to 1.
     * @param cond
     * @returns {monomial_basis} A monomial_basis object containing the set of classes so generated.
     */
   addPolynomialClasses(var_degree_dict,var_spec_list, cond){
        let var_name_list = [];
        let stem_list = [];
        let filtration_list = [];
        let range_list = [];
        
        for(let i=0; i<var_spec_list.length; i++){
            let var_spec = var_spec_list[i];
            let var_name = var_spec[0];
            if(!var_degree_dict.hasOwnProperty(var_name)){
                throw "No bidegree specified for variable '" + var_name + "'."
            }
            var_name_list.push(var_name);
            stem_list.push(var_degree_dict[var_name][0]);
            filtration_list.push(var_degree_dict[var_name][1]);
            range_list.push(range(...var_spec.slice(1)));
        }

        let class_dict = new monomial_basis(this, var_name_list);
            
        let l = product(...range_list);
        for(let i = 0; i < l.length; i++){
            let monomial_exponents = l[i];
            // This is the dot product here...
            let stem = dot_product(monomial_exponents, stem_list);
            let filtration = dot_product(monomial_exponents, filtration_list);
            if(this.xRange){
                if(stem < this.xRange[0] -10 || stem > this.xRange[1] + 10){
                    continue;
                }
            }
            if(cond && cond()){

            }
            if(this.yRange && this.max_differential_length){
                if(filtration > this.yRange[1] + this.max_differential_length || filtration < this.yRange[0]){
                    continue;
                }
            }
            let name = monomialString(var_name_list,monomial_exponents);
            class_dict._add_class(monomial_exponents, name, this.addClass(stem,filtration).setName(name));
        }
        return class_dict; 
   }
    
}


/**
 * Make an array based on the given start, stop, step
 * @param start
 * @param stop
 * @param step
 * @returns {Array|int}
 */
function range(start, stop, step = 1){
    if(arguments.length === 1){
        start = 1;
        stop = arguments[0];
        step = 1;
    }
    return Array(Math.ceil((stop - start + step)/step)).fill(start).map((x, y) => x + y * step);
}

function product() {
  const args = Array.prototype.slice.call(arguments); // makes array from arguments
  return args.reduce(function tl (accumulator, value) {
      const tmp = [];
      accumulator.forEach(function (a0) {
      value.forEach(function (a1) {
        tmp.push(a0.concat(a1));
      });
    });
    return tmp;
  }, [[]]);
}

/**
 * Calculate the dot product of two vectors of the same length
 * @param {Array|int} k
 * @param {Array|int} l
 * @returns {int} the dot product of k and l.
 */
function dot_product(k,l){
    let s = 0;
    for(let i=0; i<k.length; i++){
        s += k[i] * l[i];
    }
    return s;
}

/**
 * Add two vectors of the same length.
 * @param {Array|int} k
 * @param {Array|int} l
 * @returns {Array|int} The sum k + l.
 */
function vectorSum(k,l){
    let out = [];
    for(let i=0; i<k.length; i++){
        out.push(k[i]+l[i]);
    }
    return out;
}


class monomial_basis {
    /**
     * Construct a monomial_basis.
     * @param sseq Parent spectral sequence.
     * @param variable_list The list of variable names in the order that they are referred to by vectors.
     * @private
     */
    constructor(sseq, variable_list){
        this.sseq = sseq;
        this._tuples_to_classes = new StringifyingMap();
        this._strings_to_classes = new Map();
        this._tuples_to_strings = new StringifyingMap();
        this._strings_to_tuples = new Map();
        this.length = 0;
        this.variable_list = variable_list;
    }

    /**
     * Add a class to the basis.
     * @param tuple The vector of powers of each variable in the monomial
     * @param name The name of the class.
     * @param the_class The class
     * @package
     */
    _add_class(tuple, name, the_class){
        this.length++;
        this._tuples_to_classes.set(tuple, the_class);
        this._strings_to_classes.set(name, the_class);
        this._tuples_to_strings.set(tuple, name);
        this._strings_to_tuples.set(name, tuple);
    }

    /**
     * Convert an object of the form {..., variable_name : power, ...} to a vector.
     * @param map
     * @returns {*}
     * @private
     */
    _monomial_map_to_vect(map){
        // We just map over the variable_list as a list of property names. Check if property is present, else return zero.
        return this.variable_list.map(v => {
            if(map.hasOwnProperty(v)){
                return map[v];
            } else {
                return 0;
            }
        });
    }

    /**
     * If the argument is already an array, do nothing. If it's a map, apply _monomial_map_to_vect to it. If it's a
     * string look it up in _strings_to_classes.
     * @param vect
     * @returns {Array|int} The offset vector
     * @private
     */
    _ensure_vect(vect){
        if(! Array.isArray(vect)){
            if(typeof(vect) === "string"){
                if(!this._strings_to_classes.has(vect)){
                    throw "Invalid variable name";
                } else {
                    vect = this._strings_to_tuples.get(vect);
                }
            } else {
                vect = this._monomial_map_to_vect(vect);
            }
        }
        return vect;
    }

    /*
     * Add structlines to every monomial corresponding to the given offset vector.
     * For instance, if there is a generator called
     */
    addStructline(offset_vector, callback){
        offset_vector = this._ensure_vect(offset_vector);
        for(let k of this){
            let c1 = k[1];
            let c2 = this.get(vectorSum(k[0],offset_vector));
            if(c2 !== undefined){
                let sline = this.sseq.addStructline(c1, c2);
                if(callback){
                    callback(sline);
                }
            }
        }
        return this;
    }


    /**
     * Add differentials to monomials.
     * @param page The page of the differential
     * @param target_vect The differential is effectively of the form d(x) = r*x where r is specified by target_vect.
     *        This can either be of the form `[first_var_power, ..., last_var_power]` or of the form `{ "var_name" : var_power }`
     * @param cond A conditional used to determine whether to place a differential coming off of this particular source.
     * @param callback A callback called on each resulting differential.
     * @returns {monomial_basis} Chainable
     */
    addDifferential(page, target_vect, cond, callback){
        target_vect = this._ensure_vect(target_vect);
        for(let key_value of this){
            let k = key_value[0];   
            let c1 = key_value[1];  
            let c2 = this.get(vectorSum(k, target_vect));
            if(cond(k)){
                if(c2){
                    let d = this.sseq.addDifferential(c1, c2, page);
                    if(callback !== undefined){
                        callback(d,k);
                    }
                } else {
                    if(c1.getPage() > page){
                        c1.setPage(page);
                    }
                }
            }
        }
        return this;
    }

    // These are immutable map methods.

    has(key){
        if(this._strings_to_classes.has(key))
            return true;
        key = this._ensure_vect(key);
        return this._tuples_to_classes.has(key);
    }
    
    get(key, default_value){
        if(this._strings_to_classes.has(key)) {
            return this._strings_to_classes.get(key);
        }
        key = this._ensure_vect(key);
        if(this._tuples_to_classes.has(key)){
            return this._tuples_to_classes.get(key);
        }
        return default_value;
    }
}

    
monomial_basis.prototype[Symbol.iterator] = function*(){
    for(let k of this._tuples_to_classes){
        yield k;
    }
};

exports.Sseq = Sseq;
window.SseqNode = Node;


},{"./Edges.js":2,"./Shape.js":3,"./SseqClass.js":5,"./StringifyingMap.js":6}],5:[function(require,module,exports){
/**
 * The Node class controls the display of SseqClass's.
 * The behavior of a Node's fields is controlled by the method Konva.Shape.prototype.setNode defined in display.js.
 * The fields are:
 *    color -- the color to draw with. Default black.
 *    fill -- either a boolean or a color. "true" means fill it, and use the color field to decide what color.
 *            Specifying a color overrides the value of the color key.
 *    stroke -- similar to fill except for the stroke.
 *    shape -- an object with a key "draw" with value a drawing function. Optionally a second key "hitRegion" which
 *             determines what region the shape lies over.
 *    size  -- this key should determine the scaling of the node. It is the responsibility of the draw function to
 *             consider the value of this key when drawing the shape.
 */
class Node {
    copy(){
        return Object.assign(new Node(), this);
    }

    setShape(shape){
        this.shape = shape;
        return this;
    }

    /**
     * @param {...Node} nodes -- a list of nodes to merge. Merges them into a new object.
     * @returns {Node} -- a new node formed by merging the list of nodes passed as arguments. Later arguments have
     *    priority over earlier ones.
     */
    static merge(...nodes){
        let root = new SseqNode();
        for ( var i = 0; i < nodes.length; i++ )
            for ( var key in nodes[i] )
                root[key] = nodes[i][key];
        return root;
    }
}






/**
 *  A SseqClass represents a particular subgroup of some bidegree in the E2 page of the spectral sequence, and should
 *  contain the information about the fate of that subgroup -- what differentials does it support, what subquotients
 *  live to each page, what differentials, structure lines, and extensions occur.
 *
 *  A class contains the following fields:
 *    degree  -- an object representing the multidegree the class lives in
 *    name    -- the name of this class (a string)
 *    extra_info -- extra information about this class (a string)
 *    edges, structlines, etc -- lists of edges incident to this class
 *    page_list -- a list of pages on which the class supports or receives a differential
 *    node_list -- a list of nodes that control the display of the class in each range
 *
 *  The page_list and node_list should be the same length. Here's an example to explain page_list and node_list:
 *  suppose the class represents a group that
 *  starts out being Z on the E2 page, say on page 5 it supports a differential with kernel pZ and on page 9 it's hit by
 *  a differential with cokernel pZ/p^2Z. Then:
 *     `page_list = [5, 9, infinity]` and
 *     `node_list = [ Znode, pZnode, Zmpnode]`,
 *  where maybe Znode is a filled black square, pZnode is an unfilled black square (just the border) and Zmpnode is a
 *  filled black circle. This means that on page range [0,5] the class is displayed using Znode, on page range [6,9]
 *  it's displayed using pZnode, and on [10, infinity] it's displayed using Zmpnode.
 *
 *  If instead the d9 were surjective, then the class shouldn't be displayed at all after page 9. This would be
 *  represented as `page_list = [5, 9]` and `node_list = [ Znode, pZnode ]`.
 */
class SseqClass {
    /**
     * @param sseq The parent spectral sequence.
     *
     */
    constructor(sseq, degree){
        this.sseq = sseq;
        this.degree = degree;
        this.projection = sseq.projection(this);
        this.x = this.projection[0];
        this.y = this.projection[1];

        this.edges = [];
        this.structlines = [];
        this.outgoing_differentials = [];
        this.incoming_differentials = [];
        this.name = "";
        this.extra_info = "";
        this.page_list = [infinity];
        this.node_list = [sseq.default_node.copy()];
        this.visible = true;


        // internal fields only.
        this._last_page = 0;
        this._last_page_idx = 0;
    }

    /**
     * Add a structline to this class. Called by Structline constructor.
     * @param sl The
     * @package
     */
    _addStructline(sl){
        this.structlines.push(sl);
        this.edges.push(sl);
    }

    /**
     * @returns {int} The page this class dies on (or infinity if it lives forever).
     */
    getPage(){
        return this.page_list[this.page_list.length - 1];
    }

    setPage(page){
        this.page_list[this.page_list.length - 1] = page;
        return this;
    }

    setName(name){
        this.name = name;
        return this;
    }

    /**
     * This gets the index of a specified page in the page list. What this means is that if the page list is of the
     * form [5, 9, infinity], this divides the pages into three intervals, [0,5], [6,9], and [10, infinity].
     * If page is in the range from 0 to 5, the pageIndex is zero, if it is in the range 6 to 9, the index is 1,
     * and in the range 10 to infinity, it is 2.
     *
     * If the page_list does not end in infinity and page is larger than the largest entry in page_list then this throws
     * an error.
     * @param {int} page
     * @returns {int} the index
     * @private
     */
    _getPageIndex(page){
        if( page === undefined ) {
            return this.page_list.length - 1;
        } else if( page === this._last_page ) {
            return this._last_page_idx;
        }
        let page_idx;
        for(let i = 0; i < this.page_list.length; i++){
            if(this.page_list[i] >= page){
                page_idx = i;
                break;
            }
        }
        if(page_idx === undefined){
            throw "Page too large.";
        }
        this._last_page = page;
        this._last_page_idx = page_idx;
        return page_idx;
    }

    /**
     * Get the node that controls the display of the class on the given page.
     * @param page
     * @returns {Node} The node that controls the display of this class on page `page`.
     */
    getNode(page){
        const idx = this._getPageIndex(page);
        return this.node_list[idx];
    }

    /**
     * Sets the node that controls the display on the given page.
     * Properties that are missing from the given node are left unchanged.
     * @param {Node} node
     * @param {int} page
     * @returns {SseqClass} Chainable
     */
    setNode(node, page){
        if(node === undefined){
            node = {};
        }
        const idx = this._getPageIndex(page);
        this.node_list[idx] = Node.merge(this.node_list[idx], node);
        return this;
    }


    /**
     * Appends a page to the list of pages and sets the corresponding node to be the previous node.
     * @param {int} page The page to append. Really should always be infinity...
     * @returns {SseqClass} Chainable
     * @private
     */
    _appendPage(page){
        this.page_list.push(page);
        this.node_list.push(this.node_list[this.node_list.length - 1].copy());
        return this;
    }

    /**
     * Replace a "dead" class.
     * @param node Control the way the display of the "replaced" class changes. If the node is undefined, no change
     *   in appearance will occur.
     * @returns {SseqClass}
     */
    replace(node){
        this._appendPage(infinity);
        this.setNode(node);
        return this;
    }

    /**
     * Adds a string to extra_info (in practice, this controls the tooltip for the class).
     * @param str
     * @returns {SseqClass} Chainable
     */
    addExtraInfo(str){
        this.extra_info += "\n" + str;
        return this;
    }

    /**
     * If multiple classes are in the same (x,y) location, we offset their position a bit to avoid clashes.
     * Gets called by display code.
     * @returns {number} The x offset
     * @package
     */
    _getXOffset(){
        let total_classes = this.sseq.num_classes_by_degree.get(this.projection);
        let idx = this.idx;
        return (idx - (total_classes - 1)/2)*this.sseq.offset_size;
    }

    /**
     * If multiple classes are in the same (x,y) location, we offset their position a bit to avoid clashes.
     * Gets called by display code.
     * @returns {number} The y offset
     * @package
     */
    _getYOffset(){
        let total_classes = this.sseq.num_classes_by_degree.get(this.projection);
        let idx = this.idx;
        return -(idx - (total_classes - 1)/2)*this.sseq.offset_size;
    }

    toString(){
        return this.name;
    }

    /**
     * Adds an outgoing differential. Called by the differential constructor.
     * @param differential
     * @package
     */
    _addOutgoingDifferential(differential){
        if(this.getPage() < differential.page){
            //this.handleDoubledDifferential("supporting another" + differential.supportedMessage());
        }
        this.setPage(differential.page);
        this.outgoing_differentials.push(differential);
        this.edges.push(differential);
    }

    /**
     * Adds an incoming differential. Called by the differential constructor.
     * @param differential
     * @package
     */
    _addIncomingDifferential(differential){
        if(this.getPage() < differential.page){
            //this.handleDoubledDifferential("receiving another" + differential.hitMessage());
        }
        this.setPage(differential.page);
        this.incoming_differentials.push(differential);
        this.edges.push(differential);
    }


    /**
     * Set the page of every structline incident to this edge. Structlines are not displayed on pages later than their
     * page.
     * @param page
     * @returns {SseqClass}
     */
    setStructlinePages(page){
        for(let i = 0; i < this.structlines.length; i++){
            let sl = this.structlines[i];
            if(sl.page > page){
                sl.page = page;
            }
        }
        return this;
    }

    /**
     * Determines whether this class is drawn on the given page.
     * @param page
     * @returns {boolean}
     * @package
     */
    _drawOnPageQ(page){
        return this.page_list[this.page_list.length -1] >= page && this.visible;
    }

    /**
     * Determines wither the class is in the given range.
     * @param xmin
     * @param xmax
     * @param ymin
     * @param ymax
     * @returns {boolean}
     * @package
     */
    _inRangeQ(xmin, xmax, ymin, ymax){
        return xmin <= this.x && this.x <= xmax
            && ymin <= this.y && this.y <= ymax;
    }

}

exports.Node = Node;
exports.SseqClass = SseqClass;

},{}],6:[function(require,module,exports){
"use strict";

function stdCatToString(x){
    if(x.catToString !== undefined){
        return x.catToString();
    } else {
        return x.toString();
    }
}

var StringifyingMap = (function () {
    function StringifyingMap(catToString) {
        if(catToString === undefined){
            catToString = stdCatToString
        }
        this.catToString = catToString;
        this.m = new Map();
        this.keys = new Map();
    }
    StringifyingMap.prototype.set = function (k, v) {
        this.keys.set(this.catToString(k),k);
        let s = this.m.set(this.catToString(k), v);
        return s;
    };
    StringifyingMap.prototype.get = function (k) {
        return this.m.get(this.catToString(k));
    };
    StringifyingMap.prototype.delete = function (k) {
        this.keys.delete(this.catToString(k));
        return this.m.delete(this.catToString(k));
    };
    StringifyingMap.prototype.has = function (k) {
        return this.m.has(this.catToString(k));
    };    

    StringifyingMap.prototype.getOrElse = function(key, value) {
      return this.has(key) ? this.get(key) : value;
    }
    
    StringifyingMap.prototype[Symbol.iterator] = function*(){
        for(let k of this.m){
            yield [this.keys.get(k[0]),k[1]];
        }
    }
    
    Object.defineProperty(StringifyingMap.prototype, "size", {
        get: function () {
            return this.m.size;
        },
        enumerable: true,
        configurable: true
    });
    return StringifyingMap;
}());


module.exports = StringifyingMap;

},{}],7:[function(require,module,exports){
"use strict";


let d3 = require("d3");
let Mousetrap = require("mousetrap");
let Konva = require("konva");
// prevent scrollbars
document.documentElement.style.overflow = 'hidden';  // firefox, chrome
// noinspection JSValidateTypes
document.body.scroll = "no"; // ie only

Konva.Factory.addGetterSetter(Konva.Shape, 'size');
Konva.Shape.prototype.setNode = function (node) {
    this.node = node;
    this.setAttrs(node);
    this.sceneFunc(node.shape.draw);
    if (node.shape.hitRegion) {
        this.hitFunc(node.shape.hitRegion);
    }
    this.setFillEnabled(node.fill);
    this.setStrokeEnabled(node.stroke);
    if ((node.fill !== true && node.fill) || node.color) {
        this.fill((node.fill !== true && node.fill) || node.color);
    }
    if ((node.stroke !== true && node.stroke) || node.color) {
        this.stroke((node.stroke !== true && node.stroke) || node.color);
    }

}



class Display {
    constructor(ss) {
        this.sseq = ss;
        ss.disp = this;
        // Global constants for grid and setup
        this.gridColor = "#555";
        this.gridStrokeWidth = 0.5;
        this.boxSize = 50;
        this.ZOOM_BASE = 1.1;
        const boundingRectangle = document.getElementById("main").getBoundingClientRect();
        const canvasWidth = boundingRectangle.width;
        const canvasHeight = boundingRectangle.height;

        this.old_scales_maxed = false;

        this.domainOffset = 1 / 2;

        // The sseq object contains the list of valid pages. Always includes at least 0 and infinity.
        this.page_idx = 0;
        this.page = 0;

        // Handle left / right mouse buttons to change page.
        // noinspection JSUnusedLocalSymbols
        Mousetrap.bind('left', (e, n) => {
            if (this.page_idx > 0) {
                this.page_idx--;
                this.page = this.sseq.page_list[this.page_idx];
                //pageNumText.text(page);
                //window.page = page;
                this.drawAll();
                if (this.stage.getPointerPosition() && this.stage.getIntersection(this.stage.getPointerPosition())) {
                    this.handleMouseover(this.stage.getIntersection(this.stage.getPointerPosition()));
                }

            }
        });

        // noinspection JSUnusedLocalSymbols
        Mousetrap.bind('right', (e, n) => {
            if (this.page_idx < this.sseq.page_list.length - 1) {
                this.page_idx++;
                this.page = this.sseq.page_list[this.page_idx];
                if (this.page_idx === this.sseq.page_list.length - 1) {
                    //pageNumText.text("");
                } else {
                    //pageNumText.text(page);
                }
                //window.page = page;
                this.drawAll();
            }
        });

        // Drawing elements
        this.body = d3.select("body");
        let body = this.body;

        this.tooltip_div = body.append("div")
            .attr("id", "tooltip_div")
            .attr("class", "tooltip")
            .style("opacity", 0);

        this.tooltip_div_dummy = body.append("div")
            .attr("id", "tooltip_div_dummy")
            .attr("class", "tooltip")
            .style("opacity", 0);

        this.stage = new Konva.Stage({
            container: 'main',
            width: canvasWidth,
            height: canvasHeight
        });
        let stage = this.stage;

        this.width = stage.width();
        this.height = stage.height();

        //window.stage = stage;

        // Layers from back to front.
        this.gridLayer = new Konva.Layer();
        this.edgeLayer = new Konva.Layer();
        this.classLayer = new Konva.Layer();
        // For axes labels.
        this.margin = new Konva.Layer();
        // This just contains a white square in the bottom right corner to prevent axes labels
        // from showing up down there. The zoom event handler is attached to the supermargin.
        this.supermargin = new Konva.Layer();

        stage.add(this.gridLayer);
        stage.add(this.edgeLayer);
        stage.add(this.classLayer);
        stage.add(this.margin);
        stage.add(this.supermargin);

        Array.prototype.forEach.call(document.getElementsByTagName("canvas"),
            (c, idx) => c.setAttribute("id", ["gridLayer", "edgeLayer", "classLayer", "marginLayer", "supermarginLayer"][idx]));

        this.gridLayerContext = d3.select("#gridLayer").node().getContext("2d");
        this.edgeLayerContext = d3.select("#edgeLayer").node().getContext("2d");
        this.classLayerContext = d3.select("#classLayer").node().getContext("2d");
        this.marginLayerContext = d3.select("#marginLayer").node().getContext("2d");
        this.supermarginLayerContext = d3.select("#supermarginLayer").node().getContext("2d");

        this.xMarginSize = this.boxSize / 2 + 30;
        this.yMarginSize = this.boxSize;

        this.clipX = this.xMarginSize;
        this.clipY = -this.boxSize;
        this.clipWidth = this.width;
        this.clipHeight = this.height - this.yMarginSize;

        this.gridLayerContext.rect(this.clipX, this.clipY, this.clipWidth - this.clipX, this.clipHeight - this.clipY);
        this.gridLayerContext.clip();
        this.gridLayerContext.strokeStyle = this.gridColor;

        this.edgeLayerContext.rect(this.clipX, this.clipY, this.clipWidth - this.clipX, this.clipHeight - this.clipY);
        this.edgeLayerContext.clip();

        this.classLayerContext.rect(this.clipX, this.clipY, this.clipWidth - this.clipX, this.clipHeight - this.clipY);
        this.classLayerContext.clip();
        this.hitCtx = this.classLayer.getHitCanvas().context;

        this.marginLayerContext.textBaseline = "middle";
        this.marginLayerContext.font = "15px Arial";

        this.supermarginLayerContext.fillStyle = "#FFF";
        this.supermarginLayerContext.rect(0, this.clipHeight, this.xMarginSize - 5, this.boxSize);
        this.supermarginLayerContext.fill();
        this.supermarginLayerContext.fillStyle = "#000";

        this.supermarginLayerContext.beginPath();
        this.supermarginLayerContext.moveTo(this.xMarginSize, 0);
        this.supermarginLayerContext.lineTo(this.xMarginSize, this.clipHeight);
        this.supermarginLayerContext.lineTo(this.width, this.clipHeight);
        this.supermarginLayerContext.stroke();

        //window.context = this.classLayerContext;

        this.xScaleInit = d3.scaleLinear().range([this.xMarginSize, this.width]);
        this.yScaleInit = d3.scaleLinear().range([this.height - this.yMarginSize, 0]);

        this.xScaleInit.domain([this.sseq.initialxRange[0] - this.domainOffset, this.sseq.initialxRange[1] + this.domainOffset]);
        this.yScaleInit.domain([this.sseq.initialyRange[0] - this.domainOffset, this.sseq.initialyRange[1] + this.domainOffset]);

        this.zoomDomElement = d3.select("#supermarginLayer");

        this.drawAll = this.drawAll.bind(this);
        this.drawGrid = this.drawGrid.bind(this);
        this.drawTicks = this.drawTicks.bind(this);
        this.draw = this.draw.bind(this);


        this.zoom = d3.zoom().scaleExtent([0, 4]);
        this.zoom.on("zoom", () => this.drawAll());
        this.zoomDomElement.call(this.zoom).on("dblclick.zoom", null);


        //window.sseq = sseq;
        this.addClasses();
        this.drawAll();
    }

    drawAll() {
        let zoomDomElement = this.zoomDomElement;
        this.transform = d3.zoomTransform(zoomDomElement.node());
        this.scale = this.transform.k;
        let scale = this.scale;
        let xScale = this.xScale;
        let yScale = this.yScale;
        let sseq = this.sseq;

        xScale = this.transform.rescaleX(this.xScaleInit);
        if (!sseq.fixY) {
            yScale = this.transform.rescaleY(this.yScaleInit);
        } else {
            yScale = this.yScaleInit;
        }

        // We have to call zoom.translateBy when the user hits the boundary of the pan region
        // to adjust the zoom transform. However, this causes the zoom handler (this function) to be called a second time,
        // which is less intuitive program flow than just continuing on in the current function.
        // In order to prevent this, temporarily unset the zoom handler.
        this.zoom.on("zoom", null);
        if (!this.old_scales_maxed) {
            if (sseq.xRange) {
                let xMinOffset = scale > 1 ? 10 * scale : 10;
                let xMaxOffset = xMinOffset;
                if (xScale(sseq.xRange[0]) > this.xMarginSize + xMinOffset) {
                    this.zoom.translateBy(zoomDomElement, (this.xMarginSize + xMinOffset - xScale(sseq.xRange[0]) - 0.1) / scale, 0);
                } else if (xScale(sseq.xRange[1]) < this.width - xMaxOffset) {
                    this.zoom.translateBy(zoomDomElement, (this.width - xMaxOffset - xScale(sseq.xRange[1]) + 0.1) / scale, 0);
                }
            }

            if (!sseq.fixY) {
                if (sseq.yRange) {
                    let yMinOffset = scale > 1 ? 10 * scale : 10;
                    let yMaxOffset = yMinOffset;
                    if (yScale(sseq.yRange[0]) < this.clipHeight - yMinOffset) {
                        this.zoom.translateBy(zoomDomElement, 0, (this.clipHeight - yMinOffset - yScale(sseq.yRange[0]) - 0.1) / scale);
                    } else if (yScale(sseq.yRange[1]) > yMaxOffset) {
                        this.zoom.translateBy(zoomDomElement, 0, (yMaxOffset - yScale(sseq.yRange[1]) + 0.1) / scale);
                    }
                }
            }
        }

        this.transform = d3.zoomTransform(zoomDomElement.node());
        xScale = this.transform.rescaleX(this.xScaleInit);

        if (!sseq.fixY) {
            yScale = this.transform.rescaleY(this.yScaleInit);
        }

        let xmin = Math.ceil(xScale.invert(this.xMarginSize));
        let xmax = Math.floor(xScale.invert(this.width));
        let ymin = Math.ceil(yScale.invert(this.height - this.yMarginSize));
        let ymax = Math.floor(yScale.invert(0));


        let xScaleMaxed = false, yScaleMaxed = false;

        if (sseq.xRange && (xmax - xmin) > sseq.xRange[1] - sseq.xRange[0]) {
            xScaleMaxed = true;
            xScale.domain([sseq.xRange[0] - this.domainOffset, sseq.xRange[1] + this.domainOffset]);
        }

        if (sseq.yRange && (ymax - ymin) > sseq.yRange[1] - sseq.yRange[0]) {
            yScaleMaxed = true;
            yScale.domain([sseq.yRange[0] - this.domainOffset, sseq.yRange[1] + this.domainOffset]);
        }

        if (xScaleMaxed && yScaleMaxed) {
            if (!this.old_scales_maxed) {
                this.old_scales_maxed = true;
                this.zoom_max_transform = this.transform;
            } else {
                this.zoom.transform(zoomDomElement, this.zoom_max_transform);
            }
        } else {
            if (this.old_scales_maxed) {
                //zoom.transform(zoomDomElement, pre_zoom_max_transform);
                this.old_scales_maxed = false;
            } else {
                this.pre_zoom_max_transform = this.transform;
            }
        }

        this.transform = d3.zoomTransform(zoomDomElement.node());
        this.scale = this.transform.k;
        this.xmin = Math.ceil(xScale.invert(this.xMarginSize));
        this.xmax = Math.floor(xScale.invert(this.width));
        this.ymin = Math.ceil(yScale.invert(this.height - this.yMarginSize));
        this.ymax = Math.floor(yScale.invert(0));
        this.zoom.on("zoom", this.drawAll);
        this.xScale = xScale;
        this.yScale = yScale;

        // window.transform = transform;
        // window.xScale = xScale;

        this.xZoom = Math.log(scale) / Math.log(this.ZOOM_BASE);
        this.yZoom = this.xZoom;

        this.xTicks = this.xScale.ticks(15);
        this.yTicks = this.yScale.ticks();

        this.xTickStep = Math.ceil(this.xTicks[1] - this.xTicks[0]);
        this.yTickStep = Math.ceil(this.yTicks[1] - this.yTicks[0]);

        this.xGridStep = (Math.floor(this.xTickStep / 5) === 0) ? 1 : Math.floor(this.xTickStep / 5);
        this.yGridStep = (Math.floor(this.yTickStep / 5) === 0) ? 1 : Math.floor(this.yTickStep / 5);

        this.drawGrid();
        this.drawTicks();
        this.draw();


        if (d3.event) {
            // The Konvas stage tracks the pointer position using _setPointerPosition.
            // d3 zoom doesn't allow the events it handles to bubble, so Konvas fails to track pointer position.
            // We have to manually tell Konvas to update the pointer position using the event.
            this.stage._setPointerPosition(d3.event.sourceEvent);
        }

        // If there is a tooltip being displayed and the zoom event has modified the canvas so that the cursor is no
        // longer over the
        if (this.stage.getPointerPosition() === undefined || this.stage.getIntersection(this.stage.getPointerPosition()) === null) {
            this.handleMouseout();
        }
    }

    drawGrid() {
        let context = this.gridLayerContext;
        context.clearRect(0, 0, this.width, this.height);

        context.beginPath();
        for (let col = Math.floor(this.xmin / this.xGridStep) * this.xGridStep; col <= this.xmax; col += this.xGridStep) {
            context.moveTo(this.xScale(col), 0);
            context.lineTo(this.xScale(col), this.clipHeight);
        }
        this.gridLayerContext.lineWidth = this.gridStrokeWidth;
        context.stroke();

        context.beginPath();
        for (let row = Math.floor(this.ymin / this.yGridStep) * this.yGridStep; row <= this.ymax; row += this.yGridStep) {
            context.moveTo(-this.boxSize, this.yScale(row));
            context.lineTo(this.width + this.boxSize, this.yScale(row));
        }
        this.gridLayerContext.lineWidth = this.gridStrokeWidth;
        context.stroke();
    }


    drawTicks() {
        let context = this.marginLayerContext;
        context.clearRect(0, 0, this.width, this.height);
        context.textAlign = "center";
        for (let i = Math.floor(this.xTicks[0]); i <= this.xTicks[this.xTicks.length - 1]; i += this.xTickStep) {
            context.fillText(i, this.xScale(i), this.clipHeight + 20);
        }

        context.textAlign = "right";
        for (let i = Math.floor(this.yTicks[0]); i <= this.yTicks[this.yTicks.length - 1]; i += this.yTickStep) {
            context.fillText(i, this.xMarginSize - 10, this.yScale(i));
        }
    }


    getPositionColorKey(x, y) {
        return "#" + Konva.Util._rgbToHex(...this.hitCtx.getImageData(x, y, 1, 1).data);
    }

    findBoundaryTowards(shape, x, y) {
        const colorKey = shape.colorKey;
        const start_distance = 8;
        let x0 = shape.x();
        let y0 = shape.y();
        let dx = x - x0;
        let dy = y - y0;
        let length = Math.sqrt(dx * dx + dy * dy);

        if (length === 0) {
            return {x: x0, y: y0};
        }

        dx = dx / length * start_distance;
        dy = dy / length * start_distance;
        length = start_distance;
        while (length > 0.5) {
            length /= 2;
            dx /= 2;
            dy /= 2;
            if (this.getPositionColorKey(x0 + dx, y0 + dy) === colorKey) {
                x0 += dx;
                y0 += dy;
            }
        }
        return {x: x0, y: y0};
    }

    addClasses() {
        let classes = this.sseq.classes;
        for (let i = 0; i < classes.length; i++) {
            let c = classes[i];
            c.canvas_shape = new Konva.Shape();
            c.canvas_shape.sseq_class = c;
            let self = this;
            c.canvas_shape.on('mouseover', (event) => this.handleMouseover(event.currentTarget));
            c.canvas_shape.on('mouseout', function () {
                self.handleMouseout(this)
            });
            this.classLayer.add(c.canvas_shape);
        }
    }

    setUpEdge(edge) {
        let source_shape = edge.source.canvas_shape;
        let target_shape = edge.target.canvas_shape;

        source_shape.show();
        source_shape.draw();
        target_shape.show();
        target_shape.draw();


        let sourcePt = this.findBoundaryTowards(source_shape, target_shape.x(), target_shape.y());
        let targetPt = this.findBoundaryTowards(target_shape, source_shape.x(), source_shape.y());
        edge.sourceOffset = {x: (sourcePt.x - source_shape.x()), y: (sourcePt.y - source_shape.y())};
        edge.targetOffset = {x: (targetPt.x - source_shape.x()), y: (targetPt.y - source_shape.y())};
    }


    draw() {
        // window.layer = classLayer;
        let context = this.classLayerContext;
        context.clearRect(0, 0, this.width, this.height);
        context.save();
        this.sseq._calculateDrawnElements(this.page, this.xmin, this.xmax, this.ymin, this.ymax);


        let classes = this.sseq.getClassesToDisplay();
        this.classLayer.removeChildren();

        let scale_size;
        if (this.scale < 1 / 2) {
            scale_size = 1 / 2;
        } else if (this.scale > 2) {
            scale_size = 2;
        } else {
            scale_size = this.scale;
        }

        for (let i = 0; i < classes.length; i++) {
            let c = classes[i];
            let s = c.canvas_shape;
            if (!s) {
                continue;
            }
            s.setPosition({x: this.xScale(c.x) + c._getXOffset(), y: this.yScale(c.y) + c._getYOffset()});
            s.setNode(c.getNode(this.page));
            s.size(s.size() * scale_size);
            this.classLayer.add(s);
        }

        this.classLayer.draw();

        context = this.edgeLayerContext;
        context.clearRect(0, 0, this.width, this.height);

        let edges = this.sseq.getEdgesToDisplay();
        for (let i = 0; i < edges.length; i++) {
            let e = edges[i];
            let source_shape = e.source.canvas_shape;
            let target_shape = e.target.canvas_shape;
            context.beginPath();
            if (!e.sourceOffset || (e.sourceOffset.x === 0 && e.sourceOffset.y === 0)) {
                e.sourceOffset = {x: 0, y: 0};
                e.targetOffset = {x: 0, y: 0};
                //setTimeout(setUpEdge(e),0);
            }
            context.lineWidth = 1;
            context.strokeStyle = e.color;
            context.moveTo(source_shape.x() + e.sourceOffset.x, source_shape.y() + e.sourceOffset.y);
            context.lineTo(target_shape.x() + e.targetOffset.x, target_shape.y() + e.targetOffset.y);
            context.closePath();
            context.stroke();
        }

    }


    handleMouseover(shape) {
        let c = shape.sseq_class;
        let disp = c.sseq.disp;
        if (c.tooltip_html) {
            disp.tooltip_div_dummy.html(c.tooltip_html);
            disp.setupTooltipDiv(shape);
        } else {
            let extra_info_html = c.extra_info.replace("\n", "\n<hr>\n");
            if (MathJax && MathJax.Hub) {
                disp.tooltip_div_dummy.html(`\\(${c.name}\\) -- (${c.x}, ${c.y})` + extra_info_html);
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, "tooltip_div_dummy"]);
                MathJax.Hub.Queue(() => disp.setupTooltipDiv(shape));
            } else {
                disp.tooltip_div_dummy.html(`\\(${c.name}\\) -- (${c.x}, ${c.y})` + extra_info_html);
                disp.setupTooltipDiv(this);
            }
        }
    }

    setupTooltipDiv(shape) {
        let rect = this.tooltip_div.node().getBoundingClientRect();
        let tooltip_width = rect.width;
        let tooltip_height = rect.height;
        shape.sseq_class.tooltip_html = this.tooltip_div_dummy.html();
        this.tooltip_div.html(this.tooltip_div_dummy.html());
        this.tooltip_div.style("left", (shape.x() + 25) + "px")
            .style("top", (shape.y() - tooltip_height) + "px")
            .style("right", null).style("bottom", null);
        let bounding_rect = this.tooltip_div.node().getBoundingClientRect();
        if (bounding_rect.right > this.width) {
            this.tooltip_div.style("left", null)
                .style("right", (this.width - shape.x() + 10) + "px")
        }
        if (bounding_rect.top < 0) {
            this.tooltip_div.style("top", (shape.y() + 10) + "px")
        }

        this.tooltip_div.transition()
            .duration(200)
            .style("opacity", .9);
    }

    handleMouseout() {
        this.tooltip_div.transition()
            .duration(500)
            .style("opacity", 0);
    }
}

exports.Display = Display;
},{"d3":40,"konva":1,"mousetrap":41}],8:[function(require,module,exports){
// This MathJax file comes from the MathJax-single-file git archive folder dist/TeXSVGTeX
// It isn't designed to work with node / browserify -- it just installs itself as a global variable.
// because of this, require just "returns" an empty object, so there's no use in saving the output.
//require("./mathjax.min.js");

window.infinity = 10000;

window.mod = function(n,d){
    return (n % d + d)%d;
}


window.Shapes = require("./Shape.js");
window.Display = require("./display.js").Display;


window.Sseq = require("./Sseq.js").Sseq;
window.d3 = require("d3");
//require("../examples/KO.js");

},{"./Shape.js":3,"./Sseq.js":4,"./display.js":7,"d3":40}],9:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.2.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector = function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

var pairs = function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
};

function pair(a, b) {
  return [a, b];
}

var cross = function(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;

  if (reduce == null) reduce = pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var number = function(x) {
  return x === null ? NaN : +x;
};

var variance = function(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
};

var deviation = function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
};

var extent = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
};

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

var constant = function(x) {
  return function() {
    return x;
  };
};

var identity = function(x) {
  return x;
};

var range = function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

var ticks = function(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;

  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();

  return ticks;
};

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0
      ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
      : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

var sturges = function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram = function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      tz = tickStep(x0, x1, tz);
      tz = range(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    }

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
};

var quantile = function(values, p, valueof) {
  if (valueof == null) valueof = number;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
};

var freedmanDiaconis = function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

var scott = function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
};

var max = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
};

var mean = function(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) sum += value;
      else --m;
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) sum += value;
      else --m;
    }
  }

  if (m) return sum / m;
};

var median = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number(values[i]))) {
        numbers.push(value);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(value = number(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return quantile(numbers.sort(ascending), 0.5);
};

var merge = function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
};

var min = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) { // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  else {
    while (++i < n) { // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;
        while (++i < n) { // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
};

var permute = function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
};

var scan = function(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];

  if (compare == null) compare = ascending;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
};

var shuffle = function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
};

var sum = function(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  }

  else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
};

var transpose = function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
};

function length(d) {
  return d.length;
}

var zip = function() {
  return transpose(arguments);
};

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],10:[function(require,module,exports){
// https://d3js.org/d3-axis/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var slice = Array.prototype.slice;

var identity = function(x) {
  return x;
};

var top = 1;
var right = 2;
var bottom = 3;
var left = 4;
var epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function(d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
  if (scale.round()) offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
        format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity) : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");

    path = path.merge(path.enter().insert("path", ".tick")
        .attr("class", "domain")
        .attr("stroke", "#000"));

    tick = tick.merge(tickEnter);

    line = line.merge(tickEnter.append("line")
        .attr("stroke", "#000")
        .attr(x + "2", k * tickSizeInner));

    text = text.merge(tickEnter.append("text")
        .attr("fill", "#000")
        .attr(x, k * spacing)
        .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);

      tickExit = tickExit.transition(context)
          .attr("opacity", epsilon)
          .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });

      tickEnter
          .attr("opacity", epsilon)
          .attr("transform", function(d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
    }

    tickExit.remove();

    path
        .attr("d", orient === left || orient == right
            ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
            : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);

    tick
        .attr("opacity", 1)
        .attr("transform", function(d) { return transform(position(d)); });

    line
        .attr(x + "2", k * tickSizeInner);

    text
        .attr(x, k * spacing)
        .text(format);

    selection.filter(entering)
        .attr("fill", "none")
        .attr("font-size", 10)
        .attr("font-family", "sans-serif")
        .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

    selection
        .each(function() { this.__axis = position; });
  }

  axis.scale = function(_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function() {
    return tickArguments = slice.call(arguments), axis;
  };

  axis.tickArguments = function(_) {
    return arguments.length ? (tickArguments = _ == null ? [] : slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function(_) {
    return arguments.length ? (tickValues = _ == null ? null : slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function(_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function(_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function(_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function(_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function(_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}

exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],11:[function(require,module,exports){
// https://d3js.org/d3-brush/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

var BrushEvent = function(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
};

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

var MODE_DRAG = {name: "drag"};
var MODE_SPACE = {name: "space"};
var MODE_HANDLE = {name: "handle"};
var MODE_CENTER = {name: "center"};

var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function(x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
  output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
};

var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function(y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
  output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
};

var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function(xy) { return xy; },
  output: function(xy) { return xy; }
};

var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};

var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};

var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};

var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};

var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {type: t};
}

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
}

// Like d3.local, but with the name __brush rather than auto-generated.
function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;
  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0]
      || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush$1(X);
}

function brushY() {
  return brush$1(Y);
}

var brush = function() {
  return brush$1(XY);
};

function brush$1(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = d3Dispatch.dispatch(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group
        .property("__brush", initialize)
      .selectAll(".overlay")
      .data([type("overlay")]);

    overlay.enter().append("rect")
        .attr("class", "overlay")
        .attr("pointer-events", "all")
        .attr("cursor", cursors.overlay)
      .merge(overlay)
        .each(function() {
          var extent = local(this).extent;
          d3Selection.select(this)
              .attr("x", extent[0][0])
              .attr("y", extent[0][1])
              .attr("width", extent[1][0] - extent[0][0])
              .attr("height", extent[1][1] - extent[0][1]);
        });

    group.selectAll(".selection")
      .data([type("selection")])
      .enter().append("rect")
        .attr("class", "selection")
        .attr("cursor", cursors.selection)
        .attr("fill", "#777")
        .attr("fill-opacity", 0.3)
        .attr("stroke", "#fff")
        .attr("shape-rendering", "crispEdges");

    var handle = group.selectAll(".handle")
      .data(dim.handles, function(d) { return d.type; });

    handle.exit().remove();

    handle.enter().append("rect")
        .attr("class", function(d) { return "handle handle--" + d.type; })
        .attr("cursor", function(d) { return cursors[d.type]; });

    group
        .each(redraw)
        .attr("fill", "none")
        .attr("pointer-events", "all")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
        .on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function(group, selection) {
    if (group.selection) {
      group
          .on("start.brush", function() { emitter(this, arguments).beforestart().start(); })
          .on("interrupt.brush end.brush", function() { emitter(this, arguments).end(); })
          .tween("brush", function() {
            var that = this,
                state = that.__brush,
                emit = emitter(that, arguments),
                selection0 = state.selection,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                i = d3Interpolate.interpolate(selection0, selection1);

            function tween(t) {
              state.selection = t === 1 && empty(selection1) ? null : i(t);
              redraw.call(that);
              emit.brush();
            }

            return selection0 && selection1 ? tween : tween(1);
          });
    } else {
      group
          .each(function() {
            var that = this,
                args = arguments,
                state = that.__brush,
                selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                emit = emitter(that, args).beforestart();

            d3Transition.interrupt(that);
            state.selection = selection1 == null || empty(selection1) ? null : selection1;
            redraw.call(that);
            emit.start().brush().end();
          });
    }
  };

  function redraw() {
    var group = d3Selection.select(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection")
          .style("display", null)
          .attr("x", selection[0][0])
          .attr("y", selection[0][1])
          .attr("width", selection[1][0] - selection[0][0])
          .attr("height", selection[1][1] - selection[0][1]);

      group.selectAll(".handle")
          .style("display", null)
          .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
          .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
          .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
          .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
    }

    else {
      group.selectAll(".selection,.handle")
          .style("display", "none")
          .attr("x", null)
          .attr("y", null)
          .attr("width", null)
          .attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (d3Selection.event.touches) { if (d3Selection.event.changedTouches.length < d3Selection.event.touches.length) return noevent(); }
    else if (touchending) return;
    if (!filter.apply(this, arguments)) return;

    var that = this,
        type = d3Selection.event.target.__data__.type,
        mode = (d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE),
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0], w0, w1,
        N = extent[0][1], n0, n1,
        E = extent[1][0], e0, e1,
        S = extent[1][1], s0, s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = d3Selection.mouse(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;

    var group = d3Selection.select(that)
        .attr("pointer-events", "none");

    var overlay = group.selectAll(".overlay")
        .attr("cursor", cursors[type]);

    if (d3Selection.event.touches) {
      group
          .on("touchmove.brush", moved, true)
          .on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = d3Selection.select(d3Selection.event.view)
          .on("keydown.brush", keydowned, true)
          .on("keyup.brush", keyupped, true)
          .on("mousemove.brush", moved, true)
          .on("mouseup.brush", ended, true);

      d3Drag.dragDisable(d3Selection.event.view);
    }

    nopropagation();
    d3Transition.interrupt(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = d3Selection.mouse(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;
        else lockX = true;
      }
      point = point1;
      moving = true;
      noevent();
      move();
    }

    function move() {
      var t;

      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
          if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!
      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1
          || selection[0][1] !== n1
          || selection[1][0] !== e1
          || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      nopropagation();
      if (d3Selection.event.touches) {
        if (d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        d3Drag.dragEnable(d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          shifting = signX && signY;
          break;
        }
        case 18: { // ALT
          if (mode === MODE_HANDLE) {
            if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: { // SPACE; takes priority over ALT
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
            if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }

    function keyupped() {
      switch (d3Selection.event.keyCode) {
        case 16: { // SHIFT
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: { // ALT
          if (mode === MODE_CENTER) {
            if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
            if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: { // SPACE
          if (mode === MODE_SPACE) {
            if (d3Selection.event.altKey) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type]);
            move();
          }
          break;
        }
        default: return;
      }
      noevent();
    }
  }

  function initialize() {
    var state = this.__brush || {selection: null};
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), brush) : filter;
  };

  brush.handleSize = function(_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}

exports.brush = brush;
exports.brushX = brushX;
exports.brushY = brushY;
exports.brushSelection = brushSelection;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":16,"d3-drag":17,"d3-interpolate":25,"d3-selection":32,"d3-transition":37}],12:[function(require,module,exports){
// https://d3js.org/d3-chord/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-path')) :
  typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-path'], factory) :
  (factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Array,d3Path) { 'use strict';

var cos = Math.cos;
var sin = Math.sin;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = pi * 2;
var max = Math.max;

function compareValue(compare) {
  return function(a, b) {
    return compare(
      a.source.value + a.target.value,
      b.source.value + b.target.value
    );
  };
}

var chord = function() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = d3Array.range(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j;

    // Compute the sum.
    k = 0, i = -1; while (++i < n) {
      x = 0, j = -1; while (++j < n) {
        x += matrix[i][j];
      }
      groupSums.push(x);
      subgroupIndex.push(d3Array.range(n));
      k += x;
    }

    // Sort groups
    if (sortGroups) groupIndex.sort(function(a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    });

    // Sort subgroups
    if (sortSubgroups) subgroupIndex.forEach(function(d, i) {
      d.sort(function(a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    });

    // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?
    k = max(0, tau - padAngle * n) / k;
    dx = k ? padAngle : tau / n;

    // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!
    x = 0, i = -1; while (++i < n) {
      x0 = x, j = -1; while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    }

    // Generate chords for each (non-empty) subgroup-subgroup link.
    i = -1; while (++i < n) {
      j = i - 1; while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value
              ? {source: target, target: source}
              : {source: source, target: target});
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function(_) {
    return arguments.length ? (padAngle = max(0, _), chord) : padAngle;
  };

  chord.sortGroups = function(_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function(_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function(_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
};

var slice = Array.prototype.slice;

var constant = function(x) {
  return function() {
    return x;
  };
};

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

var ribbon = function() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - halfPi,
        sa1 = endAngle.apply(this, argv) - halfPi,
        sx0 = sr * cos(sa0),
        sy0 = sr * sin(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - halfPi,
        ta1 = endAngle.apply(this, argv) - halfPi;

    if (!context) context = buffer = d3Path.path();

    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), ribbon) : radius;
  };

  ribbon.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), ribbon) : endAngle;
  };

  ribbon.source = function(_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function(_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
  };

  return ribbon;
};

exports.chord = chord;
exports.ribbon = ribbon;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":9,"d3-path":26}],13:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume its an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],14:[function(require,module,exports){
// https://d3js.org/d3-color/ Version 1.2.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var define = function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: function() {
    return this.rgb().hex();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: function() {
    return "#" + hex(this.r) + hex(this.g) + hex(this.b);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

// https://beta.observablehq.com/@mbostock/lab-and-rgb
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r),
      g = rgb2lrgb(o.g),
      b = rgb2lrgb(o.b),
      y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y; else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
      lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function lrgb2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function lch(l, c, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.lch = lch;
exports.gray = gray;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],15:[function(require,module,exports){
// https://d3js.org/d3-contour/ Version 1.2.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

var array = Array.prototype;

var slice = array.slice;

var ascending = function(a, b) {
  return a - b;
};

var area = function(ring) {
  var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var contains = function(ring, hole) {
  var i = -1, n = hole.length, c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
};

function ringContains(ring, point) {
  var x = point[0], y = point[1], contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
  }
  return contains;
}

function segmentContains(a, b, c) {
  var i; return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}

function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}

function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

var noop = function() {};

var cases = [
  [],
  [[[1.0, 1.5], [0.5, 1.0]]],
  [[[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [0.5, 1.0]]],
  [[[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
  [[[1.0, 0.5], [1.0, 1.5]]],
  [[[1.0, 0.5], [0.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 0.5]]],
  [[[1.0, 1.5], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
  [[[1.5, 1.0], [1.0, 0.5]]],
  [[[0.5, 1.0], [1.5, 1.0]]],
  [[[1.0, 1.5], [1.5, 1.0]]],
  [[[0.5, 1.0], [1.0, 1.5]]],
  []
];

var contours = function() {
  var dx = 1,
      dy = 1,
      threshold = d3Array.thresholdSturges,
      smooth = smoothLinear;

  function contours(values) {
    var tz = threshold(values);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var domain = d3Array.extent(values), start = domain[0], stop = domain[1];
      tz = d3Array.tickStep(start, stop, tz);
      tz = d3Array.range(Math.floor(start / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending);
    }

    return tz.map(function(value) {
      return contour(values, value);
    });
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
        holes = [];

    isorings(values, value, function(ring) {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);
      else holes.push(ring);
    });

    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });

    return {
      type: "MultiPolygon",
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = new Array,
        fragmentByEnd = new Array,
        x, y, t0, t1, t2, t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);

    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
          end = [line[1][0] + x, line[1][1] + y],
          startIndex = index(start),
          endIndex = index(end),
          f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
      }
    }
  }

  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }

  function smoothLinear(ring, values, value) {
    ring.forEach(function(point) {
      var x = point[0],
          y = point[1],
          xt = x | 0,
          yt = y | 0,
          v0,
          v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }

  contours.contour = contour;

  contours.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 > 0) || !(_1 > 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, contours;
  };

  contours.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), contours) : threshold;
  };

  contours.smooth = function(_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };

  return contours;
};

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurX(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source.data[i - w + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}

// TODO Optimize edge cases.
// TODO Optimize index calculation.
// TODO Optimize arguments.
function blurY(source, target, r) {
  var n = source.width,
      m = source.height,
      w = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source.data[i + (j - w) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

function defaultX(d) {
  return d[0];
}

function defaultY(d) {
  return d[1];
}

var density = function() {
  var x = defaultX,
      y = defaultY,
      dx = 960,
      dy = 500,
      r = 20, // blur radius
      k = 2, // log2(grid cell size)
      o = r * 3, // grid offset, to pad for blur
      n = (dx + o * 2) >> k, // grid width
      m = (dy + o * 2) >> k, // grid height
      threshold = constant(20);

  function density(data) {
    var values0 = new Float32Array(n * m),
        values1 = new Float32Array(n * m);

    data.forEach(function(d, i, data) {
      var xi = (x(d, i, data) + o) >> k,
          yi = (y(d, i, data) + o) >> k;
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        ++values0[xi + yi * n];
      }
    });

    // TODO Optimize.
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
    blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
    blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

    var tz = threshold(values0);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) {
      var stop = d3Array.max(values0);
      tz = d3Array.tickStep(0, stop, tz);
      tz = d3Array.range(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }

    return contours()
        .thresholds(tz)
        .size([n, m])
      (values0)
        .map(transform);
  }

  function transform(geometry) {
    geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }

  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }

  function transformRing(coordinates) {
    coordinates.forEach(transformPoint);
  }

  // TODO Optimize.
  function transformPoint(coordinates) {
    coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
    coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
  }

  function resize() {
    o = r * 3;
    n = (dx + o * 2) >> k;
    m = (dy + o * 2) >> k;
    return density;
  }

  density.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), density) : x;
  };

  density.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), density) : y;
  };

  density.size = function(_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.ceil(_[0]), _1 = Math.ceil(_[1]);
    if (!(_0 >= 0) && !(_0 >= 0)) throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };

  density.cellSize = function(_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
    return k = Math.floor(Math.log(_) / Math.LN2), resize();
  };

  density.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), density) : threshold;
  };

  density.bandwidth = function(_) {
    if (!arguments.length) return Math.sqrt(r * (r + 1));
    if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
  };

  return density;
};

exports.contours = contours;
exports.contourDensity = density;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":9}],16:[function(require,module,exports){
// https://d3js.org/d3-dispatch/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var noop = {value: function() {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

exports.dispatch = dispatch;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],17:[function(require,module,exports){
// https://d3js.org/d3-drag/ Version 1.2.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-selection')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-selection'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Selection) { 'use strict';

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

var nodrag = function(view) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", noevent, true);
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", noevent, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
};

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = d3Selection.select(view).on("dragstart.drag", null);
  if (noclick) {
    selection.on("click.drag", noevent, true);
    setTimeout(function() { selection.on("click.drag", null); }, 0);
  }
  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}

var constant = function(x) {
  return function() {
    return x;
  };
};

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch$$1) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch$$1;
}

DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {x: d3Selection.event.x, y: d3Selection.event.y} : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

var drag = function() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = d3Dispatch.dispatch("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection
        .on("mousedown.drag", mousedowned)
      .filter(touchable)
        .on("touchstart.drag", touchstarted)
        .on("touchmove.drag", touchmoved)
        .on("touchend.drag touchcancel.drag", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), d3Selection.mouse, this, arguments);
    if (!gesture) return;
    d3Selection.select(d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    nodrag(d3Selection.event.view);
    nopropagation();
    mousemoving = false;
    mousedownx = d3Selection.event.clientX;
    mousedowny = d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    noevent();
    if (!mousemoving) {
      var dx = d3Selection.event.clientX - mousedownx, dy = d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }

  function mouseupped() {
    d3Selection.select(d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(d3Selection.event.view, mousemoving);
    noevent();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, d3Selection.touch, this, arguments)) {
        nopropagation();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        noevent();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = d3Selection.event.changedTouches,
        n = touches.length, i, gesture;

    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        nopropagation();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id), s, dx, dy,
        sublisteners = listeners.copy();

    if (!d3Selection.customEvent(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function() {
      if ((d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;

    return function gesture(type) {
      var p0 = p, n;
      switch (type) {
        case "start": gestures[id] = gesture, n = active++; break;
        case "end": delete gestures[id], --active; // nobreak
        case "drag": p = point(container, id), n = active; break;
      }
      d3Selection.customEvent(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), drag) : filter;
  };

  drag.container = function(_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : constant(_), drag) : container;
  };

  drag.subject = function(_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : constant(_), drag) : subject;
  };

  drag.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), drag) : touchable;
  };

  drag.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
};

exports.drag = drag;
exports.dragDisable = nodrag;
exports.dragEnable = yesdrag;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":16,"d3-selection":32}],18:[function(require,module,exports){
// https://d3js.org/d3-dsv/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}

// Compute unique columns in order of discovery.
function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];

  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });

  return columns;
}

var dsv = function(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert, columns, rows = parseRows(text, function(row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [], // output rows
        N = text.length,
        I = 0, // current character index
        n = 0, // current line number
        t, // current token
        eof = N <= 0, // current token followed by EOF?
        eol = false; // current token followed by EOL?

    // Strip the trailing newline.
    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL;

      // Unescape quotes.
      var i, j = I, c;
      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
        if ((i = I) >= N) eof = true;
        else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      }

      // Find next delimiter or newline.
      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
        else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
        else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      }

      // Return last token before EOF.
      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF) row.push(t), t = token();
      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? ""
        : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
        : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
};

var csv = dsv(",");

var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatRows = csv.formatRows;

var tsv = dsv("\t");

var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatRows = tsv.formatRows;

exports.dsvFormat = dsv;
exports.csvParse = csvParse;
exports.csvParseRows = csvParseRows;
exports.csvFormat = csvFormat;
exports.csvFormatRows = csvFormatRows;
exports.tsvParse = tsvParse;
exports.tsvParseRows = tsvParseRows;
exports.tsvFormat = tsvFormat;
exports.tsvFormatRows = tsvFormatRows;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],19:[function(require,module,exports){
// https://d3js.org/d3-ease/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function linear(t) {
  return +t;
}

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var exponent = 3;

var polyIn = (function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;

  return polyIn;
})(exponent);

var polyOut = (function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;

  return polyOut;
})(exponent);

var polyInOut = (function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;

  return polyInOut;
})(exponent);

var pi = Math.PI;
var halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}

var b1 = 4 / 11;
var b2 = 6 / 11;
var b3 = 8 / 11;
var b4 = 3 / 4;
var b5 = 9 / 11;
var b6 = 10 / 11;
var b7 = 15 / 16;
var b8 = 21 / 22;
var b9 = 63 / 64;
var b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}

var overshoot = 1.70158;

var backIn = (function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;

  return backIn;
})(overshoot);

var backOut = (function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;

  return backOut;
})(overshoot);

var backInOut = (function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;

  return backInOut;
})(overshoot);

var tau = 2 * Math.PI;
var amplitude = 1;
var period = 0.3;

var elasticIn = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function(a) { return custom(a, p * tau); };
  elasticIn.period = function(p) { return custom(a, p); };

  return elasticIn;
})(amplitude, period);

var elasticOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticOut.period = function(p) { return custom(a, p); };

  return elasticOut;
})(amplitude, period);

var elasticInOut = (function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0
        ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
        : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function(a) { return custom(a, p * tau); };
  elasticInOut.period = function(p) { return custom(a, p); };

  return elasticInOut;
})(amplitude, period);

exports.easeLinear = linear;
exports.easeQuad = quadInOut;
exports.easeQuadIn = quadIn;
exports.easeQuadOut = quadOut;
exports.easeQuadInOut = quadInOut;
exports.easeCubic = cubicInOut;
exports.easeCubicIn = cubicIn;
exports.easeCubicOut = cubicOut;
exports.easeCubicInOut = cubicInOut;
exports.easePoly = polyInOut;
exports.easePolyIn = polyIn;
exports.easePolyOut = polyOut;
exports.easePolyInOut = polyInOut;
exports.easeSin = sinInOut;
exports.easeSinIn = sinIn;
exports.easeSinOut = sinOut;
exports.easeSinInOut = sinInOut;
exports.easeExp = expInOut;
exports.easeExpIn = expIn;
exports.easeExpOut = expOut;
exports.easeExpInOut = expInOut;
exports.easeCircle = circleInOut;
exports.easeCircleIn = circleIn;
exports.easeCircleOut = circleOut;
exports.easeCircleInOut = circleInOut;
exports.easeBounce = bounceOut;
exports.easeBounceIn = bounceIn;
exports.easeBounceOut = bounceOut;
exports.easeBounceInOut = bounceInOut;
exports.easeBack = backInOut;
exports.easeBackIn = backIn;
exports.easeBackOut = backOut;
exports.easeBackInOut = backInOut;
exports.easeElastic = elasticOut;
exports.easeElasticIn = elasticIn;
exports.easeElasticOut = elasticOut;
exports.easeElasticInOut = elasticInOut;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],20:[function(require,module,exports){
// https://d3js.org/d3-fetch/ Version 1.1.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dsv')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dsv'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Dsv) { 'use strict';

function responseBlob(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.blob();
}

function blob(input, init) {
  return fetch(input, init).then(responseBlob);
}

function responseArrayBuffer(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}

function buffer(input, init) {
  return fetch(input, init).then(responseArrayBuffer);
}

function responseText(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.text();
}

function text(input, init) {
  return fetch(input, init).then(responseText);
}

function dsvParse(parse) {
  return function(input, init, row) {
    if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
    return text(input, init).then(function(response) {
      return parse(response, row);
    });
  };
}

function dsv(delimiter, input, init, row) {
  if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
  var format = d3Dsv.dsvFormat(delimiter);
  return text(input, init).then(function(response) {
    return format.parse(response, row);
  });
}

var csv = dsvParse(d3Dsv.csvParse);
var tsv = dsvParse(d3Dsv.tsvParse);

function image(input, init) {
  return new Promise(function(resolve, reject) {
    var image = new Image;
    for (var key in init) image[key] = init[key];
    image.onerror = reject;
    image.onload = function() { resolve(image); };
    image.src = input;
  });
}

function responseJson(response) {
  if (!response.ok) throw new Error(response.status + " " + response.statusText);
  return response.json();
}

function json(input, init) {
  return fetch(input, init).then(responseJson);
}

function parser(type) {
  return function(input, init)  {
    return text(input, init).then(function(text$$1) {
      return (new DOMParser).parseFromString(text$$1, type);
    });
  };
}

var xml = parser("application/xml");

var html = parser("text/html");

var svg = parser("image/svg+xml");

exports.blob = blob;
exports.buffer = buffer;
exports.dsv = dsv;
exports.csv = csv;
exports.tsv = tsv;
exports.image = image;
exports.json = json;
exports.text = text;
exports.xml = xml;
exports.html = html;
exports.svg = svg;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dsv":18}],21:[function(require,module,exports){
// https://d3js.org/d3-force/ Version 1.1.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-quadtree'), require('d3-collection'), require('d3-dispatch'), require('d3-timer')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-quadtree', 'd3-collection', 'd3-dispatch', 'd3-timer'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Quadtree,d3Collection,d3Dispatch,d3Timer) { 'use strict';

var center = function(x, y) {
  var nodes;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
};

var constant = function(x) {
  return function() {
    return x;
  };
};

var jiggle = function() {
  return (Math.random() - 0.5) * 1e-6;
};

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

var collide = function(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = constant(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = d3Quadtree.quadtree(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = jiggle(), l += x * x;
            if (y === 0) y = jiggle(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  return force;
};

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

var link = function(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = constant(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || jiggle();
        y = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = d3Collection.map(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : constant(+_), initializeDistance(), force) : distance;
  };

  return force;
};

function x$1(d) {
  return d.x;
}

function y$1(d) {
  return d.y;
}

var initialRadius = 10;
var initialAngle = Math.PI * (3 - Math.sqrt(5));

var simulation = function(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = d3Collection.map(),
      stepper = d3Timer.timer(step),
      event = d3Dispatch.dispatch("tick", "end");

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i, n = nodes.length, node;

    alpha += (alphaTarget - alpha) * alphaDecay;

    forces.each(function(force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;
      else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;
      else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
};

var manyBody = function() {
  var nodes,
      node,
      alpha,
      strength = constant(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = d3Quadtree.quadtree(nodes, x$1, y$1).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = jiggle(), l += x * x;
        if (y === 0) y = jiggle(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = jiggle(), l += x * x;
      if (y === 0) y = jiggle(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
};

var radial = function(radius, x, y) {
  var nodes,
      strength = constant(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = constant(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
};

var x$2 = function(x) {
  var strength = constant(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = constant(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant(+_), initialize(), force) : x;
  };

  return force;
};

var y$2 = function(y) {
  var strength = constant(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = constant(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : constant(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant(+_), initialize(), force) : y;
  };

  return force;
};

exports.forceCenter = center;
exports.forceCollide = collide;
exports.forceLink = link;
exports.forceManyBody = manyBody;
exports.forceRadial = radial;
exports.forceSimulation = simulation;
exports.forceX = x$2;
exports.forceY = y$2;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-collection":13,"d3-dispatch":16,"d3-quadtree":28,"d3-timer":36}],22:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.3.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
var formatDecimal = function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
};

var exponent = function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
};

// [[fill]align][sign][symbol][0][width][,][.precision][~][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  this.fill = match[1] || " ";
  this.align = match[2] || ">";
  this.sign = match[3] || "-";
  this.symbol = match[4] || "";
  this.zero = !!match[5];
  this.width = match[6] && +match[6];
  this.comma = !!match[7];
  this.precision = match[8] && +match[8].slice(1);
  this.trim = !!match[9];
  this.type = match[10] || "";
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + (this.trim ? "~" : "")
      + this.type;
};

// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
var formatTrim = function(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      default: if (i0 > 0) { if (!+s[i]) break out; i0 = 0; } break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
};

var prefixExponent;

var formatPrefixAuto = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

var identity = function(x) {
  return x;
};

var prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

var formatLocale = function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        trim = specifier.trim,
        type = specifier.type;

    // The "n" type is an alias for ",g".
    if (type === "n") comma = true, type = "g";

    // The "" type, and any invalid type, is an alias for ".12~g".
    else if (!formatTypes[type]) precision == null && (precision = 12), trim = true, type = "g";

    // If zero fill is specified, padding goes after sign and before digits.
    if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? 6
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // Trim insignificant zeros.
        if (trim) value = formatTrim(value);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer value part that can be
        // grouped, and fractional or exponential suffix part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

var precisionFixed = function(step) {
  return Math.max(0, -exponent(Math.abs(step)));
};

var precisionPrefix = function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
};

var precisionRound = function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
};

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],23:[function(require,module,exports){
// https://d3js.org/d3-geo/ Version 1.10.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Array) { 'use strict';

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/

function adder() {
  return new Adder;
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;
    else this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};

var temp = new Adder;

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = (a - av) + (b - bv);
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;

var degrees = 180 / pi;
var radians = pi / 180;

var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;

var log = Math.log;
var pow = Math.pow;
var sin = Math.sin;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sqrt = Math.sqrt;
var tan = Math.tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}

function noop() {}

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};

var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}

function geoStream(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

var areaRingSum = adder();

var areaSum = adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;

var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians, phi *= radians;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}

function areaPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  phi = phi / 2 + quarterPi; // half the angular distance from south pole

  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnolis
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = cos(phi),
      sinPhi = sin(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * cos(adLambda),
      v = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v, u));

  // Advance the previous points.
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function area(object) {
  areaSum.reset();
  geoStream(object, areaStream);
  return areaSum * 2;
}

function spherical(cartesian) {
  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0], phi = spherical[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}

// TODO return a
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}

// TODO return d
function cartesianNormalizeInPlace(d) {
  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

var lambda0$1;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda00$1;
var phi00$1;
var p0;
var deltaSum = adder();
var ranges;
var range$1;

var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    range$1[0] = lambda0$1, range$1[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians, phi * radians]);
  if (p0) {
    var normal = cartesianCross(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = cartesianCross(equatorial, normal);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2,
        sign$$1 = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * degrees * sign$$1,
        phii,
        antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign$$1 * lambda2 < lambdai && lambdai < sign$$1 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1) lambda0$1 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range$1 = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range$1[0] = lambda0$1, range$1[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}

function boundsRingStart() {
  areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) lambda0$1 = -(lambda1 = 180);
  range$1[0] = lambda0$1, range$1[1] = lambda1;
  p0 = null;
}

// Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
// the distance between 180 to be 360.
function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range$$1, x) {
  return range$$1[0] <= range$$1[1] ? range$$1[0] <= x && x <= range$$1[1] : x < range$$1[0] || range$$1[1] < x;
}

function bounds(feature) {
  var i, n, a, b, merged, deltaMax, delta;

  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream);

  // First, sort ranges by their minimum longitudes.
  if (n = ranges.length) {
    ranges.sort(rangeCompare);

    // Then, merge any ranges that overlap.
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }

    // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
    }
  }

  ranges = range$1 = null;

  return lambda0$1 === Infinity || phi0 === Infinity
      ? [[NaN, NaN], [NaN, NaN]]
      : [[lambda0$1, phi0], [lambda1, phi1]];
}

var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda00$2;
var phi00$2;
var x0;
var y0;
var z0; // previous point

var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};

// Arithmetic mean of Cartesian vectors.
function centroidPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      w = atan2(sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

// See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00$2, phi00$2);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00$2 = lambda, phi00$2 = phi;
  lambda *= radians, phi *= radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var cosPhi = cos(phi),
      x = cosPhi * cos(lambda),
      y = cosPhi * sin(lambda),
      z = sin(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = sqrt(cx * cx + cy * cy + cz * cz),
      w = asin(m), // line weight = angle
      v = m && -w / m; // area weight multiplier
  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroid(object) {
  W0 = W1 =
  X0 = Y0 = Z0 =
  X1 = Y1 = Z1 =
  X2 = Y2 = Z2 = 0;
  geoStream(object, centroidStream);

  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z;

  // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
  if (m < epsilon2) {
    x = X1, y = Y1, z = Z1;
    // If the feature has zero length, fall back to arithmetic mean of point vectors.
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z;
    // If the feature still has an undefined ccentroid, then return.
    if (m < epsilon2) return [NaN, NaN];
  }

  return [atan2(y, x) * degrees, asin(z / sqrt(m)) * degrees];
}

function constant(x) {
  return function() {
    return x;
  };
}

function compose(a, b) {

  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };

  return compose;
}

function rotationIdentity(lambda, phi) {
  return [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
    : rotationLambda(deltaLambda))
    : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
    : rotationIdentity);
}

function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi ? lambda - tau : lambda < -pi ? lambda + tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi),
      sinDeltaPhi = sin(deltaPhi),
      cosDeltaGamma = cos(deltaGamma),
      sinDeltaGamma = sin(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }

  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi),
        x = cos(lambda) * cosPhi,
        y = sin(lambda) * cosPhi,
        z = sin(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };

  return rotation;
}

function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }

  forward.invert = function(coordinates) {
    coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };

  return forward;
}

// Generates a circle centered at [0, 0], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = cos(radius),
      sinRadius = sin(radius),
      step = direction * delta;
  if (t0 == null) {
    t0 = radius + direction * tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau;
  }
  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point[0], point[1]);
  }
}

// Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
function circleRadius(cosRadius, point) {
  point = cartesian(point), point[0] -= cosRadius;
  cartesianNormalizeInPlace(point);
  var radius = acos(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

function circle() {
  var center = constant([0, 0]),
      radius = constant(90),
      precision = constant(6),
      ring,
      rotate,
      stream = {point: point};

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= degrees, x[1] *= degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * radians,
        p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {type: "Polygon", coordinates: [ring]};
    ring = rotate = null;
    return c;
  }

  circle.center = function(_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : constant([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : constant(+_), circle) : radius;
  };

  circle.precision = function(_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : constant(+_), circle) : precision;
  };

  return circle;
}

function clipBuffer() {
  var lines = [],
      line;
  return {
    point: function(x, y) {
      line.push([x, y]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

function pointEqual(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection
  this.e = entry; // is an entry?
  this.v = false; // visited
  this.n = this.p = null; // next & previous
}

// A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.
function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;

  segments.forEach(function(segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n, p0 = segment[0], p1 = segment[n], x;

    // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.
    if (pointEqual(p0, p1)) {
      stream.lineStart();
      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });

  if (!subject.length) return;

  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;
  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }
  a.n = b = array[0];
  b.p = a;
}

var sum = adder();

function polygonContains(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      sinPhi = sin(phi),
      normal = [sin(lambda), -cos(lambda), 0],
      angle = 0,
      winding = 0;

  sum.reset();

  if (sinPhi === 1) phi = halfPi + epsilon;
  else if (sinPhi === -1) phi = -halfPi - epsilon;

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + quarterPi,
        sinPhi0 = sin(phi0),
        cosPhi0 = cos(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + quarterPi,
          sinPhi1 = sin(phi1),
          cosPhi1 = cos(phi1),
          delta = lambda1 - lambda0,
          sign$$1 = delta >= 0 ? 1 : -1,
          absDelta = sign$$1 * delta,
          antimeridian = absDelta > pi,
          k = sinPhi0 * sinPhi1;

      sum.add(atan2(k * sign$$1 * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));
      angle += antimeridian ? delta + sign$$1 * tau : delta;

      // Are the longitudes either side of the points meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }

  // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.

  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ (winding & 1);
}

function clip(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink),
        ringBuffer = clipBuffer(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;

    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = d3Array.merge(segments);
        var startInside = polygonContains(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();

      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i, n = ringSegments.length, m,
          segment,
          point;

      ring.pop();
      polygon.push(ring);
      ring = null;

      if (!n) return;

      // No intersections.
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
          sink.lineEnd();
        }
        return;
      }

      // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
}

// Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1])
       - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

var clipAntimeridian = clip(
  function() { return true; },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);

// Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.
function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi : -pi,
          delta = abs(lambda1 - lambda0);
      if (abs(delta - pi) < epsilon) { // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) { // line crosses antimeridian
        if (abs(lambda0 - sign0) < epsilon) lambda0 -= sign0 * epsilon; // handle degeneracies
        if (abs(lambda1 - sign1) < epsilon) lambda1 -= sign1 * epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = sin(lambda0 - lambda1);
  return abs(sinLambda0Lambda1) > epsilon
      ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1)
          - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0))
          / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
      : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

function clipCircle(radius) {
  var cr = cos(radius),
      delta = 6 * radians,
      smallRadius = cr > 0,
      notHemisphere = abs(cr) > epsilon; // TODO optimise for this common case

  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }

  // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.
  function clipLine(stream) {
    var point0, // previous point
        c0, // code for previous point
        v0, // visibility of previous point
        v00, // visibility of first point
        clean; // no intersections
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius
              ? v ? 0 : code(lambda, phi)
              : v ? code(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart();
        // Handle degeneracies.
        // TODO ignore if not clipping polygons.
        if (v !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
            point1[0] += epsilon;
            point1[1] += epsilon;
            v = visible(point1[0], point1[1]);
          }
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.
          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | ((v00 && v0) << 1);
      }
    };
  }

  // Intersects the great circle between a and b with the clip circle.
  function intersect(a, b, two) {
    var pa = cartesian(a),
        pb = cartesian(b);

    // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
    var n1 = [1, 0, 0], // normal
        n2 = cartesianCross(pa, pb),
        n2n2 = cartesianDot(n2, n2),
        n1n2 = n2[0], // cartesianDot(n1, n2),
        determinant = n2n2 - n1n2 * n1n2;

    // Two polar points.
    if (!determinant) return !two && a;

    var c1 =  cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = cartesianCross(n1, n2),
        A = cartesianScale(n1, c1),
        B = cartesianScale(n2, c2);
    cartesianAddInPlace(A, B);

    // Solve |p(t)|^2 = 1.
    var u = n1xn2,
        w = cartesianDot(A, u),
        uu = cartesianDot(u, u),
        t2 = w * w - uu * (cartesianDot(A, A) - 1);

    if (t2 < 0) return;

    var t = sqrt(t2),
        q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);

    if (!two) return q;

    // Two intersection points.
    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;

    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = abs(delta - pi) < epsilon,
        meridian = polar || delta < epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

    // Check that the first point is between a and b.
    if (meridian
        ? polar
          ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1)
          : phi0 <= q[1] && q[1] <= phi1
        : delta > pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }

  // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right
    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above
    return code;
  }

  return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

function clipLine(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

var clipMax = 1e9;
var clipMin = -clipMax;

// TODO Use d3-polygons polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {

  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null
        || (a = corner(from, direction)) !== (a1 = corner(to, direction))
        || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3
        : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1
        : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0
        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb
        : ca === 0 ? b[1] - a[1]
        : ca === 1 ? a[0] - b[0]
        : ca === 2 ? a[1] - b[1]
        : b[0] - a[0];
  }

  return function(stream) {
    var activeStream = stream,
        bufferStream = clipBuffer(),
        segments,
        polygon,
        ring,
        x__, y__, v__, // first point
        x_, y_, v_, // previous point
        first,
        clean;

    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
          if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
          else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
        }
      }

      return winding;
    }

    // Buffer geometry within a polygon and then clip it en masse.
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = d3Array.merge(segments)).length;
      if (cleanInside || visible) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible) {
          clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }

    // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.
    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (clipLine(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}

function extent() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;

  return clip = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function(_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}

var lengthSum = adder();
var lambda0$2;
var sinPhi0$1;
var cosPhi0$1;

var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}

function lengthPointFirst(lambda, phi) {
  lambda *= radians, phi *= radians;
  lambda0$2 = lambda, sinPhi0$1 = sin(phi), cosPhi0$1 = cos(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= radians, phi *= radians;
  var sinPhi = sin(phi),
      cosPhi = cos(phi),
      delta = abs(lambda - lambda0$2),
      cosDelta = cos(delta),
      sinDelta = sin(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta,
      z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt(x * x + y * y), z));
  lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
}

function length(object) {
  lengthSum.reset();
  geoStream(object, lengthStream);
  return +lengthSum;
}

var coordinates = [null, null];
var object = {type: "LineString", coordinates: coordinates};

function distance(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length(object);
}

var containsObjectType = {
  Feature: function(object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function(object, point) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
    return false;
  }
};

var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPoint(coordinates[i], point)) return true;
    return false;
  },
  LineString: function(object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsLine(coordinates[i], point)) return true;
    return false;
  },
  Polygon: function(object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function(object, point) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
    return false;
  },
  GeometryCollection: function(object, point) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point)) return true;
    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type)
      ? containsGeometryType[geometry.type](geometry, point)
      : false;
}

function containsPoint(coordinates, point) {
  return distance(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = distance(coordinates[0], coordinates[1]),
      ao = distance(coordinates[0], point),
      ob = distance(point, coordinates[1]);
  return ao + ob <= ab + epsilon;
}

function containsPolygon(coordinates, point) {
  return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * radians, point[1] * radians];
}

function contains(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type)
      ? containsObjectType[object.type]
      : containsGeometry)(object, point);
}

function graticuleX(y0, y1, dy) {
  var y = d3Array.range(y0, y1 - epsilon, dy).concat(y1);
  return function(x) { return y.map(function(y) { return [x, y]; }); };
}

function graticuleY(x0, x1, dx) {
  var x = d3Array.range(x0, x1 - epsilon, dx).concat(x1);
  return function(y) { return x.map(function(x) { return [x, y]; }); };
}

function graticule() {
  var x1, x0, X1, X0,
      y1, y0, Y1, Y0,
      dx = 10, dy = dx, DX = 90, DY = 360,
      x, y, X, Y,
      precision = 2.5;

  function graticule() {
    return {type: "MultiLineString", coordinates: lines()};
  }

  function lines() {
    return d3Array.range(ceil(X0 / DX) * DX, X1, DX).map(X)
        .concat(d3Array.range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
        .concat(d3Array.range(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs(x % DX) > epsilon; }).map(x))
        .concat(d3Array.range(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs(y % DY) > epsilon; }).map(y));
  }

  graticule.lines = function() {
    return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
  };

  graticule.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X0).concat(
        Y(Y1).slice(1),
        X(X1).reverse().slice(1),
        Y(Y0).reverse().slice(1))
      ]
    };
  };

  graticule.extent = function(_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function(_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function(_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function(_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule
      .extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]])
      .extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}

function graticule10() {
  return graticule()();
}

function interpolate(a, b) {
  var x0 = a[0] * radians,
      y0 = a[1] * radians,
      x1 = b[0] * radians,
      y1 = b[1] * radians,
      cy0 = cos(y0),
      sy0 = sin(y0),
      cy1 = cos(y1),
      sy1 = sin(y1),
      kx0 = cy0 * cos(x0),
      ky0 = cy0 * sin(x0),
      kx1 = cy1 * cos(x1),
      ky1 = cy1 * sin(x1),
      d = 2 * asin(sqrt(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
      k = sin(d);

  var interpolate = d ? function(t) {
    var B = sin(t *= d) / k,
        A = sin(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [
      atan2(y, x) * degrees,
      atan2(z, sqrt(x * x + y * y)) * degrees
    ];
  } : function() {
    return [x0 * degrees, y0 * degrees];
  };

  interpolate.distance = d;

  return interpolate;
}

function identity(x) {
  return x;
}

var areaSum$1 = adder();
var areaRingSum$1 = adder();
var x00;
var y00;
var x0$1;
var y0$1;

var areaStream$1 = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop;
    areaSum$1.add(abs(areaRingSum$1));
    areaRingSum$1.reset();
  },
  result: function() {
    var area = areaSum$1 / 2;
    areaSum$1.reset();
    return area;
  }
};

function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}

function areaPointFirst$1(x, y) {
  areaStream$1.point = areaPoint$1;
  x00 = x0$1 = x, y00 = y0$1 = y;
}

function areaPoint$1(x, y) {
  areaRingSum$1.add(y0$1 * x - x0$1 * y);
  x0$1 = x, y0$1 = y;
}

function areaRingEnd$1() {
  areaPoint$1(x00, y00);
}

var x0$2 = Infinity;
var y0$2 = x0$2;
var x1 = -x0$2;
var y1 = x1;

var boundsStream$1 = {
  point: boundsPoint$1,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds;
  }
};

function boundsPoint$1(x, y) {
  if (x < x0$2) x0$2 = x;
  if (x > x1) x1 = x;
  if (y < y0$2) y0$2 = y;
  if (y > y1) y1 = y;
}

// TODO Enforce positive area for exterior, negative area for interior?

var X0$1 = 0;
var Y0$1 = 0;
var Z0$1 = 0;
var X1$1 = 0;
var Y1$1 = 0;
var Z1$1 = 0;
var X2$1 = 0;
var Y2$1 = 0;
var Z2$1 = 0;
var x00$1;
var y00$1;
var x0$3;
var y0$3;

var centroidStream$1 = {
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.point = centroidPoint$1;
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  },
  result: function() {
    var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
        : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
        : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
        : [NaN, NaN];
    X0$1 = Y0$1 = Z0$1 =
    X1$1 = Y1$1 = Z1$1 =
    X2$1 = Y2$1 = Z2$1 = 0;
    return centroid;
  }
};

function centroidPoint$1(x, y) {
  X0$1 += x;
  Y0$1 += y;
  ++Z0$1;
}

function centroidLineStart$1() {
  centroidStream$1.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream$1.point = centroidPointLine;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0$3, dy = y - y0$3, z = sqrt(dx * dx + dy * dy);
  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}

function centroidRingStart$1() {
  centroidStream$1.point = centroidPointFirstRing;
}

function centroidRingEnd$1() {
  centroidPointRing(x00$1, y00$1);
}

function centroidPointFirstRing(x, y) {
  centroidStream$1.point = centroidPointRing;
  centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0$3,
      dy = y - y0$3,
      z = sqrt(dx * dx + dy * dy);

  X1$1 += z * (x0$3 + x) / 2;
  Y1$1 += z * (y0$3 + y) / 2;
  Z1$1 += z;

  z = y0$3 * x - x0$3 * y;
  X2$1 += z * (x0$3 + x);
  Y2$1 += z * (y0$3 + y);
  Z2$1 += z * 3;
  centroidPoint$1(x0$3 = x, y0$3 = y);
}

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

var lengthSum$1 = adder();
var lengthRing;
var x00$2;
var y00$2;
var x0$4;
var y0$4;

var lengthStream$1 = {
  point: noop,
  lineStart: function() {
    lengthStream$1.point = lengthPointFirst$1;
  },
  lineEnd: function() {
    if (lengthRing) lengthPoint$1(x00$2, y00$2);
    lengthStream$1.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length = +lengthSum$1;
    lengthSum$1.reset();
    return length;
  }
};

function lengthPointFirst$1(x, y) {
  lengthStream$1.point = lengthPoint$1;
  x00$2 = x0$4 = x, y00$2 = y0$4 = y;
}

function lengthPoint$1(x, y) {
  x0$4 -= x, y0$4 -= y;
  lengthSum$1.add(sqrt(x0$4 * x0$4 + y0$4 * y0$4));
  x0$4 = x, y0$4 = y;
}

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle$1(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null) this._circle = circle$1(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle$1(radius) {
  return "m0," + radius
      + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
      + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
      + "z";
}

function index(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }

  path.area = function(object) {
    geoStream(object, projectionStream(areaStream$1));
    return areaStream$1.result();
  };

  path.measure = function(object) {
    geoStream(object, projectionStream(lengthStream$1));
    return lengthStream$1.result();
  };

  path.bounds = function(object) {
    geoStream(object, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };

  path.centroid = function(object) {
    geoStream(object, projectionStream(centroidStream$1));
    return centroidStream$1.result();
  };

  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, identity) : (projection = _).stream, path) : projection;
  };

  path.context = function(_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function(_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}

function transform(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function(stream) {
    var s = new TransformStream;
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) { this.stream.point(x, y); },
  sphere: function() { this.stream.sphere(); },
  lineStart: function() { this.stream.lineStart(); },
  lineEnd: function() { this.stream.lineEnd(); },
  polygonStart: function() { this.stream.polygonStart(); },
  polygonEnd: function() { this.stream.polygonEnd(); }
};

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  geoStream(object, projection.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function(b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function(b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function(b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

var maxDepth = 16;
var cosMinDistance = cos(30 * radians); // cos(minimum angular distance)

function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample$1(project, delta2) {

  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = sqrt(a * a + b * b + c * c),
          phi2 = asin(c /= m),
          lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : atan2(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 // perpendicular projected distance
          || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
          || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
        lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
      polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}

var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});

function transformRotate(rotate) {
  return transformer({
    point: function(x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function scaleTranslate(k, dx, dy) {
  function transform$$1(x, y) {
    return [dx + k * x, dy - k * y];
  }
  transform$$1.invert = function(x, y) {
    return [(x - dx) / k, (dy - y) / k];
  };
  return transform$$1;
}

function scaleTranslateRotate(k, dx, dy, alpha) {
  var cosAlpha = cos(alpha),
      sinAlpha = sin(alpha),
      a = cosAlpha * k,
      b = sinAlpha * k,
      ai = cosAlpha / k,
      bi = sinAlpha / k,
      ci = (sinAlpha * dy - cosAlpha * dx) / k,
      fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform$$1(x, y) {
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform$$1.invert = function(x, y) {
    return [ai * x - bi * y + ci, fi - bi * x - ai * y];
  };
  return transform$$1;
}

function projection(project) {
  return projectionMutator(function() { return project; })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150, // scale
      x = 480, y = 250, // translate
      lambda = 0, phi = 0, // center
      deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
      alpha = 0, // post-rotate
      theta = null, preclip = clipAntimeridian, // pre-clip angle
      x0 = null, y0, x1, y1, postclip = identity, // post-clip extent
      delta2 = 0.5, // precision
      projectResample,
      projectTransform,
      projectRotateTransform,
      cache,
      cacheStream;

  function projection(point) {
    return projectRotateTransform(point[0] * radians, point[1] * radians);
  }

  function invert(point) {
    point = projectRotateTransform.invert(point[0], point[1]);
    return point && [point[0] * degrees, point[1] * degrees];
  }

  projection.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function(_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
  };

  projection.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };

  projection.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };

  projection.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };

  projection.precision = function(_) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt(delta2);
  };

  projection.fitExtent = function(extent, object) {
    return fitExtent(projection, extent, object);
  };

  projection.fitSize = function(size, object) {
    return fitSize(projection, size, object);
  };

  projection.fitWidth = function(width, object) {
    return fitWidth(projection, width, object);
  };

  projection.fitHeight = function(height, object) {
    return fitHeight(projection, height, object);
  };

  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, alpha).apply(null, project(lambda, phi)),
        transform$$1 = (alpha ? scaleTranslateRotate : scaleTranslate)(k, x - center[0], y - center[1], alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform$$1);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function() {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = pi / 3,
      m = projectionMutator(projectAt),
      p = m(phi0, phi1);

  p.parallels = function(_) {
    return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };

  return p;
}

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin(phi) / cosPhi0];
  }

  forward.invert = function(x, y) {
    return [x / cosPhi0, asin(y * cosPhi0)];
  };

  return forward;
}

function conicEqualAreaRaw(y0, y1) {
  var sy0 = sin(y0), n = (sy0 + sin(y1)) / 2;

  // Are the parallels symmetrical around the Equator?
  if (abs(n) < epsilon) return cylindricalEqualAreaRaw(y0);

  var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt(c) / n;

  function project(x, y) {
    var r = sqrt(c - 2 * n * sin(y)) / n;
    return [r * sin(x *= n), r0 - r * cos(x)];
  }

  project.invert = function(x, y) {
    var r0y = r0 - y;
    return [atan2(x, abs(r0y)) / n * sign(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw)
      .scale(155.424)
      .center([0, 33.6442]);
}

function albers() {
  return conicEqualArea()
      .parallels([29.5, 45.5])
      .scale(1070)
      .translate([480, 250])
      .rotate([96, 0])
      .center([-0.6, 38.7]);
}

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
    sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
    lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
    lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
    polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
    polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
  };
}

// A composite projection for the United States, configured by default for
// 960500. The projection also works quite well at 960600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
function albersUsa() {
  var cache,
      cacheStream,
      lower48 = albers(), lower48Point,
      alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
      hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
      point, pointStream = {point: function(x, y) { point = [x, y]; }};

  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point)
        || (alaskaPoint.point(x, y), point)
        || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function(coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
        : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
        : lower48).invert(coordinates);
  };

  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function(_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function(_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function(_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(), x = +_[0], y = +_[1];

    lower48Point = lower48
        .translate(_)
        .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
        .stream(pointStream);

    alaskaPoint = alaska
        .translate([x - 0.307 * k, y + 0.201 * k])
        .clipExtent([[x - 0.425 * k + epsilon, y + 0.120 * k + epsilon], [x - 0.214 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    hawaiiPoint = hawaii
        .translate([x - 0.205 * k, y + 0.212 * k])
        .clipExtent([[x - 0.214 * k + epsilon, y + 0.166 * k + epsilon], [x - 0.115 * k - epsilon, y + 0.234 * k - epsilon]])
        .stream(pointStream);

    return reset();
  };

  albersUsa.fitExtent = function(extent, object) {
    return fitExtent(albersUsa, extent, object);
  };

  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };

  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };

  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}

function azimuthalRaw(scale) {
  return function(x, y) {
    var cx = cos(x),
        cy = cos(y),
        k = scale(cx * cy);
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  }
}

function azimuthalInvert(angle) {
  return function(x, y) {
    var z = sqrt(x * x + y * y),
        c = angle(z),
        sc = sin(c),
        cc = cos(c);
    return [
      atan2(x * sc, z * cc),
      asin(z && y * sc / z)
    ];
  }
}

var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt(2 / (1 + cxcy));
});

azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw)
      .scale(124.75)
      .clipAngle(180 - 1e-3);
}

var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
  return (c = acos(c)) && c / sin(c);
});

azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw)
      .scale(79.4188)
      .clipAngle(180 - 1e-3);
}

function mercatorRaw(lambda, phi) {
  return [lambda, log(tan((halfPi + phi) / 2))];
}

mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

function mercator() {
  return mercatorProjection(mercatorRaw)
      .scale(961 / tau);
}

function mercatorProjection(project) {
  var m = projection(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null, y0, x1, y1; // clip extent

  m.scale = function(_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function(_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function(_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = pi * scale(),
        t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null
        ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
        ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
        : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}

function tany(y) {
  return tan((halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : log(cy0 / cos(y1)) / log(tany(y1) / tany(y0)),
      f = cy0 * pow(tany(y0), n) / n;

  if (!n) return mercatorRaw;

  function project(x, y) {
    if (f > 0) { if (y < -halfPi + epsilon) y = -halfPi + epsilon; }
    else { if (y > halfPi - epsilon) y = halfPi - epsilon; }
    var r = f / pow(tany(y), n);
    return [r * sin(n * x), f - r * cos(n * x)];
  }

  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt(x * x + fy * fy);
    return [atan2(x, abs(fy)) / n * sign(fy), 2 * atan(pow(f / r, 1 / n)) - halfPi];
  };

  return project;
}

function conicConformal() {
  return conicProjection(conicConformalRaw)
      .scale(109.5)
      .parallels([30, 30]);
}

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function equirectangular() {
  return projection(equirectangularRaw)
      .scale(152.63);
}

function conicEquidistantRaw(y0, y1) {
  var cy0 = cos(y0),
      n = y0 === y1 ? sin(y0) : (cy0 - cos(y1)) / (y1 - y0),
      g = cy0 / n + y0;

  if (abs(n) < epsilon) return equirectangularRaw;

  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin(nx), g - gy * cos(nx)];
  }

  project.invert = function(x, y) {
    var gy = g - y;
    return [atan2(x, abs(gy)) / n * sign(gy), g - sign(n) * sqrt(x * x + gy * gy)];
  };

  return project;
}

function conicEquidistant() {
  return conicProjection(conicEquidistantRaw)
      .scale(131.154)
      .center([0, 13.9389]);
}

function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

gnomonicRaw.invert = azimuthalInvert(atan);

function gnomonic() {
  return projection(gnomonicRaw)
      .scale(144.049)
      .clipAngle(60);
}

function scaleTranslate$1(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity : transformer({
    point: function(x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function identity$1() {
  var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform$$1 = identity, // scale, translate and reflect
      x0 = null, y0, x1, y1, // clip extent
      postclip = identity,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = transform$$1(postclip(cacheStream = stream));
    },
    postclip: function(_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function(_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate$1((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate$1(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function(_) {
      return arguments.length ? (transform$$1 = scaleTranslate$1(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function(extent, object) {
      return fitExtent(projection, extent, object);
    },
    fitSize: function(size, object) {
      return fitSize(projection, size, object);
    },
    fitWidth: function(width, object) {
      return fitWidth(projection, width, object);
    },
    fitHeight: function(height, object) {
      return fitHeight(projection, height, object);
    }
  };
}

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
  ];
}

naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
        (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
    phi
  ];
};

function naturalEarth1() {
  return projection(naturalEarth1Raw)
      .scale(175.295);
}

function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}

orthographicRaw.invert = azimuthalInvert(asin);

function orthographic() {
  return projection(orthographicRaw)
      .scale(249.5)
      .clipAngle(90 + epsilon);
}

function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}

stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});

function stereographic() {
  return projection(stereographicRaw)
      .scale(250)
      .clipAngle(142);
}

function transverseMercatorRaw(lambda, phi) {
  return [log(tan((halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function(_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function(_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90])
      .scale(159.155);
}

exports.geoArea = area;
exports.geoBounds = bounds;
exports.geoCentroid = centroid;
exports.geoCircle = circle;
exports.geoClipAntimeridian = clipAntimeridian;
exports.geoClipCircle = clipCircle;
exports.geoClipExtent = extent;
exports.geoClipRectangle = clipRectangle;
exports.geoContains = contains;
exports.geoDistance = distance;
exports.geoGraticule = graticule;
exports.geoGraticule10 = graticule10;
exports.geoInterpolate = interpolate;
exports.geoLength = length;
exports.geoPath = index;
exports.geoAlbers = albers;
exports.geoAlbersUsa = albersUsa;
exports.geoAzimuthalEqualArea = azimuthalEqualArea;
exports.geoAzimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
exports.geoAzimuthalEquidistant = azimuthalEquidistant;
exports.geoAzimuthalEquidistantRaw = azimuthalEquidistantRaw;
exports.geoConicConformal = conicConformal;
exports.geoConicConformalRaw = conicConformalRaw;
exports.geoConicEqualArea = conicEqualArea;
exports.geoConicEqualAreaRaw = conicEqualAreaRaw;
exports.geoConicEquidistant = conicEquidistant;
exports.geoConicEquidistantRaw = conicEquidistantRaw;
exports.geoEquirectangular = equirectangular;
exports.geoEquirectangularRaw = equirectangularRaw;
exports.geoGnomonic = gnomonic;
exports.geoGnomonicRaw = gnomonicRaw;
exports.geoIdentity = identity$1;
exports.geoProjection = projection;
exports.geoProjectionMutator = projectionMutator;
exports.geoMercator = mercator;
exports.geoMercatorRaw = mercatorRaw;
exports.geoNaturalEarth1 = naturalEarth1;
exports.geoNaturalEarth1Raw = naturalEarth1Raw;
exports.geoOrthographic = orthographic;
exports.geoOrthographicRaw = orthographicRaw;
exports.geoStereographic = stereographic;
exports.geoStereographicRaw = stereographicRaw;
exports.geoTransverseMercator = transverseMercator;
exports.geoTransverseMercatorRaw = transverseMercatorRaw;
exports.geoRotation = rotation;
exports.geoStream = geoStream;
exports.geoTransform = transform;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":9}],24:[function(require,module,exports){
// https://d3js.org/d3-hierarchy/ Version 1.1.6. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;
  while (children = node.children) node = children[0];
  return node;
}

function leafRight(node) {
  var children;
  while (children = node.children) node = children[children.length - 1];
  return node;
}

var cluster = function() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0;

    // First walk, computing the initial x & y values.
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });

    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2;

    // Second walk, normalizing x & y to the desired size.
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function(x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
  };

  cluster.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
  };

  return cluster;
};

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

var node_count = function() {
  return this.eachAfter(count);
};

var node_each = function(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
};

var node_eachBefore = function(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
};

var node_eachAfter = function(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
};

var node_sum = function(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
};

var node_sort = function(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
};

var node_path = function(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
};

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

var node_ancestors = function() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
};

var node_descendants = function() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
};

var node_leaves = function() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
};

var node_links = function() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Dont include the roots parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
};

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

var enclose = function(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
};

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node$1(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node$1(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // Closeness is determined by linear distance along the front-chain.
    // Ahead or behind is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

var siblings = function(circles) {
  packEnclose(circles);
  return circles;
};

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

var constant = function(x) {
  return function() {
    return x;
  };
};

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

var index = function() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
};

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

var roundNode = function(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
};

var treemapDice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
};

var partition = function() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 =
    root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(dy, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }
      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function(x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function(x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
};

var keyPrefix = "$";
var preroot = {depth: -1};
var ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

var stratify = function() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
};

function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

// function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }

// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}

// This function works analogously to nextLeft.
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}

// Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}

// All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).
function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}

// If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
// returns the specified (default) ancestor.
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor
  this.a = this; // ancestor
  this.z = 0; // prelim
  this.m = 0; // mod
  this.c = 0; // change
  this.s = 0; // shift
  this.t = null; // thread
  this.i = i; // number
}

TreeNode.prototype = Object.create(Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
}

// Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
var tree = function() {
  var separation = defaultSeparation$1,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root);

    // Compute the layout using Buchheim et al.s algorithm.
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);

    // If a fixed node size is specified, scale x and y.
    if (nodeSize) root.eachBefore(sizeNode);

    // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
      var left = root,
          right = root,
          bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s = left === right ? 1 : separation(left, right) / 2,
          tx = s - left.x,
          kx = dx / (right.x + s + tx),
          ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }

    return root;
  }

  // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.
  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  }

  // Computes all real x-coordinates by summing up the modifiers recursively.
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }

  // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function(x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
  };

  tree.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
  };

  return tree;
};

var treemapSlice = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
};

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = ((function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}))(phi);

var index$1 = function() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
};

var binary = function(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i, n = nodes.length,
      sum, sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = (value / 2) + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;
      else hi = mid;
    }

    if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if ((x1 - x0) > (y1 - y0)) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
};

var sliceDice = function(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
};

var resquarify = ((function custom(ratio) {

  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && (rows.ratio === ratio)) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
        if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
        else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}))(phi);

exports.cluster = cluster;
exports.hierarchy = hierarchy;
exports.pack = index;
exports.packSiblings = siblings;
exports.packEnclose = enclose;
exports.partition = partition;
exports.stratify = stratify;
exports.tree = tree;
exports.treemap = index$1;
exports.treemapBinary = binary;
exports.treemapDice = treemapDice;
exports.treemapSlice = treemapSlice;
exports.treemapSliceDice = sliceDice;
exports.treemapSquarify = squarify;
exports.treemapResquarify = resquarify;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],25:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ Version 1.2.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

var basis$1 = function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var basisClosed = function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var constant = function(x) {
  return function() {
    return x;
  };
};

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb$1 = ((function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
}))(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = d3Color.rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var array = function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
};

var date = function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
};

var number = function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
};

var object = function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

var string = function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
};

var value = function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
      : b instanceof d3Color.color ? rgb$1
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
      : number)(a, b);
};

var round = function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
var zoom = function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0  u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
};

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

function piecewise(interpolate, values) {
  var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
  while (i < n) I[i] = interpolate(v, v = values[++i]);
  return function(t) {
    var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i](t - i);
  };
}

var quantize = function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
};

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb$1;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.piecewise = piecewise;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":14}],26:[function(require,module,exports){
// https://d3js.org/d3-path/ Version 1.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var pi = Math.PI;
var tau = 2 * pi;
var epsilon = 1e-6;
var tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath
  this._ = "";
}

function path() {
  return new Path;
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function(x1, y1, x, y) {
    this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) {
    this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {}

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    }

    // Otherwise, draw an arc!
    else {
      var x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }

      this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is the radius negative? Error.
    if (r < 0) throw new Error("negative radius: " + r);

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }

    // Is this arc empty? Were done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau + tau;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
    }
  },
  rect: function(x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
  },
  toString: function() {
    return this._;
  }
};

exports.path = path;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],27:[function(require,module,exports){
// https://d3js.org/d3-polygon/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var area = function(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
};

var centroid = function(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
};

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
var cross = function(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
};

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
}

// Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.
function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

var hull = function(points) {
  if ((n = points.length) < 3) return null;

  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints);

  // Construct the hull polygon, removing possible duplicate endpoints.
  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = [];

  // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.
  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
};

var contains = function(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0], y = point[1],
      x0 = p[0], y0 = p[1],
      x1, y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
};

var length = function(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
};

exports.polygonArea = area;
exports.polygonCentroid = centroid;
exports.polygonHull = hull;
exports.polygonContains = contains;
exports.polygonLength = length;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],28:[function(require,module,exports){
// https://d3js.org/d3-quadtree/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var tree_add = function(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
};

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, inherit the existing extent.
  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}

var tree_cover = function(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries dont change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
    var z = x1 - x0,
        node = this._root,
        parent,
        i;

    switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
      case 0: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
        break;
      }
      case 1: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
        break;
      }
      case 2: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
        break;
      }
      case 3: {
        do parent = new Array(4), parent[i] = node, node = parent;
        while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
        break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  // If the quadtree covers the point already, just return.
  else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
};

var tree_data = function() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
};

var tree_extent = function(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
};

var Quad = function(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
};

var tree_find = function(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new Quad(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant cant contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new Quad(node[3], xm, ym, x2, y2),
        new Quad(node[2], x1, ym, xm, y2),
        new Quad(node[1], xm, y1, x2, ym),
        new Quad(node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isnt necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
};

var tree_remove = function(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
};

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

var tree_root = function() {
  return this._root;
};

var tree_size = function() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
};

var tree_visit = function(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
    }
  }
  return this;
};

var tree_visitAfter = function(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
};

function defaultX(d) {
  return d[0];
}

var tree_x = function(_) {
  return arguments.length ? (this._x = _, this) : this._x;
};

function defaultY(d) {
  return d[1];
}

var tree_y = function(_) {
  return arguments.length ? (this._y = _, this) : this._y;
};

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;

exports.quadtree = quadtree;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],29:[function(require,module,exports){
// https://d3js.org/d3-random/ Version 1.1.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var defaultSource = function() {
  return Math.random();
};

var uniform = ((function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;
    else max -= min;
    return function() {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;

  return randomUniform;
}))(defaultSource);

var normal = ((function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y;

      // If available, use the second previously-generated uniform random.
      if (x != null) y = x, x = null;

      // Otherwise, generate a new x and y.
      else do {
        x = source() * 2 - 1;
        y = source() * 2 - 1;
        r = x * x + y * y;
      } while (!r || r > 1);

      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;

  return randomNormal;
}))(defaultSource);

var logNormal = ((function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;

  return randomLogNormal;
}))(defaultSource);

var irwinHall = ((function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();
      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;

  return randomIrwinHall;
}))(defaultSource);

var bates = ((function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;

  return randomBates;
}))(defaultSource);

var exponential = ((function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;

  return randomExponential;
}))(defaultSource);

exports.randomUniform = uniform;
exports.randomNormal = normal;
exports.randomLogNormal = logNormal;
exports.randomBates = bates;
exports.randomIrwinHall = irwinHall;
exports.randomExponential = exponential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],30:[function(require,module,exports){
// https://d3js.org/d3-scale-chromatic/ Version 1.3.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-interpolate'), require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3));
}(this, (function (exports,d3Interpolate,d3Color) { 'use strict';

function colors(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

function ramp(scheme) {
  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
}

var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);

var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);

var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);

var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);

var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);

var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);

var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);

var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);

var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);

var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);

var BuGn = ramp(scheme$9);

var scheme$10 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);

var BuPu = ramp(scheme$10);

var scheme$11 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);

var GnBu = ramp(scheme$11);

var scheme$12 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);

var OrRd = ramp(scheme$12);

var scheme$13 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);

var PuBuGn = ramp(scheme$13);

var scheme$14 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);

var PuBu = ramp(scheme$14);

var scheme$15 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);

var PuRd = ramp(scheme$15);

var scheme$16 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);

var RdPu = ramp(scheme$16);

var scheme$17 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);

var YlGnBu = ramp(scheme$17);

var scheme$18 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);

var YlGn = ramp(scheme$18);

var scheme$19 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);

var YlOrBr = ramp(scheme$19);

var scheme$20 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);

var YlOrRd = ramp(scheme$20);

var scheme$21 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);

var Blues = ramp(scheme$21);

var scheme$22 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);

var Greens = ramp(scheme$22);

var scheme$23 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);

var Greys = ramp(scheme$23);

var scheme$24 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);

var Purples = ramp(scheme$24);

var scheme$25 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);

var Reds = ramp(scheme$25);

var scheme$26 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);

var Oranges = ramp(scheme$26);

var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var c = d3Color.cubehelix();

function rainbow(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c.h = 360 * t - 100;
  c.s = 1.5 - 1.5 * ts;
  c.l = 0.8 - 0.9 * ts;
  return c + "";
}

var c$1 = d3Color.rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

function sinebow(t) {
  var x;
  t = (0.5 - t) * Math.PI;
  c$1.r = 255 * (x = Math.sin(t)) * x;
  c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
  c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
  return c$1 + "";
}

function ramp$1(range) {
  var n = range.length;
  return function(t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp$1(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp$1(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp$1(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp$1(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

exports.schemeCategory10 = category10;
exports.schemeAccent = Accent;
exports.schemeDark2 = Dark2;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.interpolateBrBG = BrBG;
exports.schemeBrBG = scheme;
exports.interpolatePRGn = PRGn;
exports.schemePRGn = scheme$1;
exports.interpolatePiYG = PiYG;
exports.schemePiYG = scheme$2;
exports.interpolatePuOr = PuOr;
exports.schemePuOr = scheme$3;
exports.interpolateRdBu = RdBu;
exports.schemeRdBu = scheme$4;
exports.interpolateRdGy = RdGy;
exports.schemeRdGy = scheme$5;
exports.interpolateRdYlBu = RdYlBu;
exports.schemeRdYlBu = scheme$6;
exports.interpolateRdYlGn = RdYlGn;
exports.schemeRdYlGn = scheme$7;
exports.interpolateSpectral = Spectral;
exports.schemeSpectral = scheme$8;
exports.interpolateBuGn = BuGn;
exports.schemeBuGn = scheme$9;
exports.interpolateBuPu = BuPu;
exports.schemeBuPu = scheme$10;
exports.interpolateGnBu = GnBu;
exports.schemeGnBu = scheme$11;
exports.interpolateOrRd = OrRd;
exports.schemeOrRd = scheme$12;
exports.interpolatePuBuGn = PuBuGn;
exports.schemePuBuGn = scheme$13;
exports.interpolatePuBu = PuBu;
exports.schemePuBu = scheme$14;
exports.interpolatePuRd = PuRd;
exports.schemePuRd = scheme$15;
exports.interpolateRdPu = RdPu;
exports.schemeRdPu = scheme$16;
exports.interpolateYlGnBu = YlGnBu;
exports.schemeYlGnBu = scheme$17;
exports.interpolateYlGn = YlGn;
exports.schemeYlGn = scheme$18;
exports.interpolateYlOrBr = YlOrBr;
exports.schemeYlOrBr = scheme$19;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeYlOrRd = scheme$20;
exports.interpolateBlues = Blues;
exports.schemeBlues = scheme$21;
exports.interpolateGreens = Greens;
exports.schemeGreens = scheme$22;
exports.interpolateGreys = Greys;
exports.schemeGreys = scheme$23;
exports.interpolatePurples = Purples;
exports.schemePurples = scheme$24;
exports.interpolateReds = Reds;
exports.schemeReds = scheme$25;
exports.interpolateOranges = Oranges;
exports.schemeOranges = scheme$26;
exports.interpolateCubehelixDefault = cubehelix$1;
exports.interpolateRainbow = rainbow;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateSinebow = sinebow;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":14,"d3-interpolate":25}],31:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 2.0.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat) { 'use strict';

var array = Array.prototype;

var map$1 = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal(range$$1) {
  var index = d3Collection.map(),
      domain = [],
      unknown = implicit;

  range$$1 = range$$1 == null ? [] : slice.call(range$$1);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range$$1[(i - 1) % range$$1.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), scale) : range$$1.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range$$1)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

function constant(x) {
  return function() {
    return x;
  };
}

function number(x) {
  return +x;
}

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range$$1, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range$$1, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range$$1.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range$$1 = range$$1.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range$$1 = unit,
      interpolate$$1 = d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = slice.call(_), interpolate$$1 = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

function tickFormat(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
}

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    if (count == null) count = 10;

    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = d3Array.tickIncrement(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = d3Array.tickIncrement(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = d3Array.tickIncrement(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range$$1 = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range$$1.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range$$1[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range$$1 = [0, 1];

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range$$1 = slice.call(_)).length - 1, rescale()) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range$$1);
  };

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range$$1 = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format$$1) {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format$$1(".%L"),
      formatSecond = format$$1(":%S"),
      formatMinute = format$$1("%I:%M"),
      formatHour = format$$1("%I %p"),
      formatDay = format$$1("%a %d"),
      formatWeek = format$$1("%b %d"),
      formatMonth = format$$1("%B"),
      formatYear = format$$1("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max(d3Array.tickStep(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format$$1(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format$$1));
  };

  return scale;
}

function time() {
  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}

function utcTime() {
  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile$1;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.scaleSequential = sequential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":9,"d3-collection":13,"d3-format":22,"d3-interpolate":25,"d3-time":35,"d3-time-format":34}],32:[function(require,module,exports){
// https://d3js.org/d3-selection/ Version 1.3.0. Copyright 2018 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var xhtml = "http://www.w3.org/1999/xhtml";

var namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

var matcher = function(selector) {
  return function() {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector
        || element.msMatchesSelector
        || element.mozMatchesSelector
        || element.oMatchesSelector;
    matcher = function(selector) {
      return function() {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var matcher$1 = matcher;

function selection_filter(match) {
  if (typeof match !== "function") match = matcher$1(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like __proto__.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that dont fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_merge(selection$$1) {

  for (var groups0 = this._groups, groups1 = selection$$1._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

exports.event = null;

if (typeof document !== "undefined") {
  var element$1 = document.documentElement;
  if (!("onmouseenter" in element$1)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = exports.event; // Events can be reentrant (e.g., focus).
    exports.event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = exports.event;
  event1.sourceEvent = exports.event;
  exports.event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event0;
  }
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

function create(name) {
  return select(creator(name).call(document.documentElement));
}

var nextId = 0;

function local() {
  return new Local;
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function(node) {
    var id = this._;
    while (!(id in node)) if (!(node = node.parentNode)) return;
    return node[id];
  },
  set: function(node, value) {
    return node[this._] = value;
  },
  remove: function(node) {
    return this._ in node && delete node[this._];
  },
  toString: function() {
    return this._;
  }
};

function sourceEvent() {
  var current = exports.event, source;
  while (source = current.sourceEvent) current = source;
  return current;
}

function point(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}

function mouse(node) {
  var event = sourceEvent();
  if (event.changedTouches) event = event.changedTouches[0];
  return point(node, event);
}

function selectAll(selector) {
  return typeof selector === "string"
      ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
      : new Selection([selector == null ? [] : selector], root);
}

function touch(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = sourceEvent().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return point(node, touch);
    }
  }

  return null;
}

function touches(node, touches) {
  if (touches == null) touches = sourceEvent().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point(node, touches[i]);
  }

  return points;
}

exports.create = create;
exports.creator = creator;
exports.local = local;
exports.matcher = matcher$1;
exports.mouse = mouse;
exports.namespace = namespace;
exports.namespaces = namespaces;
exports.clientPoint = point;
exports.select = select;
exports.selectAll = selectAll;
exports.selection = selection;
exports.selector = selector;
exports.selectorAll = selectorAll;
exports.style = styleValue;
exports.touch = touch;
exports.touches = touches;
exports.window = defaultView;
exports.customEvent = customEvent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],33:[function(require,module,exports){
// https://d3js.org/d3-shape/ Version 1.2.0. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-path')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-path'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Path) { 'use strict';

var constant = function(x) {
  return function constant() {
    return x;
  };
};

var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;

var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0, y10 = y1 - y0,
      x32 = x3 - x2, y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
}

// Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html
function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00;

  // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

var arc = function() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = constant(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - halfPi,
        a1 = endAngle.apply(this, arguments) - halfPi,
        da = abs(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = d3Path.path();

    // Ensure that the outer radius is always larger than the inner radius.
    if (r1 < r0) r = r1, r1 = r0, r0 = r;

    // Is it a point?
    if (!(r1 > epsilon)) context.moveTo(0, 0);

    // Or is it a circle or annulus?
    else if (da > tau - epsilon) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    }

    // Or is it a circular or annular sector?
    else {
      var a01 = a0,
          a11 = a1,
          a00 = a0,
          a10 = a1,
          da0 = da,
          da1 = da,
          ap = padAngle.apply(this, arguments) / 2,
          rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
          rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
          rc0 = rc,
          rc1 = rc,
          t0,
          t1;

      // Apply padding? Note that since r1  r0, da1  da0.
      if (rp > epsilon) {
        var p0 = asin(rp / r0 * sin(ap)),
            p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
        else da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
        else da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }

      var x01 = r1 * cos(a01),
          y01 = r1 * sin(a01),
          x10 = r0 * cos(a10),
          y10 = r0 * sin(a10);

      // Apply rounded corners?
      if (rc > epsilon) {
        var x11 = r1 * cos(a11),
            y11 = r1 * sin(a11),
            x00 = r0 * cos(a00),
            y00 = r0 * sin(a00);

        // Restrict the corner radius according to the sector angle.
        if (da < pi) {
          var oc = da0 > epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
              ax = x01 - oc[0],
              ay = y01 - oc[1],
              bx = x11 - oc[0],
              by = y11 - oc[1],
              kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
              lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }

      // Is the sector collapsed to a line?
      if (!(da1 > epsilon)) context.moveTo(x01, y01);

      // Does the sectors outer ring have rounded corners?
      else if (rc1 > epsilon) {
        t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
        t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

        context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
          context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the outer ring just a circular arc?
      else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

      // Is there no inner ring, and its a circular sector?
      // Or perhaps its an annular sector collapsed due to padding?
      if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

      // Does the sectors inner ring (or point) have rounded corners?
      else if (rc0 > epsilon) {
        t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

        context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

        // Have the corners merged?
        if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

        // Otherwise, draw the two corners and the ring.
        else {
          context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
          context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
          context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
        }
      }

      // Or is the inner ring just a circular arc?
      else context.arc(0, 0, r0, a10, a00, cw);
    }

    context.closePath();

    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a) * r, sin(a) * r];
  };

  arc.innerRadius = function(_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant(+_), arc) : innerRadius;
  };

  arc.outerRadius = function(_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function(_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant(+_), arc) : cornerRadius;
  };

  arc.padRadius = function(_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant(+_), arc) : padRadius;
  };

  arc.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), arc) : startAngle;
  };

  arc.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), arc) : endAngle;
  };

  arc.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), arc) : padAngle;
  };

  arc.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), arc) : context;
  };

  return arc;
};

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: this._context.lineTo(x, y); break;
    }
  }
};

var curveLinear = function(context) {
  return new Linear(context);
};

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}

var line = function() {
  var x$$1 = x,
      y$$1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x$$1(d, i, data), +y$$1(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), line) : x$$1;
  };

  line.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), line) : y$$1;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
};

var area = function() {
  var x0 = x,
      x1 = null,
      y0 = constant(0),
      y1 = y,
      defined = constant(true),
      context = null,
      curve = curveLinear,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = d3Path.path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var identity = function(d) {
  return d;
};

var pie = function() {
  var value = identity,
      sortValues = descending,
      sort = null,
      startAngle = constant(0),
      endAngle = constant(tau),
      padAngle = constant(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    }

    // Optionally sort the arcs by previously-computed values or by data.
    if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
    else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

    // Compute the arcs! They are stored in the original data's order.
    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), pie) : value;
  };

  pie.sortValues = function(_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function(_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function(_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant(+_), pie) : startAngle;
  };

  pie.endAngle = function(_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant(+_), pie) : endAngle;
  };

  pie.padAngle = function(_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant(+_), pie) : padAngle;
  };

  return pie;
};

var curveRadialLinear = curveRadial(curveLinear);

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {

  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;

  return radial;
}

function lineRadial(l) {
  var c = l.curve;

  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return l;
}

var lineRadial$1 = function() {
  return lineRadial(line().curve(curveRadialLinear));
};

var areaRadial = function() {
  var a = area().curve(curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;

  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
  a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
  a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
  a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

  a.curve = function(_) {
    return arguments.length ? c(curveRadial(_)) : c()._curve;
  };

  return a;
};

var pointRadial = function(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
};

var slice = Array.prototype.slice;

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x$$1 = x,
      y$$1 = y,
      context = null;

  function link() {
    var buffer, argv = slice.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
    if (!context) context = buffer = d3Path.path();
    curve(context, +x$$1.apply(this, (argv[0] = s, argv)), +y$$1.apply(this, argv), +x$$1.apply(this, (argv[0] = t, argv)), +y$$1.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function(_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function(_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), link) : x$$1;
  };

  link.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), link) : y$$1;
  };

  link.context = function(_) {
    return arguments.length ? ((context = _ == null ? null : _), link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial$1(context, x0, y0, x1, y1) {
  var p0 = pointRadial(x0, y0),
      p1 = pointRadial(x0, y0 = (y0 + y1) / 2),
      p2 = pointRadial(x1, y0),
      p3 = pointRadial(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial$1);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}

var circle = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};

var cross = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};

var tan30 = Math.sqrt(1 / 3);
var tan30_2 = tan30 * 2;

var diamond = {
  draw: function(context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};

var ka = 0.89081309152928522810;
var kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;

var star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);
    for (var i = 1; i < 5; ++i) {
      var a = tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }
    context.closePath();
  }
};

var square = {
  draw: function(context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};

var sqrt3 = Math.sqrt(3);

var triangle = {
  draw: function(context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};

var c = -0.5;
var s = Math.sqrt(3) / 2;
var k = 1 / Math.sqrt(12);
var a = (k / 2 + 1) * 3;

var wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};

var symbols = [
  circle,
  cross,
  diamond,
  square,
  star,
  triangle,
  wye
];

var symbol = function() {
  var type = constant(circle),
      size = constant(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = d3Path.path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant(_), symbol) : type;
  };

  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant(+_), symbol) : size;
  };

  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
};

var noop = function() {};

function point(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point(this, this._x1, this._y1); // proceed
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basis = function(context) {
  return new Basis(context);
};

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisClosed = function(context) {
  return new BasisClosed(context);
};

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // proceed
      default: point(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

var basisOpen = function(context) {
  return new BasisOpen(context);
};

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

var bundle = ((function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
}))(0.85);

function point$1(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$1(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinal = ((function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalClosed = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$1(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var cardinalOpen = ((function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
}))(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRom = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomClosed = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // proceed
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var catmullRomOpen = ((function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}))(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

var linearClosed = function(context) {
  return new LinearClosed(context);
};

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bzier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$3(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$3(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$3(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$3(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

var natural = function(context) {
  return new Natural(context);
};

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // proceed
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

var step = function(context) {
  return new Step(context, 0.5);
};

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

var none = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
};

var none$1 = function(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0) o[n] = n;
  return o;
};

function stackValue(d, key) {
  return d[key];
}

var stack = function() {
  var keys = constant([]),
      order = none$1,
      offset = none,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function(_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : constant(slice.call(_)), stack) : keys;
  };

  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(+_), stack) : value;
  };

  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? none$1 : typeof _ === "function" ? _ : constant(slice.call(_)), stack) : order;
  };

  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? none : _, stack) : offset;
  };

  return stack;
};

var expand = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }
  none(series, order);
};

var diverging = function(series, order) {
  if (!((n = series.length) > 1)) return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
};

var silhouette = function(series, order) {
  if (!((n = series.length) > 0)) return;
  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y / 2;
  }
  none(series, order);
};

var wiggle = function(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;
      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y;
  none(series, order);
};

var ascending = function(series) {
  var sums = series.map(sum);
  return none$1(series).sort(function(a, b) { return sums[a] - sums[b]; });
};

function sum(series) {
  var s = 0, i = -1, n = series.length, v;
  while (++i < n) if (v = +series[i][1]) s += v;
  return s;
}

var descending$1 = function(series) {
  return ascending(series).reverse();
};

var insideOut = function(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(sum),
      order = none$1(series).sort(function(a, b) { return sums[b] - sums[a]; }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];
    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
};

var reverse = function(series) {
  return none$1(series).reverse();
};

exports.arc = arc;
exports.area = area;
exports.line = line;
exports.pie = pie;
exports.areaRadial = areaRadial;
exports.radialArea = areaRadial;
exports.lineRadial = lineRadial$1;
exports.radialLine = lineRadial$1;
exports.pointRadial = pointRadial;
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;
exports.symbol = symbol;
exports.symbols = symbols;
exports.symbolCircle = circle;
exports.symbolCross = cross;
exports.symbolDiamond = diamond;
exports.symbolSquare = square;
exports.symbolStar = star;
exports.symbolTriangle = triangle;
exports.symbolWye = wye;
exports.curveBasisClosed = basisClosed;
exports.curveBasisOpen = basisOpen;
exports.curveBasis = basis;
exports.curveBundle = bundle;
exports.curveCardinalClosed = cardinalClosed;
exports.curveCardinalOpen = cardinalOpen;
exports.curveCardinal = cardinal;
exports.curveCatmullRomClosed = catmullRomClosed;
exports.curveCatmullRomOpen = catmullRomOpen;
exports.curveCatmullRom = catmullRom;
exports.curveLinearClosed = linearClosed;
exports.curveLinear = curveLinear;
exports.curveMonotoneX = monotoneX;
exports.curveMonotoneY = monotoneY;
exports.curveNatural = natural;
exports.curveStep = step;
exports.curveStepAfter = stepAfter;
exports.curveStepBefore = stepBefore;
exports.stack = stack;
exports.stackOffsetExpand = expand;
exports.stackOffsetDiverging = diverging;
exports.stackOffsetNone = none;
exports.stackOffsetSilhouette = silhouette;
exports.stackOffsetWiggle = wiggle;
exports.stackOrderAscending = ascending;
exports.stackOrderDescending = descending$1;
exports.stackOrderInsideOut = insideOut;
exports.stackOrderNone = none$1;
exports.stackOrderReverse = reverse;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-path":26}],34:[function(require,module,exports){
// https://d3js.org/d3-time-format/ Version 2.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? d3Time.utcMonday.ceil(week) : d3Time.utcMonday(week);
          week = d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? d3Time.timeMonday.ceil(week) : d3Time.timeMonday(week);
          week = d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? d3Time.timeThursday(d) : d3Time.timeThursday.ceil(d);
  return pad(d3Time.timeThursday.count(d3Time.timeYear(d), d) + (d3Time.timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? d3Time.utcThursday(d) : d3Time.utcThursday.ceil(d);
  return pad(d3Time.utcThursday.count(d3Time.utcYear(d), d) + (d3Time.utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;





defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.timeFormat = locale.format;
  exports.timeParse = locale.parse;
  exports.utcFormat = locale.utcFormat;
  exports.utcParse = locale.utcParse;
  return locale;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":35}],35:[function(require,module,exports){
// https://d3js.org/d3-time/ Version 1.0.8. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date;
var t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [], previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],36:[function(require,module,exports){
// https://d3js.org/d3-timer/ Version 1.0.7. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var frame = 0;
var timeout = 0;
var interval = 0;
var pokeDelay = 1000;
var taskHead;
var taskTail;
var clockLast = 0;
var clockNow = 0;
var clockSkew = 0;
var clock = typeof performance === "object" && performance.now ? performance : Date;
var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend weve set an alarm, if we havent already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

var timeout$1 = function(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
};

var interval$1 = function(callback, delay, time) {
  var t = new Timer, total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? now() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
};

exports.now = now;
exports.timer = timer;
exports.timerFlush = timerFlush;
exports.timeout = timeout$1;
exports.interval = interval$1;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],37:[function(require,module,exports){
// https://d3js.org/d3-transition/ Version 1.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-dispatch'), require('d3-timer'), require('d3-interpolate'), require('d3-color'), require('d3-ease')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-dispatch', 'd3-timer', 'd3-interpolate', 'd3-color', 'd3-ease'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Selection,d3Dispatch,d3Timer,d3Interpolate,d3Color,d3Ease) { 'use strict';

var emptyOn = d3Dispatch.dispatch("start", "end", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

var schedule = function(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
};

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = d3Timer.timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return d3Timer.timeout(start);

      // Interrupt the active transition, if any.
      // Dispatch the interrupt event.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    d3Timer.timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

var interrupt = function(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
};

var selection_interrupt = function(name) {
  return this.each(function() {
    interrupt(this, name);
  });
};

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and were done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

var transition_tween = function(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
};

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

var interpolate = function(a, b) {
  var c;
  return (typeof b === "number" ? d3Interpolate.interpolateNumber
      : b instanceof d3Color.color ? d3Interpolate.interpolateRgb
      : (c = d3Color.color(b)) ? (b = c, d3Interpolate.interpolateRgb)
      : d3Interpolate.interpolateString)(a, b);
};

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0, value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

var transition_attr = function(name, value) {
  var fullname = d3Selection.namespace(name), i = fullname === "transform" ? d3Interpolate.interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
};

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.setAttribute(name, i(t));
    };
  }
  tween._value = value;
  return tween;
}

var transition_attrTween = function(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = d3Selection.namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
};

function delayFunction(id, value) {
  return function() {
    init(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init(this, id).delay = value;
  };
}

var transition_delay = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
};

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

var transition_duration = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
};

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

var transition_ease = function(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
};

var transition_filter = function(match) {
  if (typeof match !== "function") match = d3Selection.matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
};

var transition_merge = function(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
};

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and were done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

var transition_on = function(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
};

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

var transition_remove = function() {
  return this.on("end.remove", removeFunction(this._id));
};

var transition_select = function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
};

var transition_selectAll = function(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = d3Selection.selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
};

var Selection = d3Selection.selection.prototype.constructor;

var transition_selection = function() {
  return new Selection(this._groups, this._parents);
};

function styleRemove(name, interpolate$$1) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate$$1, value1) {
  var value00,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name);
    return value0 === value1 ? null
        : value0 === value00 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate$$1, value) {
  var value00,
      value10,
      interpolate0;
  return function() {
    var value0 = d3Selection.style(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), d3Selection.style(this, name));
    return value0 === value1 ? null
        : value0 === value00 && value1 === value10 ? interpolate0
        : interpolate0 = interpolate$$1(value00 = value0, value10 = value1);
  };
}

var transition_style = function(name, value, priority) {
  var i = (name += "") === "transform" ? d3Interpolate.interpolateTransformCss : interpolate;
  return value == null ? this
          .styleTween(name, styleRemove(name, i))
          .on("end.style." + name, styleRemoveEnd(name))
      : this.styleTween(name, typeof value === "function"
          ? styleFunction(name, i, tweenValue(this, "style." + name, value))
          : styleConstant(name, i, value + ""), priority);
};

function styleTween(name, value, priority) {
  function tween() {
    var node = this, i = value.apply(node, arguments);
    return i && function(t) {
      node.style.setProperty(name, i(t), priority);
    };
  }
  tween._value = value;
  return tween;
}

var transition_styleTween = function(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
};

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

var transition_text = function(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
};

var transition_transition = function() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
};

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return d3Selection.selection().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = d3Selection.selection.prototype;

Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease
};

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = d3Timer.now(), defaultTiming;
    }
  }
  return timing;
}

var selection_transition = function(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = d3Timer.now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
};

d3Selection.selection.prototype.interrupt = selection_interrupt;
d3Selection.selection.prototype.transition = selection_transition;

var root = [null];

var active = function(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
        return new Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
};

exports.transition = transition;
exports.active = active;
exports.interrupt = interrupt;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":14,"d3-dispatch":16,"d3-ease":19,"d3-interpolate":25,"d3-selection":32,"d3-timer":36}],38:[function(require,module,exports){
// https://d3js.org/d3-voronoi/ Version 1.1.2. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,

  insert: function(after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;
      if (after.R) {
        after = after.R;
        while (after.L) after = after.L;
        after.L = node;
      } else {
        after.R = node;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }
    node.L = node.R = null;
    node.U = parent;
    node.C = true;

    after = node;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },

  remove: function(node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;

    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;

    if (!left) next = right;
    else if (!right) next = left;
    else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;
      else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;
      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;
    if (node && node.C) { node.C = false; return; }

    do {
      if (node === this._) break;
      if (node === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if ((sibling.L && sibling.L.C)
            || (sibling.R && sibling.R.C)) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if ((sibling.L && sibling.L.C)
          || (sibling.R && sibling.R.C)) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }
      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;
    else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;
  return node;
}

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);
  cells[left.index].halfedges.push(index);
  cells[right.index].halfedges.push(index);
  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}

// LiangBarsky line clipping.
function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;

  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;

  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;
    if (lx > rx) {
      if (!v0) v0 = [fx, y0];
      else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];
      else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];
        else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];
        else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];
        else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];
        else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
        || !clipEdge(edge, x0, y0, x1, y1)
        || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon
            || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges[i];
    }
  }
}

function createCell(site) {
  return cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];
  else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);
      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
      index.sort(function(i, j) { return array[j] - array[i]; });
      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];
      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;

      // Remove any dangling clipped edges.
      while (iHalfedge--) {
        if (!edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }

      // Insert any border edges as necessary.
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,
              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]
              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]
              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]
              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]
              : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  }

  // If there werent any edges, have the closest site cover the extent.
  // It doesnt matter which corner of the extent we measure!
  if (cover) {
    var dx, dy, d2, dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
      cover.halfedges.push(
        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges.push(createBorderEdge(site, v01, v11)) - 1,
        edges.push(createBorderEdge(site, v11, v10)) - 1,
        edges.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }

  // Lastly delete any cells with no edges; these were entirely clipped.
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}

var circlePool = [];

var firstCircle;

function Circle() {
  RedBlackNode(this);
  this.x =
  this.y =
  this.arc =
  this.site =
  this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;

  if (!lArc || !rArc) return;

  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;

  if (lSite === rSite) return;

  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;

  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2) return;

  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;

  var circle = circlePool.pop() || new Circle;
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;

  var before = null,
      node = circles._;

  while (node) {
    if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
      if (node.L) node = node.L;
      else { before = node.P; break; }
    } else {
      if (node.R) node = node.R;
      else { before = node; break; }
    }
  }

  circles.insert(before, circle);
  if (!before) firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;
  if (circle) {
    if (!circle.P) firstCircle = circle.N;
    circles.remove(circle);
    circlePool.push(circle);
    RedBlackNode(circle);
    arc.circle = null;
  }
}

var beachPool = [];

function Beach() {
  RedBlackNode(this);
  this.edge =
  this.site =
  this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach;
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];

  detachBeach(beach);

  var lArc = previous;
  while (lArc.circle
      && Math.abs(x - lArc.circle.x) < epsilon
      && Math.abs(y - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  detachCircle(lArc);

  var rArc = next;
  while (rArc.circle
      && Math.abs(x - rArc.circle.x) < epsilon
      && Math.abs(y - rArc.circle.cy) < epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  detachCircle(rArc);

  var nArcs = disappearing.length,
      iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);

  attachCircle(lArc);
  attachCircle(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > epsilon) node = node.L; else {
      dxr = x - rightBreakPoint(node, directrix);
      if (dxr > epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }
        node = node.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }
        break;
      }
    }
  }

  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }

  if (!rArc) { // && lArc
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }

  // else lArc !== rArc
  detachCircle(lArc);
  detachCircle(rArc);

  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];

  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;

  if (!pby2) return rfocx;

  var lArc = arc.P;
  if (!lArc) return -Infinity;

  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;

  if (!plby2) return lfocx;

  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;

  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;

  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1]
      || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;

  edges = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree;
  circles = new RedBlackTree;

  while (true) {
    circle = firstCircle;
    if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
      if (site[0] !== x || site[1] !== y) {
        addBeach(site);
        x = site[0], y = site[1];
      }
      site = sites.pop();
    } else if (circle) {
      removeBeach(circle.arc);
    } else {
      break;
    }
  }

  sortCellHalfedges();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    clipEdges(x0, y0, x1, y1);
    clipCells(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;

  beaches =
  circles =
  edges =
  cells = null;
}

Diagram.prototype = {
  constructor: Diagram,

  polygons: function() {
    var edges = this.edges;

    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) { return cellHalfedgeStart(cell, edges[i]); });
      polygon.data = cell.site.data;
      return polygon;
    });
  },

  triangles: function() {
    var triangles = [],
        edges = this.edges;

    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });

    return triangles;
  },

  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },

  find: function(x, y, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;

    // Use the previously-found cell, or start with an arbitrary one.
    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;
    var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;

    // Traverse the half-edges to find a closer cell, if any.
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;

    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};

var voronoi = function() {
  var x$$1 = x,
      y$$1 = y,
      extent = null;

  function voronoi(data) {
    return new Diagram(data.map(function(d, i) {
      var s = [Math.round(x$$1(d, i, data) / epsilon) * epsilon, Math.round(y$$1(d, i, data) / epsilon) * epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function(data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function(data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function(data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function(_) {
    return arguments.length ? (x$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : x$$1;
  };

  voronoi.y = function(_) {
    return arguments.length ? (y$$1 = typeof _ === "function" ? _ : constant(+_), voronoi) : y$$1;
  };

  voronoi.extent = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function(_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
};

exports.voronoi = voronoi;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],39:[function(require,module,exports){
// https://d3js.org/d3-zoom/ Version 1.7.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-dispatch'), require('d3-drag'), require('d3-interpolate'), require('d3-selection'), require('d3-transition')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-dispatch', 'd3-drag', 'd3-interpolate', 'd3-selection', 'd3-transition'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Dispatch,d3Drag,d3Interpolate,d3Selection,d3Transition) { 'use strict';

var constant = function(x) {
  return function() {
    return x;
  };
};

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

var identity = new Transform(1, 0, 0);

transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}

function nopropagation() {
  d3Selection.event.stopImmediatePropagation();
}

var noevent = function() {
  d3Selection.event.preventDefault();
  d3Selection.event.stopImmediatePropagation();
};

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !d3Selection.event.button;
}

function defaultExtent() {
  var e = this, w, h;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }
  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || identity;
}

function defaultWheelDelta() {
  return -d3Selection.event.deltaY * (d3Selection.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform$$1, extent, translateExtent) {
  var dx0 = transform$$1.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform$$1.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform$$1.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform$$1.invertY(extent[1][1]) - translateExtent[1][1];
  return transform$$1.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}

var zoom = function() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = d3Interpolate.interpolateZoom,
      gestures = [],
      listeners = d3Dispatch.dispatch("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection
        .property("__zoom", defaultTransform)
        .on("wheel.zoom", wheeled)
        .on("mousedown.zoom", mousedowned)
        .on("dblclick.zoom", dblclicked)
      .filter(touchable)
        .on("touchstart.zoom", touchstarted)
        .on("touchmove.zoom", touchmoved)
        .on("touchend.zoom touchcancel.zoom", touchended)
        .style("touch-action", "none")
        .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function(collection, transform$$1) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);
    if (collection !== selection) {
      schedule(collection, transform$$1);
    } else {
      selection.interrupt().each(function() {
        gesture(this, arguments)
            .start()
            .zoom(null, typeof transform$$1 === "function" ? transform$$1.apply(this, arguments) : transform$$1)
            .end();
      });
    }
  };

  zoom.scaleBy = function(selection, k) {
    zoom.scaleTo(selection, function() {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function(selection, k) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function(selection, x, y) {
    zoom.transform(selection, function() {
      return constrain(this.__zoom.translate(
        typeof x === "function" ? x.apply(this, arguments) : x,
        typeof y === "function" ? y.apply(this, arguments) : y
      ), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function(selection, x, y) {
    zoom.transform(selection, function() {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(
        typeof x === "function" ? -x.apply(this, arguments) : -x,
        typeof y === "function" ? -y.apply(this, arguments) : -y
      ), e, translateExtent);
    });
  };

  function scale(transform$$1, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform$$1.k ? transform$$1 : new Transform(k, transform$$1.x, transform$$1.y);
  }

  function translate(transform$$1, p0, p1) {
    var x = p0[0] - p1[0] * transform$$1.k, y = p0[1] - p1[1] * transform$$1.k;
    return x === transform$$1.x && y === transform$$1.y ? transform$$1 : new Transform(transform$$1.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform$$1, center) {
    transition
        .on("start.zoom", function() { gesture(this, arguments).start(); })
        .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).end(); })
        .tween("zoom", function() {
          var that = this,
              args = arguments,
              g = gesture(that, args),
              e = extent.apply(that, args),
              p = center || centroid(e),
              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
              a = that.__zoom,
              b = typeof transform$$1 === "function" ? transform$$1.apply(that, args) : transform$$1,
              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
          return function(t) {
            if (t === 1) t = b; // Avoid rounding error on end.
            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
            g.zoom(null, t);
          };
        });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }
    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform$$1) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform$$1.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform$$1.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform$$1.invert(this.touch1[0]);
      this.that.__zoom = transform$$1;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      d3Selection.customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = d3Selection.mouse(this);

    // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    }

    // If this wheel event wont trigger a transform change, ignore it.
    else if (t.k === k) return;

    // Otherwise, capture the mouse point and location at the start.
    else {
      g.mouse = [p, t.invert(p)];
      d3Transition.interrupt(this);
      g.start();
    }

    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = d3Selection.select(d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = d3Selection.mouse(this),
        x0 = d3Selection.event.clientX,
        y0 = d3Selection.event.clientY;

    d3Drag.dragDisable(d3Selection.event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    d3Transition.interrupt(this);
    g.start();

    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = d3Selection.event.clientX - x0, dy = d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = d3Selection.mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      d3Drag.dragEnable(d3Selection.event.view, g.moved);
      noevent();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = d3Selection.mouse(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);

    noevent();
    if (duration > 0) d3Selection.select(this).transition().duration(duration).call(schedule, t1, p0);
    else d3Selection.select(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        started,
        n = touches.length, i, t, p;

    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;
      else if (!g.touch1) g.touch1 = p;
    }

    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);
      if (!g.touch1) {
        g.end();
        p = d3Selection.select(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
      d3Transition.interrupt(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t, p, l;

    noevent();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    for (i = 0; i < n; ++i) {
      t = touches[i], p = d3Selection.touch(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1],
          p1 = g.touch1[0], l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    }
    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = d3Selection.event.changedTouches,
        n = touches.length, i, t;

    nopropagation();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() { touchending = null; }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else g.end();
  }

  zoom.wheelDelta = function(_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
  };

  zoom.filter = function(_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
  };

  zoom.touchable = function(_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
  };

  zoom.extent = function(_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function(_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function(_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function(_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function(_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function(_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function(_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
};

exports.zoom = zoom;
exports.zoomTransform = transform;
exports.zoomIdentity = identity;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-dispatch":16,"d3-drag":17,"d3-interpolate":25,"d3-selection":32,"d3-transition":37}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var d3Array = require('d3-array');
var d3Axis = require('d3-axis');
var d3Brush = require('d3-brush');
var d3Chord = require('d3-chord');
var d3Collection = require('d3-collection');
var d3Color = require('d3-color');
var d3Contour = require('d3-contour');
var d3Dispatch = require('d3-dispatch');
var d3Drag = require('d3-drag');
var d3Dsv = require('d3-dsv');
var d3Ease = require('d3-ease');
var d3Fetch = require('d3-fetch');
var d3Force = require('d3-force');
var d3Format = require('d3-format');
var d3Geo = require('d3-geo');
var d3Hierarchy = require('d3-hierarchy');
var d3Interpolate = require('d3-interpolate');
var d3Path = require('d3-path');
var d3Polygon = require('d3-polygon');
var d3Quadtree = require('d3-quadtree');
var d3Random = require('d3-random');
var d3Scale = require('d3-scale');
var d3ScaleChromatic = require('d3-scale-chromatic');
var d3Selection = require('d3-selection');
var d3Shape = require('d3-shape');
var d3Time = require('d3-time');
var d3TimeFormat = require('d3-time-format');
var d3Timer = require('d3-timer');
var d3Transition = require('d3-transition');
var d3Voronoi = require('d3-voronoi');
var d3Zoom = require('d3-zoom');

var version = "5.4.0";

Object.keys(d3Array).forEach(function (key) { exports[key] = d3Array[key]; });
Object.keys(d3Axis).forEach(function (key) { exports[key] = d3Axis[key]; });
Object.keys(d3Brush).forEach(function (key) { exports[key] = d3Brush[key]; });
Object.keys(d3Chord).forEach(function (key) { exports[key] = d3Chord[key]; });
Object.keys(d3Collection).forEach(function (key) { exports[key] = d3Collection[key]; });
Object.keys(d3Color).forEach(function (key) { exports[key] = d3Color[key]; });
Object.keys(d3Contour).forEach(function (key) { exports[key] = d3Contour[key]; });
Object.keys(d3Dispatch).forEach(function (key) { exports[key] = d3Dispatch[key]; });
Object.keys(d3Drag).forEach(function (key) { exports[key] = d3Drag[key]; });
Object.keys(d3Dsv).forEach(function (key) { exports[key] = d3Dsv[key]; });
Object.keys(d3Ease).forEach(function (key) { exports[key] = d3Ease[key]; });
Object.keys(d3Fetch).forEach(function (key) { exports[key] = d3Fetch[key]; });
Object.keys(d3Force).forEach(function (key) { exports[key] = d3Force[key]; });
Object.keys(d3Format).forEach(function (key) { exports[key] = d3Format[key]; });
Object.keys(d3Geo).forEach(function (key) { exports[key] = d3Geo[key]; });
Object.keys(d3Hierarchy).forEach(function (key) { exports[key] = d3Hierarchy[key]; });
Object.keys(d3Interpolate).forEach(function (key) { exports[key] = d3Interpolate[key]; });
Object.keys(d3Path).forEach(function (key) { exports[key] = d3Path[key]; });
Object.keys(d3Polygon).forEach(function (key) { exports[key] = d3Polygon[key]; });
Object.keys(d3Quadtree).forEach(function (key) { exports[key] = d3Quadtree[key]; });
Object.keys(d3Random).forEach(function (key) { exports[key] = d3Random[key]; });
Object.keys(d3Scale).forEach(function (key) { exports[key] = d3Scale[key]; });
Object.keys(d3ScaleChromatic).forEach(function (key) { exports[key] = d3ScaleChromatic[key]; });
Object.keys(d3Selection).forEach(function (key) { exports[key] = d3Selection[key]; });
Object.keys(d3Shape).forEach(function (key) { exports[key] = d3Shape[key]; });
Object.keys(d3Time).forEach(function (key) { exports[key] = d3Time[key]; });
Object.keys(d3TimeFormat).forEach(function (key) { exports[key] = d3TimeFormat[key]; });
Object.keys(d3Timer).forEach(function (key) { exports[key] = d3Timer[key]; });
Object.keys(d3Transition).forEach(function (key) { exports[key] = d3Transition[key]; });
Object.keys(d3Voronoi).forEach(function (key) { exports[key] = d3Voronoi[key]; });
Object.keys(d3Zoom).forEach(function (key) { exports[key] = d3Zoom[key]; });
exports.version = version;
Object.defineProperty(exports, "event", {get: function() { return d3Selection.event; }});

},{"d3-array":9,"d3-axis":10,"d3-brush":11,"d3-chord":12,"d3-collection":13,"d3-color":14,"d3-contour":15,"d3-dispatch":16,"d3-drag":17,"d3-dsv":18,"d3-ease":19,"d3-fetch":20,"d3-force":21,"d3-format":22,"d3-geo":23,"d3-hierarchy":24,"d3-interpolate":25,"d3-path":26,"d3-polygon":27,"d3-quadtree":28,"d3-random":29,"d3-scale":31,"d3-scale-chromatic":30,"d3-selection":32,"d3-shape":33,"d3-time":35,"d3-time-format":34,"d3-timer":36,"d3-transition":37,"d3-voronoi":38,"d3-zoom":39}],41:[function(require,module,exports){
/*global define:false */
/**
 * Copyright 2012-2017 Craig Campbell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Mousetrap is a simple keyboard shortcut library for Javascript with
 * no external dependencies
 *
 * @version 1.6.2
 * @url craig.is/killing/mice
 */
(function(window, document, undefined) {

    // Check if mousetrap is used inside browser, if not, return
    if (!window) {
        return;
    }

    /**
     * mapping of special keycodes to their corresponding keys
     *
     * everything in this dictionary cannot use keypress events
     * so it has to be here to map to the correct keycodes for
     * keyup/keydown events
     *
     * @type {Object}
     */
    var _MAP = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        20: 'capslock',
        27: 'esc',
        32: 'space',
        33: 'pageup',
        34: 'pagedown',
        35: 'end',
        36: 'home',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        45: 'ins',
        46: 'del',
        91: 'meta',
        93: 'meta',
        224: 'meta'
    };

    /**
     * mapping for special characters so they can support
     *
     * this dictionary is only used incase you want to bind a
     * keyup or keydown event to one of these keys
     *
     * @type {Object}
     */
    var _KEYCODE_MAP = {
        106: '*',
        107: '+',
        109: '-',
        110: '.',
        111 : '/',
        186: ';',
        187: '=',
        188: ',',
        189: '-',
        190: '.',
        191: '/',
        192: '`',
        219: '[',
        220: '\\',
        221: ']',
        222: '\''
    };

    /**
     * this is a mapping of keys that require shift on a US keypad
     * back to the non shift equivelents
     *
     * this is so you can use keyup events with these keys
     *
     * note that this will only work reliably on US keyboards
     *
     * @type {Object}
     */
    var _SHIFT_MAP = {
        '~': '`',
        '!': '1',
        '@': '2',
        '#': '3',
        '$': '4',
        '%': '5',
        '^': '6',
        '&': '7',
        '*': '8',
        '(': '9',
        ')': '0',
        '_': '-',
        '+': '=',
        ':': ';',
        '\"': '\'',
        '<': ',',
        '>': '.',
        '?': '/',
        '|': '\\'
    };

    /**
     * this is a list of special strings you can use to map
     * to modifier keys when you specify your keyboard shortcuts
     *
     * @type {Object}
     */
    var _SPECIAL_ALIASES = {
        'option': 'alt',
        'command': 'meta',
        'return': 'enter',
        'escape': 'esc',
        'plus': '+',
        'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
    };

    /**
     * variable to store the flipped version of _MAP from above
     * needed to check if we should use keypress or not when no action
     * is specified
     *
     * @type {Object|undefined}
     */
    var _REVERSE_MAP;

    /**
     * loop through the f keys, f1 to f19 and add them to the map
     * programatically
     */
    for (var i = 1; i < 20; ++i) {
        _MAP[111 + i] = 'f' + i;
    }

    /**
     * loop through to map numbers on the numeric keypad
     */
    for (i = 0; i <= 9; ++i) {

        // This needs to use a string cause otherwise since 0 is falsey
        // mousetrap will never fire for numpad 0 pressed as part of a keydown
        // event.
        //
        // @see https://github.com/ccampbell/mousetrap/pull/258
        _MAP[i + 96] = i.toString();
    }

    /**
     * cross browser add event method
     *
     * @param {Element|HTMLDocument} object
     * @param {string} type
     * @param {Function} callback
     * @returns void
     */
    function _addEvent(object, type, callback) {
        if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
        }

        object.attachEvent('on' + type, callback);
    }

    /**
     * takes the event and returns the key character
     *
     * @param {Event} e
     * @return {string}
     */
    function _characterFromEvent(e) {

        // for keypress events we should return the character as is
        if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which);

            // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.
            if (!e.shiftKey) {
                character = character.toLowerCase();
            }

            return character;
        }

        // for non keypress events the special maps are needed
        if (_MAP[e.which]) {
            return _MAP[e.which];
        }

        if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
        }

        // if it is not in the special map

        // with keydown and keyup events the character seems to always
        // come in as an uppercase character whether you are pressing shift
        // or not.  we should make sure it is always lowercase for comparisons
        return String.fromCharCode(e.which).toLowerCase();
    }

    /**
     * checks if two arrays are equal
     *
     * @param {Array} modifiers1
     * @param {Array} modifiers2
     * @returns {boolean}
     */
    function _modifiersMatch(modifiers1, modifiers2) {
        return modifiers1.sort().join(',') === modifiers2.sort().join(',');
    }

    /**
     * takes a key event and figures out what the modifiers are
     *
     * @param {Event} e
     * @returns {Array}
     */
    function _eventModifiers(e) {
        var modifiers = [];

        if (e.shiftKey) {
            modifiers.push('shift');
        }

        if (e.altKey) {
            modifiers.push('alt');
        }

        if (e.ctrlKey) {
            modifiers.push('ctrl');
        }

        if (e.metaKey) {
            modifiers.push('meta');
        }

        return modifiers;
    }

    /**
     * prevents default for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _preventDefault(e) {
        if (e.preventDefault) {
            e.preventDefault();
            return;
        }

        e.returnValue = false;
    }

    /**
     * stops propogation for this event
     *
     * @param {Event} e
     * @returns void
     */
    function _stopPropagation(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
            return;
        }

        e.cancelBubble = true;
    }

    /**
     * determines if the keycode specified is a modifier key or not
     *
     * @param {string} key
     * @returns {boolean}
     */
    function _isModifier(key) {
        return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
    }

    /**
     * reverses the map lookup so that we can look for specific keys
     * to see what can and can't use keypress
     *
     * @return {Object}
     */
    function _getReverseMap() {
        if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};
            for (var key in _MAP) {

                // pull out the numeric keypad from here cause keypress should
                // be able to detect the keys from the character
                if (key > 95 && key < 112) {
                    continue;
                }

                if (_MAP.hasOwnProperty(key)) {
                    _REVERSE_MAP[_MAP[key]] = key;
                }
            }
        }
        return _REVERSE_MAP;
    }

    /**
     * picks the best action based on the key combination
     *
     * @param {string} key - character for key
     * @param {Array} modifiers
     * @param {string=} action passed in
     */
    function _pickBestAction(key, modifiers, action) {

        // if no action was picked in we should try to pick the one
        // that we think would work best for this key
        if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
        }

        // modifier keys don't work as expected with keypress,
        // switch to keydown
        if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
        }

        return action;
    }

    /**
     * Converts from a string key combination to an array
     *
     * @param  {string} combination like "command+shift+l"
     * @return {Array}
     */
    function _keysFromString(combination) {
        if (combination === '+') {
            return ['+'];
        }

        combination = combination.replace(/\+{2}/g, '+plus');
        return combination.split('+');
    }

    /**
     * Gets info for a specific key combination
     *
     * @param  {string} combination key combination ("command+s" or "a" or "*")
     * @param  {string=} action
     * @returns {Object}
     */
    function _getKeyInfo(combination, action) {
        var keys;
        var key;
        var i;
        var modifiers = [];

        // take the keys from this pattern and figure out what the actual
        // pattern is all about
        keys = _keysFromString(combination);

        for (i = 0; i < keys.length; ++i) {
            key = keys[i];

            // normalize key names
            if (_SPECIAL_ALIASES[key]) {
                key = _SPECIAL_ALIASES[key];
            }

            // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however
            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
                key = _SHIFT_MAP[key];
                modifiers.push('shift');
            }

            // if this key is a modifier then add it to the list of modifiers
            if (_isModifier(key)) {
                modifiers.push(key);
            }
        }

        // depending on what the key combination is
        // we will try to pick the best event for it
        action = _pickBestAction(key, modifiers, action);

        return {
            key: key,
            modifiers: modifiers,
            action: action
        };
    }

    function _belongsTo(element, ancestor) {
        if (element === null || element === document) {
            return false;
        }

        if (element === ancestor) {
            return true;
        }

        return _belongsTo(element.parentNode, ancestor);
    }

    function Mousetrap(targetElement) {
        var self = this;

        targetElement = targetElement || document;

        if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
        }

        /**
         * element to attach key events to
         *
         * @type {Element}
         */
        self.target = targetElement;

        /**
         * a list of all the callbacks setup via Mousetrap.bind()
         *
         * @type {Object}
         */
        self._callbacks = {};

        /**
         * direct map of string combinations to callbacks used for trigger()
         *
         * @type {Object}
         */
        self._directMap = {};

        /**
         * keeps track of what level each sequence is at since multiple
         * sequences can start out with the same sequence
         *
         * @type {Object}
         */
        var _sequenceLevels = {};

        /**
         * variable to store the setTimeout call
         *
         * @type {null|number}
         */
        var _resetTimer;

        /**
         * temporary state where we will ignore the next keyup
         *
         * @type {boolean|string}
         */
        var _ignoreNextKeyup = false;

        /**
         * temporary state where we will ignore the next keypress
         *
         * @type {boolean}
         */
        var _ignoreNextKeypress = false;

        /**
         * are we currently inside of a sequence?
         * type of action ("keyup" or "keydown" or "keypress") or false
         *
         * @type {boolean|string}
         */
        var _nextExpectedAction = false;

        /**
         * resets all sequence counters except for the ones passed in
         *
         * @param {Object} doNotReset
         * @returns void
         */
        function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};

            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
                if (doNotReset[key]) {
                    activeSequences = true;
                    continue;
                }
                _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
                _nextExpectedAction = false;
            }
        }

        /**
         * finds all callbacks that match based on the keycode, modifiers,
         * and action
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event|Object} e
         * @param {string=} sequenceName - name of the sequence we are looking for
         * @param {string=} combination
         * @param {number=} level
         * @returns {Array}
         */
        function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type;

            // if there are no events related to this keycode
            if (!self._callbacks[character]) {
                return [];
            }

            // if a modifier key is coming up on its own we should allow it
            if (action == 'keyup' && _isModifier(character)) {
                modifiers = [character];
            }

            // loop through all callbacks for the key that was pressed
            // and see if any of them match
            for (i = 0; i < self._callbacks[character].length; ++i) {
                callback = self._callbacks[character][i];

                // if a sequence name is not specified, but this is a sequence at
                // the wrong level then move onto the next match
                if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                    continue;
                }

                // if the action we are looking for doesn't match the action we got
                // then we should keep going
                if (action != callback.action) {
                    continue;
                }

                // if this is a keypress event and the meta key and control key
                // are not pressed that means that we need to only look at the
                // character, otherwise check the modifiers as well
                //
                // chrome will not fire a keypress if meta or control is down
                // safari will fire a keypress if meta or meta+shift is down
                // firefox will fire a keypress if meta or control is down
                if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {

                    // when you bind a combination or sequence a second time it
                    // should overwrite the first one.  if a sequenceName or
                    // combination is specified in this call it does just that
                    //
                    // @todo make deleting its own method?
                    var deleteCombo = !sequenceName && callback.combo == combination;
                    var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                    if (deleteCombo || deleteSequence) {
                        self._callbacks[character].splice(i, 1);
                    }

                    matches.push(callback);
                }
            }

            return matches;
        }

        /**
         * actually calls the callback function
         *
         * if your callback function returns false this will use the jquery
         * convention - prevent default and stop propogation on the event
         *
         * @param {Function} callback
         * @param {Event} e
         * @returns void
         */
        function _fireCallback(callback, e, combo, sequence) {

            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
                return;
            }

            if (callback(e, combo) === false) {
                _preventDefault(e);
                _stopPropagation(e);
            }
        }

        /**
         * handles a character key event
         *
         * @param {string} character
         * @param {Array} modifiers
         * @param {Event} e
         * @returns void
         */
        self._handleKey = function(character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);
            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false;

            // Calculate the maxLevel for sequences so we can only execute the longest callback sequence
            for (i = 0; i < callbacks.length; ++i) {
                if (callbacks[i].seq) {
                    maxLevel = Math.max(maxLevel, callbacks[i].level);
                }
            }

            // loop through matching callbacks for this key event
            for (i = 0; i < callbacks.length; ++i) {

                // fire for all sequence callbacks
                // this is because if for example you have multiple sequences
                // bound such as "g i" and "g t" they both need to fire the
                // callback for matching g cause otherwise you can only ever
                // match the first one
                if (callbacks[i].seq) {

                    // only fire callbacks for the maxLevel to prevent
                    // subsequences from also firing
                    //
                    // for example 'a option b' should not cause 'option b' to fire
                    // even though 'option b' is part of the other sequence
                    //
                    // any sequences that do not match here will be discarded
                    // below by the _resetSequences call
                    if (callbacks[i].level != maxLevel) {
                        continue;
                    }

                    processedSequenceCallback = true;

                    // keep a list of which sequences were matches for later
                    doNotReset[callbacks[i].seq] = 1;
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);
                    continue;
                }

                // if there were no sequence matches but we are still here
                // that means this is a regular match so we should fire that
                if (!processedSequenceCallback) {
                    _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                }
            }

            // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character
            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;
            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
                _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
        };

        /**
         * handles a keydown event
         *
         * @param {Event} e
         * @returns void
         */
        function _handleKeyEvent(e) {

            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
                e.which = e.keyCode;
            }

            var character = _characterFromEvent(e);

            // no character found then stop
            if (!character) {
                return;
            }

            // need to use === for the character check because the character can be 0
            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
                _ignoreNextKeyup = false;
                return;
            }

            self.handleKey(character, _eventModifiers(e), e);
        }

        /**
         * called to set a 1 second timeout on the specified sequence
         *
         * this is so after each key press in the sequence you have 1 second
         * to press the next key before you have to start over
         *
         * @returns void
         */
        function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
        }

        /**
         * binds a key sequence to an event
         *
         * @param {string} combo - combo specified in bind call
         * @param {Array} keys
         * @param {Function} callback
         * @param {string=} action
         * @returns void
         */
        function _bindSequence(combo, keys, callback, action) {

            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;

            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */
            function _increaseSequence(nextAction) {
                return function() {
                    _nextExpectedAction = nextAction;
                    ++_sequenceLevels[combo];
                    _resetSequenceTimer();
                };
            }

            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */
            function _callbackAndReset(e) {
                _fireCallback(callback, e, combo);

                // we should ignore the next key up if the action is key down
                // or keypress.  this is so if you finish a sequence and
                // release the key the final key will not trigger a keyup
                if (action !== 'keyup') {
                    _ignoreNextKeyup = _characterFromEvent(e);
                }

                // weird race condition if a sequence ends with the key
                // another sequence begins with
                setTimeout(_resetSequences, 10);
            }

            // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided
            for (var i = 0; i < keys.length; ++i) {
                var isFinal = i + 1 === keys.length;
                var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
        }

        /**
         * binds a single keyboard combination
         *
         * @param {string} combination
         * @param {Function} callback
         * @param {string=} action
         * @param {string=} sequenceName - name of sequence if part of sequence
         * @param {number=} level - what part of the sequence the command is
         * @returns void
         */
        function _bindSingle(combination, callback, action, sequenceName, level) {

            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback;

            // make sure multiple spaces in a row become a single space
            combination = combination.replace(/\s+/g, ' ');

            var sequence = combination.split(' ');
            var info;

            // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time
            if (sequence.length > 1) {
                _bindSequence(combination, sequence, callback, action);
                return;
            }

            info = _getKeyInfo(combination, action);

            // make sure to initialize array if this is the first time
            // a callback is added for this key
            self._callbacks[info.key] = self._callbacks[info.key] || [];

            // remove an existing match if there is one
            _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);

            // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first
            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
                callback: callback,
                modifiers: info.modifiers,
                action: info.action,
                seq: sequenceName,
                level: level,
                combo: combination
            });
        }

        /**
         * binds multiple combinations to the same callback
         *
         * @param {Array} combinations
         * @param {Function} callback
         * @param {string|undefined} action
         * @returns void
         */
        self._bindMultiple = function(combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
                _bindSingle(combinations[i], callback, action);
            }
        };

        // start!
        _addEvent(targetElement, 'keypress', _handleKeyEvent);
        _addEvent(targetElement, 'keydown', _handleKeyEvent);
        _addEvent(targetElement, 'keyup', _handleKeyEvent);
    }

    /**
     * binds an event to mousetrap
     *
     * can be a single key, a combination of keys separated with +,
     * an array of keys, or a sequence of keys separated by spaces
     *
     * be sure to list the modifier keys first to make sure that the
     * correct key ends up getting bound (the last key in the pattern)
     *
     * @param {string|Array} keys
     * @param {Function} callback
     * @param {string=} action - 'keypress', 'keydown', or 'keyup'
     * @returns void
     */
    Mousetrap.prototype.bind = function(keys, callback, action) {
        var self = this;
        keys = keys instanceof Array ? keys : [keys];
        self._bindMultiple.call(self, keys, callback, action);
        return self;
    };

    /**
     * unbinds an event to mousetrap
     *
     * the unbinding sets the callback function of the specified key combo
     * to an empty function and deletes the corresponding key in the
     * _directMap dict.
     *
     * TODO: actually remove this from the _callbacks dictionary instead
     * of binding an empty function
     *
     * the keycombo+action has to be exactly the same as
     * it was defined in the bind method
     *
     * @param {string|Array} keys
     * @param {string} action
     * @returns void
     */
    Mousetrap.prototype.unbind = function(keys, action) {
        var self = this;
        return self.bind.call(self, keys, function() {}, action);
    };

    /**
     * triggers an event that has already been bound
     *
     * @param {string} keys
     * @param {string=} action
     * @returns void
     */
    Mousetrap.prototype.trigger = function(keys, action) {
        var self = this;
        if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
        }
        return self;
    };

    /**
     * resets the library back to its initial state.  this is useful
     * if you want to clear out the current keyboard shortcuts and bind
     * new ones - for example if you switch to another page
     *
     * @returns void
     */
    Mousetrap.prototype.reset = function() {
        var self = this;
        self._callbacks = {};
        self._directMap = {};
        return self;
    };

    /**
     * should we stop this event before firing off callbacks
     *
     * @param {Event} e
     * @param {Element} element
     * @return {boolean}
     */
    Mousetrap.prototype.stopCallback = function(e, element) {
        var self = this;

        // if the element has the class "mousetrap" then no need to stop
        if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
        }

        if (_belongsTo(element, self.target)) {
            return false;
        }

        // stop for input, select, and textarea
        return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
    };

    /**
     * exposes _handleKey publicly so it can be overwritten by extensions
     */
    Mousetrap.prototype.handleKey = function() {
        var self = this;
        return self._handleKey.apply(self, arguments);
    };

    /**
     * allow custom key mappings
     */
    Mousetrap.addKeycodes = function(object) {
        for (var key in object) {
            if (object.hasOwnProperty(key)) {
                _MAP[key] = object[key];
            }
        }
        _REVERSE_MAP = null;
    };

    /**
     * Init the global mousetrap functions
     *
     * This method is needed to allow the global mousetrap functions to work
     * now that mousetrap is a constructor function.
     */
    Mousetrap.init = function() {
        var documentMousetrap = Mousetrap(document);
        for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
                Mousetrap[method] = (function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments);
                    };
                } (method));
            }
        }
    };

    Mousetrap.init();

    // expose mousetrap to the global object
    window.Mousetrap = Mousetrap;

    // expose as a common js module
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = Mousetrap;
    }

    // expose mousetrap as an AMD module
    if (typeof define === 'function' && define.amd) {
        define(function() {
            return Mousetrap;
        });
    }
}) (typeof window !== 'undefined' ? window : null, typeof  window !== 'undefined' ? document : null);

},{}]},{},[8])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMva29udmEva29udmEuanMiLCJzcmMvRWRnZXMuanMiLCJzcmMvU2hhcGUuanMiLCJzcmMvU3NlcS5qcyIsInNyYy9Tc2VxQ2xhc3MuanMiLCJzcmMvU3RyaW5naWZ5aW5nTWFwLmpzIiwic3JjL2Rpc3BsYXkuanMiLCJzcmMvbWFpbi5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtYXJyYXkvYnVpbGQvZDMtYXJyYXkuanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLWF4aXMvYnVpbGQvZDMtYXhpcy5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtYnJ1c2gvYnVpbGQvZDMtYnJ1c2guanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLWNob3JkL2J1aWxkL2QzLWNob3JkLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1jb2xsZWN0aW9uL2J1aWxkL2QzLWNvbGxlY3Rpb24uanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLWNvbG9yL2J1aWxkL2QzLWNvbG9yLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1jb250b3VyL2Rpc3QvZDMtY29udG91ci5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtZGlzcGF0Y2gvYnVpbGQvZDMtZGlzcGF0Y2guanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLWRyYWcvYnVpbGQvZDMtZHJhZy5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtZHN2L2J1aWxkL2QzLWRzdi5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtZWFzZS9idWlsZC9kMy1lYXNlLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1mZXRjaC9kaXN0L2QzLWZldGNoLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9idWlsZC9kMy1mb3JjZS5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtZm9ybWF0L2J1aWxkL2QzLWZvcm1hdC5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtZ2VvL2Rpc3QvZDMtZ2VvLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1oaWVyYXJjaHkvZGlzdC9kMy1oaWVyYXJjaHkuanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLWludGVycG9sYXRlL2J1aWxkL2QzLWludGVycG9sYXRlLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1wYXRoL2J1aWxkL2QzLXBhdGguanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLXBvbHlnb24vYnVpbGQvZDMtcG9seWdvbi5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvYnVpbGQvZDMtcXVhZHRyZWUuanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLXJhbmRvbS9idWlsZC9kMy1yYW5kb20uanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLXNjYWxlLWNocm9tYXRpYy9kaXN0L2QzLXNjYWxlLWNocm9tYXRpYy5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtc2NhbGUvZGlzdC9kMy1zY2FsZS5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtc2VsZWN0aW9uL2Rpc3QvZDMtc2VsZWN0aW9uLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy1zaGFwZS9idWlsZC9kMy1zaGFwZS5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtdGltZS1mb3JtYXQvYnVpbGQvZDMtdGltZS1mb3JtYXQuanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLXRpbWUvYnVpbGQvZDMtdGltZS5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtdGltZXIvYnVpbGQvZDMtdGltZXIuanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzLXRyYW5zaXRpb24vYnVpbGQvZDMtdHJhbnNpdGlvbi5qcyIsInNyYy9ub2RlX21vZHVsZXMvZDMtdm9yb25vaS9idWlsZC9kMy12b3Jvbm9pLmpzIiwic3JjL25vZGVfbW9kdWxlcy9kMy16b29tL2J1aWxkL2QzLXpvb20uanMiLCJzcmMvbm9kZV9tb2R1bGVzL2QzL2Rpc3QvZDMubm9kZS5qcyIsInNyYy9ub2RlX21vZHVsZXMvbW91c2V0cmFwL21vdXNldHJhcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2prbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5a0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcHBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFnR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuK0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy80REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNockJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNueEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8qXG4gKiBLb252YSBKYXZhU2NyaXB0IEZyYW1ld29yayB2Mi4xLjNcbiAqIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVRcbiAqIERhdGU6IFRodSBNYXkgMTcgMjAxOFxuICpcbiAqIE9yaWdpbmFsIHdvcmsgQ29weXJpZ2h0IChDKSAyMDExIC0gMjAxMyBieSBFcmljIFJvd2VsbCAoS2luZXRpY0pTKVxuICogTW9kaWZpZWQgd29yayBDb3B5cmlnaHQgKEMpIDIwMTQgLSBwcmVzZW50IGJ5IEFudG9uIExhdnJlbm92IChLb252YSlcbiAqXG4gKiBAbGljZW5zZVxuICovXG5cbi8vIHJ1bnRpbWUgY2hlY2sgZm9yIGFscmVhZHkgaW5jbHVkZWQgS29udmFcbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQG5hbWVzcGFjZSBLb252YVxuICAgKi9cblxuICB2YXIgUElfT1ZFUl8xODAgPSBNYXRoLlBJIC8gMTgwO1xuXG4gIHZhciBLb252YSA9IHtcbiAgICAvLyBwdWJsaWNcbiAgICB2ZXJzaW9uOiAnMi4xLjMnLFxuXG4gICAgLy8gcHJpdmF0ZVxuICAgIHN0YWdlczogW10sXG4gICAgaWRDb3VudGVyOiAwLFxuICAgIGlkczoge30sXG4gICAgbmFtZXM6IHt9LFxuICAgIHNoYXBlczoge30sXG4gICAgbGlzdGVuQ2xpY2tUYXA6IGZhbHNlLFxuICAgIGluRGJsQ2xpY2tXaW5kb3c6IGZhbHNlLFxuXG4gICAgaXNCcm93c2VyOlxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIC8vIGJyb3dzZXIgY2FzZVxuICAgICAgKHt9LnRvU3RyaW5nLmNhbGwod2luZG93KSA9PT0gJ1tvYmplY3QgV2luZG93XScgfHxcbiAgICAgICAgLy8gZWxlY3Ryb24gY2FzZVxuICAgICAgICB7fS50b1N0cmluZy5jYWxsKHdpbmRvdykgPT09ICdbb2JqZWN0IGdsb2JhbF0nKSxcblxuICAgIC8vIGNvbmZpZ3VyYXRpb25zXG4gICAgZW5hYmxlVHJhY2U6IGZhbHNlLFxuICAgIHRyYWNlQXJyTWF4OiAxMDAsXG4gICAgZGJsQ2xpY2tXaW5kb3c6IDQwMCxcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgcGl4ZWwgcmF0aW8gY29uZmlndXJhdGlvbi4gS29udmFKUyBhdXRvbWF0aWNhbGx5IGRldGVjdCBwaXhlbCByYXRpbyBvZiBjdXJyZW50IGRldmljZS5cbiAgICAgKiBCdXQgeW91IG1heSBvdmVycmlkZSBzdWNoIHByb3BlcnR5LCBpZiB5b3Ugd2FudCB0byB1c2UgeW91ciB2YWx1ZS5cbiAgICAgKiBAcHJvcGVydHkgcGl4ZWxSYXRpb1xuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogS29udmEucGl4ZWxSYXRpbyA9IDE7XG4gICAgICovXG4gICAgcGl4ZWxSYXRpbzogdW5kZWZpbmVkLFxuICAgIC8qKlxuICAgICAqIERyYWcgZGlzdGFuY2UgcHJvcGVydHkuIElmIHlvdSBzdGFydCB0byBkcmFnIGEgbm9kZSB5b3UgbWF5IHdhbnQgdG8gd2FpdCB1bnRpbCBwb2ludGVyIGlzIG1vdmVkIHRvIHNvbWUgZGlzdGFuY2UgZnJvbSBzdGFydCBwb2ludCxcbiAgICAgKiBvbmx5IHRoZW4gc3RhcnQgZHJhZ2dpbmcuIERlZmF1bHQgaXMgM3B4LlxuICAgICAqIEBwcm9wZXJ0eSBkcmFnRGlzdGFuY2VcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBLb252YS5kcmFnRGlzdGFuY2UgPSAxMDtcbiAgICAgKi9cbiAgICBkcmFnRGlzdGFuY2U6IDMsXG4gICAgLyoqXG4gICAgICogVXNlIGRlZ3JlZSB2YWx1ZXMgZm9yIGFuZ2xlIHByb3BlcnRpZXMuIFlvdSBtYXkgc2V0IHRoaXMgcHJvcGVydHkgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gdXNlIHJhZGlhbnQgdmFsdWVzLlxuICAgICAqIEBwcm9wZXJ0eSBhbmdsZURlZ1xuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUucm90YXRpb24oNDUpOyAvLyA0NSBkZWdyZWVzXG4gICAgICogS29udmEuYW5nbGVEZWcgPSBmYWxzZTtcbiAgICAgKiBub2RlLnJvdGF0aW9uKE1hdGguUEkgLyAyKTsgLy8gUEkvMiByYWRpYW5cbiAgICAgKi9cbiAgICBhbmdsZURlZzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBTaG93IGRpZmZlcmVudCB3YXJuaW5ncyBhYm91dCBlcnJvcnMgb3Igd3JvbmcgQVBJIHVzYWdlXG4gICAgICogQHByb3BlcnR5IHNob3dXYXJuaW5nc1xuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIEtvbnZhLnNob3dXYXJuaW5ncyA9IGZhbHNlO1xuICAgICAqL1xuICAgIHNob3dXYXJuaW5nczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2UgRmlsdGVyc1xuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqL1xuICAgIEZpbHRlcnM6IHt9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBkcmFnIGFuZCBkcm9wIGlzIGN1cnJlbnRseSBhY3RpdmVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gICAgaXNEcmFnZ2luZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICBpZiAoZGQpIHtcbiAgICAgICAgcmV0dXJuIGRkLmlzRHJhZ2dpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgZHJhZyBhbmQgZHJvcCBvcGVyYXRpb24gaXMgcmVhZHksIGJ1dCBtYXlcbiAgICAgKiAgbm90IG5lY2Vzc2FyaWx5IGhhdmUgc3RhcnRlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKi9cbiAgICBpc0RyYWdSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgICAgLy8gaWYgREQgaXMgbm90IGluY2x1ZGVkIHdpdGggdGhlIGJ1aWxkLCB0aGVuXG4gICAgICAvLyBkcmFnIGFuZCBkcm9wIGlzIG5vdCBldmVuIHBvc3NpYmxlXG4gICAgICBpZiAoZGQpIHtcbiAgICAgICAgcmV0dXJuICEhZGQubm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIF9hZGRJZDogZnVuY3Rpb24obm9kZSwgaWQpIHtcbiAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuaWRzW2lkXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlSWQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHNbaWRdO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FkZE5hbWU6IGZ1bmN0aW9uKG5vZGUsIG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5uYW1lc1tuYW1lXSkge1xuICAgICAgICAgIHRoaXMubmFtZXNbbmFtZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWVzW25hbWVdLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfcmVtb3ZlTmFtZTogZnVuY3Rpb24obmFtZSwgX2lkKSB7XG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIG5vZGVzID0gdGhpcy5uYW1lc1tuYW1lXTtcbiAgICAgIGlmICghbm9kZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub2Rlcy5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgbm8gPSBub2Rlc1tuXTtcbiAgICAgICAgaWYgKG5vLl9pZCA9PT0gX2lkKSB7XG4gICAgICAgICAgbm9kZXMuc3BsaWNlKG4sIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5hbWVzW25hbWVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0QW5nbGU6IGZ1bmN0aW9uKGFuZ2xlKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZURlZyA/IGFuZ2xlICogUElfT1ZFUl8xODAgOiBhbmdsZTtcbiAgICB9LFxuICAgIF9kZXRlY3RJRTogZnVuY3Rpb24odWEpIHtcbiAgICAgIHZhciBtc2llID0gdWEuaW5kZXhPZignbXNpZSAnKTtcbiAgICAgIGlmIChtc2llID4gMCkge1xuICAgICAgICAvLyBJRSAxMCBvciBvbGRlciA9PiByZXR1cm4gdmVyc2lvbiBudW1iZXJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHVhLnN1YnN0cmluZyhtc2llICsgNSwgdWEuaW5kZXhPZignLicsIG1zaWUpKSwgMTApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJpZGVudCA9IHVhLmluZGV4T2YoJ3RyaWRlbnQvJyk7XG4gICAgICBpZiAodHJpZGVudCA+IDApIHtcbiAgICAgICAgLy8gSUUgMTEgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHZhciBydiA9IHVhLmluZGV4T2YoJ3J2OicpO1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodWEuc3Vic3RyaW5nKHJ2ICsgMywgdWEuaW5kZXhPZignLicsIHJ2KSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2UgPSB1YS5pbmRleE9mKCdlZGdlLycpO1xuICAgICAgaWYgKGVkZ2UgPiAwKSB7XG4gICAgICAgIC8vIEVkZ2UgKElFIDEyKykgPT4gcmV0dXJuIHZlcnNpb24gbnVtYmVyXG4gICAgICAgIHJldHVybiBwYXJzZUludCh1YS5zdWJzdHJpbmcoZWRnZSArIDUsIHVhLmluZGV4T2YoJy4nLCBlZGdlKSksIDEwKTtcbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXIgYnJvd3NlclxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgX3BhcnNlVUE6IGZ1bmN0aW9uKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVhID0gdXNlckFnZW50LnRvTG93ZXJDYXNlKCksXG4gICAgICAgIC8vIGpRdWVyeSBVQSByZWdleFxuICAgICAgICBtYXRjaCA9XG4gICAgICAgICAgLyhjaHJvbWUpWyAvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHxcbiAgICAgICAgICAvKHdlYmtpdClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIC9dKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgIC8obXNpZSkgKFtcXHcuXSspLy5leGVjKHVhKSB8fFxuICAgICAgICAgICh1YS5pbmRleE9mKCdjb21wYXRpYmxlJykgPCAwICYmXG4gICAgICAgICAgICAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKHVhKSkgfHxcbiAgICAgICAgICBbXSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFnIGFzIHdlbGxcbiAgICAgICAgbW9iaWxlID0gISF1c2VyQWdlbnQubWF0Y2goXG4gICAgICAgICAgL0FuZHJvaWR8QmxhY2tCZXJyeXxpUGhvbmV8aVBhZHxpUG9kfE9wZXJhIE1pbml8SUVNb2JpbGUvaVxuICAgICAgICApLFxuICAgICAgICBpZU1vYmlsZSA9ICEhdXNlckFnZW50Lm1hdGNoKC9JRU1vYmlsZS9pKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYnJvd3NlcjogbWF0Y2hbMV0gfHwgJycsXG4gICAgICAgIHZlcnNpb246IG1hdGNoWzJdIHx8ICcwJyxcbiAgICAgICAgaXNJRTogS29udmEuX2RldGVjdElFKHVhKSxcbiAgICAgICAgLy8gYWRkaW5nIG1vYmlsZSBmbGFiXG4gICAgICAgIG1vYmlsZTogbW9iaWxlLFxuICAgICAgICBpZU1vYmlsZTogaWVNb2JpbGUgLy8gSWYgdGhpcyBpcyB0cnVlIChpLmUuLCBXUDgpLCB0aGVuIEtvbnZhIHRvdWNoIGV2ZW50cyBhcmUgZXhlY3V0ZWQgaW5zdGVhZCBvZiBlcXVpdmFsZW50IEtvbnZhIG1vdXNlIGV2ZW50c1xuICAgICAgfTtcbiAgICB9LFxuICAgIC8vIHVzZXIgYWdlbnRcbiAgICBVQTogdW5kZWZpbmVkXG4gIH07XG5cbiAgdmFyIGdsb2IgPVxuICAgIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICA/IGdsb2JhbFxuICAgICAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cbiAgS29udmEuVUEgPSBLb252YS5fcGFyc2VVQSgoZ2xvYi5uYXZpZ2F0b3IgJiYgZ2xvYi5uYXZpZ2F0b3IudXNlckFnZW50KSB8fCAnJyk7XG5cbiAgaWYgKGdsb2IuS29udmEpIHtcbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgJ0tvbnZhIGluc3RhbmNlIGlzIGFscmVhZHkgZXhpc3QgaW4gY3VycmVudCBldmlyb21lbnQuICcgK1xuICAgICAgICAnUGxlYXNlIHVzZSBvbmx5IG9uZSBpbnN0YW5jZS4nXG4gICAgKTtcbiAgfVxuICBnbG9iLktvbnZhID0gS29udmE7XG4gIEtvbnZhLmdsb2JhbCA9IGdsb2I7XG4gIEtvbnZhLndpbmRvdyA9IGdsb2I7XG4gIEtvbnZhLmRvY3VtZW50ID0gZ2xvYi5kb2N1bWVudDtcblxuICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBLb252YTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtvbnZhO1xuICAgIH0pO1xuICB9XG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlICBlcWVxZXEsIG5vLWNvbmQtYXNzaWduLCBuby1lbXB0eSovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gY29uc3RydWN0b3IuICBDb2xsZWN0aW9uIGV4dGVuZHNcbiAgICogIEFycmF5LiAgVGhpcyBjbGFzcyBpcyB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIEtvbnZhLkNvbnRhaW5lciNnZXR9XG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICovXG4gIEtvbnZhLkNvbGxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgIGxlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgaSA9IDA7XG5cbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYXJnc1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlID0gW107XG4gIC8qKlxuICAgKiBpdGVyYXRlIHRocm91Z2ggbm9kZSBhcnJheSBhbmQgcnVuIGEgZnVuY3Rpb24gZm9yIGVhY2ggbm9kZS5cbiAgICogIFRoZSBub2RlIGFuZCBpbmRleCBpcyBwYXNzZWQgaW50byB0aGUgZnVuY3Rpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvbi5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgYWxsIG5vZGVzIHdpdGggbmFtZSBmb28gaW5zaWRlIGxheWVyLCBhbmQgc2V0IHggdG8gMTAgZm9yIGVhY2hcbiAgICogbGF5ZXIuZ2V0KCcuZm9vJykuZWFjaChmdW5jdGlvbihzaGFwZSwgbikge1xuICAgKiAgIHNoYXBlLnNldFgoMTApO1xuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlLmVhY2ggPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgZm9yICh2YXIgbiA9IDA7IG4gPCB0aGlzLmxlbmd0aDsgbisrKSB7XG4gICAgICBmdW5jKHRoaXNbbl0sIG4pO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIGNvbnZlcnQgY29sbGVjdGlvbiBpbnRvIGFuIGFycmF5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlXG4gICAqL1xuICBLb252YS5Db2xsZWN0aW9uLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyciA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICBuO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICBhcnIucHVzaCh0aGlzW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbiAgfTtcbiAgLyoqXG4gICAqIGNvbnZlcnQgYXJyYXkgaW50byBhIGNvbGxlY3Rpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29sbGVjdGlvblxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJcbiAgICovXG4gIEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uID0gZnVuY3Rpb24oYXJyKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpLFxuICAgICAgbGVuID0gYXJyLmxlbmd0aCxcbiAgICAgIG47XG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgIGNvbGxlY3Rpb24ucHVzaChhcnJbbl0pO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcblxuICAvLyBtYXAgb25lIG1ldGhvZCBieSBpdCdzIG5hbWVcbiAgS29udmEuQ29sbGVjdGlvbi5fbWFwTWV0aG9kID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIEtvbnZhLkNvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgIGk7XG5cbiAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV1bbWV0aG9kTmFtZV0uYXBwbHkodGhpc1tpXSwgYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH07XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzID0gZnVuY3Rpb24oY29uc3RydWN0b3IpIHtcbiAgICB2YXIgcHJvdCA9IGNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHByb3QpIHtcbiAgICAgIEtvbnZhLkNvbGxlY3Rpb24uX21hcE1ldGhvZChtZXRob2ROYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgLypcbiAgICAqIExhc3QgdXBkYXRlZCBOb3ZlbWJlciAyMDExXG4gICAgKiBCeSBTaW1vbiBTYXJyaXNcbiAgICAqIHd3dy5zaW1vbnNhcnJpcy5jb21cbiAgICAqIHNhcnJpc0BhY20ub3JnXG4gICAgKlxuICAgICogRnJlZSB0byB1c2UgYW5kIGRpc3RyaWJ1dGUgYXQgd2lsbFxuICAgICogU28gbG9uZyBhcyB5b3UgYXJlIG5pY2UgdG8gcGVvcGxlLCBldGNcbiAgICAqL1xuXG4gIC8qXG4gICAgKiBUaGUgdXNhZ2Ugb2YgdGhpcyBjbGFzcyB3YXMgaW5zcGlyZWQgYnkgc29tZSBvZiB0aGUgd29yayBkb25lIGJ5IGEgZm9ya2VkXG4gICAgKiBwcm9qZWN0LCBLaW5ldGljSlMtRXh0IGJ5IFdhcHB3b3Jrcywgd2hpY2ggaXMgYmFzZWQgb24gU2ltb24ncyBUcmFuc2Zvcm1cbiAgICAqIGNsYXNzLiAgTW9kaWZpZWQgYnkgRXJpYyBSb3dlbGxcbiAgICAqL1xuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gY29uc3RydWN0b3IuIFRyYW5zZm9ybSBvYmplY3QgaXMgYSBwcml2YXRlIGNsYXNzIG9mIEtvbnZhIGZyYW1ld29yay5cbiAgICogSW4gbW9zdCBvZiB0aGUgY2FzZXMgeW91IGRvbid0IG5lZWQgdG8gdXNlIGl0IGluIHlvdXIgYXBwLlxuICAgKiBCdXQgdGhlcmUgaXMgYSBkb2N1bWVudGF0aW9uIGZvciB0aGF0IGNsYXNzIGluIGNhc2UgeW91IHN0aWxsIHdhbnRcbiAgICogdG8gbWFrZSBzb21lIG1hbnVhbCBjYWxjdWxhdGlvbnMuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge0FycmF5fSBbbV0gT3B0aW9uYWwgc2l4LWVsZW1lbnQgbWF0cml4XG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKi9cbiAgS29udmEuVHJhbnNmb3JtID0gZnVuY3Rpb24obSkge1xuICAgIHRoaXMubSA9IChtICYmIG0uc2xpY2UoKSkgfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICB9O1xuXG4gIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ29weSBLb252YS5UcmFuc2Zvcm0gb2JqZWN0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgS29udmEuVHJhbnNmb3JtKHRoaXMubSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gcG9pbnRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgMkQgcG9pbnQoeCwgeSlcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxuICAgICAqL1xuICAgIHBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIG0gPSB0aGlzLm07XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBtWzBdICogcG9pbnQueCArIG1bMl0gKiBwb2ludC55ICsgbVs0XSxcbiAgICAgICAgeTogbVsxXSAqIHBvaW50LnggKyBtWzNdICogcG9pbnQueSArIG1bNV1cbiAgICAgIH07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSB0cmFuc2xhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdGhpcy5tWzRdICs9IHRoaXMubVswXSAqIHggKyB0aGlzLm1bMl0gKiB5O1xuICAgICAgdGhpcy5tWzVdICs9IHRoaXMubVsxXSAqIHggKyB0aGlzLm1bM10gKiB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSBzY2FsZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSkge1xuICAgICAgdGhpcy5tWzBdICo9IHN4O1xuICAgICAgdGhpcy5tWzFdICo9IHN4O1xuICAgICAgdGhpcy5tWzJdICo9IHN5O1xuICAgICAgdGhpcy5tWzNdICo9IHN5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBcHBseSByb3RhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWQgIEFuZ2xlIGluIHJhZGlhbnNcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24ocmFkKSB7XG4gICAgICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgICB2YXIgbTExID0gdGhpcy5tWzBdICogYyArIHRoaXMubVsyXSAqIHM7XG4gICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICogYyArIHRoaXMubVszXSAqIHM7XG4gICAgICB2YXIgbTIxID0gdGhpcy5tWzBdICogLXMgKyB0aGlzLm1bMl0gKiBjO1xuICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIC1zICsgdGhpcy5tWzNdICogYztcbiAgICAgIHRoaXMubVswXSA9IG0xMTtcbiAgICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICAgIHRoaXMubVsyXSA9IG0yMTtcbiAgICAgIHRoaXMubVszXSA9IG0yMjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAyRCBwb2ludCh4LCB5KVxuICAgICAqL1xuICAgIGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMubVs0XSxcbiAgICAgICAgeTogdGhpcy5tWzVdXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQXBwbHkgc2tld1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgc2tldzogZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgICB2YXIgbTExID0gdGhpcy5tWzBdICsgdGhpcy5tWzJdICogc3k7XG4gICAgICB2YXIgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogc3k7XG4gICAgICB2YXIgbTIxID0gdGhpcy5tWzJdICsgdGhpcy5tWzBdICogc3g7XG4gICAgICB2YXIgbTIyID0gdGhpcy5tWzNdICsgdGhpcy5tWzFdICogc3g7XG4gICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBtdWx0aXBsaWNhdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7S29udmEuVHJhbnNmb3JtfSBtYXRyaXhcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICAgIHZhciBtMTEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVswXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzFdO1xuICAgICAgdmFyIG0xMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzBdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bMV07XG5cbiAgICAgIHZhciBtMjEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVsyXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzNdO1xuICAgICAgdmFyIG0yMiA9IHRoaXMubVsxXSAqIG1hdHJpeC5tWzJdICsgdGhpcy5tWzNdICogbWF0cml4Lm1bM107XG5cbiAgICAgIHZhciBkeCA9IHRoaXMubVswXSAqIG1hdHJpeC5tWzRdICsgdGhpcy5tWzJdICogbWF0cml4Lm1bNV0gKyB0aGlzLm1bNF07XG4gICAgICB2YXIgZHkgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVs0XSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzVdO1xuXG4gICAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgICB0aGlzLm1bM10gPSBtMjI7XG4gICAgICB0aGlzLm1bNF0gPSBkeDtcbiAgICAgIHRoaXMubVs1XSA9IGR5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBJbnZlcnQgdGhlIG1hdHJpeFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgaW52ZXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkID0gMSAvICh0aGlzLm1bMF0gKiB0aGlzLm1bM10gLSB0aGlzLm1bMV0gKiB0aGlzLm1bMl0pO1xuICAgICAgdmFyIG0wID0gdGhpcy5tWzNdICogZDtcbiAgICAgIHZhciBtMSA9IC10aGlzLm1bMV0gKiBkO1xuICAgICAgdmFyIG0yID0gLXRoaXMubVsyXSAqIGQ7XG4gICAgICB2YXIgbTMgPSB0aGlzLm1bMF0gKiBkO1xuICAgICAgdmFyIG00ID0gZCAqICh0aGlzLm1bMl0gKiB0aGlzLm1bNV0gLSB0aGlzLm1bM10gKiB0aGlzLm1bNF0pO1xuICAgICAgdmFyIG01ID0gZCAqICh0aGlzLm1bMV0gKiB0aGlzLm1bNF0gLSB0aGlzLm1bMF0gKiB0aGlzLm1bNV0pO1xuICAgICAgdGhpcy5tWzBdID0gbTA7XG4gICAgICB0aGlzLm1bMV0gPSBtMTtcbiAgICAgIHRoaXMubVsyXSA9IG0yO1xuICAgICAgdGhpcy5tWzNdID0gbTM7XG4gICAgICB0aGlzLm1bNF0gPSBtNDtcbiAgICAgIHRoaXMubVs1XSA9IG01O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gbWF0cml4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0TWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgdG8gYWJzb2x1dGUgcG9zaXRpb24gdmlhIHRyYW5zbGF0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm0ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybX1cbiAgICAgKiBAYXV0aG9yIGVyaWNkcm93ZWxsXG4gICAgICovXG4gICAgc2V0QWJzb2x1dGVQb3NpdGlvbjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgdmFyIG0wID0gdGhpcy5tWzBdLFxuICAgICAgICBtMSA9IHRoaXMubVsxXSxcbiAgICAgICAgbTIgPSB0aGlzLm1bMl0sXG4gICAgICAgIG0zID0gdGhpcy5tWzNdLFxuICAgICAgICBtNCA9IHRoaXMubVs0XSxcbiAgICAgICAgbTUgPSB0aGlzLm1bNV0sXG4gICAgICAgIHl0ID0gKG0wICogKHkgLSBtNSkgLSBtMSAqICh4IC0gbTQpKSAvIChtMCAqIG0zIC0gbTEgKiBtMiksXG4gICAgICAgIHh0ID0gKHggLSBtNCAtIG0yICogeXQpIC8gbTA7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSh4dCwgeXQpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDT05TVEFOVFNcbiAgdmFyIENPTlRFWFRfMkQgPSAnMmQnLFxuICAgIE9CSkVDVF9BUlJBWSA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgT0JKRUNUX05VTUJFUiA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBQSV9PVkVSX0RFRzE4MCA9IE1hdGguUEkgLyAxODAsXG4gICAgREVHMTgwX09WRVJfUEkgPSAxODAgLyBNYXRoLlBJLFxuICAgIEhBU0ggPSAnIycsXG4gICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgWkVSTyA9ICcwJyxcbiAgICBLT05WQV9XQVJOSU5HID0gJ0tvbnZhIHdhcm5pbmc6ICcsXG4gICAgS09OVkFfRVJST1IgPSAnS29udmEgZXJyb3I6ICcsXG4gICAgUkdCX1BBUkVOID0gJ3JnYignLFxuICAgIENPTE9SUyA9IHtcbiAgICAgIGFsaWNlYmx1ZTogWzI0MCwgMjQ4LCAyNTVdLFxuICAgICAgYW50aXF1ZXdoaXRlOiBbMjUwLCAyMzUsIDIxNV0sXG4gICAgICBhcXVhOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgYXF1YW1hcmluZTogWzEyNywgMjU1LCAyMTJdLFxuICAgICAgYXp1cmU6IFsyNDAsIDI1NSwgMjU1XSxcbiAgICAgIGJlaWdlOiBbMjQ1LCAyNDUsIDIyMF0sXG4gICAgICBiaXNxdWU6IFsyNTUsIDIyOCwgMTk2XSxcbiAgICAgIGJsYWNrOiBbMCwgMCwgMF0sXG4gICAgICBibGFuY2hlZGFsbW9uZDogWzI1NSwgMjM1LCAyMDVdLFxuICAgICAgYmx1ZTogWzAsIDAsIDI1NV0sXG4gICAgICBibHVldmlvbGV0OiBbMTM4LCA0MywgMjI2XSxcbiAgICAgIGJyb3duOiBbMTY1LCA0MiwgNDJdLFxuICAgICAgYnVybHl3b29kOiBbMjIyLCAxODQsIDEzNV0sXG4gICAgICBjYWRldGJsdWU6IFs5NSwgMTU4LCAxNjBdLFxuICAgICAgY2hhcnRyZXVzZTogWzEyNywgMjU1LCAwXSxcbiAgICAgIGNob2NvbGF0ZTogWzIxMCwgMTA1LCAzMF0sXG4gICAgICBjb3JhbDogWzI1NSwgMTI3LCA4MF0sXG4gICAgICBjb3JuZmxvd2VyYmx1ZTogWzEwMCwgMTQ5LCAyMzddLFxuICAgICAgY29ybnNpbGs6IFsyNTUsIDI0OCwgMjIwXSxcbiAgICAgIGNyaW1zb246IFsyMjAsIDIwLCA2MF0sXG4gICAgICBjeWFuOiBbMCwgMjU1LCAyNTVdLFxuICAgICAgZGFya2JsdWU6IFswLCAwLCAxMzldLFxuICAgICAgZGFya2N5YW46IFswLCAxMzksIDEzOV0sXG4gICAgICBkYXJrZ29sZGVucm9kOiBbMTg0LCAxMzIsIDExXSxcbiAgICAgIGRhcmtncmF5OiBbMTY5LCAxNjksIDE2OV0sXG4gICAgICBkYXJrZ3JlZW46IFswLCAxMDAsIDBdLFxuICAgICAgZGFya2dyZXk6IFsxNjksIDE2OSwgMTY5XSxcbiAgICAgIGRhcmtraGFraTogWzE4OSwgMTgzLCAxMDddLFxuICAgICAgZGFya21hZ2VudGE6IFsxMzksIDAsIDEzOV0sXG4gICAgICBkYXJrb2xpdmVncmVlbjogWzg1LCAxMDcsIDQ3XSxcbiAgICAgIGRhcmtvcmFuZ2U6IFsyNTUsIDE0MCwgMF0sXG4gICAgICBkYXJrb3JjaGlkOiBbMTUzLCA1MCwgMjA0XSxcbiAgICAgIGRhcmtyZWQ6IFsxMzksIDAsIDBdLFxuICAgICAgZGFya3NhbG1vbjogWzIzMywgMTUwLCAxMjJdLFxuICAgICAgZGFya3NlYWdyZWVuOiBbMTQzLCAxODgsIDE0M10sXG4gICAgICBkYXJrc2xhdGVibHVlOiBbNzIsIDYxLCAxMzldLFxuICAgICAgZGFya3NsYXRlZ3JheTogWzQ3LCA3OSwgNzldLFxuICAgICAgZGFya3NsYXRlZ3JleTogWzQ3LCA3OSwgNzldLFxuICAgICAgZGFya3R1cnF1b2lzZTogWzAsIDIwNiwgMjA5XSxcbiAgICAgIGRhcmt2aW9sZXQ6IFsxNDgsIDAsIDIxMV0sXG4gICAgICBkZWVwcGluazogWzI1NSwgMjAsIDE0N10sXG4gICAgICBkZWVwc2t5Ymx1ZTogWzAsIDE5MSwgMjU1XSxcbiAgICAgIGRpbWdyYXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgIGRpbWdyZXk6IFsxMDUsIDEwNSwgMTA1XSxcbiAgICAgIGRvZGdlcmJsdWU6IFszMCwgMTQ0LCAyNTVdLFxuICAgICAgZmlyZWJyaWNrOiBbMTc4LCAzNCwgMzRdLFxuICAgICAgZmxvcmFsd2hpdGU6IFsyNTUsIDI1NSwgMjQwXSxcbiAgICAgIGZvcmVzdGdyZWVuOiBbMzQsIDEzOSwgMzRdLFxuICAgICAgZnVjaHNpYTogWzI1NSwgMCwgMjU1XSxcbiAgICAgIGdhaW5zYm9ybzogWzIyMCwgMjIwLCAyMjBdLFxuICAgICAgZ2hvc3R3aGl0ZTogWzI0OCwgMjQ4LCAyNTVdLFxuICAgICAgZ29sZDogWzI1NSwgMjE1LCAwXSxcbiAgICAgIGdvbGRlbnJvZDogWzIxOCwgMTY1LCAzMl0sXG4gICAgICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBncmVlbjogWzAsIDEyOCwgMF0sXG4gICAgICBncmVlbnllbGxvdzogWzE3MywgMjU1LCA0N10sXG4gICAgICBncmV5OiBbMTI4LCAxMjgsIDEyOF0sXG4gICAgICBob25leWRldzogWzI0MCwgMjU1LCAyNDBdLFxuICAgICAgaG90cGluazogWzI1NSwgMTA1LCAxODBdLFxuICAgICAgaW5kaWFucmVkOiBbMjA1LCA5MiwgOTJdLFxuICAgICAgaW5kaWdvOiBbNzUsIDAsIDEzMF0sXG4gICAgICBpdm9yeTogWzI1NSwgMjU1LCAyNDBdLFxuICAgICAga2hha2k6IFsyNDAsIDIzMCwgMTQwXSxcbiAgICAgIGxhdmVuZGVyOiBbMjMwLCAyMzAsIDI1MF0sXG4gICAgICBsYXZlbmRlcmJsdXNoOiBbMjU1LCAyNDAsIDI0NV0sXG4gICAgICBsYXduZ3JlZW46IFsxMjQsIDI1MiwgMF0sXG4gICAgICBsZW1vbmNoaWZmb246IFsyNTUsIDI1MCwgMjA1XSxcbiAgICAgIGxpZ2h0Ymx1ZTogWzE3MywgMjE2LCAyMzBdLFxuICAgICAgbGlnaHRjb3JhbDogWzI0MCwgMTI4LCAxMjhdLFxuICAgICAgbGlnaHRjeWFuOiBbMjI0LCAyNTUsIDI1NV0sXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogWzI1MCwgMjUwLCAyMTBdLFxuICAgICAgbGlnaHRncmF5OiBbMjExLCAyMTEsIDIxMV0sXG4gICAgICBsaWdodGdyZWVuOiBbMTQ0LCAyMzgsIDE0NF0sXG4gICAgICBsaWdodGdyZXk6IFsyMTEsIDIxMSwgMjExXSxcbiAgICAgIGxpZ2h0cGluazogWzI1NSwgMTgyLCAxOTNdLFxuICAgICAgbGlnaHRzYWxtb246IFsyNTUsIDE2MCwgMTIyXSxcbiAgICAgIGxpZ2h0c2VhZ3JlZW46IFszMiwgMTc4LCAxNzBdLFxuICAgICAgbGlnaHRza3libHVlOiBbMTM1LCAyMDYsIDI1MF0sXG4gICAgICBsaWdodHNsYXRlZ3JheTogWzExOSwgMTM2LCAxNTNdLFxuICAgICAgbGlnaHRzbGF0ZWdyZXk6IFsxMTksIDEzNiwgMTUzXSxcbiAgICAgIGxpZ2h0c3RlZWxibHVlOiBbMTc2LCAxOTYsIDIyMl0sXG4gICAgICBsaWdodHllbGxvdzogWzI1NSwgMjU1LCAyMjRdLFxuICAgICAgbGltZTogWzAsIDI1NSwgMF0sXG4gICAgICBsaW1lZ3JlZW46IFs1MCwgMjA1LCA1MF0sXG4gICAgICBsaW5lbjogWzI1MCwgMjQwLCAyMzBdLFxuICAgICAgbWFnZW50YTogWzI1NSwgMCwgMjU1XSxcbiAgICAgIG1hcm9vbjogWzEyOCwgMCwgMF0sXG4gICAgICBtZWRpdW1hcXVhbWFyaW5lOiBbMTAyLCAyMDUsIDE3MF0sXG4gICAgICBtZWRpdW1ibHVlOiBbMCwgMCwgMjA1XSxcbiAgICAgIG1lZGl1bW9yY2hpZDogWzE4NiwgODUsIDIxMV0sXG4gICAgICBtZWRpdW1wdXJwbGU6IFsxNDcsIDExMiwgMjE5XSxcbiAgICAgIG1lZGl1bXNlYWdyZWVuOiBbNjAsIDE3OSwgMTEzXSxcbiAgICAgIG1lZGl1bXNsYXRlYmx1ZTogWzEyMywgMTA0LCAyMzhdLFxuICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46IFswLCAyNTAsIDE1NF0sXG4gICAgICBtZWRpdW10dXJxdW9pc2U6IFs3MiwgMjA5LCAyMDRdLFxuICAgICAgbWVkaXVtdmlvbGV0cmVkOiBbMTk5LCAyMSwgMTMzXSxcbiAgICAgIG1pZG5pZ2h0Ymx1ZTogWzI1LCAyNSwgMTEyXSxcbiAgICAgIG1pbnRjcmVhbTogWzI0NSwgMjU1LCAyNTBdLFxuICAgICAgbWlzdHlyb3NlOiBbMjU1LCAyMjgsIDIyNV0sXG4gICAgICBtb2NjYXNpbjogWzI1NSwgMjI4LCAxODFdLFxuICAgICAgbmF2YWpvd2hpdGU6IFsyNTUsIDIyMiwgMTczXSxcbiAgICAgIG5hdnk6IFswLCAwLCAxMjhdLFxuICAgICAgb2xkbGFjZTogWzI1MywgMjQ1LCAyMzBdLFxuICAgICAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gICAgICBvbGl2ZWRyYWI6IFsxMDcsIDE0MiwgMzVdLFxuICAgICAgb3JhbmdlOiBbMjU1LCAxNjUsIDBdLFxuICAgICAgb3JhbmdlcmVkOiBbMjU1LCA2OSwgMF0sXG4gICAgICBvcmNoaWQ6IFsyMTgsIDExMiwgMjE0XSxcbiAgICAgIHBhbGVnb2xkZW5yb2Q6IFsyMzgsIDIzMiwgMTcwXSxcbiAgICAgIHBhbGVncmVlbjogWzE1MiwgMjUxLCAxNTJdLFxuICAgICAgcGFsZXR1cnF1b2lzZTogWzE3NSwgMjM4LCAyMzhdLFxuICAgICAgcGFsZXZpb2xldHJlZDogWzIxOSwgMTEyLCAxNDddLFxuICAgICAgcGFwYXlhd2hpcDogWzI1NSwgMjM5LCAyMTNdLFxuICAgICAgcGVhY2hwdWZmOiBbMjU1LCAyMTgsIDE4NV0sXG4gICAgICBwZXJ1OiBbMjA1LCAxMzMsIDYzXSxcbiAgICAgIHBpbms6IFsyNTUsIDE5MiwgMjAzXSxcbiAgICAgIHBsdW06IFsyMjEsIDE2MCwgMjAzXSxcbiAgICAgIHBvd2RlcmJsdWU6IFsxNzYsIDIyNCwgMjMwXSxcbiAgICAgIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgICAgIHJlYmVjY2FwdXJwbGU6IFsxMDIsIDUxLCAxNTNdLFxuICAgICAgcmVkOiBbMjU1LCAwLCAwXSxcbiAgICAgIHJvc3licm93bjogWzE4OCwgMTQzLCAxNDNdLFxuICAgICAgcm95YWxibHVlOiBbNjUsIDEwNSwgMjI1XSxcbiAgICAgIHNhZGRsZWJyb3duOiBbMTM5LCA2OSwgMTldLFxuICAgICAgc2FsbW9uOiBbMjUwLCAxMjgsIDExNF0sXG4gICAgICBzYW5keWJyb3duOiBbMjQ0LCAxNjQsIDk2XSxcbiAgICAgIHNlYWdyZWVuOiBbNDYsIDEzOSwgODddLFxuICAgICAgc2Vhc2hlbGw6IFsyNTUsIDI0NSwgMjM4XSxcbiAgICAgIHNpZW5uYTogWzE2MCwgODIsIDQ1XSxcbiAgICAgIHNpbHZlcjogWzE5MiwgMTkyLCAxOTJdLFxuICAgICAgc2t5Ymx1ZTogWzEzNSwgMjA2LCAyMzVdLFxuICAgICAgc2xhdGVibHVlOiBbMTA2LCA5MCwgMjA1XSxcbiAgICAgIHNsYXRlZ3JheTogWzExOSwgMTI4LCAxNDRdLFxuICAgICAgc2xhdGVncmV5OiBbMTE5LCAxMjgsIDE0NF0sXG4gICAgICBzbm93OiBbMjU1LCAyNTUsIDI1MF0sXG4gICAgICBzcHJpbmdncmVlbjogWzAsIDI1NSwgMTI3XSxcbiAgICAgIHN0ZWVsYmx1ZTogWzcwLCAxMzAsIDE4MF0sXG4gICAgICB0YW46IFsyMTAsIDE4MCwgMTQwXSxcbiAgICAgIHRlYWw6IFswLCAxMjgsIDEyOF0sXG4gICAgICB0aGlzdGxlOiBbMjE2LCAxOTEsIDIxNl0sXG4gICAgICB0cmFuc3BhcmVudDogWzI1NSwgMjU1LCAyNTUsIDBdLFxuICAgICAgdG9tYXRvOiBbMjU1LCA5OSwgNzFdLFxuICAgICAgdHVycXVvaXNlOiBbNjQsIDIyNCwgMjA4XSxcbiAgICAgIHZpb2xldDogWzIzOCwgMTMwLCAyMzhdLFxuICAgICAgd2hlYXQ6IFsyNDUsIDIyMiwgMTc5XSxcbiAgICAgIHdoaXRlOiBbMjU1LCAyNTUsIDI1NV0sXG4gICAgICB3aGl0ZXNtb2tlOiBbMjQ1LCAyNDUsIDI0NV0sXG4gICAgICB5ZWxsb3c6IFsyNTUsIDI1NSwgMF0sXG4gICAgICB5ZWxsb3dncmVlbjogWzE1NCwgMjA1LCA1XVxuICAgIH0sXG4gICAgUkdCX1JFR0VYID0gL3JnYlxcKChcXGR7MSwzfSksKFxcZHsxLDN9KSwoXFxkezEsM30pXFwpLztcblxuICAvKipcbiAgICogQG5hbWVzcGFjZSBVdGlsXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKi9cbiAgS29udmEuVXRpbCA9IHtcbiAgICAvKlxuICAgICogY2hlcnJ5LXBpY2tlZCB1dGlsaXRpZXMgZnJvbSB1bmRlcnNjb3JlLmpzXG4gICAgKi9cbiAgICBfaXNFbGVtZW50OiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09IDEpO1xuICAgIH0sXG4gICAgX2lzRnVuY3Rpb246IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNhbGwgJiYgb2JqLmFwcGx5KTtcbiAgICB9LFxuICAgIF9pc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISFvYmogJiYgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG4gICAgfSxcbiAgICBfaXNBcnJheTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9BUlJBWTtcbiAgICB9LFxuICAgIF9pc051bWJlcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IE9CSkVDVF9OVU1CRVI7XG4gICAgfSxcbiAgICBfaXNTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HO1xuICAgIH0sXG4gICAgLy8gYXJyYXlzIGFyZSBvYmplY3RzIHRvb1xuICAgIGlzT2JqZWN0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgaW5zdGFuY2VvZiBPYmplY3Q7XG4gICAgfSxcbiAgICBpc1ZhbGlkU2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgZmlyc3RDaGFyID0gc2VsZWN0b3JbMF07XG4gICAgICByZXR1cm4gKFxuICAgICAgICBmaXJzdENoYXIgPT09ICcjJyB8fFxuICAgICAgICBmaXJzdENoYXIgPT09ICcuJyB8fFxuICAgICAgICBmaXJzdENoYXIgPT09IGZpcnN0Q2hhci50b1VwcGVyQ2FzZSgpXG4gICAgICApO1xuICAgIH0sXG4gICAgX3NpZ246IGZ1bmN0aW9uKG51bWJlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIGlmIChudW1iZXIgPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlQ2FudmFzRWxlbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2FudmFzID0gS29udmEuaXNCcm93c2VyXG4gICAgICAgID8gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgOiBuZXcgS29udmEuX25vZGVDYW52YXMoKTtcbiAgICAgIC8vIG9uIHNvbWUgZW52aXJvbm1lbnRzIGNhbnZhcy5zdHlsZSBpcyByZWFkb25seVxuICAgICAgdHJ5IHtcbiAgICAgICAgY2FudmFzLnN0eWxlID0gY2FudmFzLnN0eWxlIHx8IHt9O1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICBfaXNJbkRvY3VtZW50OiBmdW5jdGlvbihlbCkge1xuICAgICAgd2hpbGUgKChlbCA9IGVsLnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGlmIChlbCA9PSBLb252YS5kb2N1bWVudCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBfc2ltcGxpZnlBcnJheTogZnVuY3Rpb24oYXJyKSB7XG4gICAgICB2YXIgcmV0QXJyID0gW10sXG4gICAgICAgIGxlbiA9IGFyci5sZW5ndGgsXG4gICAgICAgIHV0aWwgPSBLb252YS5VdGlsLFxuICAgICAgICBuLFxuICAgICAgICB2YWw7XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICB2YWwgPSBhcnJbbl07XG4gICAgICAgIGlmICh1dGlsLl9pc051bWJlcih2YWwpKSB7XG4gICAgICAgICAgdmFsID0gTWF0aC5yb3VuZCh2YWwgKiAxMDAwKSAvIDEwMDA7XG4gICAgICAgIH0gZWxzZSBpZiAoIXV0aWwuX2lzU3RyaW5nKHZhbCkpIHtcbiAgICAgICAgICB2YWwgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldEFyci5wdXNoKHZhbCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRBcnI7XG4gICAgfSxcbiAgICAvKlxuICAgICogYXJnIGNhbiBiZSBhbiBpbWFnZSBvYmplY3Qgb3IgaW1hZ2UgZGF0YVxuICAgICovXG4gICAgX2dldEltYWdlOiBmdW5jdGlvbihhcmcsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaW1hZ2VPYmosIGNhbnZhcztcblxuICAgICAgLy8gaWYgYXJnIGlzIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICBpZiAoIWFyZykge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5faXNFbGVtZW50KGFyZykpIHtcbiAgICAgICAgLy8gaWYgYXJnIGlzIGFscmVhZHkgYW4gaW1hZ2Ugb2JqZWN0XG4gICAgICAgIGNhbGxiYWNrKGFyZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzU3RyaW5nKGFyZykpIHtcbiAgICAgICAgLy8gaWYgYXJnIGlzIGEgc3RyaW5nLCB0aGVuIGl0J3MgYSBkYXRhIHVybFxuICAgICAgICBpbWFnZU9iaiA9IG5ldyBLb252YS53aW5kb3cuSW1hZ2UoKTtcbiAgICAgICAgaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2FsbGJhY2soaW1hZ2VPYmopO1xuICAgICAgICB9O1xuICAgICAgICBpbWFnZU9iai5zcmMgPSBhcmc7XG4gICAgICB9IGVsc2UgaWYgKGFyZy5kYXRhKSB7XG4gICAgICAgIC8vaWYgYXJnIGlzIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhIHByb3BlcnR5LCBpdCdzIGFuIGltYWdlIG9iamVjdFxuICAgICAgICBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gYXJnLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gYXJnLmhlaWdodDtcbiAgICAgICAgdmFyIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG4gICAgICAgIF9jb250ZXh0LnB1dEltYWdlRGF0YShhcmcsIDAsIDApO1xuICAgICAgICB0aGlzLl9nZXRJbWFnZShjYW52YXMudG9EYXRhVVJMKCksIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldFJHQkFTdHJpbmc6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHJlZCA9IG9iai5yZWQgfHwgMCxcbiAgICAgICAgZ3JlZW4gPSBvYmouZ3JlZW4gfHwgMCxcbiAgICAgICAgYmx1ZSA9IG9iai5ibHVlIHx8IDAsXG4gICAgICAgIGFscGhhID0gb2JqLmFscGhhIHx8IDE7XG5cbiAgICAgIHJldHVybiBbJ3JnYmEoJywgcmVkLCAnLCcsIGdyZWVuLCAnLCcsIGJsdWUsICcsJywgYWxwaGEsICcpJ10uam9pbihcbiAgICAgICAgRU1QVFlfU1RSSU5HXG4gICAgICApO1xuICAgIH0sXG4gICAgX3JnYlRvSGV4OiBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICByZXR1cm4gKCgxIDw8IDI0KSArIChyIDw8IDE2KSArIChnIDw8IDgpICsgYikudG9TdHJpbmcoMTYpLnNsaWNlKDEpO1xuICAgIH0sXG4gICAgX2hleFRvUmdiOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGhleCA9IGhleC5yZXBsYWNlKEhBU0gsIEVNUFRZX1NUUklORyk7XG4gICAgICB2YXIgYmlnaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiAoYmlnaW50ID4+IDE2KSAmIDI1NSxcbiAgICAgICAgZzogKGJpZ2ludCA+PiA4KSAmIDI1NSxcbiAgICAgICAgYjogYmlnaW50ICYgMjU1XG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHJhbmRvbSBoZXggY29sb3JcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlV0aWwucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0UmFuZG9tQ29sb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJhbmRDb2xvciA9ICgoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmKSA8PCAwKS50b1N0cmluZygxNik7XG4gICAgICB3aGlsZSAocmFuZENvbG9yLmxlbmd0aCA8IDYpIHtcbiAgICAgICAgcmFuZENvbG9yID0gWkVSTyArIHJhbmRDb2xvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBIQVNIICsgcmFuZENvbG9yO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHZhbHVlIHdpdGggZGVmYXVsdCBmYWxsYmFja1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKHZhbCwgZGVmKSB7XG4gICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgUkdCIGNvbXBvbmVudHMgb2YgYSBjb2xvclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGVhY2ggb2YgdGhlIGZvbGxvd2luZyBleGFtcGxlcyByZXR1cm4ge3I6MCwgZzowLCBiOjI1NX1cbiAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJ2JsdWUnKTtcbiAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJyMwMDAwZmYnKTtcbiAgICAgKiB2YXIgcmdiID0gS29udmEuVXRpbC5nZXRSR0IoJ3JnYigwLDAsMjU1KScpO1xuICAgICAqL1xuICAgIGdldFJHQjogZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgIHZhciByZ2I7XG4gICAgICAvLyBjb2xvciBzdHJpbmdcbiAgICAgIGlmIChjb2xvciBpbiBDT0xPUlMpIHtcbiAgICAgICAgcmdiID0gQ09MT1JTW2NvbG9yXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByOiByZ2JbMF0sXG4gICAgICAgICAgZzogcmdiWzFdLFxuICAgICAgICAgIGI6IHJnYlsyXVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb2xvclswXSA9PT0gSEFTSCkge1xuICAgICAgICAvLyBoZXhcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleFRvUmdiKGNvbG9yLnN1YnN0cmluZygxKSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yLnN1YnN0cigwLCA0KSA9PT0gUkdCX1BBUkVOKSB7XG4gICAgICAgIC8vIHJnYiBzdHJpbmdcbiAgICAgICAgcmdiID0gUkdCX1JFR0VYLmV4ZWMoY29sb3IucmVwbGFjZSgvIC9nLCAnJykpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnNlSW50KHJnYlsxXSwgMTApLFxuICAgICAgICAgIGc6IHBhcnNlSW50KHJnYlsyXSwgMTApLFxuICAgICAgICAgIGI6IHBhcnNlSW50KHJnYlszXSwgMTApXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogMCxcbiAgICAgICAgICBnOiAwLFxuICAgICAgICAgIGI6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGNvbnZlcnQgYW55IGNvbG9yIHN0cmluZyB0byBSR0JBIG9iamVjdFxuICAgIC8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2NvbXBvbmVudC9jb2xvci1wYXJzZXJcbiAgICBjb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBzdHIgPSBzdHIgfHwgJ2JsYWNrJztcbiAgICAgIHJldHVybiAoXG4gICAgICAgIEtvbnZhLlV0aWwuX25hbWVkQ29sb3JUb1JCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX2hleDNDb2xvclRvUkdCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX2hleDZDb2xvclRvUkdCQShzdHIpIHx8XG4gICAgICAgIEtvbnZhLlV0aWwuX3JnYkNvbG9yVG9SR0JBKHN0cikgfHxcbiAgICAgICAgS29udmEuVXRpbC5fcmdiYUNvbG9yVG9SR0JBKHN0cilcbiAgICAgICk7XG4gICAgfSxcbiAgICAvLyBQYXJzZSBuYW1lZCBjc3MgY29sb3IuIExpa2UgXCJncmVlblwiXG4gICAgX25hbWVkQ29sb3JUb1JCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgYyA9IENPTE9SU1tzdHIudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByOiBjWzBdLFxuICAgICAgICBnOiBjWzFdLFxuICAgICAgICBiOiBjWzJdLFxuICAgICAgICBhOiAxXG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gUGFyc2UgcmdiKG4sIG4sIG4pXG4gICAgX3JnYkNvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIuaW5kZXhPZigncmdiKCcpID09PSAwKSB7XG4gICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiXFwoKFteKV0rKVxcKS8pWzFdO1xuICAgICAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqLCAqLykubWFwKE51bWJlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFydHNbMF0sXG4gICAgICAgICAgZzogcGFydHNbMV0sXG4gICAgICAgICAgYjogcGFydHNbMl0sXG4gICAgICAgICAgYTogMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gUGFyc2UgcmdiYShuLCBuLCBuLCBuKVxuICAgIF9yZ2JhQ29sb3JUb1JHQkE6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ci5pbmRleE9mKCdyZ2JhKCcpID09PSAwKSB7XG4gICAgICAgIHN0ciA9IHN0ci5tYXRjaCgvcmdiYVxcKChbXildKylcXCkvKVsxXTtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKiwgKi8pLm1hcChOdW1iZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnRzWzBdLFxuICAgICAgICAgIGc6IHBhcnRzWzFdLFxuICAgICAgICAgIGI6IHBhcnRzWzJdLFxuICAgICAgICAgIGE6IHBhcnRzWzNdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBQYXJzZSAjbm5ubm5uXG4gICAgX2hleDZDb2xvclRvUkdCQTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyWzBdID09PSAnIycgJiYgc3RyLmxlbmd0aCA9PT0gNykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHI6IHBhcnNlSW50KHN0ci5zbGljZSgxLCAzKSwgMTYpLFxuICAgICAgICAgIGc6IHBhcnNlSW50KHN0ci5zbGljZSgzLCA1KSwgMTYpLFxuICAgICAgICAgIGI6IHBhcnNlSW50KHN0ci5zbGljZSg1LCA3KSwgMTYpLFxuICAgICAgICAgIGE6IDFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFBhcnNlICNubm5cbiAgICBfaGV4M0NvbG9yVG9SR0JBOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHJbMF0gPT09ICcjJyAmJiBzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcjogcGFyc2VJbnQoc3RyWzFdICsgc3RyWzFdLCAxNiksXG4gICAgICAgICAgZzogcGFyc2VJbnQoc3RyWzJdICsgc3RyWzJdLCAxNiksXG4gICAgICAgICAgYjogcGFyc2VJbnQoc3RyWzNdICsgc3RyWzNdLCAxNiksXG4gICAgICAgICAgYTogMVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gbzEgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG8yXG4gICAgX21lcmdlOiBmdW5jdGlvbihvMSwgbzIpIHtcbiAgICAgIHZhciByZXRPYmogPSB0aGlzLl9jbG9uZShvMik7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbzEpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzT2JqZWN0KG8xW2tleV0pKSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLl9tZXJnZShvMVtrZXldLCByZXRPYmpba2V5XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSBvMVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0T2JqO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2hlY2sgaW50ZXJzZWN0aW9uIG9mIHR3byBjbGllbnQgcmVjdGFuZ2xlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYXZlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbihyMSwgcjIpIHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICByMi54ID4gcjEueCArIHIxLndpZHRoIHx8XG4gICAgICAgIHIyLnggKyByMi53aWR0aCA8IHIxLnggfHxcbiAgICAgICAgcjIueSA+IHIxLnkgKyByMS5oZWlnaHQgfHxcbiAgICAgICAgcjIueSArIHIyLmhlaWdodCA8IHIxLnlcbiAgICAgICk7XG4gICAgfSxcbiAgICBjbG9uZU9iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgcmV0T2JqID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc09iamVjdChvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXRPYmpba2V5XSA9IHRoaXMuY2xvbmVPYmplY3Qob2JqW2tleV0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2lzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0T2JqW2tleV0gPSB0aGlzLmNsb25lQXJyYXkob2JqW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldE9ialtrZXldID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXRPYmo7XG4gICAgfSxcbiAgICBjbG9uZUFycmF5OiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHJldHVybiBhcnIuc2xpY2UoMCk7XG4gICAgfSxcbiAgICBfZGVnVG9SYWQ6IGZ1bmN0aW9uKGRlZykge1xuICAgICAgcmV0dXJuIGRlZyAqIFBJX09WRVJfREVHMTgwO1xuICAgIH0sXG4gICAgX3JhZFRvRGVnOiBmdW5jdGlvbihyYWQpIHtcbiAgICAgIHJldHVybiByYWQgKiBERUcxODBfT1ZFUl9QSTtcbiAgICB9LFxuICAgIF9jYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgfSxcbiAgICB0aHJvdzogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoS09OVkFfRVJST1IgKyBzdHIpO1xuICAgIH0sXG4gICAgZXJyb3I6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgY29uc29sZS5lcnJvcihLT05WQV9FUlJPUiArIHN0cik7XG4gICAgfSxcbiAgICB3YXJuOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBJRTkgb24gV2luZG93czcgNjRiaXQgd2lsbCB0aHJvdyBhIEpTIGVycm9yXG4gICAgICAgICAgICAgKiBpZiB3ZSBkb24ndCB1c2Ugd2luZG93LmNvbnNvbGUgaW4gdGhlIGNvbmRpdGlvbmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgIGlmIChLb252YS5nbG9iYWwuY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgS29udmEuc2hvd1dhcm5pbmdzKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihLT05WQV9XQVJOSU5HICsgc3RyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZDogZnVuY3Rpb24oY2hpbGQsIHBhcmVudCkge1xuICAgICAgZnVuY3Rpb24gQ3RvcigpIHtcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgICAgdmFyIG9sZFByb3RvID0gY2hpbGQucHJvdG90eXBlO1xuICAgICAgY2hpbGQucHJvdG90eXBlID0gbmV3IEN0b3IoKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvbGRQcm90bykge1xuICAgICAgICBpZiAob2xkUHJvdG8uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIGNoaWxkLnByb3RvdHlwZVtrZXldID0gb2xkUHJvdG9ba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hpbGQuX19zdXBlcl9fID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgIC8vIGNyZWF0ZSByZWZlcmVuY2UgdG8gcGFyZW50XG4gICAgICBjaGlsZC5zdXBlciA9IHBhcmVudDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGFkZHMgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yIHByb3RvdHlwZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVXRpbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRob2RzXG4gICAgICovXG4gICAgYWRkTWV0aG9kczogZnVuY3Rpb24oY29uc3RydWN0b3IsIG1ldGhvZHMpIHtcbiAgICAgIHZhciBrZXk7XG5cbiAgICAgIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2tleV0gPSBtZXRob2RzW2tleV07XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0Q29udHJvbFBvaW50czogZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdCkge1xuICAgICAgdmFyIGQwMSA9IE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKSxcbiAgICAgICAgZDEyID0gTWF0aC5zcXJ0KE1hdGgucG93KHgyIC0geDEsIDIpICsgTWF0aC5wb3coeTIgLSB5MSwgMikpLFxuICAgICAgICBmYSA9IHQgKiBkMDEgLyAoZDAxICsgZDEyKSxcbiAgICAgICAgZmIgPSB0ICogZDEyIC8gKGQwMSArIGQxMiksXG4gICAgICAgIHAxeCA9IHgxIC0gZmEgKiAoeDIgLSB4MCksXG4gICAgICAgIHAxeSA9IHkxIC0gZmEgKiAoeTIgLSB5MCksXG4gICAgICAgIHAyeCA9IHgxICsgZmIgKiAoeDIgLSB4MCksXG4gICAgICAgIHAyeSA9IHkxICsgZmIgKiAoeTIgLSB5MCk7XG5cbiAgICAgIHJldHVybiBbcDF4LCBwMXksIHAyeCwgcDJ5XTtcbiAgICB9LFxuICAgIF9leHBhbmRQb2ludHM6IGZ1bmN0aW9uKHAsIHRlbnNpb24pIHtcbiAgICAgIHZhciBsZW4gPSBwLmxlbmd0aCxcbiAgICAgICAgYWxsUG9pbnRzID0gW10sXG4gICAgICAgIG4sXG4gICAgICAgIGNwO1xuXG4gICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuIC0gMjsgbiArPSAyKSB7XG4gICAgICAgIGNwID0gS29udmEuVXRpbC5fZ2V0Q29udHJvbFBvaW50cyhcbiAgICAgICAgICBwW24gLSAyXSxcbiAgICAgICAgICBwW24gLSAxXSxcbiAgICAgICAgICBwW25dLFxuICAgICAgICAgIHBbbiArIDFdLFxuICAgICAgICAgIHBbbiArIDJdLFxuICAgICAgICAgIHBbbiArIDNdLFxuICAgICAgICAgIHRlbnNpb25cbiAgICAgICAgKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbMF0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChjcFsxXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKHBbbl0pO1xuICAgICAgICBhbGxQb2ludHMucHVzaChwW24gKyAxXSk7XG4gICAgICAgIGFsbFBvaW50cy5wdXNoKGNwWzJdKTtcbiAgICAgICAgYWxsUG9pbnRzLnB1c2goY3BbM10pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYWxsUG9pbnRzO1xuICAgIH0sXG4gICAgX3JlbW92ZUxhc3RMZXR0ZXI6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIH0sXG4gICAgZWFjaDogZnVuY3Rpb24ob2JqLCBmdW5jKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGZ1bmMoa2V5LCBvYmpba2V5XSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfaW5SYW5nZTogZnVuY3Rpb24odmFsLCBsZWZ0LCByaWdodCkge1xuICAgICAgcmV0dXJuIGxlZnQgPD0gdmFsICYmIHZhbCA8IHJpZ2h0O1xuICAgIH0sXG4gICAgX2dldFByb2plY3Rpb25Ub1NlZ21lbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIHZhciB4LCB5LCBkaXN0O1xuXG4gICAgICB2YXIgcGQyID0gKHgxIC0geDIpICogKHgxIC0geDIpICsgKHkxIC0geTIpICogKHkxIC0geTIpO1xuICAgICAgaWYgKHBkMiA9PSAwKSB7XG4gICAgICAgIHggPSB4MTtcbiAgICAgICAgeSA9IHkxO1xuICAgICAgICBkaXN0ID0gKHgzIC0geDIpICogKHgzIC0geDIpICsgKHkzIC0geTIpICogKHkzIC0geTIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHUgPSAoKHgzIC0geDEpICogKHgyIC0geDEpICsgKHkzIC0geTEpICogKHkyIC0geTEpKSAvIHBkMjtcbiAgICAgICAgaWYgKHUgPCAwKSB7XG4gICAgICAgICAgeCA9IHgxO1xuICAgICAgICAgIHkgPSB5MTtcbiAgICAgICAgICBkaXN0ID0gKHgxIC0geDMpICogKHgxIC0geDMpICsgKHkxIC0geTMpICogKHkxIC0geTMpO1xuICAgICAgICB9IGVsc2UgaWYgKHUgPiAxLjApIHtcbiAgICAgICAgICB4ID0geDI7XG4gICAgICAgICAgeSA9IHkyO1xuICAgICAgICAgIGRpc3QgPSAoeDIgLSB4MykgKiAoeDIgLSB4MykgKyAoeTIgLSB5MykgKiAoeTIgLSB5Myk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeCA9IHgxICsgdSAqICh4MiAtIHgxKTtcbiAgICAgICAgICB5ID0geTEgKyB1ICogKHkyIC0geTEpO1xuICAgICAgICAgIGRpc3QgPSAoeCAtIHgzKSAqICh4IC0geDMpICsgKHkgLSB5MykgKiAoeSAtIHkzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFt4LCB5LCBkaXN0XTtcbiAgICB9LFxuICAgIC8vIGxpbmUgYXMgYXJyYXkgb2YgcG9pbnRzLlxuICAgIC8vIGxpbmUgbWlnaHQgYmUgY2xvc2VkXG4gICAgX2dldFByb2plY3Rpb25Ub0xpbmU6IGZ1bmN0aW9uKHB0LCBsaW5lLCBpc0Nsb3NlZCkge1xuICAgICAgdmFyIHBjID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChwdCk7XG4gICAgICB2YXIgZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICBsaW5lLmZvckVhY2goZnVuY3Rpb24ocDEsIGkpIHtcbiAgICAgICAgaWYgKCFpc0Nsb3NlZCAmJiBpID09PSBsaW5lLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAyID0gbGluZVsoaSArIDEpICUgbGluZS5sZW5ndGhdO1xuICAgICAgICB2YXIgcHJvaiA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub1NlZ21lbnQoXG4gICAgICAgICAgcDEueCxcbiAgICAgICAgICBwMS55LFxuICAgICAgICAgIHAyLngsXG4gICAgICAgICAgcDIueSxcbiAgICAgICAgICBwdC54LFxuICAgICAgICAgIHB0LnlcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIHB4ID0gcHJvalswXSxcbiAgICAgICAgICBweSA9IHByb2pbMV0sXG4gICAgICAgICAgcGRpc3QgPSBwcm9qWzJdO1xuICAgICAgICBpZiAocGRpc3QgPCBkaXN0KSB7XG4gICAgICAgICAgcGMueCA9IHB4O1xuICAgICAgICAgIHBjLnkgPSBweTtcbiAgICAgICAgICBkaXN0ID0gcGRpc3Q7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBjO1xuICAgIH0sXG4gICAgX3ByZXBhcmVBcnJheUZvclR3ZWVuOiBmdW5jdGlvbihzdGFydEFycmF5LCBlbmRBcnJheSwgaXNDbG9zZWQpIHtcbiAgICAgIHZhciBuLFxuICAgICAgICBzdGFydCA9IFtdLFxuICAgICAgICBlbmQgPSBbXTtcbiAgICAgIGlmIChzdGFydEFycmF5Lmxlbmd0aCA+IGVuZEFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIgdGVtcCA9IGVuZEFycmF5O1xuICAgICAgICBlbmRBcnJheSA9IHN0YXJ0QXJyYXk7XG4gICAgICAgIHN0YXJ0QXJyYXkgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgZm9yIChuID0gMDsgbiA8IHN0YXJ0QXJyYXkubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgc3RhcnQucHVzaCh7XG4gICAgICAgICAgeDogc3RhcnRBcnJheVtuXSxcbiAgICAgICAgICB5OiBzdGFydEFycmF5W24gKyAxXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAobiA9IDA7IG4gPCBlbmRBcnJheS5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICBlbmQucHVzaCh7XG4gICAgICAgICAgeDogZW5kQXJyYXlbbl0sXG4gICAgICAgICAgeTogZW5kQXJyYXlbbiArIDFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3U3RhcnQgPSBbXTtcbiAgICAgIGVuZC5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBwciA9IEtvbnZhLlV0aWwuX2dldFByb2plY3Rpb25Ub0xpbmUocG9pbnQsIHN0YXJ0LCBpc0Nsb3NlZCk7XG4gICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueCk7XG4gICAgICAgIG5ld1N0YXJ0LnB1c2gocHIueSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXdTdGFydDtcbiAgICB9LFxuICAgIF9wcmVwYXJlVG9TdHJpbmdpZnk6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGRlc2M7XG5cbiAgICAgIG9iai52aXNpdGVkQnlDaXJjdWxhclJlZmVyZW5jZVJlbW92YWwgPSB0cnVlO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldICYmIHR5cGVvZiBvYmpba2V5XSA9PSAnb2JqZWN0JylcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgb2JqW2tleV0udmlzaXRlZEJ5Q2lyY3VsYXJSZWZlcmVuY2VSZW1vdmFsIHx8XG4gICAgICAgICAgS29udmEuVXRpbC5faXNFbGVtZW50KG9ialtrZXldKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEtvbnZhLlV0aWwuX3ByZXBhcmVUb1N0cmluZ2lmeShvYmpba2V5XSkgPT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvYmpba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBvYmoudmlzaXRlZEJ5Q2lyY3VsYXJSZWZlcmVuY2VSZW1vdmFsO1xuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBjYWxjdWxhdGUgcGl4ZWwgcmF0aW9cblxuICB2YXIgX3BpeGVsUmF0aW87XG4gIGZ1bmN0aW9uIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgaWYgKF9waXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gX3BpeGVsUmF0aW87XG4gICAgfVxuICAgIHZhciBjYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIF9waXhlbFJhdGlvID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRldmljZVBpeGVsUmF0aW8gPSBLb252YS53aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICBiYWNraW5nU3RvcmVSYXRpbyA9XG4gICAgICAgICAgY29udGV4dC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5tb3pCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICBjb250ZXh0Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgMTtcbiAgICAgIHJldHVybiBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gICAgfSkoKTtcbiAgICByZXR1cm4gX3BpeGVsUmF0aW87XG4gIH1cblxuICAvKipcbiAgICAgKiBDYW52YXMgUmVuZGVyZXIgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy53aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5waXhlbFJhdGlvIEtvbnZhSlMgYXV0b21hdGljYWxseSBoYW5kbGVzIHBpeGVsIHJhdGlvIGFkanVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAqICBvbiBhbGwgZGV2aWNlcy4gTW9zdCBkZXNrdG9wcywgbG93IGVuZCB0YWJsZXRzLCBhbmQgbG93IGVuZCBwaG9uZXMsIGhhdmUgZGV2aWNlIHBpeGVsIHJhdGlvc1xuICAgICAqICBvZiAxLiAgU29tZSBoaWdoIGVuZCB0YWJsZXRzIGFuZCBwaG9uZXMsIGxpa2UgaVBob25lcyBhbmQgaVBhZHMgKG5vdCB0aGUgbWluaSkgaGF2ZSBhIGRldmljZSBwaXhlbCByYXRpb1xuICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgKiAgcmF0aW9zIG9mIDIgb3IgMy4gIFNvbWUgYnJvd3NlcnMgbGlrZSBGaXJlZm94IGFsbG93IHlvdSB0byBjb25maWd1cmUgdGhlIHBpeGVsIHJhdGlvIG9mIHRoZSB2aWV3cG9ydC4gIFVubGVzcyBvdGhlcndpc2VcbiAgICAgKiAgc3BlY2lmaWVkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgKiAgcmF0aW8gZm9yIHNwZWNpYWwgc2l0dWF0aW9ucywgb3IsIGlmIHlvdSBkb24ndCB3YW50IHRoZSBwaXhlbCByYXRpbyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQsIHlvdSBjYW4gc2V0IGl0IHRvIDEuXG4gICAgICovXG4gIEtvbnZhLkNhbnZhcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuaW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgdmFyIHBpeGVsUmF0aW8gPVxuICAgICAgICBjb25mLnBpeGVsUmF0aW8gfHwgS29udmEucGl4ZWxSYXRpbyB8fCBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG5cbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcblxuICAgICAgLy8gc2V0IGlubGluZSBzdHlsZXNcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmJvcmRlciA9IDA7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUuYmFja2dyb3VuZCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGNhbnZhcyBjb250ZXh0XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0NhbnZhc0NvbnRleHR9IGNvbnRleHRcbiAgICAgICAgICovXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250ZXh0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBwaXhlbCByYXRpb1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IHBpeGVsIHJhdGlvXG4gICAgICAgICAqL1xuICAgIGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpbztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBnZXQgcGl4ZWwgcmF0aW9cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQ2FudmFzLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcGl4ZWxSYXRpbyBLb252YUpTIGF1dG9tYXRpY2FsbHkgaGFuZGxlcyBwaXhlbCByYXRpbyBhZHVzdG1lbnRzIGluIG9yZGVyIHRvIHJlbmRlciBjcmlzcCBkcmF3aW5nc1xuICAgICAgICAgKiAgb24gYWxsIGRldmljZXMuIE1vc3QgZGVza3RvcHMsIGxvdyBlbmQgdGFibGV0cywgYW5kIGxvdyBlbmQgcGhvbmVzLCBoYXZlIGRldmljZSBwaXhlbCByYXRpb3NcbiAgICAgICAgICogIG9mIDEuICBTb21lIGhpZ2ggZW5kIHRhYmxldHMgYW5kIHBob25lcywgbGlrZSBpUGhvbmVzIGFuZCBpUGFkcyBoYXZlIGEgZGV2aWNlIHBpeGVsIHJhdGlvXG4gICAgICAgICAqICBvZiAyLiAgU29tZSBNYWNib29rIFByb3MsIGFuZCBpTWFjcyBhbHNvIGhhdmUgYSBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgMi4gIFNvbWUgaGlnaCBlbmQgQW5kcm9pZCBkZXZpY2VzIGhhdmUgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvcyBvZiAyIG9yIDMuICBTb21lIGJyb3dzZXJzIGxpa2UgRmlyZWZveCBhbGxvdyB5b3UgdG8gY29uZmlndXJlIHRoZSBwaXhlbCByYXRpbyBvZiB0aGUgdmlld3BvcnQuICBVbmxlc3Mgb3RoZXJ3aXNlXG4gICAgICAgICAqICBzcGVjaWZpY2VkLCB0aGUgcGl4ZWwgcmF0aW8gd2lsbCBiZSBkZWZhdWx0ZWQgdG8gdGhlIGFjdHVhbCBkZXZpY2UgcGl4ZWwgcmF0aW8uICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZXZpY2UgcGl4ZWxcbiAgICAgICAgICogIHJhdGlvIGZvciBzcGVjaWFsIHNpdHVhdGlvbnMsIG9yLCBpZiB5b3UgZG9uJ3Qgd2FudCB0aGUgcGl4ZWwgcmF0aW8gdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LCB5b3UgY2FuIHNldCBpdCB0byAxLlxuICAgICAgICAgKi9cbiAgICBzZXRQaXhlbFJhdGlvOiBmdW5jdGlvbihwaXhlbFJhdGlvKSB7XG4gICAgICB2YXIgcHJldmlvdXNSYXRpbyA9IHRoaXMucGl4ZWxSYXRpbztcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IHBpeGVsUmF0aW87XG4gICAgICB0aGlzLnNldFNpemUoXG4gICAgICAgIHRoaXMuZ2V0V2lkdGgoKSAvIHByZXZpb3VzUmF0aW8sXG4gICAgICAgIHRoaXMuZ2V0SGVpZ2h0KCkgLyBwcmV2aW91c1JhdGlvXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNldCB3aWR0aFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAgICAgKi9cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5fY2FudmFzLndpZHRoID0gd2lkdGggKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIC8vIHRha2UgaW50byBhY2NvdW50IHBpeGVsIHJhdGlvXG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XG4gICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuZ2V0Q29udGV4dCgpLl9jb250ZXh0O1xuICAgICAgX2NvbnRleHQuc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IHdpZHRoXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge051bWJlcn0gd2lkdGhcbiAgICAgICAgICovXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IGhlaWdodFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5DYW52YXMucHJvdG90eXBlXG4gICAgICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IGhlaWdodFxuICAgICAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHNldCBzaXplXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICovXG4gICAgc2V0U2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHRvIGRhdGEgdXJsXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkNhbnZhcy5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlXG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBxdWFsaXR5IGJldHdlZW4gMCBhbmQgMSBmb3IganBnIG1pbWUgdHlwZXNcbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gZGF0YSB1cmwgc3RyaW5nXG4gICAgICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24obWltZVR5cGUsIHF1YWxpdHkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIElmIHRoaXMgY2FsbCBmYWlscyAoZHVlIHRvIGJyb3dzZXIgYnVnLCBsaWtlIGluIEZpcmVmb3ggMy42KSxcbiAgICAgICAgLy8gdGhlbiByZXZlcnQgdG8gcHJldmlvdXMgbm8tcGFyYW1ldGVyIGltYWdlL3BuZyBiZWhhdmlvclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcy50b0RhdGFVUkwoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKCdVbmFibGUgdG8gZ2V0IGRhdGEgVVJMLiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5TY2VuZUNhbnZhcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBjb25mID0gY29uZmlnIHx8IHt9O1xuICAgIHZhciB3aWR0aCA9IGNvbmYud2lkdGggfHwgMCxcbiAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IDA7XG5cbiAgICBLb252YS5DYW52YXMuY2FsbCh0aGlzLCBjb25mKTtcbiAgICB0aGlzLmNvbnRleHQgPSBuZXcgS29udmEuU2NlbmVDb250ZXh0KHRoaXMpO1xuICAgIHRoaXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TY2VuZUNhbnZhcywgS29udmEuQ2FudmFzKTtcblxuICBLb252YS5IaXRDYW52YXMgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgY29uZiA9IGNvbmZpZyB8fCB7fTtcbiAgICB2YXIgd2lkdGggPSBjb25mLndpZHRoIHx8IDAsXG4gICAgICBoZWlnaHQgPSBjb25mLmhlaWdodCB8fCAwO1xuXG4gICAgS29udmEuQ2FudmFzLmNhbGwodGhpcywgY29uZik7XG4gICAgdGhpcy5jb250ZXh0ID0gbmV3IEtvbnZhLkhpdENvbnRleHQodGhpcyk7XG4gICAgdGhpcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuaGl0Q2FudmFzID0gdHJ1ZTtcbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuSGl0Q2FudmFzLCBLb252YS5DYW52YXMpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBDT01NQSA9ICcsJyxcbiAgICBPUEVOX1BBUkVOID0gJygnLFxuICAgIENMT1NFX1BBUkVOID0gJyknLFxuICAgIE9QRU5fUEFSRU5fQlJBQ0tFVCA9ICcoWycsXG4gICAgQ0xPU0VfQlJBQ0tFVF9QQVJFTiA9ICddKScsXG4gICAgU0VNSUNPTE9OID0gJzsnLFxuICAgIERPVUJMRV9QQVJFTiA9ICcoKScsXG4gICAgLy8gRU1QVFlfU1RSSU5HID0gJycsXG4gICAgRVFVQUxTID0gJz0nLFxuICAgIC8vIFNFVCA9ICdzZXQnLFxuICAgIENPTlRFWFRfTUVUSE9EUyA9IFtcbiAgICAgICdhcmMnLFxuICAgICAgJ2FyY1RvJyxcbiAgICAgICdiZWdpblBhdGgnLFxuICAgICAgJ2JlemllckN1cnZlVG8nLFxuICAgICAgJ2NsZWFyUmVjdCcsXG4gICAgICAnY2xpcCcsXG4gICAgICAnY2xvc2VQYXRoJyxcbiAgICAgICdjcmVhdGVMaW5lYXJHcmFkaWVudCcsXG4gICAgICAnY3JlYXRlUGF0dGVybicsXG4gICAgICAnY3JlYXRlUmFkaWFsR3JhZGllbnQnLFxuICAgICAgJ2RyYXdJbWFnZScsXG4gICAgICAnZmlsbCcsXG4gICAgICAnZmlsbFRleHQnLFxuICAgICAgJ2dldEltYWdlRGF0YScsXG4gICAgICAnY3JlYXRlSW1hZ2VEYXRhJyxcbiAgICAgICdsaW5lVG8nLFxuICAgICAgJ21vdmVUbycsXG4gICAgICAncHV0SW1hZ2VEYXRhJyxcbiAgICAgICdxdWFkcmF0aWNDdXJ2ZVRvJyxcbiAgICAgICdyZWN0JyxcbiAgICAgICdyZXN0b3JlJyxcbiAgICAgICdyb3RhdGUnLFxuICAgICAgJ3NhdmUnLFxuICAgICAgJ3NjYWxlJyxcbiAgICAgICdzZXRMaW5lRGFzaCcsXG4gICAgICAnc2V0VHJhbnNmb3JtJyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ3N0cm9rZVRleHQnLFxuICAgICAgJ3RyYW5zZm9ybScsXG4gICAgICAndHJhbnNsYXRlJ1xuICAgIF07XG5cbiAgdmFyIENPTlRFWFRfUFJPUEVSVElFUyA9IFtcbiAgICAnZmlsbFN0eWxlJyxcbiAgICAnc3Ryb2tlU3R5bGUnLFxuICAgICdzaGFkb3dDb2xvcicsXG4gICAgJ3NoYWRvd0JsdXInLFxuICAgICdzaGFkb3dPZmZzZXRYJyxcbiAgICAnc2hhZG93T2Zmc2V0WScsXG4gICAgJ2xpbmVDYXAnLFxuICAgICdsaW5lRGFzaE9mZnNldCcsXG4gICAgJ2xpbmVKb2luJyxcbiAgICAnbGluZVdpZHRoJyxcbiAgICAnbWl0ZXJMaW1pdCcsXG4gICAgJ2ZvbnQnLFxuICAgICd0ZXh0QWxpZ24nLFxuICAgICd0ZXh0QmFzZWxpbmUnLFxuICAgICdnbG9iYWxBbHBoYScsXG4gICAgJ2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbidcbiAgXTtcblxuICAvKipcbiAgICogQ2FudmFzIENvbnRleHQgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICovXG4gIEtvbnZhLkNvbnRleHQgPSBmdW5jdGlvbihjYW52YXMpIHtcbiAgICB0aGlzLmluaXQoY2FudmFzKTtcbiAgfTtcblxuICBLb252YS5Db250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5fY29udGV4dCA9IGNhbnZhcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIGlmIChLb252YS5lbmFibGVUcmFjZSkge1xuICAgICAgICB0aGlzLnRyYWNlQXJyID0gW107XG4gICAgICAgIHRoaXMuX2VuYWJsZVRyYWNlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBmaWxsIHNoYXBlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7S29udmEuU2hhcGV9IHNoYXBlXG4gICAgICovXG4gICAgZmlsbFNoYXBlOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgaWYgKHNoYXBlLmdldEZpbGxFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fZmlsbChzaGFwZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzdHJva2Ugc2hhcGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgKi9cbiAgICBzdHJva2VTaGFwZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZS5nZXRTdHJva2VFbmFibGVkKCkpIHtcbiAgICAgICAgdGhpcy5fc3Ryb2tlKHNoYXBlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGZpbGwgdGhlbiBzdHJva2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtLb252YS5TaGFwZX0gc2hhcGVcbiAgICAgKi9cbiAgICBmaWxsU3Ryb2tlU2hhcGU6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5nZXRGaWxsRW5hYmxlZCgpO1xuICAgICAgaWYgKGZpbGxFbmFibGVkKSB7XG4gICAgICAgIHRoaXMuX2ZpbGwoc2hhcGUpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlLmdldFN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICB0aGlzLl9zdHJva2Uoc2hhcGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNvbnRleHQgdHJhY2UgaWYgdHJhY2UgaXMgZW5hYmxlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbGF4ZWQgaWYgZmFsc2UsIHJldHVybiBzdHJpY3QgY29udGV4dCB0cmFjZSwgd2hpY2ggaW5jbHVkZXMgbWV0aG9kIG5hbWVzLCBtZXRob2QgcGFyYW1ldGVyc1xuICAgICAqICBwcm9wZXJ0aWVzLCBhbmQgcHJvcGVydHkgdmFsdWVzLiAgSWYgdHJ1ZSwgcmV0dXJuIHJlbGF4ZWQgY29udGV4dCB0cmFjZSwgd2hpY2ggb25seSByZXR1cm5zIG1ldGhvZCBuYW1lcyBhbmRcbiAgICAgKiAgcHJvcGVyaXRlcy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRyYWNlOiBmdW5jdGlvbihyZWxheGVkKSB7XG4gICAgICB2YXIgdHJhY2VBcnIgPSB0aGlzLnRyYWNlQXJyLFxuICAgICAgICBsZW4gPSB0cmFjZUFyci5sZW5ndGgsXG4gICAgICAgIHN0ciA9ICcnLFxuICAgICAgICBuLFxuICAgICAgICB0cmFjZSxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBhcmdzO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgdHJhY2UgPSB0cmFjZUFycltuXTtcbiAgICAgICAgbWV0aG9kID0gdHJhY2UubWV0aG9kO1xuXG4gICAgICAgIC8vIG1ldGhvZHNcbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgIGFyZ3MgPSB0cmFjZS5hcmdzO1xuICAgICAgICAgIHN0ciArPSBtZXRob2Q7XG4gICAgICAgICAgaWYgKHJlbGF4ZWQpIHtcbiAgICAgICAgICAgIHN0ciArPSBET1VCTEVfUEFSRU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChLb252YS5VdGlsLl9pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgIHN0ciArPVxuICAgICAgICAgICAgICAgIE9QRU5fUEFSRU5fQlJBQ0tFVCArIGFyZ3Muam9pbihDT01NQSkgKyBDTE9TRV9CUkFDS0VUX1BBUkVOO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyICs9IE9QRU5fUEFSRU4gKyBhcmdzLmpvaW4oQ09NTUEpICsgQ0xPU0VfUEFSRU47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgICBzdHIgKz0gdHJhY2UucHJvcGVydHk7XG4gICAgICAgICAgaWYgKCFyZWxheGVkKSB7XG4gICAgICAgICAgICBzdHIgKz0gRVFVQUxTICsgdHJhY2UudmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSBTRU1JQ09MT047XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjbGVhciB0cmFjZSBpZiB0cmFjZSBpcyBlbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyVHJhY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmFjZUFyciA9IFtdO1xuICAgIH0sXG4gICAgX3RyYWNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciB0cmFjZUFyciA9IHRoaXMudHJhY2VBcnIsXG4gICAgICAgIGxlbjtcblxuICAgICAgdHJhY2VBcnIucHVzaChzdHIpO1xuICAgICAgbGVuID0gdHJhY2VBcnIubGVuZ3RoO1xuXG4gICAgICBpZiAobGVuID49IEtvbnZhLnRyYWNlQXJyTWF4KSB7XG4gICAgICAgIHRyYWNlQXJyLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXNldCBjYW52YXMgY29udGV4dCB0cmFuc2Zvcm1cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRleHQucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBpeGVsUmF0aW8gPSB0aGlzLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtKDEgKiBwaXhlbFJhdGlvLCAwLCAwLCAxICogcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgY2FudmFzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250ZXh0LnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5DYW52YXN9XG4gICAgICovXG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsZWFyIGNhbnZhc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2JvdW5kc11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMuaGVpZ2h0XVxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXG4gICAgICBpZiAoYm91bmRzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJSZWN0KFxuICAgICAgICAgIGJvdW5kcy54IHx8IDAsXG4gICAgICAgICAgYm91bmRzLnkgfHwgMCxcbiAgICAgICAgICBib3VuZHMud2lkdGggfHwgMCxcbiAgICAgICAgICBib3VuZHMuaGVpZ2h0IHx8IDBcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2xlYXJSZWN0KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBjYW52YXMuZ2V0V2lkdGgoKSAvIGNhbnZhcy5waXhlbFJhdGlvLFxuICAgICAgICAgIGNhbnZhcy5nZXRIZWlnaHQoKSAvIGNhbnZhcy5waXhlbFJhdGlvXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlMaW5lQ2FwOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGxpbmVDYXAgPSBzaGFwZS5nZXRMaW5lQ2FwKCk7XG4gICAgICBpZiAobGluZUNhcCkge1xuICAgICAgICB0aGlzLnNldEF0dHIoJ2xpbmVDYXAnLCBsaW5lQ2FwKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hcHBseU9wYWNpdHk6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgYWJzT3BhY2l0eSA9IHNoYXBlLmdldEFic29sdXRlT3BhY2l0eSgpO1xuICAgICAgaWYgKGFic09wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdnbG9iYWxBbHBoYScsIGFic09wYWNpdHkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2FwcGx5TGluZUpvaW46IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgbGluZUpvaW4gPSBzaGFwZS5nZXRMaW5lSm9pbigpO1xuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cignbGluZUpvaW4nLCBsaW5lSm9pbik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyLCB2YWwpIHtcbiAgICAgIHRoaXMuX2NvbnRleHRbYXR0cl0gPSB2YWw7XG4gICAgfSxcblxuICAgIC8vIGNvbnRleHQgcGFzcyB0aHJvdWdoIG1ldGhvZHNcbiAgICBhcmM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LmFyYyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICB9LFxuICAgIGJlZ2luUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0sXG4gICAgYmV6aWVyQ3VydmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdKTtcbiAgICB9LFxuICAgIGNsZWFyUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuY2xlYXJSZWN0KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH0sXG4gICAgY2xpcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmNsaXAoKTtcbiAgICB9LFxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH0sXG4gICAgY3JlYXRlSW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgaWYgKGEubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmNyZWF0ZUltYWdlRGF0YShhWzBdLCBhWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAoYS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKGFbMF0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICB9LFxuICAgIGNyZWF0ZVBhdHRlcm46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVQYXR0ZXJuKGFbMF0sIGFbMV0pO1xuICAgIH0sXG4gICAgY3JlYXRlUmFkaWFsR3JhZGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgYVswXSxcbiAgICAgICAgYVsxXSxcbiAgICAgICAgYVsyXSxcbiAgICAgICAgYVszXSxcbiAgICAgICAgYVs0XSxcbiAgICAgICAgYVs1XVxuICAgICAgKTtcbiAgICB9LFxuICAgIGRyYXdJbWFnZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cyxcbiAgICAgICAgX2NvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICBpZiAoYS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgICAgfSBlbHNlIGlmIChhLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICBfY29udGV4dC5kcmF3SW1hZ2UoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSk7XG4gICAgICB9IGVsc2UgaWYgKGEubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIF9jb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICBhWzBdLFxuICAgICAgICAgIGFbMV0sXG4gICAgICAgICAgYVsyXSxcbiAgICAgICAgICBhWzNdLFxuICAgICAgICAgIGFbNF0sXG4gICAgICAgICAgYVs1XSxcbiAgICAgICAgICBhWzZdLFxuICAgICAgICAgIGFbN10sXG4gICAgICAgICAgYVs4XVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNQb2ludEluUGF0aDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuaXNQb2ludEluUGF0aCh4LCB5KTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY29udGV4dC5maWxsKCk7XG4gICAgfSxcbiAgICBmaWxsUmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5fY29udGV4dC5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHN0cm9rZVJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGZpbGxUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5maWxsVGV4dChhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICB9LFxuICAgIG1lYXN1cmVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICB9LFxuICAgIGdldEltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEltYWdlRGF0YShhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbiAgICB9LFxuICAgIGxpbmVUbzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKGFbMF0sIGFbMV0pO1xuICAgIH0sXG4gICAgbW92ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oYVswXSwgYVsxXSk7XG4gICAgfSxcbiAgICByZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5yZWN0KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH0sXG4gICAgcHV0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgfSxcbiAgICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10pO1xuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHJvdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQucm90YXRlKGFbMF0pO1xuICAgIH0sXG4gICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LnNhdmUoKTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5zY2FsZShhWzBdLCBhWzFdKTtcbiAgICB9LFxuICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzLFxuICAgICAgICBfY29udGV4dCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgIC8vIHdvcmtzIGZvciBDaHJvbWUgYW5kIElFMTFcbiAgICAgIGlmICh0aGlzLl9jb250ZXh0LnNldExpbmVEYXNoKSB7XG4gICAgICAgIF9jb250ZXh0LnNldExpbmVEYXNoKGFbMF0pO1xuICAgICAgfSBlbHNlIGlmICgnbW96RGFzaCcgaW4gX2NvbnRleHQpIHtcbiAgICAgICAgLy8gdmVyaWZpZWQgdGhhdCB0aGlzIHdvcmtzIGluIGZpcmVmb3hcbiAgICAgICAgX2NvbnRleHQubW96RGFzaCA9IGFbMF07XG4gICAgICB9IGVsc2UgaWYgKCd3ZWJraXRMaW5lRGFzaCcgaW4gX2NvbnRleHQpIHtcbiAgICAgICAgLy8gZG9lcyBub3QgY3VycmVudGx5IHdvcmsgZm9yIFNhZmFyaVxuICAgICAgICBfY29udGV4dC53ZWJraXRMaW5lRGFzaCA9IGFbMF07XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHN1cHBvcnQgZm9yIElFOSBhbmQgSUUxMFxuICAgIH0sXG4gICAgZ2V0TGluZURhc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0TGluZURhc2goKTtcbiAgICB9LFxuICAgIHNldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuX2NvbnRleHQuc2V0VHJhbnNmb3JtKGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0pO1xuICAgIH0sXG4gICAgc3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSxcbiAgICBzdHJva2VUZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC5zdHJva2VUZXh0KGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5fY29udGV4dC50cmFuc2Zvcm0oYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSk7XG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzLl9jb250ZXh0LnRyYW5zbGF0ZShhWzBdLCBhWzFdKTtcbiAgICB9LFxuICAgIF9lbmFibGVUcmFjZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgIGxlbiA9IENPTlRFWFRfTUVUSE9EUy5sZW5ndGgsXG4gICAgICAgIF9zaW1wbGlmeUFycmF5ID0gS29udmEuVXRpbC5fc2ltcGxpZnlBcnJheSxcbiAgICAgICAgb3JpZ1NldHRlciA9IHRoaXMuc2V0QXR0cixcbiAgICAgICAgbixcbiAgICAgICAgYXJncztcblxuICAgICAgLy8gdG8gcHJldmVudCBjcmVhdGluZyBzY29wZSBmdW5jdGlvbiBhdCBlYWNoIGxvb3BcbiAgICAgIHZhciBmdW5jID0gZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgb3JpZ01ldGhvZCA9IHRoYXRbbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0O1xuXG4gICAgICAgIHRoYXRbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhcmdzID0gX3NpbXBsaWZ5QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSk7XG4gICAgICAgICAgcmV0ID0gb3JpZ01ldGhvZC5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgdGhhdC5fdHJhY2Uoe1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2ROYW1lLFxuICAgICAgICAgICAgYXJnczogYXJnc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICAvLyBtZXRob2RzXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgZnVuYyhDT05URVhUX01FVEhPRFNbbl0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhdHRyc1xuICAgICAgdGhhdC5zZXRBdHRyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIG9yaWdTZXR0ZXIuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgdmFyIHByb3AgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciB2YWwgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wID09PSAnc2hhZG93T2Zmc2V0WCcgfHxcbiAgICAgICAgICBwcm9wID09PSAnc2hhZG93T2Zmc2V0WScgfHxcbiAgICAgICAgICBwcm9wID09PSAnc2hhZG93Qmx1cidcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFsID0gdmFsIC8gdGhpcy5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuX3RyYWNlKHtcbiAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICB2YWw6IHZhbFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIENPTlRFWFRfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoS29udmEuQ29udGV4dC5wcm90b3R5cGUsIHByb3AsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0W3Byb3BdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRbcHJvcF0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIEtvbnZhLlNjZW5lQ29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xuICB9O1xuXG4gIEtvbnZhLlNjZW5lQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgX2ZpbGxDb2xvcjogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBmaWxsID0gc2hhcGUuZmlsbCgpO1xuXG4gICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGZpbGwpO1xuICAgICAgc2hhcGUuX2ZpbGxGdW5jKHRoaXMpO1xuICAgIH0sXG4gICAgX2ZpbGxQYXR0ZXJuOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuWCgpLFxuICAgICAgICBmaWxsUGF0dGVyblkgPSBzaGFwZS5nZXRGaWxsUGF0dGVyblkoKSxcbiAgICAgICAgZmlsbFBhdHRlcm5TY2FsZSA9IHNoYXBlLmdldEZpbGxQYXR0ZXJuU2NhbGUoKSxcbiAgICAgICAgZmlsbFBhdHRlcm5Sb3RhdGlvbiA9IEtvbnZhLmdldEFuZ2xlKHNoYXBlLmdldEZpbGxQYXR0ZXJuUm90YXRpb24oKSksXG4gICAgICAgIGZpbGxQYXR0ZXJuT2Zmc2V0ID0gc2hhcGUuZ2V0RmlsbFBhdHRlcm5PZmZzZXQoKTtcblxuICAgICAgaWYgKGZpbGxQYXR0ZXJuWCB8fCBmaWxsUGF0dGVyblkpIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoZmlsbFBhdHRlcm5YIHx8IDAsIGZpbGxQYXR0ZXJuWSB8fCAwKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxsUGF0dGVyblJvdGF0aW9uKSB7XG4gICAgICAgIHRoaXMucm90YXRlKGZpbGxQYXR0ZXJuUm90YXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxQYXR0ZXJuU2NhbGUpIHtcbiAgICAgICAgdGhpcy5zY2FsZShmaWxsUGF0dGVyblNjYWxlLngsIGZpbGxQYXR0ZXJuU2NhbGUueSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFBhdHRlcm5PZmZzZXQpIHtcbiAgICAgICAgdGhpcy50cmFuc2xhdGUoLTEgKiBmaWxsUGF0dGVybk9mZnNldC54LCAtMSAqIGZpbGxQYXR0ZXJuT2Zmc2V0LnkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEF0dHIoXG4gICAgICAgICdmaWxsU3R5bGUnLFxuICAgICAgICB0aGlzLmNyZWF0ZVBhdHRlcm4oXG4gICAgICAgICAgc2hhcGUuZ2V0RmlsbFBhdHRlcm5JbWFnZSgpLFxuICAgICAgICAgIHNoYXBlLmdldEZpbGxQYXR0ZXJuUmVwZWF0KCkgfHwgJ3JlcGVhdCdcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHRoaXMuZmlsbCgpO1xuICAgIH0sXG4gICAgX2ZpbGxMaW5lYXJHcmFkaWVudDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQoKSxcbiAgICAgICAgZW5kID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSxcbiAgICAgICAgZ3JkID0gdGhpcy5jcmVhdGVMaW5lYXJHcmFkaWVudChzdGFydC54LCBzdGFydC55LCBlbmQueCwgZW5kLnkpO1xuXG4gICAgICBpZiAoY29sb3JTdG9wcykge1xuICAgICAgICAvLyBidWlsZCBjb2xvciBzdG9wc1xuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGNvbG9yU3RvcHMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcHNbbl0sIGNvbG9yU3RvcHNbbiArIDFdKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIGdyZCk7XG4gICAgICAgIHNoYXBlLl9maWxsRnVuYyh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9maWxsUmFkaWFsR3JhZGllbnQ6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgc3RhcnQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50KCksXG4gICAgICAgIGVuZCA9IHNoYXBlLmdldEZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCksXG4gICAgICAgIHN0YXJ0UmFkaXVzID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKSxcbiAgICAgICAgZW5kUmFkaXVzID0gc2hhcGUuZ2V0RmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzKCksXG4gICAgICAgIGNvbG9yU3RvcHMgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCksXG4gICAgICAgIGdyZCA9IHRoaXMuY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgc3RhcnQueCxcbiAgICAgICAgICBzdGFydC55LFxuICAgICAgICAgIHN0YXJ0UmFkaXVzLFxuICAgICAgICAgIGVuZC54LFxuICAgICAgICAgIGVuZC55LFxuICAgICAgICAgIGVuZFJhZGl1c1xuICAgICAgICApO1xuXG4gICAgICAvLyBidWlsZCBjb2xvciBzdG9wc1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjb2xvclN0b3BzLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBdHRyKCdmaWxsU3R5bGUnLCBncmQpO1xuICAgICAgdGhpcy5maWxsKCk7XG4gICAgfSxcbiAgICBfZmlsbDogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBoYXNDb2xvciA9IHNoYXBlLmZpbGwoKSxcbiAgICAgICAgZmlsbFByaW9yaXR5ID0gc2hhcGUuZ2V0RmlsbFByaW9yaXR5KCk7XG5cbiAgICAgIC8vIHByaW9yaXR5IGZpbGxzXG4gICAgICBpZiAoaGFzQ29sb3IgJiYgZmlsbFByaW9yaXR5ID09PSAnY29sb3InKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxDb2xvcihzaGFwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc1BhdHRlcm4gPSBzaGFwZS5nZXRGaWxsUGF0dGVybkltYWdlKCk7XG4gICAgICBpZiAoaGFzUGF0dGVybiAmJiBmaWxsUHJpb3JpdHkgPT09ICdwYXR0ZXJuJykge1xuICAgICAgICB0aGlzLl9maWxsUGF0dGVybihzaGFwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhc0xpbmVhckdyYWRpZW50ID0gc2hhcGUuZ2V0RmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpO1xuICAgICAgaWYgKGhhc0xpbmVhckdyYWRpZW50ICYmIGZpbGxQcmlvcml0eSA9PT0gJ2xpbmVhci1ncmFkaWVudCcpIHtcbiAgICAgICAgdGhpcy5fZmlsbExpbmVhckdyYWRpZW50KHNoYXBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzUmFkaWFsR3JhZGllbnQgPSBzaGFwZS5nZXRGaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAgICBpZiAoaGFzUmFkaWFsR3JhZGllbnQgJiYgZmlsbFByaW9yaXR5ID09PSAncmFkaWFsLWdyYWRpZW50Jykge1xuICAgICAgICB0aGlzLl9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyBqdXN0IHRyeSBhbmQgZmlsbCB3aXRoIHdoYXRldmVyIGlzIGF2YWlsYWJsZVxuICAgICAgaWYgKGhhc0NvbG9yKSB7XG4gICAgICAgIHRoaXMuX2ZpbGxDb2xvcihzaGFwZSk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5fZmlsbFBhdHRlcm4oc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNMaW5lYXJHcmFkaWVudCkge1xuICAgICAgICB0aGlzLl9maWxsTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgfSBlbHNlIGlmIChoYXNSYWRpYWxHcmFkaWVudCkge1xuICAgICAgICB0aGlzLl9maWxsUmFkaWFsR3JhZGllbnQoc2hhcGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3N0cm9rZUxpbmVhckdyYWRpZW50OiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdmFyIHN0YXJ0ID0gc2hhcGUuZ2V0U3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCksXG4gICAgICAgIGVuZCA9IHNoYXBlLmdldFN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnQoKSxcbiAgICAgICAgY29sb3JTdG9wcyA9IHNoYXBlLmdldFN0cm9rZUxpbmVhckdyYWRpZW50Q29sb3JTdG9wcygpLFxuICAgICAgICBncmQgPSB0aGlzLmNyZWF0ZUxpbmVhckdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksIGVuZC54LCBlbmQueSk7XG5cbiAgICAgIGlmIChjb2xvclN0b3BzKSB7XG4gICAgICAgIC8vIGJ1aWxkIGNvbG9yIHN0b3BzXG4gICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY29sb3JTdG9wcy5sZW5ndGg7IG4gKz0gMikge1xuICAgICAgICAgIGdyZC5hZGRDb2xvclN0b3AoY29sb3JTdG9wc1tuXSwgY29sb3JTdG9wc1tuICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBncmQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIHZhciBkYXNoID0gc2hhcGUuZGFzaCgpLFxuICAgICAgICAvLyBpZ25vcmUgc3Ryb2tlU2NhbGVFbmFibGVkIGZvciBUZXh0XG4gICAgICAgIHN0cm9rZVNjYWxlRW5hYmxlZCA9XG4gICAgICAgICAgc2hhcGUuZ2V0U3Ryb2tlU2NhbGVFbmFibGVkKCkgfHwgc2hhcGUgaW5zdGFuY2VvZiBLb252YS5UZXh0O1xuXG4gICAgICBpZiAoc2hhcGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgaWYgKCFzdHJva2VTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2FwcGx5TGluZUNhcChzaGFwZSk7XG4gICAgICAgIGlmIChkYXNoICYmIHNoYXBlLmRhc2hFbmFibGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnNldExpbmVEYXNoKGRhc2gpO1xuICAgICAgICAgIHRoaXMuc2V0QXR0cignbGluZURhc2hPZmZzZXQnLCBzaGFwZS5kYXNoT2Zmc2V0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lV2lkdGgnLCBzaGFwZS5zdHJva2VXaWR0aCgpKTtcblxuICAgICAgICBpZiAoIXNoYXBlLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cignc2hhZG93Q29sb3InLCAncmdiYSgwLDAsMCwwKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyAtIGRvIHdlIG5lZWQgdG8gbWFrZSBsaWtlIGEgZmlsbCBmdW5jdGlvbj9cblxuICAgICAgICB2YXIgaGFzTGluZWFyR3JhZGllbnQgPSBzaGFwZS5nZXRTdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICAgICAgaWYgKGhhc0xpbmVhckdyYWRpZW50KSB7XG4gICAgICAgICAgdGhpcy5fc3Ryb2tlTGluZWFyR3JhZGllbnQoc2hhcGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCBzaGFwZS5zdHJva2UoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZS5fc3Ryb2tlRnVuYyh0aGlzKTtcblxuICAgICAgICBpZiAoIXN0cm9rZVNjYWxlRW5hYmxlZCkge1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfYXBwbHlTaGFkb3c6IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIGNvbG9yID0gdXRpbC5nZXQoc2hhcGUuZ2V0U2hhZG93UkdCQSgpLCAnYmxhY2snKSxcbiAgICAgICAgYmx1ciA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd0JsdXIoKSwgNSksXG4gICAgICAgIG9mZnNldCA9IHV0aWwuZ2V0KHNoYXBlLmdldFNoYWRvd09mZnNldCgpLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBUT0RPOiBnZXQgdGhpcyBpbmZvIGZyb20gdHJhbnNmb3JtPz9cbiAgICAgICAgc2NhbGUgPSBzaGFwZS5nZXRBYnNvbHV0ZVNjYWxlKCksXG4gICAgICAgIHJhdGlvID0gdGhpcy5jYW52YXMuZ2V0UGl4ZWxSYXRpbygpLFxuICAgICAgICBzY2FsZVggPSBzY2FsZS54ICogcmF0aW8sXG4gICAgICAgIHNjYWxlWSA9IHNjYWxlLnkgKiByYXRpbztcblxuICAgICAgdGhpcy5zZXRBdHRyKCdzaGFkb3dDb2xvcicsIGNvbG9yKTtcbiAgICAgIHRoaXMuc2V0QXR0cihcbiAgICAgICAgJ3NoYWRvd0JsdXInLFxuICAgICAgICBibHVyICogTWF0aC5taW4oTWF0aC5hYnMoc2NhbGVYKSwgTWF0aC5hYnMoc2NhbGVZKSlcbiAgICAgICk7XG4gICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFgnLCBvZmZzZXQueCAqIHNjYWxlWCk7XG4gICAgICB0aGlzLnNldEF0dHIoJ3NoYWRvd09mZnNldFknLCBvZmZzZXQueSAqIHNjYWxlWSk7XG4gICAgfSxcbiAgICBfYXBwbHlHbG9iYWxDb21wb3NpdGVPcGVyYXRpb246IGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICB2YXIgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc2hhcGUuZ2V0R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKCk7XG4gICAgICBpZiAoZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uICE9PSAnc291cmNlLW92ZXInKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cignZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uJywgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNjZW5lQ29udGV4dCwgS29udmEuQ29udGV4dCk7XG5cbiAgS29udmEuSGl0Q29udGV4dCA9IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgIEtvbnZhLkNvbnRleHQuY2FsbCh0aGlzLCBjYW52YXMpO1xuICB9O1xuXG4gIEtvbnZhLkhpdENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIF9maWxsOiBmdW5jdGlvbihzaGFwZSkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB0aGlzLnNldEF0dHIoJ2ZpbGxTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgIHNoYXBlLl9maWxsRnVuY0hpdCh0aGlzKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX3N0cm9rZTogZnVuY3Rpb24oc2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZS5oYXNTdHJva2UoKSAmJiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCkpIHtcbiAgICAgICAgLy8gaWdub3JlIHN0cm9rZVNjYWxlRW5hYmxlZCBmb3IgVGV4dFxuICAgICAgICB2YXIgc3Ryb2tlU2NhbGVFbmFibGVkID1cbiAgICAgICAgICBzaGFwZS5nZXRTdHJva2VTY2FsZUVuYWJsZWQoKSB8fCBzaGFwZSBpbnN0YW5jZW9mIEtvbnZhLlRleHQ7XG4gICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwbHlMaW5lQ2FwKHNoYXBlKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdsaW5lV2lkdGgnLCBzaGFwZS5zdHJva2VXaWR0aCgpKTtcbiAgICAgICAgdGhpcy5zZXRBdHRyKCdzdHJva2VTdHlsZScsIHNoYXBlLmNvbG9yS2V5KTtcbiAgICAgICAgc2hhcGUuX3N0cm9rZUZ1bmNIaXQodGhpcyk7XG4gICAgICAgIGlmICghc3Ryb2tlU2NhbGVFbmFibGVkKSB7XG4gICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkhpdENvbnRleHQsIEtvbnZhLkNvbnRleHQpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIENPTlNUQU5UU1xuICB2YXIgR0VUID0gJ2dldCcsXG4gICAgU0VUID0gJ3NldCc7XG5cbiAgS29udmEuRmFjdG9yeSA9IHtcbiAgICBhZGRHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYsIHZhbGlkYXRvciwgYWZ0ZXIpIHtcbiAgICAgIHRoaXMuYWRkR2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyLCBkZWYpO1xuICAgICAgdGhpcy5hZGRTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIsIHZhbGlkYXRvciwgYWZ0ZXIpO1xuICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICB9LFxuICAgIGFkZEdldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIsIGRlZikge1xuICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJzW2F0dHJdO1xuICAgICAgICByZXR1cm4gdmFsID09PSB1bmRlZmluZWQgPyBkZWYgOiB2YWw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgYWRkU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBhZnRlcikge1xuICAgICAgdmFyIG1ldGhvZCA9IFNFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0QXR0cihhdHRyLCB2YWwpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIGFmdGVyLmNhbGwodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihcbiAgICAgIGNvbnN0cnVjdG9yLFxuICAgICAgYXR0cixcbiAgICAgIGNvbXBvbmVudHMsXG4gICAgICB2YWxpZGF0b3IsXG4gICAgICBhZnRlclxuICAgICkge1xuICAgICAgdmFyIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoLFxuICAgICAgICBjYXBpdGFsaXplID0gS29udmEuVXRpbC5fY2FwaXRhbGl6ZSxcbiAgICAgICAgZ2V0dGVyID0gR0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgc2V0dGVyID0gU0VUICsgY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgbixcbiAgICAgICAgY29tcG9uZW50O1xuXG4gICAgICAvLyBnZXR0ZXJcbiAgICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZVtnZXR0ZXJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZXQgPSB7fTtcblxuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW25dO1xuICAgICAgICAgIHJldFtjb21wb25lbnRdID0gdGhpcy5nZXRBdHRyKGF0dHIgKyBjYXBpdGFsaXplKGNvbXBvbmVudCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG5cbiAgICAgIC8vIHNldHRlclxuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW3NldHRlcl0gPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIG9sZFZhbCA9IHRoaXMuYXR0cnNbYXR0cl0sXG4gICAgICAgICAga2V5O1xuXG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICB2YWwgPSB2YWxpZGF0b3IuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChrZXkgaW4gdmFsKSB7XG4gICAgICAgICAgaWYgKCF2YWwuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciArIGNhcGl0YWxpemUoa2V5KSwgdmFsW2tleV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGF0dHIsIG9sZFZhbCwgdmFsKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBhZnRlci5jYWxsKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoY29uc3RydWN0b3IsIGF0dHIpO1xuICAgIH0sXG4gICAgYWRkT3ZlcmxvYWRlZEdldHRlclNldHRlcjogZnVuY3Rpb24oY29uc3RydWN0b3IsIGF0dHIpIHtcbiAgICAgIHZhciBjYXBpdGFsaXplZEF0dHIgPSBLb252YS5VdGlsLl9jYXBpdGFsaXplKGF0dHIpLFxuICAgICAgICBzZXR0ZXIgPSBTRVQgKyBjYXBpdGFsaXplZEF0dHIsXG4gICAgICAgIGdldHRlciA9IEdFVCArIGNhcGl0YWxpemVkQXR0cjtcblxuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW2F0dHJdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHNldHRpbmdcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzW3NldHRlcl0oYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXR0aW5nXG4gICAgICAgIHJldHVybiB0aGlzW2dldHRlcl0oKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBhZGREZXByZWNhdGVkR2V0dGVyU2V0dGVyOiBmdW5jdGlvbihjb25zdHJ1Y3RvciwgYXR0ciwgZGVmLCB2YWxpZGF0b3IpIHtcbiAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ0FkZGluZyBkZXByZWNhdGVkICcgKyBhdHRyKTtcblxuICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG5cbiAgICAgIHZhciBtZXNzYWdlID1cbiAgICAgICAgYXR0ciArXG4gICAgICAgICcgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIHNvb24uIExvb2sgYXQgS29udmEgY2hhbmdlIGxvZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nO1xuICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuYXR0cnNbYXR0cl07XG4gICAgICAgIHJldHVybiB2YWwgPT09IHVuZGVmaW5lZCA/IGRlZiA6IHZhbDtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkZFNldHRlcihjb25zdHJ1Y3RvciwgYXR0ciwgdmFsaWRhdG9yLCBmdW5jdGlvbigpIHtcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKGNvbnN0cnVjdG9yLCBhdHRyKTtcbiAgICB9LFxuICAgIGJhY2tDb21wYXQ6IGZ1bmN0aW9uKGNvbnN0cnVjdG9yLCBtZXRob2RzKSB7XG4gICAgICBLb252YS5VdGlsLmVhY2gobWV0aG9kcywgZnVuY3Rpb24ob2xkTWV0aG9kTmFtZSwgbmV3TWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gY29uc3RydWN0b3IucHJvdG90eXBlW25ld01ldGhvZE5hbWVdO1xuICAgICAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGVbb2xkTWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAgICAgb2xkTWV0aG9kTmFtZSArXG4gICAgICAgICAgICAgICcgbWV0aG9kIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBzb29uLiBVc2UgJyArXG4gICAgICAgICAgICAgIG5ld01ldGhvZE5hbWUgK1xuICAgICAgICAgICAgICAnIGluc3RlYWQnXG4gICAgICAgICAgKTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYWZ0ZXJTZXRGaWx0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuVmFsaWRhdG9ycyA9IHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgUkdCQ29tcG9uZW50OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgICAgcmV0dXJuIDI1NTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgfSxcbiAgICBhbHBoYUNvbXBvbmVudDogZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZiAodmFsID4gMSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsIDwgMC4wMDAxKSB7XG4gICAgICAgIC8vIGNocm9tZSBkb2VzIG5vdCBob25vciBhbHBoYSB2YWx1ZXMgb2YgMFxuICAgICAgICByZXR1cm4gMC4wMDAxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIENPTlNUQU5UU1xuICB2YXIgQUJTT0xVVEVfT1BBQ0lUWSA9ICdhYnNvbHV0ZU9wYWNpdHknLFxuICAgIEFCU09MVVRFX1RSQU5TRk9STSA9ICdhYnNvbHV0ZVRyYW5zZm9ybScsXG4gICAgQUJTT0xVVEVfU0NBTEUgPSAnYWJzb2x1dGVTY2FsZScsXG4gICAgQ0hBTkdFID0gJ0NoYW5nZScsXG4gICAgQ0hJTERSRU4gPSAnY2hpbGRyZW4nLFxuICAgIERPVCA9ICcuJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBHRVQgPSAnZ2V0JyxcbiAgICBJRCA9ICdpZCcsXG4gICAgS09OVkEgPSAna29udmEnLFxuICAgIExJU1RFTklORyA9ICdsaXN0ZW5pbmcnLFxuICAgIE1PVVNFRU5URVIgPSAnbW91c2VlbnRlcicsXG4gICAgTU9VU0VMRUFWRSA9ICdtb3VzZWxlYXZlJyxcbiAgICBOQU1FID0gJ25hbWUnLFxuICAgIFNFVCA9ICdzZXQnLFxuICAgIFNIQVBFID0gJ1NoYXBlJyxcbiAgICBTUEFDRSA9ICcgJyxcbiAgICBTVEFHRSA9ICdzdGFnZScsXG4gICAgVFJBTlNGT1JNID0gJ3RyYW5zZm9ybScsXG4gICAgVVBQRVJfU1RBR0UgPSAnU3RhZ2UnLFxuICAgIFZJU0lCTEUgPSAndmlzaWJsZScsXG4gICAgQ0xPTkVfQkxBQ0tfTElTVCA9IFsnaWQnXSxcbiAgICBUUkFOU0ZPUk1fQ0hBTkdFX1NUUiA9IFtcbiAgICAgICd4Q2hhbmdlLmtvbnZhJyxcbiAgICAgICd5Q2hhbmdlLmtvbnZhJyxcbiAgICAgICdzY2FsZVhDaGFuZ2Uua29udmEnLFxuICAgICAgJ3NjYWxlWUNoYW5nZS5rb252YScsXG4gICAgICAnc2tld1hDaGFuZ2Uua29udmEnLFxuICAgICAgJ3NrZXdZQ2hhbmdlLmtvbnZhJyxcbiAgICAgICdyb3RhdGlvbkNoYW5nZS5rb252YScsXG4gICAgICAnb2Zmc2V0WENoYW5nZS5rb252YScsXG4gICAgICAnb2Zmc2V0WUNoYW5nZS5rb252YScsXG4gICAgICAndHJhbnNmb3Jtc0VuYWJsZWRDaGFuZ2Uua29udmEnXG4gICAgXS5qb2luKFNQQUNFKSxcbiAgICBTQ0FMRV9DSEFOR0VfU1RSID0gWydzY2FsZVhDaGFuZ2Uua29udmEnLCAnc2NhbGVZQ2hhbmdlLmtvbnZhJ10uam9pbihTUEFDRSk7XG5cbiAgLyoqXG4gICAqIE5vZGUgY29uc3RydWN0b3IuIE5vZGVzIGFyZSBlbnRpdGllcyB0aGF0IGNhbiBiZSB0cmFuc2Zvcm1lZCwgbGF5ZXJlZCxcbiAgICogYW5kIGhhdmUgYm91bmQgZXZlbnRzLiBUaGUgc3RhZ2UsIGxheWVycywgZ3JvdXBzLCBhbmQgc2hhcGVzIGFsbCBleHRlbmQgTm9kZS5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYWJzdHJhY3RcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKi9cbiAgS29udmEuTm9kZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTm9kZSwge1xuICAgIF9pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMuX2lkID0gS29udmEuaWRDb3VudGVyKys7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzID0ge307XG4gICAgICB0aGlzLmF0dHJzID0ge307XG4gICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzVW5kZXJDYWNoZSA9IGZhbHNlO1xuICAgICAgdGhpcy5zZXRBdHRycyhjb25maWcpO1xuXG4gICAgICAvLyBldmVudCBiaW5kaW5ncyBmb3IgY2FjaGUgaGFuZGxpbmdcbiAgICAgIHRoaXMub24oVFJBTlNGT1JNX0NIQU5HRV9TVFIsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMub24oU0NBTEVfQ0hBTkdFX1NUUiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9TQ0FMRSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vbigndmlzaWJsZUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoVklTSUJMRSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2xpc3RlbmluZ0NoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoTElTVEVOSU5HKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vbignb3BhY2l0eUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIF9jbGVhckNhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENhY2hlOiBmdW5jdGlvbihhdHRyLCBwcml2YXRlR2V0dGVyKSB7XG4gICAgICB2YXIgY2FjaGUgPSB0aGlzLl9jYWNoZVthdHRyXTtcblxuICAgICAgLy8gaWYgbm90IGNhY2hlZCwgd2UgbmVlZCB0byBzZXQgaXQgdXNpbmcgdGhlIHByaXZhdGUgZ2V0dGVyIG1ldGhvZC5cbiAgICAgIGlmIChjYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlW2F0dHJdID0gcHJpdmF0ZUdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGVbYXR0cl07XG4gICAgfSxcbiAgICAvKlxuICAgICAgICAgKiB3aGVuIHRoZSBsb2dpYyBmb3IgYSBjYWNoZWQgcmVzdWx0IGRlcGVuZHMgb24gYW5jZXN0b3IgcHJvcGFnYXRpb24sIHVzZSB0aGlzXG4gICAgICAgICAqIG1ldGhvZCB0byBjbGVhciBzZWxmIGFuZCBjaGlsZHJlbiBjYWNoZVxuICAgICAgICAgKi9cbiAgICBfY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICB0aGlzLl9jbGVhckNhY2hlKGF0dHIpO1xuXG4gICAgICBpZiAodGhpcy5jaGlsZHJlbikge1xuICAgICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgbm9kZS5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKGF0dHIpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsZWFyIGNhY2hlZCBjYW52YXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNsZWFyQ2FjaGUoKTtcbiAgICAgKi9cbiAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9jYWNoZS5jYW52YXM7XG4gICAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiAgY2FjaGUgbm9kZSB0byBpbXByb3ZlIGRyYXdpbmcgcGVyZm9ybWFuY2UsIGFwcGx5IGZpbHRlcnMsIG9yIGNyZWF0ZSBtb3JlIGFjY3VyYXRlXG4gICAgICogIGhpdCByZWdpb25zLiBGb3IgYWxsIGJhc2ljIHNoYXBlcyBzaXplIG9mIGNhY2hlIGNhbnZhcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0ZWQuXG4gICAgICogIElmIHlvdSBuZWVkIHRvIGNhY2hlIHlvdXIgY3VzdG9tIGBLb252YS5TaGFwZWAgaW5zdGFuY2UgeW91IGhhdmUgdG8gcGFzcyBzaGFwZSdzIGJvdW5kaW5nIGJveFxuICAgICAqICBwcm9wZXJ0aWVzLiBMb29rIGF0IFtodHRwczovL2tvbnZhanMuZ2l0aHViLmlvL2RvY3MvcGVyZm9ybWFuY2UvU2hhcGVfQ2FjaGluZy5odG1sXShsaW5rIHRvIGRlbW8gcGFnZSkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0XSAgaW5jcmVhc2UgY2FudmFzIHNpemUgYnkgYG9mZnNldGAgcGl4ZWwgaW4gYWxsIGRpcmVjdGlvbnMuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYXdCb3JkZXJdIHdoZW4gc2V0IHRvIHRydWUsIGEgcmVkIGJvcmRlciB3aWxsIGJlIGRyYXduIGFyb3VuZCB0aGUgY2FjaGVkXG4gICAgICogIHJlZ2lvbiBmb3IgZGVidWdnaW5nIHB1cnBvc2VzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gY2hhbmdlIHF1YWxpdHkgKG9yIHBpeGVsIHJhdGlvKSBvZiBjYWNoZWQgaW1hZ2UuIHBpeGVsUmF0aW8gPSAyIHdpbGwgcHJvZHVjZSAyeCBzaXplZCBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGNhY2hlIGEgc2hhcGUgd2l0aCB0aGUgeCx5IHBvc2l0aW9uIG9mIHRoZSBib3VuZGluZyBib3ggYXQgdGhlIGNlbnRlciBhbmRcbiAgICAgKiAvLyB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94IGVxdWFsIHRvIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mXG4gICAgICogLy8gdGhlIHNoYXBlIG9idGFpbmVkIGZyb20gc2hhcGUud2lkdGgoKSBhbmQgc2hhcGUuaGVpZ2h0KClcbiAgICAgKiBpbWFnZS5jYWNoZSgpO1xuICAgICAqXG4gICAgICogLy8gY2FjaGUgYSBub2RlIGFuZCBkZWZpbmUgdGhlIGJvdW5kaW5nIGJveCBwb3NpdGlvbiBhbmQgc2l6ZVxuICAgICAqIG5vZGUuY2FjaGUoe1xuICAgICAqICAgeDogLTMwLFxuICAgICAqICAgeTogLTMwLFxuICAgICAqICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBjYWNoZSBhIG5vZGUgYW5kIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgYm91bmRpbmcgYm94XG4gICAgICogLy8gZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAqIG5vZGUuY2FjaGUoe1xuICAgICAqICAgeDogLTMwLFxuICAgICAqICAgeTogLTMwLFxuICAgICAqICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgIGhlaWdodDogMjAwLFxuICAgICAqICAgb2Zmc2V0IDogMTAsXG4gICAgICogICBkcmF3Qm9yZGVyOiB0cnVlXG4gICAgICogfSk7XG4gICAgICovXG4gICAgY2FjaGU6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIGNvbmYgPSBjb25maWcgfHwge30sXG4gICAgICAgIHJlY3QgPSB0aGlzLmdldENsaWVudFJlY3Qoe1xuICAgICAgICAgIHNraXBUcmFuc2Zvcm06IHRydWUsXG4gICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5nZXRQYXJlbnQoKVxuICAgICAgICB9KSxcbiAgICAgICAgd2lkdGggPSBjb25mLndpZHRoIHx8IHJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGNvbmYuaGVpZ2h0IHx8IHJlY3QuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvID0gY29uZi5waXhlbFJhdGlvLFxuICAgICAgICB4ID0gY29uZi54IHx8IHJlY3QueCxcbiAgICAgICAgeSA9IGNvbmYueSB8fCByZWN0LnksXG4gICAgICAgIG9mZnNldCA9IGNvbmYub2Zmc2V0IHx8IDAsXG4gICAgICAgIGRyYXdCb3JkZXIgPSBjb25mLmRyYXdCb3JkZXIgfHwgZmFsc2U7XG5cbiAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xuICAgICAgICAvLyBtYWtlIHRocm93IGFzeW5jLCBiZWNhdXNlIHdlIGRvbid0IG5lZWQgdG8gc3RvcCBmdW5jaW9uXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgS29udmEuVXRpbC50aHJvdyhcbiAgICAgICAgICAgICdXaWR0aCBvciBoZWlnaHQgb2YgY2FjaGluZyBjb25maWd1cmF0aW9uIGVxdWFscyAwLiBDYWNoaW5nIGlzIGlnbm9yZWQuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHdpZHRoICs9IG9mZnNldCAqIDI7XG4gICAgICBoZWlnaHQgKz0gb2Zmc2V0ICogMjtcblxuICAgICAgeCAtPSBvZmZzZXQ7XG4gICAgICB5IC09IG9mZnNldDtcblxuICAgICAgdmFyIGNhY2hlZFNjZW5lQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgY2FjaGVkRmlsdGVyQ2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKHtcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KSxcbiAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7XG4gICAgICAgICAgcGl4ZWxSYXRpbzogMSxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfSksXG4gICAgICAgIHNjZW5lQ29udGV4dCA9IGNhY2hlZFNjZW5lQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgaGl0Q29udGV4dCA9IGNhY2hlZEhpdENhbnZhcy5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGNhY2hlZEhpdENhbnZhcy5pc0NhY2hlID0gdHJ1ZTtcblxuICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XG5cbiAgICAgIHNjZW5lQ29udGV4dC5zYXZlKCk7XG4gICAgICBoaXRDb250ZXh0LnNhdmUoKTtcblxuICAgICAgc2NlbmVDb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICAgICAgaGl0Q29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcblxuICAgICAgLy8gZXh0cmEgZmxhZyB0byBza2lwIG9uIGdldEFic29sdXRlIG9wYWNpdHkgY2FsY1xuICAgICAgdGhpcy5faXNVbmRlckNhY2hlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9PUEFDSVRZKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9TQ0FMRSk7XG5cbiAgICAgIHRoaXMuZHJhd1NjZW5lKGNhY2hlZFNjZW5lQ2FudmFzLCB0aGlzLCB0cnVlKTtcbiAgICAgIHRoaXMuZHJhd0hpdChjYWNoZWRIaXRDYW52YXMsIHRoaXMsIHRydWUpO1xuICAgICAgdGhpcy5faXNVbmRlckNhY2hlID0gZmFsc2U7XG5cbiAgICAgIHNjZW5lQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICBoaXRDb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgLy8gdGhpcyB3aWxsIGRyYXcgYSByZWQgYm9yZGVyIGFyb3VuZCB0aGUgY2FjaGVkIGJveCBmb3JcbiAgICAgIC8vIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgaWYgKGRyYXdCb3JkZXIpIHtcbiAgICAgICAgc2NlbmVDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgc2NlbmVDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBzY2VuZUNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgc2NlbmVDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBzY2VuZUNvbnRleHQuc2V0QXR0cignc3Ryb2tlU3R5bGUnLCAncmVkJyk7XG4gICAgICAgIHNjZW5lQ29udGV4dC5zZXRBdHRyKCdsaW5lV2lkdGgnLCA1KTtcbiAgICAgICAgc2NlbmVDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICBzY2VuZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZS5jYW52YXMgPSB7XG4gICAgICAgIHNjZW5lOiBjYWNoZWRTY2VuZUNhbnZhcyxcbiAgICAgICAgZmlsdGVyOiBjYWNoZWRGaWx0ZXJDYW52YXMsXG4gICAgICAgIGhpdDogY2FjaGVkSGl0Q2FudmFzLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBjbGllbnQgcmVjdGFuZ2xlIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBvZiBub2RlLiBUaGlzIHJlY3RhbmdsZSBhbHNvIGluY2x1ZGUgYWxsIHN0eWxpbmcgKHN0cm9rZXMsIHNoYWRvd3MsIGV0YykuXG4gICAgICogVGhlIHJlY3RhbmdsZSBwb3NpdGlvbiBpcyByZWxhdGl2ZSB0byBwYXJlbnQgY29udGFpbmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNraXBUcmFuc2Zvcm1dIHNob3VsZCB3ZSBhcHBseSB0cmFuc2Zvcm0gdG8gbm9kZSBmb3IgY2FsY3VsYXRpbmcgcmVjdD9cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5yZWxhdGl2ZVRvXSBjYWxjdWxhdGUgY2xpZW50IHJlY3QgcmVsYXRpdmUgdG8gb25lIG9mIHRoZSBwYXJlbnRzXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcmVjdCA9IG5ldyBLb252YS5SZWN0KHtcbiAgICAgKiAgICAgIHdpZHRoIDogMTAwLFxuICAgICAqICAgICAgaGVpZ2h0IDogMTAwLFxuICAgICAqICAgICAgeCA6IDUwLFxuICAgICAqICAgICAgeSA6IDUwLFxuICAgICAqICAgICAgc3Ryb2tlV2lkdGggOiA0LFxuICAgICAqICAgICAgc3Ryb2tlIDogJ2JsYWNrJyxcbiAgICAgKiAgICAgIG9mZnNldFggOiA1MCxcbiAgICAgKiAgICAgIHNjYWxlWSA6IDJcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRob3V0IHRoaW5rIG9mZiB0cmFuc2Zvcm1hdGlvbnMgKHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIG9mZnNldCwgZXRjKVxuICAgICAqIHJlY3QuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IHRydWV9KTtcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAvLyAgICAgeCA6IC0yLCAgIC8vIHR3byBwaXhlbHMgZm9yIHN0cm9rZSAvIDJcbiAgICAgKiAvLyAgICAgeSA6IC0yLFxuICAgICAqIC8vICAgICB3aWR0aCA6IDEwNCwgLy8gaW5jcmVhc2VkIGJ5IDQgZm9yIHN0cm9rZVxuICAgICAqIC8vICAgICBoZWlnaHQgOiAxMDRcbiAgICAgKiAvL31cbiAgICAgKlxuICAgICAqIC8vIGdldCBjbGllbnQgcmVjdCB3aXRoIHRyYW5zZm9ybWF0aW9uIGFwcGxpZWRcbiAgICAgKiByZWN0LmdldENsaWVudFJlY3QoKTtcbiAgICAgKiAvLyByZXR1cm5zIE9iamVjdCB7eDogLTIsIHk6IDQ2LCB3aWR0aDogMTA0LCBoZWlnaHQ6IDIwOH1cbiAgICAgKi9cbiAgICBnZXRDbGllbnRSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGFic3RyYWN0IG1ldGhvZFxuICAgICAgLy8gcmVkZWZpbmUgaW4gQ29udGFpbmVyIGFuZCBTaGFwZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdhYnN0cmFjdCBcImdldENsaWVudFJlY3RcIiBtZXRob2QgY2FsbCcpO1xuICAgIH0sXG4gICAgX3RyYW5zZm9ybWVkUmVjdDogZnVuY3Rpb24ocmVjdCwgdG9wKSB7XG4gICAgICB2YXIgcG9pbnRzID0gW1xuICAgICAgICB7IHg6IHJlY3QueCwgeTogcmVjdC55IH0sXG4gICAgICAgIHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55IH0sXG4gICAgICAgIHsgeDogcmVjdC54ICsgcmVjdC53aWR0aCwgeTogcmVjdC55ICsgcmVjdC5oZWlnaHQgfSxcbiAgICAgICAgeyB4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IH1cbiAgICAgIF07XG4gICAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WTtcbiAgICAgIHZhciB0cmFucyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1lZCA9IHRyYW5zLnBvaW50KHBvaW50KTtcbiAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pblggPSBtYXhYID0gdHJhbnNmb3JtZWQueDtcbiAgICAgICAgICBtaW5ZID0gbWF4WSA9IHRyYW5zZm9ybWVkLnk7XG4gICAgICAgIH1cbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHRyYW5zZm9ybWVkLngpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgdHJhbnNmb3JtZWQueSk7XG4gICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB0cmFuc2Zvcm1lZC54KTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHRyYW5zZm9ybWVkLnkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBtaW5YLFxuICAgICAgICB5OiBtaW5ZLFxuICAgICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pbllcbiAgICAgIH07XG4gICAgfSxcbiAgICBfZHJhd0NhY2hlZFNjZW5lQ2FudmFzOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgY29udGV4dC50cmFuc2xhdGUodGhpcy5fY2FjaGUuY2FudmFzLngsIHRoaXMuX2NhY2hlLmNhbnZhcy55KTtcblxuICAgICAgdmFyIGNhY2hlQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKTtcbiAgICAgIHZhciByYXRpbyA9IGNhY2hlQ2FudmFzLnBpeGVsUmF0aW87XG5cbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICBjYWNoZUNhbnZhcy5fY2FudmFzLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBjYWNoZUNhbnZhcy53aWR0aCAvIHJhdGlvLFxuICAgICAgICBjYWNoZUNhbnZhcy5oZWlnaHQgLyByYXRpb1xuICAgICAgKTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX2RyYXdDYWNoZWRIaXRDYW52YXM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIGhpdENhbnZhcyA9IGNhY2hlZENhbnZhcy5oaXQ7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHRoaXMuX2NhY2hlLmNhbnZhcy54LCB0aGlzLl9jYWNoZS5jYW52YXMueSk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZShoaXRDYW52YXMuX2NhbnZhcywgMCwgMCk7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIF9nZXRDYWNoZWRTY2VuZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlsdGVycyA9IHRoaXMuZmlsdGVycygpLFxuICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIHNjZW5lQ2FudmFzID0gY2FjaGVkQ2FudmFzLnNjZW5lLFxuICAgICAgICBmaWx0ZXJDYW52YXMgPSBjYWNoZWRDYW52YXMuZmlsdGVyLFxuICAgICAgICBmaWx0ZXJDb250ZXh0ID0gZmlsdGVyQ2FudmFzLmdldENvbnRleHQoKSxcbiAgICAgICAgbGVuLFxuICAgICAgICBpbWFnZURhdGEsXG4gICAgICAgIG4sXG4gICAgICAgIGZpbHRlcjtcblxuICAgICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maWx0ZXJVcFRvRGF0ZSkge1xuICAgICAgICAgIHZhciByYXRpbyA9IHNjZW5lQ2FudmFzLnBpeGVsUmF0aW87XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGVuID0gZmlsdGVycy5sZW5ndGg7XG4gICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgIC8vIGNvcHkgY2FjaGVkIGNhbnZhcyBvbnRvIGZpbHRlciBjb250ZXh0XG4gICAgICAgICAgICBmaWx0ZXJDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgc2NlbmVDYW52YXMuX2NhbnZhcyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgc2NlbmVDYW52YXMuZ2V0V2lkdGgoKSAvIHJhdGlvLFxuICAgICAgICAgICAgICBzY2VuZUNhbnZhcy5nZXRIZWlnaHQoKSAvIHJhdGlvXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaW1hZ2VEYXRhID0gZmlsdGVyQ29udGV4dC5nZXRJbWFnZURhdGEoXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgIGZpbHRlckNhbnZhcy5nZXRXaWR0aCgpLFxuICAgICAgICAgICAgICBmaWx0ZXJDYW52YXMuZ2V0SGVpZ2h0KClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIGFwcGx5IGZpbHRlcnMgdG8gZmlsdGVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgICBmaWx0ZXIgPSBmaWx0ZXJzW25dO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAnRmlsdGVyIHNob3VsZCBiZSB0eXBlIG9mIGZ1bmN0aW9uLCBidXQgZ290ICcgK1xuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZmlsdGVyICtcbiAgICAgICAgICAgICAgICAgICAgJyBpbnN0ZWQuIFBsZWFzZSBjaGVjayBjb3JyZWN0IGZpbHRlcnMnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaWx0ZXIuY2FsbCh0aGlzLCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgICBmaWx0ZXJDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ1VuYWJsZSB0byBhcHBseSBmaWx0ZXIuICcgKyBlLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJDYW52YXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2NlbmVDYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBiaW5kIGV2ZW50cyB0byB0aGUgbm9kZS4gS29udmFKUyBzdXBwb3J0cyBtb3VzZW92ZXIsIG1vdXNlbW92ZSxcbiAgICAgKiAgbW91c2VvdXQsIG1vdXNlZW50ZXIsIG1vdXNlbGVhdmUsIG1vdXNlZG93biwgbW91c2V1cCwgd2hlZWwsIGNvbnRleHRtZW51LCBjbGljaywgZGJsY2xpY2ssIHRvdWNoc3RhcnQsIHRvdWNobW92ZSxcbiAgICAgKiAgdG91Y2hlbmQsIHRhcCwgZGJsdGFwLCBkcmFnc3RhcnQsIGRyYWdtb3ZlLCBhbmQgZHJhZ2VuZCBldmVudHMuIFRoZSBLb252YSBTdGFnZSBzdXBwb3J0c1xuICAgICAqICBjb250ZW50TW91c2VvdmVyLCBjb250ZW50TW91c2Vtb3ZlLCBjb250ZW50TW91c2VvdXQsIGNvbnRlbnRNb3VzZWRvd24sIGNvbnRlbnRNb3VzZXVwLCBjb250ZW50V2hlZWwsIGNvbnRlbnRDb250ZXh0bWVudVxuICAgICAqICBjb250ZW50Q2xpY2ssIGNvbnRlbnREYmxjbGljaywgY29udGVudFRvdWNoc3RhcnQsIGNvbnRlbnRUb3VjaG1vdmUsIGNvbnRlbnRUb3VjaGVuZCwgY29udGVudFRhcCxcbiAgICAgKiAgYW5kIGNvbnRlbnREYmxUYXAuICBQYXNzIGluIGEgc3RyaW5nIG9mIGV2ZW50cyBkZWxpbWl0ZWQgYnkgYSBzcGFjZSB0byBiaW5kIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gICAgICogIHN1Y2ggYXMgJ21vdXNlZG93biBtb3VzZXVwIG1vdXNlbW92ZScuIEluY2x1ZGUgYSBuYW1lc3BhY2UgdG8gYmluZCBhblxuICAgICAqICBldmVudCBieSBuYW1lIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldnRTdHIgZS5nLiAnY2xpY2snLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCAnbW91c2Vkb3duLmZvbyB0b3VjaHN0YXJ0LmZvbydcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIGlzIHBhc3NlZCBhbiBldmVudCBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGFkZCBjbGljayBsaXN0ZW5lclxuICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygneW91IGNsaWNrZWQgbWUhJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgdGhlIHRhcmdldCBub2RlXG4gICAgICogbm9kZS5vbignY2xpY2snLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKGV2dC50YXJnZXQpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gc3RvcCBldmVudCBwcm9wYWdhdGlvblxuICAgICAqIG5vZGUub24oJ2NsaWNrJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICBldnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGJpbmQgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICogbm9kZS5vbignY2xpY2sgdG91Y2hzdGFydCcsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgY29uc29sZS5sb2coJ3lvdSBjbGlja2VkL3RvdWNoZWQgbWUhJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBuYW1lc3BhY2UgbGlzdGVuZXJcbiAgICAgKiBub2RlLm9uKCdjbGljay5mb28nLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCd5b3UgY2xpY2tlZC90b3VjaGVkIG1lIScpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gZ2V0IHRoZSBldmVudCB0eXBlXG4gICAgICogbm9kZS5vbignY2xpY2sgdGFwJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICogICB2YXIgZXZlbnRUeXBlID0gZXZ0LnR5cGU7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgbmF0aXZlIGV2ZW50IG9iamVjdFxuICAgICAqIG5vZGUub24oJ2NsaWNrIHRhcCcsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAqICAgdmFyIG5hdGl2ZUV2ZW50ID0gZXZ0LmV2dDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGZvciBjaGFuZ2UgZXZlbnRzLCBnZXQgdGhlIG9sZCBhbmQgbmV3IHZhbFxuICAgICAqIG5vZGUub24oJ3hDaGFuZ2UnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgIHZhciBvbGRWYWwgPSBldnQub2xkVmFsO1xuICAgICAqICAgdmFyIG5ld1ZhbCA9IGV2dC5uZXdWYWw7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgZXZlbnQgdGFyZ2V0c1xuICAgICAqIC8vIHdpdGggZXZlbnQgZGVsZWdhdGlvbnNcbiAgICAgKiBsYXllci5vbignY2xpY2snLCAnR3JvdXAnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgKiAgIHZhciBzaGFwZSA9IGV2dC50YXJnZXQ7XG4gICAgICogICB2YXIgZ3JvdXAgPSBldnRuLmN1cnJlbnRUYXJnZXI7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2dFN0ciwgaGFuZGxlcikge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbGVnYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICB2YXIgZXZlbnRzID0gZXZ0U3RyLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgbGVuID0gZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHBhcnRzLFxuICAgICAgICBiYXNlRXZlbnQsXG4gICAgICAgIG5hbWU7XG5cbiAgICAgIC8qXG4gICAgICAgICAgICAgKiBsb29wIHRocm91Z2ggdHlwZXMgYW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMgdG9cbiAgICAgICAgICAgICAqIGVhY2ggb25lLiAgZWcuICdjbGljayBtb3VzZW92ZXIubmFtZXNwYWNlIG1vdXNlb3V0J1xuICAgICAgICAgICAgICogd2lsbCBjcmVhdGUgdGhyZWUgZXZlbnQgYmluZGluZ3NcbiAgICAgICAgICAgICAqL1xuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGV2ZW50ID0gZXZlbnRzW25dO1xuICAgICAgICBwYXJ0cyA9IGV2ZW50LnNwbGl0KERPVCk7XG4gICAgICAgIGJhc2VFdmVudCA9IHBhcnRzWzBdO1xuICAgICAgICBuYW1lID0gcGFydHNbMV0gfHwgRU1QVFlfU1RSSU5HO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBldmVudHMgYXJyYXkgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgICAgICBpZiAoIXRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyc1tiYXNlRXZlbnRdLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgaGFuZGxlcjogaGFuZGxlclxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgZXZlbnQgYmluZGluZ3MgZnJvbSB0aGUgbm9kZS4gUGFzcyBpbiBhIHN0cmluZyBvZlxuICAgICAqICBldmVudCB0eXBlcyBkZWxpbW1pdGVkIGJ5IGEgc3BhY2UgdG8gcmVtb3ZlIG11bHRpcGxlIGV2ZW50XG4gICAgICogIGJpbmRpbmdzIGF0IG9uY2Ugc3VjaCBhcyAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlJy5cbiAgICAgKiAgaW5jbHVkZSBhIG5hbWVzcGFjZSB0byByZW1vdmUgYW4gZXZlbnQgYmluZGluZyBieSBuYW1lXG4gICAgICogIHN1Y2ggYXMgJ2NsaWNrLmZvb2JhcicuIElmIHlvdSBvbmx5IGdpdmUgYSBuYW1lIGxpa2UgJy5mb29iYXInLFxuICAgICAqICBhbGwgZXZlbnRzIGluIHRoYXQgbmFtZXNwYWNlIHdpbGwgYmUgcmVtb3ZlZC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dFN0ciBlLmcuICdjbGljaycsICdtb3VzZWRvd24gdG91Y2hzdGFydCcsICcuZm9vYmFyJ1xuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gcmVtb3ZlIGxpc3RlbmVyXG4gICAgICogbm9kZS5vZmYoJ2NsaWNrJyk7XG4gICAgICpcbiAgICAgKiAvLyByZW1vdmUgbXVsdGlwbGUgbGlzdGVuZXJzXG4gICAgICogbm9kZS5vZmYoJ2NsaWNrIHRvdWNoc3RhcnQnKTtcbiAgICAgKlxuICAgICAqIC8vIHJlbW92ZSBsaXN0ZW5lciBieSBuYW1lXG4gICAgICogbm9kZS5vZmYoJ2NsaWNrLmZvbycpO1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZ0U3RyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGV2ZW50cyA9IChldnRTdHIgfHwgJycpLnNwbGl0KFNQQUNFKSxcbiAgICAgICAgbGVuID0gZXZlbnRzLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgdCxcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIHBhcnRzLFxuICAgICAgICBiYXNlRXZlbnQsXG4gICAgICAgIG5hbWU7XG5cbiAgICAgIGlmICghZXZ0U3RyKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgZXZlbnRzXG4gICAgICAgIGZvciAodCBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgdGhpcy5fb2ZmKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgZXZlbnQgPSBldmVudHNbbl07XG4gICAgICAgIHBhcnRzID0gZXZlbnQuc3BsaXQoRE9UKTtcbiAgICAgICAgYmFzZUV2ZW50ID0gcGFydHNbMF07XG4gICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcblxuICAgICAgICBpZiAoYmFzZUV2ZW50KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZXZlbnRMaXN0ZW5lcnNbYmFzZUV2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5fb2ZmKGJhc2VFdmVudCwgbmFtZSwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKHQgaW4gdGhpcy5ldmVudExpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fb2ZmKHQsIG5hbWUsIGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gc29tZSBldmVudCBhbGlhc2VzIGZvciB0aGlyZCBwYXJ0eSBpbnRlZ3JhdGlvbiBsaWtlIEhhbW1lckpTXG4gICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgZSA9IHtcbiAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICB0eXBlOiBldnQudHlwZSxcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoZXZ0LnR5cGUsIGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gICAgICAvLyB3ZSBoYXZlIHRvIHBhc3MgbmF0aXZlIGV2ZW50IHRvIGhhbmRsZXJcbiAgICAgIHRoaXMub24odHlwZSwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBldnQuZXZ0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB0aGlzLm9mZih0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gbGlrZSBub2RlLm9uXG4gICAgX2RlbGVnYXRlOiBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGhhbmRsZXIpIHtcbiAgICAgIHZhciBzdG9wTm9kZSA9IHRoaXM7XG4gICAgICB0aGlzLm9uKGV2ZW50LCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHRhcmdldHMgPSBldnQudGFyZ2V0LmZpbmRBbmNlc3RvcnMoc2VsZWN0b3IsIHRydWUsIHN0b3BOb2RlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXZ0ID0gS29udmEuVXRpbC5jbG9uZU9iamVjdChldnQpO1xuICAgICAgICAgIGV2dC5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGFyZ2V0c1tpXSwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgc2VsZiBmcm9tIHBhcmVudCwgYnV0IGRvbid0IGRlc3Ryb3lcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLnJlbW92ZSgpO1xuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcblxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4LCAxKTtcbiAgICAgICAgcGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBldmVyeSBjYWNoZWQgYXR0ciB0aGF0IGlzIGNhbGN1bGF0ZWQgdmlhIG5vZGUgdHJlZVxuICAgICAgLy8gdHJhdmVyc2FsIG11c3QgYmUgY2xlYXJlZCB3aGVuIHJlbW92aW5nIGEgbm9kZVxuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFNUQUdFKTtcbiAgICAgIHRoaXMuX2NsZWFyU2VsZkFuZERlc2NlbmRhbnRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0pO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKFZJU0lCTEUpO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKExJU1RFTklORyk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIGFuZCBkZXN0cm95IHNlbGZcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmRlc3Ryb3koKTtcbiAgICAgKi9cbiAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHJlbW92ZSBmcm9tIGlkcyBhbmQgbmFtZXMgaGFzaGVzXG4gICAgICBLb252YS5fcmVtb3ZlSWQodGhpcy5nZXRJZCgpKTtcblxuICAgICAgLy8gcmVtb3ZlIGFsbCBuYW1lc1xuICAgICAgdmFyIG5hbWVzID0gKHRoaXMuZ2V0TmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VibmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBLb252YS5fcmVtb3ZlTmFtZShzdWJuYW1lLCB0aGlzLl9pZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhdHRyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICogQHJldHVybnMge0ludGVnZXJ8U3RyaW5nfE9iamVjdHxBcnJheX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciB4ID0gbm9kZS5nZXRBdHRyKCd4Jyk7XG4gICAgICovXG4gICAgZ2V0QXR0cjogZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIG1ldGhvZCA9IEdFVCArIEtvbnZhLlV0aWwuX2NhcGl0YWxpemUoYXR0cik7XG4gICAgICBpZiAoS29udmEuVXRpbC5faXNGdW5jdGlvbih0aGlzW21ldGhvZF0pKSB7XG4gICAgICAgIHJldHVybiB0aGlzW21ldGhvZF0oKTtcbiAgICAgIH1cbiAgICAgIC8vIG90aGVyd2lzZSBnZXQgZGlyZWN0bHlcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzW2F0dHJdO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGFuY2VzdG9yc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuQ29sbGVjdGlvbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNoYXBlLmdldEFuY2VzdG9ycygpLmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgICAqICAgY29uc29sZS5sb2cobm9kZS5nZXRJZCgpKTtcbiAgICAgKiB9KVxuICAgICAqL1xuICAgIGdldEFuY2VzdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKSxcbiAgICAgICAgYW5jZXN0b3JzID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcblxuICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChwYXJlbnQpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYXR0cnMgb2JqZWN0IGxpdGVyYWxcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRBdHRyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRycyB8fCB7fTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNldCBtdWx0aXBsZSBhdHRycyBhdCBvbmNlIHVzaW5nIGFuIG9iamVjdCBsaXRlcmFsXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgb2JqZWN0IGNvbnRhaW5pbmcga2V5IHZhbHVlIHBhaXJzXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLnNldEF0dHJzKHtcbiAgICAgKiAgIHg6IDUsXG4gICAgICogICBmaWxsOiAncmVkJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHNldEF0dHJzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHZhciBrZXksIG1ldGhvZDtcblxuICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBmb3IgKGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2QgPSBTRVQgKyBLb252YS5VdGlsLl9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgIC8vIHVzZSBzZXR0ZXIgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChLb252YS5VdGlsLl9pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcbiAgICAgICAgICB0aGlzW21ldGhvZF0oY29uZmlnW2tleV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSBzZXQgZGlyZWN0bHlcbiAgICAgICAgICB0aGlzLl9zZXRBdHRyKGtleSwgY29uZmlnW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzIGJ5IHRha2luZyBpbnRvIGFjY291bnQgYW5jZXN0b3JzLlxuICAgICAqXG4gICAgICogUGFyZW50ICAgIHwgU2VsZiAgICAgIHwgaXNMaXN0ZW5pbmdcbiAgICAgKiBsaXN0ZW5pbmcgfCBsaXN0ZW5pbmcgfFxuICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICogVCAgICAgICAgIHwgVCAgICAgICAgIHwgVFxuICAgICAqIFQgICAgICAgICB8IEYgICAgICAgICB8IEZcbiAgICAgKiBGICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICogRiAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAqIC0tLS0tLS0tLS0rLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tXG4gICAgICogVCAgICAgICAgIHwgSSAgICAgICAgIHwgVFxuICAgICAqIEYgICAgICAgICB8IEkgICAgICAgICB8IEZcbiAgICAgKiBJICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNMaXN0ZW5pbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKExJU1RFTklORywgdGhpcy5faXNMaXN0ZW5pbmcpO1xuICAgIH0sXG4gICAgX2lzTGlzdGVuaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsaXN0ZW5pbmcgPSB0aGlzLmdldExpc3RlbmluZygpLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgIGlmIChsaXN0ZW5pbmcgPT09ICdpbmhlcml0Jykge1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHBhcmVudC5pc0xpc3RlbmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbGlzdGVuaW5nO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIG5vZGUgaXMgdmlzaWJsZSBieSB0YWtpbmcgaW50byBhY2NvdW50IGFuY2VzdG9ycy5cbiAgICAgKlxuICAgICAqIFBhcmVudCAgICB8IFNlbGYgICAgICB8IGlzVmlzaWJsZVxuICAgICAqIHZpc2libGUgICB8IHZpc2libGUgICB8XG4gICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgKiBUICAgICAgICAgfCBUICAgICAgICAgfCBUXG4gICAgICogVCAgICAgICAgIHwgRiAgICAgICAgIHwgRlxuICAgICAqIEYgICAgICAgICB8IFQgICAgICAgICB8IFRcbiAgICAgKiBGICAgICAgICAgfCBGICAgICAgICAgfCBGXG4gICAgICogLS0tLS0tLS0tLSstLS0tLS0tLS0tLSstLS0tLS0tLS0tLS1cbiAgICAgKiBUICAgICAgICAgfCBJICAgICAgICAgfCBUXG4gICAgICogRiAgICAgICAgIHwgSSAgICAgICAgIHwgRlxuICAgICAqIEkgICAgICAgICB8IEkgICAgICAgICB8IFRcblxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICovXG4gICAgaXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShWSVNJQkxFLCB0aGlzLl9pc1Zpc2libGUpO1xuICAgIH0sXG4gICAgX2lzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZ2V0VmlzaWJsZSgpLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuXG4gICAgICAvLyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIGEgc2ltcGxpZmljYXRpb24gb2YgdGhlIHRydXRoIHRhYmxlIGFib3ZlLlxuICAgICAgLy8gcGxlYXNlIG1vZGlmeSBjYXJlZnVsbHlcbiAgICAgIGlmICh2aXNpYmxlID09PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnQuaXNWaXNpYmxlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGV0ZXJtaW5lIGlmIGxpc3RlbmluZyBpcyBlbmFibGVkIGJ5IHRha2luZyBpbnRvIGFjY291bnQgZGVzY2VuZGFudHMuICBJZiBzZWxmIG9yIGFueSBjaGlsZHJlblxuICAgICAqIGhhdmUgX2lzTGlzdGVuaW5nRW5hYmxlZCBzZXQgdG8gdHJ1ZSwgdGhlbiBzZWxmIGFsc28gaGFzIGxpc3RlbmluZyBlbmFibGVkLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbihjYW52YXMpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjYW52YXMgJiYgY2FudmFzLmlzQ2FjaGUpIHx8XG4gICAgICAgIChsYXllciAmJlxuICAgICAgICAgIGxheWVyLmhpdEdyYXBoRW5hYmxlZCgpICYmXG4gICAgICAgICAgdGhpcy5pc0xpc3RlbmluZygpICYmXG4gICAgICAgICAgdGhpcy5pc1Zpc2libGUoKSlcbiAgICAgICk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzaG93IG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGhpZGUgbm9kZS4gIEhpZGRlbiBub2RlcyBhcmUgbm8gbG9uZ2VyIGRldGVjdGFibGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldFZpc2libGUoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgekluZGV4IHJlbGF0aXZlIHRvIHRoZSBub2RlJ3Mgc2libGluZ3Mgd2hvIHNoYXJlIHRoZSBzYW1lIHBhcmVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAgKi9cbiAgICBnZXRaSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5kZXggfHwgMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhYnNvbHV0ZSB6LWluZGV4IHdoaWNoIHRha2VzIGludG8gYWNjb3VudCBzaWJsaW5nXG4gICAgICogIGFuZCBhbmNlc3RvciBpbmRpY2VzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIGdldEFic29sdXRlWkluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXB0aCA9IHRoaXMuZ2V0RGVwdGgoKSxcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIGxlbixcbiAgICAgICAgbixcbiAgICAgICAgY2hpbGQ7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltuXTtcbiAgICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlICE9PSBTSEFQRSkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGQuZ2V0Q2hpbGRyZW4oKS50b0FycmF5KCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZC5faWQgPT09IHRoYXQuX2lkKSB7XG4gICAgICAgICAgICBuID0gbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwICYmIG5vZGVzWzBdLmdldERlcHRoKCkgPD0gZGVwdGgpIHtcbiAgICAgICAgICBhZGRDaGlsZHJlbihub2Rlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGF0Lm5vZGVUeXBlICE9PSBVUFBFUl9TVEFHRSkge1xuICAgICAgICBhZGRDaGlsZHJlbih0aGF0LmdldFN0YWdlKCkuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBub2RlIGRlcHRoIGluIG5vZGUgdHJlZS4gIFJldHVybnMgYW4gaW50ZWdlci5cbiAgICAgKiAgZS5nLiBTdGFnZSBkZXB0aCB3aWxsIGFsd2F5cyBiZSAwLiAgTGF5ZXJzIHdpbGwgYWx3YXlzIGJlIDEuICBHcm91cHMgYW5kIFNoYXBlcyB3aWxsIGFsd2F5c1xuICAgICAqICBiZSA+PSAyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqL1xuICAgIGdldERlcHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkZXB0aCA9IDAsXG4gICAgICAgIHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVwdGg7XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB0aGlzLnNldFgocG9zLngpO1xuICAgICAgdGhpcy5zZXRZKHBvcy55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5nZXRYKCksXG4gICAgICAgIHk6IHRoaXMuZ2V0WSgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGFic29sdXRlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHN0YWdlIGNvbnRhaW5lciBkaXZcbiAgICAgKiBvciByZWxhdGl2ZSB0byBwYXNzZWQgbm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3RvcF0gb3B0aW9uYWwgcGFyZW50IG5vZGVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgdmFyIGFic29sdXRlTWF0cml4ID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpLFxuICAgICAgICBhYnNvbHV0ZVRyYW5zZm9ybSA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuICAgICAgLy8gY2xvbmUgdGhlIG1hdHJpeCBhcnJheVxuICAgICAgYWJzb2x1dGVUcmFuc2Zvcm0ubSA9IGFic29sdXRlTWF0cml4LnNsaWNlKCk7XG4gICAgICBhYnNvbHV0ZVRyYW5zZm9ybS50cmFuc2xhdGUob2Zmc2V0LngsIG9mZnNldC55KTtcblxuICAgICAgcmV0dXJuIGFic29sdXRlVHJhbnNmb3JtLmdldFRyYW5zbGF0aW9uKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgYWJzb2x1dGUgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqL1xuICAgIHNldEFic29sdXRlUG9zaXRpb246IGZ1bmN0aW9uKHBvcykge1xuICAgICAgdmFyIG9yaWdUcmFucyA9IHRoaXMuX2NsZWFyVHJhbnNmb3JtKCksXG4gICAgICAgIGl0O1xuXG4gICAgICAvLyBkb24ndCBjbGVhciB0cmFuc2xhdGlvblxuICAgICAgdGhpcy5hdHRycy54ID0gb3JpZ1RyYW5zLng7XG4gICAgICB0aGlzLmF0dHJzLnkgPSBvcmlnVHJhbnMueTtcbiAgICAgIGRlbGV0ZSBvcmlnVHJhbnMueDtcbiAgICAgIGRlbGV0ZSBvcmlnVHJhbnMueTtcblxuICAgICAgLy8gdW5yYXZlbCB0cmFuc2Zvcm1cbiAgICAgIGl0ID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSgpO1xuXG4gICAgICBpdC5pbnZlcnQoKTtcbiAgICAgIGl0LnRyYW5zbGF0ZShwb3MueCwgcG9zLnkpO1xuICAgICAgcG9zID0ge1xuICAgICAgICB4OiB0aGlzLmF0dHJzLnggKyBpdC5nZXRUcmFuc2xhdGlvbigpLngsXG4gICAgICAgIHk6IHRoaXMuYXR0cnMueSArIGl0LmdldFRyYW5zbGF0aW9uKCkueVxuICAgICAgfTtcblxuICAgICAgdGhpcy5zZXRQb3NpdGlvbih7IHg6IHBvcy54LCB5OiBwb3MueSB9KTtcbiAgICAgIHRoaXMuX3NldFRyYW5zZm9ybShvcmlnVHJhbnMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF9zZXRUcmFuc2Zvcm06IGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICB2YXIga2V5O1xuXG4gICAgICBmb3IgKGtleSBpbiB0cmFucykge1xuICAgICAgICB0aGlzLmF0dHJzW2tleV0gPSB0cmFuc1trZXldO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhckNhY2hlKFRSQU5TRk9STSk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoQUJTT0xVVEVfVFJBTlNGT1JNKTtcbiAgICB9LFxuICAgIF9jbGVhclRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdHJhbnMgPSB7XG4gICAgICAgIHg6IHRoaXMuZ2V0WCgpLFxuICAgICAgICB5OiB0aGlzLmdldFkoKSxcbiAgICAgICAgcm90YXRpb246IHRoaXMuZ2V0Um90YXRpb24oKSxcbiAgICAgICAgc2NhbGVYOiB0aGlzLmdldFNjYWxlWCgpLFxuICAgICAgICBzY2FsZVk6IHRoaXMuZ2V0U2NhbGVZKCksXG4gICAgICAgIG9mZnNldFg6IHRoaXMuZ2V0T2Zmc2V0WCgpLFxuICAgICAgICBvZmZzZXRZOiB0aGlzLmdldE9mZnNldFkoKSxcbiAgICAgICAgc2tld1g6IHRoaXMuZ2V0U2tld1goKSxcbiAgICAgICAgc2tld1k6IHRoaXMuZ2V0U2tld1koKVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hdHRycy54ID0gMDtcbiAgICAgIHRoaXMuYXR0cnMueSA9IDA7XG4gICAgICB0aGlzLmF0dHJzLnJvdGF0aW9uID0gMDtcbiAgICAgIHRoaXMuYXR0cnMuc2NhbGVYID0gMTtcbiAgICAgIHRoaXMuYXR0cnMuc2NhbGVZID0gMTtcbiAgICAgIHRoaXMuYXR0cnMub2Zmc2V0WCA9IDA7XG4gICAgICB0aGlzLmF0dHJzLm9mZnNldFkgPSAwO1xuICAgICAgdGhpcy5hdHRycy5za2V3WCA9IDA7XG4gICAgICB0aGlzLmF0dHJzLnNrZXdZID0gMDtcblxuICAgICAgdGhpcy5fY2xlYXJDYWNoZShUUkFOU0ZPUk0pO1xuICAgICAgdGhpcy5fY2xlYXJTZWxmQW5kRGVzY2VuZGFudENhY2hlKEFCU09MVVRFX1RSQU5TRk9STSk7XG5cbiAgICAgIC8vIHJldHVybiBvcmlnaW5hbCB0cmFuc2Zvcm1cbiAgICAgIHJldHVybiB0cmFucztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIG1vdmUgbm9kZSBieSBhbiBhbW91bnQgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjaGFuZ2UueVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbW92ZSBub2RlIGluIHggZGlyZWN0aW9uIGJ5IDFweCBhbmQgeSBkaXJlY3Rpb24gYnkgMnB4XG4gICAgICogbm9kZS5tb3ZlKHtcbiAgICAgKiAgIHg6IDEsXG4gICAgICogICB5OiAyKVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIG1vdmU6IGZ1bmN0aW9uKGNoYW5nZSkge1xuICAgICAgdmFyIGNoYW5nZVggPSBjaGFuZ2UueCxcbiAgICAgICAgY2hhbmdlWSA9IGNoYW5nZS55LFxuICAgICAgICB4ID0gdGhpcy5nZXRYKCksXG4gICAgICAgIHkgPSB0aGlzLmdldFkoKTtcblxuICAgICAgaWYgKGNoYW5nZVggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB4ICs9IGNoYW5nZVg7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeSArPSBjaGFuZ2VZO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFBvc2l0aW9uKHsgeDogeCwgeTogeSB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2VhY2hBbmNlc3RvclJldmVyc2U6IGZ1bmN0aW9uKGZ1bmMsIHRvcCkge1xuICAgICAgdmFyIGZhbWlseSA9IFtdLFxuICAgICAgICBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpLFxuICAgICAgICBsZW4sXG4gICAgICAgIG47XG5cbiAgICAgIC8vIGlmIHRvcCBub2RlIGlzIGRlZmluZWQsIGFuZCB0aGlzIG5vZGUgaXMgdG9wIG5vZGUsXG4gICAgICAvLyB0aGVyZSdzIG5vIG5lZWQgdG8gYnVpbGQgYSBmYW1pbHkgdHJlZS4gIGp1c3QgZXhlY3V0ZVxuICAgICAgLy8gZnVuYyB3aXRoIHRoaXMgYmVjYXVzZSBpdCB3aWxsIGJlIHRoZSBvbmx5IG5vZGVcbiAgICAgIGlmICh0b3AgJiYgdG9wLl9pZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgICAgZnVuYyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGZhbWlseS51bnNoaWZ0KHRoaXMpO1xuXG4gICAgICB3aGlsZSAocGFyZW50ICYmICghdG9wIHx8IHBhcmVudC5faWQgIT09IHRvcC5faWQpKSB7XG4gICAgICAgIGZhbWlseS51bnNoaWZ0KHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGxlbiA9IGZhbWlseS5sZW5ndGg7XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgZnVuYyhmYW1pbHlbbl0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcm90YXRlIG5vZGUgYnkgYW4gYW1vdW50IGluIGRlZ3JlZXMgcmVsYXRpdmUgdG8gaXRzIGN1cnJlbnQgcm90YXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoZXRhXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbih0aGV0YSkge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbih0aGlzLmdldFJvdGF0aW9uKCkgKyB0aGV0YSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIG1vdmUgbm9kZSB0byB0aGUgdG9wIG9mIGl0cyBzaWJsaW5nc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBtb3ZlVG9Ub3A6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZVRvVG9wIGZ1bmN0aW9uIGlzIGlnbm9yZWQuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4ucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbW92ZSBub2RlIHVwXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBmbGFnIGlzIG1vdmVkIG9yIG5vdFxuICAgICAqL1xuICAgIG1vdmVVcDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIEtvbnZhLlV0aWwud2FybignTm9kZSBoYXMgbm8gcGFyZW50LiBtb3ZlVXAgZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleCxcbiAgICAgICAgbGVuID0gdGhpcy5wYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG4gICAgICBpZiAoaW5kZXggPCBsZW4gLSAxKSB7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCArIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnBhcmVudC5fc2V0Q2hpbGRyZW5JbmRpY2VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogbW92ZSBub2RlIGRvd25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbW92ZURvd246IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gbW92ZURvd24gZnVuY3Rpb24gaXMgaWdub3JlZC4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4IC0gMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucGFyZW50Ll9zZXRDaGlsZHJlbkluZGljZXMoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBtb3ZlIG5vZGUgdG8gdGhlIGJvdHRvbSBvZiBpdHMgc2libGluZ3NcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgbW92ZVRvQm90dG9tOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICdOb2RlIGhhcyBubyBwYXJlbnQuIG1vdmVUb0JvdHRvbSBmdW5jdGlvbiBpcyBpZ25vcmVkLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4udW5zaGlmdCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHNldCB6SW5kZXggcmVsYXRpdmUgdG8gc2libGluZ3NcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSB6SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKi9cbiAgICBzZXRaSW5kZXg6IGZ1bmN0aW9uKHpJbmRleCkge1xuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oJ05vZGUgaGFzIG5vIHBhcmVudC4gekluZGV4IHBhcmFtZXRlciBpcyBpZ25vcmVkLicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLnNwbGljZSh6SW5kZXgsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5wYXJlbnQuX3NldENoaWxkcmVuSW5kaWNlcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYWJzb2x1dGUgb3BhY2l0eVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldEFic29sdXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoQUJTT0xVVEVfT1BBQ0lUWSwgdGhpcy5fZ2V0QWJzb2x1dGVPcGFjaXR5KTtcbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZU9wYWNpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFic09wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Ll9pc1VuZGVyQ2FjaGUpIHtcbiAgICAgICAgYWJzT3BhY2l0eSAqPSB0aGlzLmdldFBhcmVudCgpLmdldEFic29sdXRlT3BhY2l0eSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFic09wYWNpdHk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBtb3ZlIG5vZGUgdG8gYW5vdGhlciBjb250YWluZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDb250YWluZXJ9IG5ld0NvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbW92ZSBub2RlIGZyb20gY3VycmVudCBsYXllciBpbnRvIGxheWVyMlxuICAgICAqIG5vZGUubW92ZVRvKGxheWVyMik7XG4gICAgICovXG4gICAgbW92ZVRvOiBmdW5jdGlvbihuZXdDb250YWluZXIpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgbmV3IGNvbnRhaW5lciBpcyBhbHJlYWR5IHBhcmVudFxuICAgICAgaWYgKHRoaXMuZ2V0UGFyZW50KCkgIT09IG5ld0NvbnRhaW5lcikge1xuICAgICAgICAvLyB0aGlzLnJlbW92ZSBteSBiZSBvdmVycmlkZWQgYnkgZHJhZyBhbmQgZHJvcFxuICAgICAgICAvLyBidXkgd2UgbmVlZCBvcmlnaW5hbFxuICAgICAgICAodGhpcy5fX29yaWdpbmFsUmVtb3ZlIHx8IHRoaXMucmVtb3ZlKS5jYWxsKHRoaXMpO1xuICAgICAgICBuZXdDb250YWluZXIuYWRkKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0IE5vZGUgaW50byBhbiBvYmplY3QgZm9yIHNlcmlhbGl6YXRpb24uICBSZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0ge30sXG4gICAgICAgIGF0dHJzID0gdGhpcy5nZXRBdHRycygpLFxuICAgICAgICBrZXksXG4gICAgICAgIHZhbCxcbiAgICAgICAgZ2V0dGVyLFxuICAgICAgICBkZWZhdWx0VmFsdWU7XG5cbiAgICAgIG9iai5hdHRycyA9IHt9O1xuXG4gICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICB2YWwgPSBhdHRyc1trZXldO1xuICAgICAgICBnZXR0ZXIgPSB0aGlzW2tleV07XG4gICAgICAgIC8vIHJlbW92ZSBhdHRyIHZhbHVlIHNvIHRoYXQgd2UgY2FuIGV4dHJhY3QgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgZ2V0dGVyXG4gICAgICAgIGRlbGV0ZSBhdHRyc1trZXldO1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSBnZXR0ZXIgPyBnZXR0ZXIuY2FsbCh0aGlzKSA6IG51bGw7XG4gICAgICAgIC8vIHJlc3RvcmUgYXR0ciB2YWx1ZVxuICAgICAgICBhdHRyc1trZXldID0gdmFsO1xuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB2YWwpIHtcbiAgICAgICAgICBvYmouYXR0cnNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5nZXRDbGFzc05hbWUoKTtcbiAgICAgIHJldHVybiBLb252YS5VdGlsLl9wcmVwYXJlVG9TdHJpbmdpZnkob2JqKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNvbnZlcnQgTm9kZSBpbnRvIGEgSlNPTiBzdHJpbmcuICBSZXR1cm5zIGEgSlNPTiBzdHJpbmcuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy50b09iamVjdCgpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBwYXJlbnQgY29udGFpbmVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqL1xuICAgIGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYWxsIGFuY2VzdHJvcyAocGFyZW50IHRoZW4gcGFyZW50IG9mIHRoZSBwYXJlbnQsIGV0Yykgb2YgdGhlIG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl0gc2VsZWN0b3IgZm9yIHNlYXJjaFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2luY2x1ZGVTZWxmXSBzaG93IHdlIHRoaW5rIHRoYXQgbm9kZSBpcyBhbmNlc3RybyBpdHNlbGY/XG4gICAgICogQHBhcmFtIHtLb252YS5Ob2RlfSBbc3RvcE5vZGVdIG9wdGlvbmFsIG5vZGUgd2hlcmUgd2UgbmVlZCB0byBzdG9wIHNlYXJjaGluZyAob25lIG9mIGFuY2VzdG9ycylcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFthbmNlc3RvcnNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb25lIG9mIHRoZSBwYXJlbnQgZ3JvdXBcbiAgICAgKiB2YXIgcGFyZW50R3JvdXBzID0gbm9kZS5maW5kQW5jZXN0b3JzKCdHcm91cCcpO1xuICAgICAqL1xuICAgIGZpbmRBbmNlc3RvcnM6IGZ1bmN0aW9uKHNlbGVjdG9yLCBpbmNsdWRlU2VsZiwgc3RvcE5vZGUpIHtcbiAgICAgIHZhciByZXMgPSBbXTtcblxuICAgICAgaWYgKGluY2x1ZGVTZWxmICYmIHRoaXMuX2lzTWF0Y2goc2VsZWN0b3IpKSB7XG4gICAgICAgIHJlcy5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgICAgdmFyIGFuY2VzdG9yID0gdGhpcy5wYXJlbnQ7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGFuY2VzdG9yID09PSBzdG9wTm9kZSkge1xuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuY2VzdG9yLl9pc01hdGNoKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJlcy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYW5jZXN0b3IgKHBhcmVudCBvciBwYXJlbnQgb2YgdGhlIHBhcmVudCwgZXRjKSBvZiB0aGUgbm9kZSB0aGF0IG1hdGNoIHBhc3NlZCBzZWxlY3RvclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3NlbGVjdG9yXSBzZWxlY3RvciBmb3Igc2VhcmNoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbaW5jbHVkZVNlbGZdIHNob3cgd2UgdGhpbmsgdGhhdCBub2RlIGlzIGFuY2VzdHJvIGl0c2VsZj9cbiAgICAgKiBAcGFyYW0ge0tvbnZhLk5vZGV9IFtzdG9wTm9kZV0gb3B0aW9uYWwgbm9kZSB3aGVyZSB3ZSBuZWVkIHRvIHN0b3Agc2VhcmNoaW5nIChvbmUgb2YgYW5jZXN0b3JzKVxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfSBhbmNlc3RvclxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IG9uZSBvZiB0aGUgcGFyZW50IGdyb3VwXG4gICAgICogdmFyIGdyb3VwID0gbm9kZS5maW5kQW5jZXN0b3JzKCcubXlncm91cCcpO1xuICAgICAqL1xuICAgIGZpbmRBbmNlc3RvcjogZnVuY3Rpb24oc2VsZWN0b3IsIGluY2x1ZGVTZWxmLCBzdG9wTm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZEFuY2VzdG9ycyhzZWxlY3RvciwgaW5jbHVkZVNlbGYsIHN0b3BOb2RlKVswXTtcbiAgICB9LFxuICAgIC8vIGlzIGN1cnJlbnQgbm9kZSBtYXRjaCBwYXNzZWQgc2VsZWN0b3I/XG4gICAgX2lzTWF0Y2g6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICBpZiAoIXNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBzZWxlY3RvckFyciA9IHNlbGVjdG9yLnJlcGxhY2UoLyAvZywgJycpLnNwbGl0KCcsJyksXG4gICAgICAgIGxlbiA9IHNlbGVjdG9yQXJyLmxlbmd0aCxcbiAgICAgICAgbixcbiAgICAgICAgc2VsO1xuXG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgc2VsID0gc2VsZWN0b3JBcnJbbl07XG4gICAgICAgIGlmICghS29udmEuVXRpbC5pc1ZhbGlkU2VsZWN0b3Ioc2VsKSkge1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdTZWxlY3RvciBcIicgK1xuICAgICAgICAgICAgICBzZWwgK1xuICAgICAgICAgICAgICAnXCIgaXMgaW52YWxpZC4gQWxsb3dlZCBzZWxlY3RvcnMgZXhhbXBsZXMgYXJlIFwiI2Zvb1wiLCBcIi5iYXJcIiBvciBcIkdyb3VwXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAgICAgJ0lmIHlvdSBoYXZlIGEgY3VzdG9tIHNoYXBlIHdpdGggc3VjaCBjbGFzc05hbWUsIHBsZWFzZSBjaGFuZ2UgaXQgdG8gc3RhcnQgd2l0aCB1cHBlciBsZXR0ZXIgbGlrZSBcIlRyaWFuZ2xlXCIuJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgS29udmEuVXRpbC53YXJuKCdLb252YSBpcyBhd2Vzb21lLCByaWdodD8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZCBzZWxlY3RvclxuICAgICAgICBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaWQoKSA9PT0gc2VsLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgIGlmICh0aGlzLmhhc05hbWUoc2VsLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2dldChzZWwpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgbGF5ZXIgYW5jZXN0b3JcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLkxheWVyfVxuICAgICAqL1xuICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5nZXRMYXllcigpIDogbnVsbDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBzdGFnZSBhbmNlc3RvclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuU3RhZ2V9XG4gICAgICovXG4gICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKFNUQUdFLCB0aGlzLl9nZXRTdGFnZSk7XG4gICAgfSxcbiAgICBfZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuZ2V0U3RhZ2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBmaXJlIGV2ZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFR5cGUgZXZlbnQgdHlwZS4gIGNhbiBiZSBhIHJlZ3VsYXIgZXZlbnQsIGxpa2UgY2xpY2ssIG1vdXNlb3Zlciwgb3IgbW91c2VvdXQsIG9yIGl0IGNhbiBiZSBhIGN1c3RvbSBldmVudCwgbGlrZSBteUN1c3RvbUV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gW2V2dF0gZXZlbnQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlXSBzZXR0aW5nIHRoZSB2YWx1ZSB0byBmYWxzZSwgb3IgbGVhdmluZyBpdCB1bmRlZmluZWQsIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudFxuICAgICAqICBub3QgYnViYmxpbmcuICBTZXR0aW5nIHRoZSB2YWx1ZSB0byB0cnVlIHdpbGwgcmVzdWx0IGluIHRoZSBldmVudCBidWJibGluZy5cbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIG1hbnVhbGx5IGZpcmUgY2xpY2sgZXZlbnRcbiAgICAgKiBub2RlLmZpcmUoJ2NsaWNrJyk7XG4gICAgICpcbiAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudFxuICAgICAqIG5vZGUuZmlyZSgnZm9vJyk7XG4gICAgICpcbiAgICAgKiAvLyBmaXJlIGN1c3RvbSBldmVudCB3aXRoIGN1c3RvbSBldmVudCBvYmplY3RcbiAgICAgKiBub2RlLmZpcmUoJ2ZvbycsIHtcbiAgICAgKiAgIGJhcjogMTBcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIC8vIGZpcmUgY2xpY2sgZXZlbnQgdGhhdCBidWJibGVzXG4gICAgICogbm9kZS5maXJlKCdjbGljaycsIG51bGwsIHRydWUpO1xuICAgICAqL1xuICAgIGZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0LCBidWJibGUpIHtcbiAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgIGV2dC50YXJnZXQgPSBldnQudGFyZ2V0IHx8IHRoaXM7XG4gICAgICAvLyBidWJibGVcbiAgICAgIGlmIChidWJibGUpIHtcbiAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZShldmVudFR5cGUsIGV2dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBidWJibGVcbiAgICAgICAgdGhpcy5fZmlyZShldmVudFR5cGUsIGV2dCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhYnNvbHV0ZSB0cmFuc2Zvcm0gb2YgdGhlIG5vZGUgd2hpY2ggdGFrZXMgaW50b1xuICAgICAqICBhY2NvdW50IGl0cyBhbmNlc3RvciB0cmFuc2Zvcm1zXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtLb252YS5UcmFuc2Zvcm19XG4gICAgICovXG4gICAgZ2V0QWJzb2x1dGVUcmFuc2Zvcm06IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgLy8gaWYgdXNpbmcgYW4gYXJndW1lbnQsIHdlIGNhbid0IGNhY2hlIHRoZSByZXN1bHQuXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm8gYXJndW1lbnQsIHdlIGNhbiBjYWNoZSB0aGUgcmVzdWx0XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShBQlNPTFVURV9UUkFOU0ZPUk0sIHRoaXMuX2dldEFic29sdXRlVHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZVRyYW5zZm9ybTogZnVuY3Rpb24odG9wKSB7XG4gICAgICB2YXIgYXQgPSBuZXcgS29udmEuVHJhbnNmb3JtKCksXG4gICAgICAgIHRyYW5zZm9ybXNFbmFibGVkLFxuICAgICAgICB0cmFucztcblxuICAgICAgLy8gc3RhcnQgd2l0aCBzdGFnZSBhbmQgdHJhdmVyc2UgZG93bndhcmRzIHRvIHNlbGZcbiAgICAgIHRoaXMuX2VhY2hBbmNlc3RvclJldmVyc2UoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICB0cmFuc2Zvcm1zRW5hYmxlZCA9IG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoKTtcbiAgICAgICAgdHJhbnMgPSBub2RlLmdldFRyYW5zZm9ybSgpO1xuXG4gICAgICAgIGlmICh0cmFuc2Zvcm1zRW5hYmxlZCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICBhdC5tdWx0aXBseSh0cmFucyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmb3Jtc0VuYWJsZWQgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICBhdC50cmFuc2xhdGUobm9kZS54KCksIG5vZGUueSgpKTtcbiAgICAgICAgfVxuICAgICAgfSwgdG9wKTtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBhYnNvbHV0ZSBzY2FsZSBvZiB0aGUgbm9kZSB3aGljaCB0YWtlcyBpbnRvXG4gICAgICogIGFjY291bnQgaXRzIGFuY2VzdG9yIHNjYWxlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGdldEFic29sdXRlU2NhbGU6IGZ1bmN0aW9uKHRvcCkge1xuICAgICAgLy8gaWYgdXNpbmcgYW4gYXJndW1lbnQsIHdlIGNhbid0IGNhY2hlIHRoZSByZXN1bHQuXG4gICAgICBpZiAodG9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRBYnNvbHV0ZVNjYWxlKHRvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBubyBhcmd1bWVudCwgd2UgY2FuIGNhY2hlIHRoZSByZXN1bHRcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEFCU09MVVRFX1NDQUxFLCB0aGlzLl9nZXRBYnNvbHV0ZVNjYWxlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRBYnNvbHV0ZVNjYWxlOiBmdW5jdGlvbih0b3ApIHtcbiAgICAgIC8vIHRoaXMgaXMgc3BlY2lhbCBsb2dpYyBmb3IgY2FjaGluZyB3aXRoIHNvbWUgc2hhcGVzIHdpdGggc2hhZG93XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgaWYgKHBhcmVudC5faXNVbmRlckNhY2hlKSB7XG4gICAgICAgICAgdG9wID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjYWxlWCA9IDEsXG4gICAgICAgIHNjYWxlWSA9IDE7XG5cbiAgICAgIC8vIHN0YXJ0IHdpdGggc3RhZ2UgYW5kIHRyYXZlcnNlIGRvd253YXJkcyB0byBzZWxmXG4gICAgICB0aGlzLl9lYWNoQW5jZXN0b3JSZXZlcnNlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgc2NhbGVYICo9IG5vZGUuc2NhbGVYKCk7XG4gICAgICAgIHNjYWxlWSAqPSBub2RlLnNjYWxlWSgpO1xuICAgICAgfSwgdG9wKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHNjYWxlWCxcbiAgICAgICAgeTogc2NhbGVZXG4gICAgICB9O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHRyYW5zZm9ybSBvZiB0aGUgbm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtfVxuICAgICAqL1xuICAgIGdldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoVFJBTlNGT1JNLCB0aGlzLl9nZXRUcmFuc2Zvcm0pO1xuICAgIH0sXG4gICAgX2dldFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbSA9IG5ldyBLb252YS5UcmFuc2Zvcm0oKSxcbiAgICAgICAgeCA9IHRoaXMuZ2V0WCgpLFxuICAgICAgICB5ID0gdGhpcy5nZXRZKCksXG4gICAgICAgIHJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUodGhpcy5nZXRSb3RhdGlvbigpKSxcbiAgICAgICAgc2NhbGVYID0gdGhpcy5nZXRTY2FsZVgoKSxcbiAgICAgICAgc2NhbGVZID0gdGhpcy5nZXRTY2FsZVkoKSxcbiAgICAgICAgc2tld1ggPSB0aGlzLmdldFNrZXdYKCksXG4gICAgICAgIHNrZXdZID0gdGhpcy5nZXRTa2V3WSgpLFxuICAgICAgICBvZmZzZXRYID0gdGhpcy5nZXRPZmZzZXRYKCksXG4gICAgICAgIG9mZnNldFkgPSB0aGlzLmdldE9mZnNldFkoKTtcblxuICAgICAgaWYgKHggIT09IDAgfHwgeSAhPT0gMCkge1xuICAgICAgICBtLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGlmIChyb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICBtLnJvdGF0ZShyb3RhdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoc2tld1ggIT09IDAgfHwgc2tld1kgIT09IDApIHtcbiAgICAgICAgbS5za2V3KHNrZXdYLCBza2V3WSk7XG4gICAgICB9XG4gICAgICBpZiAoc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMSkge1xuICAgICAgICBtLnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIH1cbiAgICAgIGlmIChvZmZzZXRYICE9PSAwIHx8IG9mZnNldFkgIT09IDApIHtcbiAgICAgICAgbS50cmFuc2xhdGUoLTEgKiBvZmZzZXRYLCAtMSAqIG9mZnNldFkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsb25lIG5vZGUuICBSZXR1cm5zIGEgbmV3IE5vZGUgaW5zdGFuY2Ugd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcy4gIFlvdSBjYW4gYWxzbyBvdmVycmlkZVxuICAgICAqICB0aGUgbm9kZSBwcm9wZXJ0aWVzIHdpdGggYW4gb2JqZWN0IGxpdGVyYWwsIGVuYWJsaW5nIHlvdSB0byB1c2UgYW4gZXhpc3Rpbmcgbm9kZSBhcyBhIHRlbXBsYXRlXG4gICAgICogIGZvciBhbm90aGVyIG5vZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiBvdmVycmlkZSBhdHRyc1xuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gc2ltcGxlIGNsb25lXG4gICAgICogdmFyIGNsb25lID0gbm9kZS5jbG9uZSgpO1xuICAgICAqXG4gICAgICogLy8gY2xvbmUgYSBub2RlIGFuZCBvdmVycmlkZSB0aGUgeCBwb3NpdGlvblxuICAgICAqIHZhciBjbG9uZSA9IHJlY3QuY2xvbmUoe1xuICAgICAqICAgeDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIC8vIGluc3RhbnRpYXRlIG5ldyBub2RlXG4gICAgICB2YXIgYXR0cnMgPSBLb252YS5VdGlsLmNsb25lT2JqZWN0KHRoaXMuYXR0cnMpLFxuICAgICAgICBrZXksXG4gICAgICAgIGFsbExpc3RlbmVycyxcbiAgICAgICAgbGVuLFxuICAgICAgICBuLFxuICAgICAgICBsaXN0ZW5lcjtcbiAgICAgIC8vIGZpbHRlciBibGFjayBhdHRyc1xuICAgICAgZm9yICh2YXIgaSBpbiBDTE9ORV9CTEFDS19MSVNUKSB7XG4gICAgICAgIHZhciBibG9ja0F0dHIgPSBDTE9ORV9CTEFDS19MSVNUW2ldO1xuICAgICAgICBkZWxldGUgYXR0cnNbYmxvY2tBdHRyXTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IGF0dHIgb3ZlcnJpZGVzXG4gICAgICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICAgICAgYXR0cnNba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGF0dHJzKTtcbiAgICAgIC8vIGNvcHkgb3ZlciBsaXN0ZW5lcnNcbiAgICAgIGZvciAoa2V5IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgYWxsTGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1trZXldO1xuICAgICAgICBsZW4gPSBhbGxMaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgICBsaXN0ZW5lciA9IGFsbExpc3RlbmVyc1tuXTtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBkb24ndCBpbmNsdWRlIGtvbnZhIG5hbWVzcGFjZWQgbGlzdGVuZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogIHRoZXNlIGFyZSBnZW5lcmF0ZWQgYnkgdGhlIGNvbnN0cnVjdG9yc1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAobGlzdGVuZXIubmFtZS5pbmRleE9mKEtPTlZBKSA8IDApIHtcbiAgICAgICAgICAgIC8vIGlmIGxpc3RlbmVycyBhcnJheSBkb2Vzbid0IGV4aXN0LCB0aGVuIGNyZWF0ZSBpdFxuICAgICAgICAgICAgaWYgKCFub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0pIHtcbiAgICAgICAgICAgICAgbm9kZS5ldmVudExpc3RlbmVyc1trZXldID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmV2ZW50TGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIF90b0tvbnZhQ2FudmFzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICB4ID0gY29uZmlnLnggfHwgMCxcbiAgICAgICAgeSA9IGNvbmZpZy55IHx8IDAsXG4gICAgICAgIHBpeGVsUmF0aW8gPSBjb25maWcucGl4ZWxSYXRpbyB8fCAxLFxuICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgIHdpZHRoOlxuICAgICAgICAgICAgY29uZmlnLndpZHRoIHx8IHRoaXMuZ2V0V2lkdGgoKSB8fCAoc3RhZ2UgPyBzdGFnZS5nZXRXaWR0aCgpIDogMCksXG4gICAgICAgICAgaGVpZ2h0OlxuICAgICAgICAgICAgY29uZmlnLmhlaWdodCB8fFxuICAgICAgICAgICAgdGhpcy5nZXRIZWlnaHQoKSB8fFxuICAgICAgICAgICAgKHN0YWdlID8gc3RhZ2UuZ2V0SGVpZ2h0KCkgOiAwKSxcbiAgICAgICAgICBwaXhlbFJhdGlvOiBwaXhlbFJhdGlvXG4gICAgICAgIH0pLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKTtcblxuICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgIGlmICh4IHx8IHkpIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYXdTY2VuZShjYW52YXMpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBub2RlIGludG8gYW4gY2FudmFzIGVsZW1lbnQuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UuICBEZWZhdWx0IGlzIDEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgY2FudmFzID0gbm9kZS50b0NhbnZhcygpO1xuICAgICAqL1xuICAgIHRvQ2FudmFzOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLl90b0tvbnZhQ2FudmFzKGNvbmZpZykuX2NhbnZhcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgZGF0YSBVUkwuIElmIE1JTUUgdHlwZSBpcyBub3RcbiAgICAgKiBzcGVjaWZpZWQsIHRoZW4gXCJpbWFnZS9wbmdcIiB3aWxsIHJlc3VsdC4gRm9yIFwiaW1hZ2UvanBlZ1wiLCBzcGVjaWZ5IGEgcXVhbGl0eVxuICAgICAqIGxldmVsIGFzIHF1YWxpdHkgKHJhbmdlIDAuMCAtIDEuMClcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucGl4ZWxSYXRpb10gcGl4ZWxSYXRpbyBvZiBvdXRwdXQgaW1hZ2UgdXJsLiBEZWZhdWx0IGlzIDFcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgICB2YXIgbWltZVR5cGUgPSBjb25maWcubWltZVR5cGUgfHwgbnVsbCxcbiAgICAgICAgcXVhbGl0eSA9IGNvbmZpZy5xdWFsaXR5IHx8IG51bGw7XG4gICAgICByZXR1cm4gdGhpcy5fdG9Lb252YUNhbnZhcyhjb25maWcpLnRvRGF0YVVSTChtaW1lVHlwZSwgcXVhbGl0eSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBub2RlIGludG8gYW4gaW1hZ2UuICBTaW5jZSB0aGUgdG9JbWFnZVxuICAgICAqICBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCBhIGNhbGxiYWNrIGlzIHJlcXVpcmVkLiAgdG9JbWFnZSBpcyBtb3N0IGNvbW1vbmx5IHVzZWRcbiAgICAgKiAgdG8gY2FjaGUgY29tcGxleCBkcmF3aW5ncyBhcyBhbiBpbWFnZSBzbyB0aGF0IHRoZXkgZG9uJ3QgaGF2ZSB0byBjb25zdGFudGx5IGJlIHJlZHJhd25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbmZpZy5jYWxsYmFjayBmdW5jdGlvbiBleGVjdXRlZCB3aGVuIHRoZSBjb21wb3NpdGUgaGFzIGNvbXBsZXRlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm1pbWVUeXBlXSBjYW4gYmUgXCJpbWFnZS9wbmdcIiBvciBcImltYWdlL2pwZWdcIi5cbiAgICAgKiAgXCJpbWFnZS9wbmdcIiBpcyB0aGUgZGVmYXVsdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdIHggcG9zaXRpb24gb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XSB5IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdIHdpZHRoIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XSBoZWlnaHQgb2YgY2FudmFzIHNlY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5xdWFsaXR5XSBqcGVnIHF1YWxpdHkuICBJZiB1c2luZyBhbiBcImltYWdlL2pwZWdcIiBtaW1lVHlwZSxcbiAgICAgKiAgeW91IGNhbiBzcGVjaWZ5IHRoZSBxdWFsaXR5IGZyb20gMCB0byAxLCB3aGVyZSAwIGlzIHZlcnkgcG9vciBxdWFsaXR5IGFuZCAxXG4gICAgICogIGlzIHZlcnkgaGlnaCBxdWFsaXR5XG4gICAgICogQHBhcmVtdCB7TnVtYmVyfSBbY29uZmlnLnBpeGVsUmF0aW9dIHBpeGVsUmF0aW8gb2Ygb3VwdXQgaW1hZ2UuICBEZWZhdWx0IGlzIDEuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaW1hZ2UgPSBub2RlLnRvSW1hZ2Uoe1xuICAgICAqICAgY2FsbGJhY2s6IGZ1bmN0aW9uKGltZykge1xuICAgICAqICAgICAvLyBkbyBzdHVmZiB3aXRoIGltZ1xuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIHRvSW1hZ2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgaWYgKCFjb25maWcgfHwgIWNvbmZpZy5jYWxsYmFjaykge1xuICAgICAgICB0aHJvdyAnY2FsbGJhY2sgcmVxdWlyZWQgZm9yIHRvSW1hZ2UgbWV0aG9kIGNvbmZpZyBhcmd1bWVudCc7XG4gICAgICB9XG4gICAgICBLb252YS5VdGlsLl9nZXRJbWFnZSh0aGlzLnRvRGF0YVVSTChjb25maWcpLCBmdW5jdGlvbihpbWcpIHtcbiAgICAgICAgY29uZmlnLmNhbGxiYWNrKGltZyk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgIHRoaXMuc2V0V2lkdGgoc2l6ZS53aWR0aCk7XG4gICAgICB0aGlzLnNldEhlaWdodChzaXplLmhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmdldEhlaWdodCgpXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cnMud2lkdGggfHwgMDtcbiAgICB9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRycy5oZWlnaHQgfHwgMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBjbGFzcyBuYW1lLCB3aGljaCBtYXkgcmV0dXJuIFN0YWdlLCBMYXllciwgR3JvdXAsIG9yIHNoYXBlIGNsYXNzIG5hbWVzIGxpa2UgUmVjdCwgQ2lyY2xlLCBUZXh0LCBldGMuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZSB8fCB0aGlzLm5vZGVUeXBlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHRoZSBub2RlIHR5cGUsIHdoaWNoIG1heSByZXR1cm4gU3RhZ2UsIExheWVyLCBHcm91cCwgb3IgTm9kZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVR5cGU7XG4gICAgfSxcbiAgICBnZXREcmFnRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29tcGFyZSB3aXRoIHVuZGVmaW5lZCBiZWNhdXNlIHdlIG5lZWQgdG8gdHJhY2sgMCB2YWx1ZVxuICAgICAgaWYgKHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuZHJhZ0Rpc3RhbmNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0RHJhZ0Rpc3RhbmNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gS29udmEuZHJhZ0Rpc3RhbmNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsYXNzTmFtZSA9PT0gc2VsZWN0b3IgfHwgdGhpcy5ub2RlVHlwZSA9PT0gc2VsZWN0b3JcbiAgICAgICAgPyBbdGhpc11cbiAgICAgICAgOiBbXTtcbiAgICB9LFxuICAgIF9vZmY6IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZXZ0TGlzdGVuZXJzID0gdGhpcy5ldmVudExpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgaSxcbiAgICAgICAgZXZ0TmFtZSxcbiAgICAgICAgaGFuZGxlcjtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGV2dExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBldnROYW1lID0gZXZ0TGlzdGVuZXJzW2ldLm5hbWU7XG4gICAgICAgIGhhbmRsZXIgPSBldnRMaXN0ZW5lcnNbaV0uaGFuZGxlcjtcblxuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHR3byBjb25kaXRpb25zIG11c3QgYmUgdHJ1ZSBpbiBvcmRlciB0byByZW1vdmUgYSBoYW5kbGVyOlxuICAgICAgICAvLyAxKSB0aGUgY3VycmVudCBldmVudCBuYW1lIGNhbm5vdCBiZSBrb252YSB1bmxlc3MgdGhlIGV2ZW50IG5hbWUgaXMga29udmFcbiAgICAgICAgLy8gICAgdGhpcyBlbmFibGVzIGRldmVsb3BlcnMgdG8gZm9yY2UgcmVtb3ZlIGEga29udmEgc3BlY2lmaWMgbGlzdGVuZXIgZm9yIHdoYXRldmVyIHJlYXNvblxuICAgICAgICAvLyAyKSBhbiBldmVudCBuYW1lIGlzIG5vdCBzcGVjaWZpZWQsIG9yIGlmIG9uZSBpcyBzcGVjaWZpZWQsIGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgZXZlbnQgbmFtZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKGV2dE5hbWUgIT09ICdrb252YScgfHwgbmFtZSA9PT0gJ2tvbnZhJykgJiZcbiAgICAgICAgICAoIW5hbWUgfHwgZXZ0TmFtZSA9PT0gbmFtZSkgJiZcbiAgICAgICAgICAoIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBoYW5kbGVyKVxuICAgICAgICApIHtcbiAgICAgICAgICBldnRMaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGlmIChldnRMaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF9maXJlQ2hhbmdlRXZlbnQ6IGZ1bmN0aW9uKGF0dHIsIG9sZFZhbCwgbmV3VmFsKSB7XG4gICAgICB0aGlzLl9maXJlKGF0dHIgKyBDSEFOR0UsIHtcbiAgICAgICAgb2xkVmFsOiBvbGRWYWwsXG4gICAgICAgIG5ld1ZhbDogbmV3VmFsXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldElkOiBmdW5jdGlvbihpZCkge1xuICAgICAgdmFyIG9sZElkID0gdGhpcy5nZXRJZCgpO1xuXG4gICAgICBLb252YS5fcmVtb3ZlSWQob2xkSWQpO1xuICAgICAgS29udmEuX2FkZElkKHRoaXMsIGlkKTtcbiAgICAgIHRoaXMuX3NldEF0dHIoSUQsIGlkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG9sZE5hbWVzID0gKHRoaXMuZ2V0TmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgdmFyIG5ld05hbWVzID0gKG5hbWUgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICB2YXIgc3VibmFtZSwgaTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgc3VibmFtZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBvbGROYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdWJuYW1lID0gb2xkTmFtZXNbaV07XG4gICAgICAgIGlmIChuZXdOYW1lcy5pbmRleE9mKHN1Ym5hbWUpID09PSAtMSAmJiBzdWJuYW1lKSB7XG4gICAgICAgICAgS29udmEuX3JlbW92ZU5hbWUoc3VibmFtZSwgdGhpcy5faWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBuZXcgbmFtZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXdOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdWJuYW1lID0gbmV3TmFtZXNbaV07XG4gICAgICAgIGlmIChvbGROYW1lcy5pbmRleE9mKHN1Ym5hbWUpID09PSAtMSAmJiBzdWJuYW1lKSB7XG4gICAgICAgICAgS29udmEuX2FkZE5hbWUodGhpcywgc3VibmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0QXR0cihOQU1FLCBuYW1lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gbmFtaW5nIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBhZGQgbmFtZSB0byBub2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLm5hbWUoJ3JlZCcpO1xuICAgICAqIG5vZGUuYWRkTmFtZSgnc2VsZWN0ZWQnKTtcbiAgICAgKiBub2RlLm5hbWUoKTsgLy8gcmV0dXJuICdyZWQgc2VsZWN0ZWQnXG4gICAgICovXG4gICAgYWRkTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgaWYgKCF0aGlzLmhhc05hbWUobmFtZSkpIHtcbiAgICAgICAgdmFyIG9sZE5hbWUgPSB0aGlzLm5hbWUoKTtcbiAgICAgICAgdmFyIG5ld05hbWUgPSBvbGROYW1lID8gb2xkTmFtZSArICcgJyArIG5hbWUgOiBuYW1lO1xuICAgICAgICB0aGlzLnNldE5hbWUobmV3TmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNoZWNrIGlzIG5vZGUgaGFzIG5hbWVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUubmFtZSgncmVkJyk7XG4gICAgICogbm9kZS5oYXNOYW1lKCdyZWQnKTsgICAvLyByZXR1cm4gdHJ1ZVxuICAgICAqIG5vZGUuaGFzTmFtZSgnc2VsZWN0ZWQnKTsgLy8gcmV0dXJuIGZhbHNlXG4gICAgICovXG4gICAgaGFzTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIG5hbWVzID0gKHRoaXMubmFtZSgpIHx8ICcnKS5zcGxpdCgvXFxzL2cpO1xuICAgICAgcmV0dXJuIG5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmVtb3ZlIG5hbWUgZnJvbSBub2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLm5hbWUoJ3JlZCBzZWxlY3RlZCcpO1xuICAgICAqIG5vZGUucmVtb3ZlTmFtZSgnc2VsZWN0ZWQnKTtcbiAgICAgKiBub2RlLmhhc05hbWUoJ3NlbGVjdGVkJyk7IC8vIHJldHVybiBmYWxzZVxuICAgICAqIG5vZGUubmFtZSgpOyAvLyByZXR1cm4gJ3JlZCdcbiAgICAgKi9cbiAgICByZW1vdmVOYW1lOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgbmFtZXMgPSAodGhpcy5uYW1lKCkgfHwgJycpLnNwbGl0KC9cXHMvZyk7XG4gICAgICB2YXIgaW5kZXggPSBuYW1lcy5pbmRleE9mKG5hbWUpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICBuYW1lcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLnNldE5hbWUobmFtZXMuam9pbignICcpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IGF0dHJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbFxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5zZXRBdHRyKCd4JywgNSk7XG4gICAgICovXG4gICAgc2V0QXR0cjogZnVuY3Rpb24oYXR0ciwgdmFsKSB7XG4gICAgICB2YXIgbWV0aG9kID0gU0VUICsgS29udmEuVXRpbC5fY2FwaXRhbGl6ZShhdHRyKSxcbiAgICAgICAgZnVuYyA9IHRoaXNbbWV0aG9kXTtcblxuICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzRnVuY3Rpb24oZnVuYykpIHtcbiAgICAgICAgZnVuYy5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvdGhlcndpc2Ugc2V0IGRpcmVjdGx5XG4gICAgICAgIHRoaXMuX3NldEF0dHIoYXR0ciwgdmFsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX3NldEF0dHI6IGZ1bmN0aW9uKGtleSwgdmFsKSB7XG4gICAgICB2YXIgb2xkVmFsO1xuICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuICAgICAgdmFyIHNhbWUgPSBvbGRWYWwgPT09IHZhbDtcbiAgICAgIGlmIChzYW1lICYmICFLb252YS5VdGlsLmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkIHx8IHZhbCA9PT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hdHRyc1trZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hdHRyc1trZXldID0gdmFsO1xuICAgICAgfVxuICAgICAgdGhpcy5fZmlyZUNoYW5nZUV2ZW50KGtleSwgb2xkVmFsLCB2YWwpO1xuICAgIH0sXG4gICAgX3NldENvbXBvbmVudEF0dHI6IGZ1bmN0aW9uKGtleSwgY29tcG9uZW50LCB2YWwpIHtcbiAgICAgIHZhciBvbGRWYWw7XG4gICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb2xkVmFsID0gdGhpcy5hdHRyc1trZXldO1xuXG4gICAgICAgIGlmICghb2xkVmFsKSB7XG4gICAgICAgICAgLy8gc2V0IHZhbHVlIHRvIGRlZmF1bHQgdmFsdWUgdXNpbmcgZ2V0QXR0clxuICAgICAgICAgIHRoaXMuYXR0cnNba2V5XSA9IHRoaXMuZ2V0QXR0cihrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hdHRyc1trZXldW2NvbXBvbmVudF0gPSB2YWw7XG4gICAgICAgIHRoaXMuX2ZpcmVDaGFuZ2VFdmVudChrZXksIG9sZFZhbCwgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9maXJlQW5kQnViYmxlOiBmdW5jdGlvbihldmVudFR5cGUsIGV2dCwgY29tcGFyZVNoYXBlKSB7XG4gICAgICB2YXIgb2theVRvUnVuID0gdHJ1ZTtcblxuICAgICAgaWYgKGV2dCAmJiB0aGlzLm5vZGVUeXBlID09PSBTSEFQRSkge1xuICAgICAgICBldnQudGFyZ2V0ID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBldmVudFR5cGUgPT09IE1PVVNFRU5URVIgJiZcbiAgICAgICAgY29tcGFyZVNoYXBlICYmXG4gICAgICAgICh0aGlzLl9pZCA9PT0gY29tcGFyZVNoYXBlLl9pZCB8fFxuICAgICAgICAgICh0aGlzLmlzQW5jZXN0b3JPZiAmJiB0aGlzLmlzQW5jZXN0b3JPZihjb21wYXJlU2hhcGUpKSlcbiAgICAgICkge1xuICAgICAgICBva2F5VG9SdW4gPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGV2ZW50VHlwZSA9PT0gTU9VU0VMRUFWRSAmJlxuICAgICAgICBjb21wYXJlU2hhcGUgJiZcbiAgICAgICAgKHRoaXMuX2lkID09PSBjb21wYXJlU2hhcGUuX2lkIHx8XG4gICAgICAgICAgKHRoaXMuaXNBbmNlc3Rvck9mICYmIHRoaXMuaXNBbmNlc3Rvck9mKGNvbXBhcmVTaGFwZSkpKVxuICAgICAgKSB7XG4gICAgICAgIG9rYXlUb1J1biA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG9rYXlUb1J1bikge1xuICAgICAgICB0aGlzLl9maXJlKGV2ZW50VHlwZSwgZXZ0KTtcblxuICAgICAgICAvLyBzaW11bGF0ZSBldmVudCBidWJibGluZ1xuICAgICAgICB2YXIgc3RvcEJ1YmJsZSA9XG4gICAgICAgICAgKGV2ZW50VHlwZSA9PT0gTU9VU0VFTlRFUiB8fCBldmVudFR5cGUgPT09IE1PVVNFTEVBVkUpICYmXG4gICAgICAgICAgKGNvbXBhcmVTaGFwZSAmJlxuICAgICAgICAgICAgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZiAmJlxuICAgICAgICAgICAgY29tcGFyZVNoYXBlLmlzQW5jZXN0b3JPZih0aGlzKSAmJlxuICAgICAgICAgICAgIWNvbXBhcmVTaGFwZS5pc0FuY2VzdG9yT2YodGhpcy5wYXJlbnQpKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgoZXZ0ICYmICFldnQuY2FuY2VsQnViYmxlKSB8fCAhZXZ0KSAmJlxuICAgICAgICAgIHRoaXMucGFyZW50ICYmXG4gICAgICAgICAgdGhpcy5wYXJlbnQuaXNMaXN0ZW5pbmcoKSAmJlxuICAgICAgICAgICFzdG9wQnViYmxlXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChjb21wYXJlU2hhcGUgJiYgY29tcGFyZVNoYXBlLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5fZmlyZUFuZEJ1YmJsZS5jYWxsKFxuICAgICAgICAgICAgICB0aGlzLnBhcmVudCxcbiAgICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgICBldnQsXG4gICAgICAgICAgICAgIGNvbXBhcmVTaGFwZS5wYXJlbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmVBbmRCdWJibGUuY2FsbCh0aGlzLnBhcmVudCwgZXZlbnRUeXBlLCBldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2ZpcmU6IGZ1bmN0aW9uKGV2ZW50VHlwZSwgZXZ0KSB7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5ldmVudExpc3RlbmVyc1tldmVudFR5cGVdLFxuICAgICAgICBpO1xuXG4gICAgICBldnQgPSBldnQgfHwge307XG4gICAgICBldnQuY3VycmVudFRhcmdldCA9IHRoaXM7XG4gICAgICBldnQudHlwZSA9IGV2ZW50VHlwZTtcblxuICAgICAgaWYgKGV2ZW50cykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXZlbnRzW2ldLmhhbmRsZXIuY2FsbCh0aGlzLCBldnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkcmF3IGJvdGggc2NlbmUgYW5kIGhpdCBncmFwaHMuICBJZiB0aGUgbm9kZSBiZWluZyBkcmF3biBpcyB0aGUgc3RhZ2UsIGFsbCBvZiB0aGUgbGF5ZXJzIHdpbGwgYmUgY2xlYXJlZCBhbmQgcmVkcmF3blxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuTm9kZX1cbiAgICAgKi9cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZHJhd1NjZW5lKCk7XG4gICAgICB0aGlzLmRyYXdIaXQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIGNyZWF0ZSBub2RlIHdpdGggSlNPTiBzdHJpbmcgb3IgYW4gT2JqZWN0LiAgRGUtc2VyaWFsaXp0aW9uIGRvZXMgbm90IGdlbmVyYXRlIGN1c3RvbVxuICAgKiAgc2hhcGUgZHJhd2luZyBmdW5jdGlvbnMsIGltYWdlcywgb3IgZXZlbnQgaGFuZGxlcnMgKHRoaXMgd291bGQgbWFrZSB0aGVcbiAgICogIHNlcmlhbGl6ZWQgb2JqZWN0IGh1Z2UpLiAgSWYgeW91ciBhcHAgdXNlcyBjdXN0b20gc2hhcGVzLCBpbWFnZXMsIGFuZFxuICAgKiAgZXZlbnQgaGFuZGxlcnMgKGl0IHByb2JhYmx5IGRvZXMpLCB0aGVuIHlvdSBuZWVkIHRvIHNlbGVjdCB0aGUgYXBwcm9wcmlhdGVcbiAgICogIHNoYXBlcyBhZnRlciBsb2FkaW5nIHRoZSBzdGFnZSBhbmQgc2V0IHRoZXNlIHByb3BlcnRpZXMgdmlhIG9uKCksIHNldERyYXdGdW5jKCksXG4gICAqICBhbmQgc2V0SW1hZ2UoKSBtZXRob2RzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGVcbiAgICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBqc29uIHN0cmluZyBvciBvYmplY3RcbiAgICogQHBhcmFtIHtFbGVtZW50fSBbY29udGFpbmVyXSBvcHRpb25hbCBjb250YWluZXIgZG9tIGVsZW1lbnQgdXNlZCBvbmx5IGlmIHlvdSdyZVxuICAgKiAgY3JlYXRpbmcgYSBzdGFnZSBub2RlXG4gICAqL1xuICBLb252YS5Ob2RlLmNyZWF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGNvbnRhaW5lcikge1xuICAgIGlmIChLb252YS5VdGlsLl9pc1N0cmluZyhkYXRhKSkge1xuICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVOb2RlKGRhdGEsIGNvbnRhaW5lcik7XG4gIH07XG4gIEtvbnZhLk5vZGUuX2NyZWF0ZU5vZGUgPSBmdW5jdGlvbihvYmosIGNvbnRhaW5lcikge1xuICAgIHZhciBjbGFzc05hbWUgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5nZXRDbGFzc05hbWUuY2FsbChvYmopLFxuICAgICAgY2hpbGRyZW4gPSBvYmouY2hpbGRyZW4sXG4gICAgICBubyxcbiAgICAgIGxlbixcbiAgICAgIG47XG5cbiAgICAvLyBpZiBjb250YWluZXIgd2FzIHBhc3NlZCBpbiwgYWRkIGl0IHRvIGF0dHJzXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgb2JqLmF0dHJzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBubyA9IG5ldyBLb252YVtjbGFzc05hbWVdKG9iai5hdHRycyk7XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgbm8uYWRkKHRoaXMuX2NyZWF0ZU5vZGUoY2hpbGRyZW5bbl0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm87XG4gIH07XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09IGFkZCBnZXR0ZXJzIHNldHRlcnMgPT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwb3NpdGlvbicpO1xuICAvKipcbiAgICogZ2V0L3NldCBub2RlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBhcmVudFxuICAgKiBAbmFtZSBwb3NpdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcG9zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHBvc2l0aW9uXG4gICAqIHZhciBwb3NpdGlvbiA9IG5vZGUucG9zaXRpb24oKTtcbiAgICpcbiAgICogLy8gc2V0IHBvc2l0aW9uXG4gICAqIG5vZGUucG9zaXRpb24oe1xuICAgKiAgIHg6IDVcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3gnLCAwKTtcblxuICAvKipcbiAgICogZ2V0L3NldCB4IHBvc2l0aW9uXG4gICAqIEBuYW1lIHhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHhcbiAgICogdmFyIHggPSBub2RlLngoKTtcbiAgICpcbiAgICogLy8gc2V0IHhcbiAgICogbm9kZS54KDUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAneScsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHkgcG9zaXRpb25cbiAgICogQG5hbWUgeVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHlcbiAgICogdmFyIHkgPSBub2RlLnkoKTtcbiAgICpcbiAgICogLy8gc2V0IHlcbiAgICogbm9kZS55KDUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24nLFxuICAgICdzb3VyY2Utb3ZlcidcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gb2YgYSBzaGFwZVxuICAgKiBAbmFtZSBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgKiB2YXIgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc2hhcGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKCk7XG4gICAqXG4gICAqIC8vIHNldCBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cbiAgICogc2hhcGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKCdzb3VyY2UtaW4nKTtcbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvcGFjaXR5JywgMSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgb3BhY2l0eS4gIE9wYWNpdHkgdmFsdWVzIHJhbmdlIGZyb20gMCB0byAxLlxuICAgKiAgQSBub2RlIHdpdGggYW4gb3BhY2l0eSBvZiAwIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCBhbmQgYSBub2RlXG4gICAqICB3aXRoIGFuIG9wYWNpdHkgb2YgMSBpcyBmdWxseSBvcGFxdWVcbiAgICogQG5hbWUgb3BhY2l0eVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3BhY2l0eVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb3BhY2l0eVxuICAgKiB2YXIgb3BhY2l0eSA9IG5vZGUub3BhY2l0eSgpO1xuICAgKlxuICAgKiAvLyBzZXQgb3BhY2l0eVxuICAgKiBub2RlLm9wYWNpdHkoMC41KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ25hbWUnKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICduYW1lJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgbmFtZVxuICAgKiBAbmFtZSBuYW1lXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBuYW1lXG4gICAqIHZhciBuYW1lID0gbm9kZS5uYW1lKCk7XG4gICAqXG4gICAqIC8vIHNldCBuYW1lXG4gICAqIG5vZGUubmFtZSgnZm9vJyk7XG4gICAqXG4gICAqIC8vIGFsc28gbm9kZSBtYXkgaGF2ZSBtdWx0aXBsZSBuYW1lcyAoYXMgY3NzIGNsYXNzZXMpXG4gICAqIG5vZGUubmFtZSgnZm9vIGJhcicpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5Ob2RlLCAnaWQnKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdpZCcpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGlkLiBJZCBpcyBnbG9iYWwgZm9yIHdob2xlIHBhZ2UuXG4gICAqIEBuYW1lIGlkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgaWRcbiAgICogdmFyIG5hbWUgPSBub2RlLmlkKCk7XG4gICAqXG4gICAqIC8vIHNldCBpZFxuICAgKiBub2RlLmlkKCdmb28nKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3JvdGF0aW9uJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgKiBAbmFtZSByb3RhdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcm90YXRpb25cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICogdmFyIHJvdGF0aW9uID0gbm9kZS5yb3RhdGlvbigpO1xuICAgKlxuICAgKiAvLyBzZXQgcm90YXRpb24gaW4gZGVncmVlc1xuICAgKiBub2RlLnJvdGF0aW9uKDQ1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdzY2FsZScsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNjYWxlXG4gICAqIEBuYW1lIHNjYWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzY2FsZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUueVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2NhbGVcbiAgICogdmFyIHNjYWxlID0gbm9kZS5zY2FsZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2NhbGVcbiAgICogc2hhcGUuc2NhbGUoe1xuICAgKiAgIHg6IDJcbiAgICogICB5OiAzXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVYJywgMSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2NhbGUgeFxuICAgKiBAbmFtZSBzY2FsZVhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNjYWxlIHhcbiAgICogdmFyIHNjYWxlWCA9IG5vZGUuc2NhbGVYKCk7XG4gICAqXG4gICAqIC8vIHNldCBzY2FsZSB4XG4gICAqIG5vZGUuc2NhbGVYKDIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnc2NhbGVZJywgMSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2NhbGUgeVxuICAgKiBAbmFtZSBzY2FsZVlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNjYWxlIHlcbiAgICogdmFyIHNjYWxlWSA9IG5vZGUuc2NhbGVZKCk7XG4gICAqXG4gICAqIC8vIHNldCBzY2FsZSB5XG4gICAqIG5vZGUuc2NhbGVZKDIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXcnLCBbJ3gnLCAneSddKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBza2V3XG4gICAqIEBuYW1lIHNrZXdcbiAgICogQHBhcmFtIHtPYmplY3R9IHNrZXdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNrZXcueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc2tldy55XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBza2V3XG4gICAqIHZhciBza2V3ID0gbm9kZS5za2V3KCk7XG4gICAqXG4gICAqIC8vIHNldCBza2V3XG4gICAqIG5vZGUuc2tldyh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NrZXdYJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2tldyB4XG4gICAqIEBuYW1lIHNrZXdYXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBza2V3IHhcbiAgICogdmFyIHNrZXdYID0gbm9kZS5za2V3WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2tldyB4XG4gICAqIG5vZGUuc2tld1goMyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdza2V3WScsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNrZXcgeVxuICAgKiBAbmFtZSBza2V3WVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2tldyB5XG4gICAqIHZhciBza2V3WSA9IG5vZGUuc2tld1koKTtcbiAgICpcbiAgICogLy8gc2V0IHNrZXcgeVxuICAgKiBub2RlLnNrZXdZKDMpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ29mZnNldCcsIFsneCcsICd5J10pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IG9mZnNldC4gIE9mZnNldHMgdGhlIGRlZmF1bHQgcG9zaXRpb24gYW5kIHJvdGF0aW9uIHBvaW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb2Zmc2V0XG4gICAqIHZhciBvZmZzZXQgPSBub2RlLm9mZnNldCgpO1xuICAgKlxuICAgKiAvLyBzZXQgb2Zmc2V0XG4gICAqIG5vZGUub2Zmc2V0KHtcbiAgICogICB4OiAyMFxuICAgKiAgIHk6IDEwXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnb2Zmc2V0WCcsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IG9mZnNldCB4XG4gICAqIEBuYW1lIG9mZnNldFhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IG9mZnNldCB4XG4gICAqIHZhciBvZmZzZXRYID0gbm9kZS5vZmZzZXRYKCk7XG4gICAqXG4gICAqIC8vIHNldCBvZmZzZXQgeFxuICAgKiBub2RlLm9mZnNldFgoMyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdvZmZzZXRZJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgb2Zmc2V0IHlcbiAgICogQG5hbWUgb2Zmc2V0WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgb2Zmc2V0IHlcbiAgICogdmFyIG9mZnNldFkgPSBub2RlLm9mZnNldFkoKTtcbiAgICpcbiAgICogLy8gc2V0IG9mZnNldCB5XG4gICAqIG5vZGUub2Zmc2V0WSgzKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdEaXN0YW5jZScpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdEaXN0YW5jZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGRyYWcgZGlzdGFuY2VcbiAgICogQG5hbWUgZHJhZ0Rpc3RhbmNlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkaXN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZHJhZyBkaXN0YW5jZVxuICAgKiB2YXIgZHJhZ0Rpc3RhbmNlID0gbm9kZS5kcmFnRGlzdGFuY2UoKTtcbiAgICpcbiAgICogLy8gc2V0IGRpc3RhbmNlXG4gICAqIC8vIG5vZGUgc3RhcnRzIGRyYWdnaW5nIG9ubHkgaWYgcG9pbnRlciBtb3ZlZCBtb3JlIHRoZW4gMyBwaXhlbHNcbiAgICogbm9kZS5kcmFnRGlzdGFuY2UoMyk7XG4gICAqIC8vIG9yIHNldCBnbG9iYWxseVxuICAgKiBLb252YS5kcmFnRGlzdGFuY2UgPSAzO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZFNldHRlcihLb252YS5Ob2RlLCAnd2lkdGgnLCAwKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICd3aWR0aCcpO1xuICAvKipcbiAgICogZ2V0L3NldCB3aWR0aFxuICAgKiBAbmFtZSB3aWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHdpZHRoXG4gICAqIHZhciB3aWR0aCA9IG5vZGUud2lkdGgoKTtcbiAgICpcbiAgICogLy8gc2V0IHdpZHRoXG4gICAqIG5vZGUud2lkdGgoMTAwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRTZXR0ZXIoS29udmEuTm9kZSwgJ2hlaWdodCcsIDApO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2hlaWdodCcpO1xuICAvKipcbiAgICogZ2V0L3NldCBoZWlnaHRcbiAgICogQG5hbWUgaGVpZ2h0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGhlaWdodFxuICAgKiB2YXIgaGVpZ2h0ID0gbm9kZS5oZWlnaHQoKTtcbiAgICpcbiAgICogLy8gc2V0IGhlaWdodFxuICAgKiBub2RlLmhlaWdodCgxMDApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnbGlzdGVuaW5nJywgJ2luaGVyaXQnKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgbGlzdGVuaWcgYXR0ci4gIElmIHlvdSBuZWVkIHRvIGRldGVybWluZSBpZiBhIG5vZGUgaXMgbGlzdGVuaW5nIG9yIG5vdFxuICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNMaXN0ZW5pbmcoKSBtZXRob2RcbiAgICogQG5hbWUgbGlzdGVuaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IGxpc3RlbmluZyBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufFN0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpc3RlbmluZyBhdHRyXG4gICAqIHZhciBsaXN0ZW5pbmcgPSBub2RlLmxpc3RlbmluZygpO1xuICAgKlxuICAgKiAvLyBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAqIG5vZGUubGlzdGVuaW5nKGZhbHNlKTtcbiAgICpcbiAgICogLy8gbGlzdGVuIGZvciBldmVudHNcbiAgICogbm9kZS5saXN0ZW5pbmcodHJ1ZSk7XG4gICAqXG4gICAqIC8vIGxpc3RlbiB0byBldmVudHMgYWNjb3JkaW5nIHRvIHRoZSBwYXJlbnRcbiAgICogbm9kZS5saXN0ZW5pbmcoJ2luaGVyaXQnKTtcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcHJldmVudERlZmF1bHRcbiAgICogQnkgZGVmYXVsdCBhbGwgc2hhcGVzIHdpbGwgcHJldmVudCBkZWZhdWx0IGJlaGF2aW91clxuICAgKiBvZiBhIGJyb3dzZXIgb24gYSBwb2ludGVyIG1vdmUgb3IgdGFwLlxuICAgKiB0aGF0IHdpbGwgcHJldmVudCBuYXRpdmUgc2Nyb2xsaW5nIHdoZW4geW91IGFyZSB0cnlpbmcgdG8gZHJhZyZkcm9wIGEgbm9kZVxuICAgKiBidXQgc29tZXRpbWVzIHlvdSBtYXkgbmVlZCB0byBlbmFibGUgZGVmYXVsdCBhY3Rpb25zXG4gICAqIGluIHRoYXQgY2FzZSB5b3UgY2FuIHNldCB0aGUgcHJvcGVydHkgdG8gZmFsc2VcbiAgICogQG5hbWUgcHJldmVudERlZmF1bHRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHByZXZlbnREZWZhdWx0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBwcmV2ZW50RGVmYXVsdFxuICAgKiB2YXIgc2hvdWxkUHJldmVudCA9IHNoYXBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAqXG4gICAqIC8vIHNldCBwcmV2ZW50RGVmYXVsdFxuICAgKiBzaGFwZS5wcmV2ZW50RGVmYXVsdChmYWxzZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdwcmV2ZW50RGVmYXVsdCcsIHRydWUpO1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdmaWx0ZXJzJywgdW5kZWZpbmVkLCBmdW5jdGlvbihcbiAgICB2YWxcbiAgKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICByZXR1cm4gdmFsO1xuICB9KTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsdGVycy4gIEZpbHRlcnMgYXJlIGFwcGxpZWQgdG8gY2FjaGVkIGNhbnZhc2VzXG4gICAqIEBuYW1lIGZpbHRlcnNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gZmlsdGVycyBhcnJheSBvZiBmaWx0ZXJzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbHRlcnNcbiAgICogdmFyIGZpbHRlcnMgPSBub2RlLmZpbHRlcnMoKTtcbiAgICpcbiAgICogLy8gc2V0IGEgc2luZ2xlIGZpbHRlclxuICAgKiBub2RlLmNhY2hlKCk7XG4gICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5CbHVyXSk7XG4gICAqXG4gICAqIC8vIHNldCBtdWx0aXBsZSBmaWx0ZXJzXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtcbiAgICogICBLb252YS5GaWx0ZXJzLkJsdXIsXG4gICAqICAgS29udmEuRmlsdGVycy5TZXBpYSxcbiAgICogICBLb252YS5GaWx0ZXJzLkludmVydFxuICAgKiBdKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3Zpc2libGUnLCAnaW5oZXJpdCcpO1xuICAvKipcbiAgICogZ2V0L3NldCB2aXNpYmxlIGF0dHIuICBDYW4gYmUgXCJpbmhlcml0XCIsIHRydWUsIG9yIGZhbHNlLiAgVGhlIGRlZmF1bHQgaXMgXCJpbmhlcml0XCIuXG4gICAqICAgSWYgeW91IG5lZWQgdG8gZGV0ZXJtaW5lIGlmIGEgbm9kZSBpcyB2aXNpYmxlIG9yIG5vdFxuICAgKiAgIGJ5IHRha2luZyBpbnRvIGFjY291bnQgaXRzIHBhcmVudHMsIHVzZSB0aGUgaXNWaXNpYmxlKCkgbWV0aG9kXG4gICAqIEBuYW1lIHZpc2libGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gdmlzaWJsZVxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbnxTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB2aXNpYmxlIGF0dHJcbiAgICogdmFyIHZpc2libGUgPSBub2RlLnZpc2libGUoKTtcbiAgICpcbiAgICogLy8gbWFrZSBpbnZpc2libGVcbiAgICogbm9kZS52aXNpYmxlKGZhbHNlKTtcbiAgICpcbiAgICogLy8gbWFrZSB2aXNpYmxlXG4gICAqIG5vZGUudmlzaWJsZSh0cnVlKTtcbiAgICpcbiAgICogLy8gbWFrZSB2aXNpYmxlIGFjY29yZGluZyB0byB0aGUgcGFyZW50XG4gICAqIG5vZGUudmlzaWJsZSgnaW5oZXJpdCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAndHJhbnNmb3Jtc0VuYWJsZWQnLCAnYWxsJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdHJhbnNmb3JtcyB0aGF0IGFyZSBlbmFibGVkLiAgQ2FuIGJlIFwiYWxsXCIsIFwibm9uZVwiLCBvciBcInBvc2l0aW9uXCIuICBUaGUgZGVmYXVsdFxuICAgKiAgaXMgXCJhbGxcIlxuICAgKiBAbmFtZSB0cmFuc2Zvcm1zRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBlbmFibGUgcG9zaXRpb24gdHJhbnNmb3JtIG9ubHkgdG8gaW1wcm92ZSBkcmF3IHBlcmZvcm1hbmNlXG4gICAqIG5vZGUudHJhbnNmb3Jtc0VuYWJsZWQoJ3Bvc2l0aW9uJyk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBhbGwgdHJhbnNmb3Jtc1xuICAgKiBub2RlLnRyYW5zZm9ybXNFbmFibGVkKCdhbGwnKTtcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldC9zZXQgbm9kZSBzaXplXG4gICAqIEBuYW1lIHNpemVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNpemVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUud2lkdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHNpemUuaGVpZ2h0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBub2RlIHNpemVcbiAgICogdmFyIHNpemUgPSBub2RlLnNpemUoKTtcbiAgICogdmFyIHggPSBzaXplLng7XG4gICAqIHZhciB5ID0gc2l6ZS55O1xuICAgKlxuICAgKiAvLyBzZXQgc2l6ZVxuICAgKiBub2RlLnNpemUoe1xuICAgKiAgIHdpZHRoOiAxMDAsXG4gICAqICAgaGVpZ2h0OiAyMDBcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3NpemUnKTtcblxuICBLb252YS5GYWN0b3J5LmJhY2tDb21wYXQoS29udmEuTm9kZSwge1xuICAgIHJvdGF0ZURlZzogJ3JvdGF0ZScsXG4gICAgc2V0Um90YXRpb25EZWc6ICdzZXRSb3RhdGlvbicsXG4gICAgZ2V0Um90YXRpb25EZWc6ICdnZXRSb3RhdGlvbidcbiAgfSk7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLk5vZGUpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIEdyYXlzY2FsZSBGaWx0ZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuR3JheXNjYWxlXSk7XG4gICAqL1xuICBLb252YS5GaWx0ZXJzLkdyYXlzY2FsZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBicmlnaHRuZXNzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICBicmlnaHRuZXNzID0gMC4zNCAqIGRhdGFbaV0gKyAwLjUgKiBkYXRhW2kgKyAxXSArIDAuMTYgKiBkYXRhW2kgKyAyXTtcbiAgICAgIC8vIHJlZFxuICAgICAgZGF0YVtpXSA9IGJyaWdodG5lc3M7XG4gICAgICAvLyBncmVlblxuICAgICAgZGF0YVtpICsgMV0gPSBicmlnaHRuZXNzO1xuICAgICAgLy8gYmx1ZVxuICAgICAgZGF0YVtpICsgMl0gPSBicmlnaHRuZXNzO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIEJyaWdodGVuIEZpbHRlci5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQnJpZ2h0ZW5dKTtcbiAgICAgKiBub2RlLmJyaWdodG5lc3MoMC44KTtcbiAgICAgKi9cbiAgS29udmEuRmlsdGVycy5CcmlnaHRlbiA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5icmlnaHRuZXNzKCkgKiAyNTUsXG4gICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBsZW4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgIC8vIHJlZFxuICAgICAgZGF0YVtpXSArPSBicmlnaHRuZXNzO1xuICAgICAgLy8gZ3JlZW5cbiAgICAgIGRhdGFbaSArIDFdICs9IGJyaWdodG5lc3M7XG4gICAgICAvLyBibHVlXG4gICAgICBkYXRhW2kgKyAyXSArPSBicmlnaHRuZXNzO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdicmlnaHRuZXNzJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGJyaWdodG5lc3MuICBUaGUgYnJpZ2h0bmVzcyBpcyBhIG51bWJlciBiZXR3ZWVuIC0xIGFuZCAxLiZuYnNwOyBQb3NpdGl2ZSB2YWx1ZXNcbiAgICAqICBicmlnaHRlbiB0aGUgcGl4ZWxzIGFuZCBuZWdhdGl2ZSB2YWx1ZXMgZGFya2VuIHRoZW0uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkJyaWdodGVufSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBicmlnaHRuZXNzXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBicmlnaHRuZXNzIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBJbnZlcnQgRmlsdGVyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkludmVydF0pO1xuICAgKi9cbiAgS29udmEuRmlsdGVycy5JbnZlcnQgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgICAvLyByZWRcbiAgICAgIGRhdGFbaV0gPSAyNTUgLSBkYXRhW2ldO1xuICAgICAgLy8gZ3JlZW5cbiAgICAgIGRhdGFbaSArIDFdID0gMjU1IC0gZGF0YVtpICsgMV07XG4gICAgICAvLyBibHVlXG4gICAgICBkYXRhW2kgKyAyXSA9IDI1NSAtIGRhdGFbaSArIDJdO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbi8qXG4gdGhlIEdhdXNzIGZpbHRlclxuIG1hc3RlciByZXBvOiBodHRwczovL2dpdGh1Yi5jb20vcGF2ZWxwb3dlci9raW5ldGljanNHYXVzc0ZpbHRlclxuKi9cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qXG5cbiAgICAgU3RhY2tCbHVyIC0gYSBmYXN0IGFsbW9zdCBHYXVzc2lhbiBCbHVyIEZvciBDYW52YXNcblxuICAgICBWZXJzaW9uOiAgIDAuNVxuICAgICBBdXRob3I6ICAgIE1hcmlvIEtsaW5nZW1hbm5cbiAgICAgQ29udGFjdDogICBtYXJpb0BxdWFzaW1vbmRvLmNvbVxuICAgICBXZWJzaXRlOiAgIGh0dHA6Ly93d3cucXVhc2ltb25kby5jb20vU3RhY2tCbHVyRm9yQ2FudmFzXG4gICAgIFR3aXR0ZXI6ICAgQHF1YXNpbW9uZG9cblxuICAgICBJbiBjYXNlIHlvdSBmaW5kIHRoaXMgY2xhc3MgdXNlZnVsIC0gZXNwZWNpYWxseSBpbiBjb21tZXJjaWFsIHByb2plY3RzIC1cbiAgICAgSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG4gICAgIG1hcmlvQHF1YXNpbW9uZG8uZGVcblxuICAgICBPciBzdXBwb3J0IG1lIG9uIGZsYXR0cjpcbiAgICAgaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbiAgICAgQ29weXJpZ2h0IChjKSAyMDEwIE1hcmlvIEtsaW5nZW1hbm5cblxuICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICAgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsXG4gICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAgIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgICBjb25kaXRpb25zOlxuXG4gICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gICAgIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgICBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuICAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICAgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcbiAgICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAqL1xuXG4gIGZ1bmN0aW9uIEJsdXJTdGFjaygpIHtcbiAgICB0aGlzLnIgPSAwO1xuICAgIHRoaXMuZyA9IDA7XG4gICAgdGhpcy5iID0gMDtcbiAgICB0aGlzLmEgPSAwO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG4gIH1cblxuICB2YXIgbXVsX3RhYmxlID0gW1xuICAgIDUxMixcbiAgICA1MTIsXG4gICAgNDU2LFxuICAgIDUxMixcbiAgICAzMjgsXG4gICAgNDU2LFxuICAgIDMzNSxcbiAgICA1MTIsXG4gICAgNDA1LFxuICAgIDMyOCxcbiAgICAyNzEsXG4gICAgNDU2LFxuICAgIDM4OCxcbiAgICAzMzUsXG4gICAgMjkyLFxuICAgIDUxMixcbiAgICA0NTQsXG4gICAgNDA1LFxuICAgIDM2NCxcbiAgICAzMjgsXG4gICAgMjk4LFxuICAgIDI3MSxcbiAgICA0OTYsXG4gICAgNDU2LFxuICAgIDQyMCxcbiAgICAzODgsXG4gICAgMzYwLFxuICAgIDMzNSxcbiAgICAzMTIsXG4gICAgMjkyLFxuICAgIDI3MyxcbiAgICA1MTIsXG4gICAgNDgyLFxuICAgIDQ1NCxcbiAgICA0MjgsXG4gICAgNDA1LFxuICAgIDM4MyxcbiAgICAzNjQsXG4gICAgMzQ1LFxuICAgIDMyOCxcbiAgICAzMTIsXG4gICAgMjk4LFxuICAgIDI4NCxcbiAgICAyNzEsXG4gICAgMjU5LFxuICAgIDQ5NixcbiAgICA0NzUsXG4gICAgNDU2LFxuICAgIDQzNyxcbiAgICA0MjAsXG4gICAgNDA0LFxuICAgIDM4OCxcbiAgICAzNzQsXG4gICAgMzYwLFxuICAgIDM0NyxcbiAgICAzMzUsXG4gICAgMzIzLFxuICAgIDMxMixcbiAgICAzMDIsXG4gICAgMjkyLFxuICAgIDI4MixcbiAgICAyNzMsXG4gICAgMjY1LFxuICAgIDUxMixcbiAgICA0OTcsXG4gICAgNDgyLFxuICAgIDQ2OCxcbiAgICA0NTQsXG4gICAgNDQxLFxuICAgIDQyOCxcbiAgICA0MTcsXG4gICAgNDA1LFxuICAgIDM5NCxcbiAgICAzODMsXG4gICAgMzczLFxuICAgIDM2NCxcbiAgICAzNTQsXG4gICAgMzQ1LFxuICAgIDMzNyxcbiAgICAzMjgsXG4gICAgMzIwLFxuICAgIDMxMixcbiAgICAzMDUsXG4gICAgMjk4LFxuICAgIDI5MSxcbiAgICAyODQsXG4gICAgMjc4LFxuICAgIDI3MSxcbiAgICAyNjUsXG4gICAgMjU5LFxuICAgIDUwNyxcbiAgICA0OTYsXG4gICAgNDg1LFxuICAgIDQ3NSxcbiAgICA0NjUsXG4gICAgNDU2LFxuICAgIDQ0NixcbiAgICA0MzcsXG4gICAgNDI4LFxuICAgIDQyMCxcbiAgICA0MTIsXG4gICAgNDA0LFxuICAgIDM5NixcbiAgICAzODgsXG4gICAgMzgxLFxuICAgIDM3NCxcbiAgICAzNjcsXG4gICAgMzYwLFxuICAgIDM1NCxcbiAgICAzNDcsXG4gICAgMzQxLFxuICAgIDMzNSxcbiAgICAzMjksXG4gICAgMzIzLFxuICAgIDMxOCxcbiAgICAzMTIsXG4gICAgMzA3LFxuICAgIDMwMixcbiAgICAyOTcsXG4gICAgMjkyLFxuICAgIDI4NyxcbiAgICAyODIsXG4gICAgMjc4LFxuICAgIDI3MyxcbiAgICAyNjksXG4gICAgMjY1LFxuICAgIDI2MSxcbiAgICA1MTIsXG4gICAgNTA1LFxuICAgIDQ5NyxcbiAgICA0ODksXG4gICAgNDgyLFxuICAgIDQ3NSxcbiAgICA0NjgsXG4gICAgNDYxLFxuICAgIDQ1NCxcbiAgICA0NDcsXG4gICAgNDQxLFxuICAgIDQzNSxcbiAgICA0MjgsXG4gICAgNDIyLFxuICAgIDQxNyxcbiAgICA0MTEsXG4gICAgNDA1LFxuICAgIDM5OSxcbiAgICAzOTQsXG4gICAgMzg5LFxuICAgIDM4MyxcbiAgICAzNzgsXG4gICAgMzczLFxuICAgIDM2OCxcbiAgICAzNjQsXG4gICAgMzU5LFxuICAgIDM1NCxcbiAgICAzNTAsXG4gICAgMzQ1LFxuICAgIDM0MSxcbiAgICAzMzcsXG4gICAgMzMyLFxuICAgIDMyOCxcbiAgICAzMjQsXG4gICAgMzIwLFxuICAgIDMxNixcbiAgICAzMTIsXG4gICAgMzA5LFxuICAgIDMwNSxcbiAgICAzMDEsXG4gICAgMjk4LFxuICAgIDI5NCxcbiAgICAyOTEsXG4gICAgMjg3LFxuICAgIDI4NCxcbiAgICAyODEsXG4gICAgMjc4LFxuICAgIDI3NCxcbiAgICAyNzEsXG4gICAgMjY4LFxuICAgIDI2NSxcbiAgICAyNjIsXG4gICAgMjU5LFxuICAgIDI1NyxcbiAgICA1MDcsXG4gICAgNTAxLFxuICAgIDQ5NixcbiAgICA0OTEsXG4gICAgNDg1LFxuICAgIDQ4MCxcbiAgICA0NzUsXG4gICAgNDcwLFxuICAgIDQ2NSxcbiAgICA0NjAsXG4gICAgNDU2LFxuICAgIDQ1MSxcbiAgICA0NDYsXG4gICAgNDQyLFxuICAgIDQzNyxcbiAgICA0MzMsXG4gICAgNDI4LFxuICAgIDQyNCxcbiAgICA0MjAsXG4gICAgNDE2LFxuICAgIDQxMixcbiAgICA0MDgsXG4gICAgNDA0LFxuICAgIDQwMCxcbiAgICAzOTYsXG4gICAgMzkyLFxuICAgIDM4OCxcbiAgICAzODUsXG4gICAgMzgxLFxuICAgIDM3NyxcbiAgICAzNzQsXG4gICAgMzcwLFxuICAgIDM2NyxcbiAgICAzNjMsXG4gICAgMzYwLFxuICAgIDM1NyxcbiAgICAzNTQsXG4gICAgMzUwLFxuICAgIDM0NyxcbiAgICAzNDQsXG4gICAgMzQxLFxuICAgIDMzOCxcbiAgICAzMzUsXG4gICAgMzMyLFxuICAgIDMyOSxcbiAgICAzMjYsXG4gICAgMzIzLFxuICAgIDMyMCxcbiAgICAzMTgsXG4gICAgMzE1LFxuICAgIDMxMixcbiAgICAzMTAsXG4gICAgMzA3LFxuICAgIDMwNCxcbiAgICAzMDIsXG4gICAgMjk5LFxuICAgIDI5NyxcbiAgICAyOTQsXG4gICAgMjkyLFxuICAgIDI4OSxcbiAgICAyODcsXG4gICAgMjg1LFxuICAgIDI4MixcbiAgICAyODAsXG4gICAgMjc4LFxuICAgIDI3NSxcbiAgICAyNzMsXG4gICAgMjcxLFxuICAgIDI2OSxcbiAgICAyNjcsXG4gICAgMjY1LFxuICAgIDI2MyxcbiAgICAyNjEsXG4gICAgMjU5XG4gIF07XG5cbiAgdmFyIHNoZ190YWJsZSA9IFtcbiAgICA5LFxuICAgIDExLFxuICAgIDEyLFxuICAgIDEzLFxuICAgIDEzLFxuICAgIDE0LFxuICAgIDE0LFxuICAgIDE1LFxuICAgIDE1LFxuICAgIDE1LFxuICAgIDE1LFxuICAgIDE2LFxuICAgIDE2LFxuICAgIDE2LFxuICAgIDE2LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE3LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE4LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDE5LFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIwLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIxLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIyLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDIzLFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0LFxuICAgIDI0XG4gIF07XG5cbiAgZnVuY3Rpb24gZmlsdGVyR2F1c3NCbHVyUkdCQShpbWFnZURhdGEsIHJhZGl1cykge1xuICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcblxuICAgIHZhciB4LFxuICAgICAgeSxcbiAgICAgIGksXG4gICAgICBwLFxuICAgICAgeXAsXG4gICAgICB5aSxcbiAgICAgIHl3LFxuICAgICAgcl9zdW0sXG4gICAgICBnX3N1bSxcbiAgICAgIGJfc3VtLFxuICAgICAgYV9zdW0sXG4gICAgICByX291dF9zdW0sXG4gICAgICBnX291dF9zdW0sXG4gICAgICBiX291dF9zdW0sXG4gICAgICBhX291dF9zdW0sXG4gICAgICByX2luX3N1bSxcbiAgICAgIGdfaW5fc3VtLFxuICAgICAgYl9pbl9zdW0sXG4gICAgICBhX2luX3N1bSxcbiAgICAgIHByLFxuICAgICAgcGcsXG4gICAgICBwYixcbiAgICAgIHBhLFxuICAgICAgcmJzO1xuXG4gICAgdmFyIGRpdiA9IHJhZGl1cyArIHJhZGl1cyArIDEsXG4gICAgICB3aWR0aE1pbnVzMSA9IHdpZHRoIC0gMSxcbiAgICAgIGhlaWdodE1pbnVzMSA9IGhlaWdodCAtIDEsXG4gICAgICByYWRpdXNQbHVzMSA9IHJhZGl1cyArIDEsXG4gICAgICBzdW1GYWN0b3IgPSByYWRpdXNQbHVzMSAqIChyYWRpdXNQbHVzMSArIDEpIC8gMixcbiAgICAgIHN0YWNrU3RhcnQgPSBuZXcgQmx1clN0YWNrKCksXG4gICAgICBzdGFja0VuZCA9IG51bGwsXG4gICAgICBzdGFjayA9IHN0YWNrU3RhcnQsXG4gICAgICBzdGFja0luID0gbnVsbCxcbiAgICAgIHN0YWNrT3V0ID0gbnVsbCxcbiAgICAgIG11bF9zdW0gPSBtdWxfdGFibGVbcmFkaXVzXSxcbiAgICAgIHNoZ19zdW0gPSBzaGdfdGFibGVbcmFkaXVzXTtcblxuICAgIGZvciAoaSA9IDE7IGkgPCBkaXY7IGkrKykge1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0ID0gbmV3IEJsdXJTdGFjaygpO1xuICAgICAgaWYgKGkgPT09IHJhZGl1c1BsdXMxKSB7XG4gICAgICAgIHN0YWNrRW5kID0gc3RhY2s7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhY2submV4dCA9IHN0YWNrU3RhcnQ7XG5cbiAgICB5dyA9IHlpID0gMDtcblxuICAgIGZvciAoeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgcl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XG5cbiAgICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG4gICAgICBnX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwZyA9IHBpeGVsc1t5aSArIDFdKTtcbiAgICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGEgPSBwaXhlbHNbeWkgKyAzXSk7XG5cbiAgICAgIHJfc3VtICs9IHN1bUZhY3RvciAqIHByO1xuICAgICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICAgIGFfc3VtICs9IHN1bUZhY3RvciAqIHBhO1xuXG4gICAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG4gICAgICAgIHN0YWNrLnIgPSBwcjtcbiAgICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgICBzdGFjay5iID0gcGI7XG4gICAgICAgIHN0YWNrLmEgPSBwYTtcbiAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuICAgICAgICBwID0geWkgKyAoKHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSkgPDwgMik7XG4gICAgICAgIHJfc3VtICs9IChzdGFjay5yID0gcHIgPSBwaXhlbHNbcF0pICogKHJicyA9IHJhZGl1c1BsdXMxIC0gaSk7XG4gICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gcGcgPSBwaXhlbHNbcCArIDFdKSAqIHJicztcbiAgICAgICAgYl9zdW0gKz0gKHN0YWNrLmIgPSBwYiA9IHBpeGVsc1twICsgMl0pICogcmJzO1xuICAgICAgICBhX3N1bSArPSAoc3RhY2suYSA9IHBhID0gcGl4ZWxzW3AgKyAzXSkgKiByYnM7XG5cbiAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgICAgfVxuXG4gICAgICBzdGFja0luID0gc3RhY2tTdGFydDtcbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICBwaXhlbHNbeWkgKyAzXSA9IHBhID0gKGFfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bTtcbiAgICAgICAgaWYgKHBhICE9PSAwKSB7XG4gICAgICAgICAgcGEgPSAyNTUgLyBwYTtcbiAgICAgICAgICBwaXhlbHNbeWldID0gKChyX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgcGl4ZWxzW3lpICsgMV0gPSAoKGdfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICBwaXhlbHNbeWkgKyAyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpeGVsc1t5aV0gPSBwaXhlbHNbeWkgKyAxXSA9IHBpeGVsc1t5aSArIDJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICAgIHAgPSAoeXcgKyAoKHAgPSB4ICsgcmFkaXVzICsgMSkgPCB3aWR0aE1pbnVzMSA/IHAgOiB3aWR0aE1pbnVzMSkpIDw8IDI7XG5cbiAgICAgICAgcl9pbl9zdW0gKz0gc3RhY2tJbi5yID0gcGl4ZWxzW3BdO1xuICAgICAgICBnX2luX3N1bSArPSBzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdO1xuICAgICAgICBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgICBhX2luX3N1bSArPSBzdGFja0luLmEgPSBwaXhlbHNbcCArIDNdO1xuXG4gICAgICAgIHJfc3VtICs9IHJfaW5fc3VtO1xuICAgICAgICBnX3N1bSArPSBnX2luX3N1bTtcbiAgICAgICAgYl9zdW0gKz0gYl9pbl9zdW07XG4gICAgICAgIGFfc3VtICs9IGFfaW5fc3VtO1xuXG4gICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgcl9vdXRfc3VtICs9IHByID0gc3RhY2tPdXQucjtcbiAgICAgICAgZ19vdXRfc3VtICs9IHBnID0gc3RhY2tPdXQuZztcbiAgICAgICAgYl9vdXRfc3VtICs9IHBiID0gc3RhY2tPdXQuYjtcbiAgICAgICAgYV9vdXRfc3VtICs9IHBhID0gc3RhY2tPdXQuYTtcblxuICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgeWkgKz0gNDtcbiAgICAgIH1cbiAgICAgIHl3ICs9IHdpZHRoO1xuICAgIH1cblxuICAgIGZvciAoeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX2luX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IHJfc3VtID0gMDtcblxuICAgICAgeWkgPSB4IDw8IDI7XG4gICAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwciA9IHBpeGVsc1t5aV0pO1xuICAgICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgICBiX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwYiA9IHBpeGVsc1t5aSArIDJdKTtcbiAgICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBhID0gcGl4ZWxzW3lpICsgM10pO1xuXG4gICAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICAgIGdfc3VtICs9IHN1bUZhY3RvciAqIHBnO1xuICAgICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFja1N0YXJ0O1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuICAgICAgICBzdGFjay5yID0gcHI7XG4gICAgICAgIHN0YWNrLmcgPSBwZztcbiAgICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgICBzdGFjay5hID0gcGE7XG4gICAgICAgIHN0YWNrID0gc3RhY2submV4dDtcbiAgICAgIH1cblxuICAgICAgeXAgPSB3aWR0aDtcblxuICAgICAgZm9yIChpID0gMTsgaSA8PSByYWRpdXM7IGkrKykge1xuICAgICAgICB5aSA9ICh5cCArIHgpIDw8IDI7XG5cbiAgICAgICAgcl9zdW0gKz0gKHN0YWNrLnIgPSBwciA9IHBpeGVsc1t5aV0pICogKHJicyA9IHJhZGl1c1BsdXMxIC0gaSk7XG4gICAgICAgIGdfc3VtICs9IChzdGFjay5nID0gcGcgPSBwaXhlbHNbeWkgKyAxXSkgKiByYnM7XG4gICAgICAgIGJfc3VtICs9IChzdGFjay5iID0gcGIgPSBwaXhlbHNbeWkgKyAyXSkgKiByYnM7XG4gICAgICAgIGFfc3VtICs9IChzdGFjay5hID0gcGEgPSBwaXhlbHNbeWkgKyAzXSkgKiByYnM7XG5cbiAgICAgICAgcl9pbl9zdW0gKz0gcHI7XG4gICAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgICBiX2luX3N1bSArPSBwYjtcbiAgICAgICAgYV9pbl9zdW0gKz0gcGE7XG5cbiAgICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICAgIGlmIChpIDwgaGVpZ2h0TWludXMxKSB7XG4gICAgICAgICAgeXAgKz0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgeWkgPSB4O1xuICAgICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgICBzdGFja091dCA9IHN0YWNrRW5kO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgICBwaXhlbHNbcCArIDNdID0gcGEgPSAoYV9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtO1xuICAgICAgICBpZiAocGEgPiAwKSB7XG4gICAgICAgICAgcGEgPSAyNTUgLyBwYTtcbiAgICAgICAgICBwaXhlbHNbcF0gPSAoKHJfc3VtICogbXVsX3N1bSkgPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgICBwaXhlbHNbcCArIDFdID0gKChnX3N1bSAqIG11bF9zdW0pID4+IHNoZ19zdW0pICogcGE7XG4gICAgICAgICAgcGl4ZWxzW3AgKyAyXSA9ICgoYl9zdW0gKiBtdWxfc3VtKSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpeGVsc1twXSA9IHBpeGVsc1twICsgMV0gPSBwaXhlbHNbcCArIDJdID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgICBiX3N1bSAtPSBiX291dF9zdW07XG4gICAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgICBnX291dF9zdW0gLT0gc3RhY2tJbi5nO1xuICAgICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICAgIHAgPVxuICAgICAgICAgICh4ICtcbiAgICAgICAgICAgICgocCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxKSAqXG4gICAgICAgICAgICAgIHdpZHRoKSA8PFxuICAgICAgICAgIDI7XG5cbiAgICAgICAgcl9zdW0gKz0gcl9pbl9zdW0gKz0gc3RhY2tJbi5yID0gcGl4ZWxzW3BdO1xuICAgICAgICBnX3N1bSArPSBnX2luX3N1bSArPSBzdGFja0luLmcgPSBwaXhlbHNbcCArIDFdO1xuICAgICAgICBiX3N1bSArPSBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgICBhX3N1bSArPSBhX2luX3N1bSArPSBzdGFja0luLmEgPSBwaXhlbHNbcCArIDNdO1xuXG4gICAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgICAgcl9vdXRfc3VtICs9IHByID0gc3RhY2tPdXQucjtcbiAgICAgICAgZ19vdXRfc3VtICs9IHBnID0gc3RhY2tPdXQuZztcbiAgICAgICAgYl9vdXRfc3VtICs9IHBiID0gc3RhY2tPdXQuYjtcbiAgICAgICAgYV9vdXRfc3VtICs9IHBhID0gc3RhY2tPdXQuYTtcblxuICAgICAgICByX2luX3N1bSAtPSBwcjtcbiAgICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgICBhX2luX3N1bSAtPSBwYTtcblxuICAgICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgICAgeWkgKz0gd2lkdGg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgICogQmx1ciBGaWx0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBCbHVyXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkJsdXJdKTtcbiAgICAgKiBub2RlLmJsdXJSYWRpdXMoMTApO1xuICAgICAqL1xuICBLb252YS5GaWx0ZXJzLkJsdXIgPSBmdW5jdGlvbiBCbHVyKGltYWdlRGF0YSkge1xuICAgIHZhciByYWRpdXMgPSBNYXRoLnJvdW5kKHRoaXMuYmx1clJhZGl1cygpKTtcblxuICAgIGlmIChyYWRpdXMgPiAwKSB7XG4gICAgICBmaWx0ZXJHYXVzc0JsdXJSR0JBKGltYWdlRGF0YSwgcmFkaXVzKTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYmx1clJhZGl1cycsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcblxuICAvKipcbiAgICAqIGdldC9zZXQgYmx1ciByYWRpdXMuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkJsdXJ9IGZpbHRlclxuICAgICogQG5hbWUgYmx1clJhZGl1c1xuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJhZGl1c1xuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbn0pKEtvbnZhKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgbWF4LWRlcHRoICovXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgZnVuY3Rpb24gcGl4ZWxBdChpZGF0YSwgeCwgeSkge1xuICAgIHZhciBpZHggPSAoeSAqIGlkYXRhLndpZHRoICsgeCkgKiA0O1xuICAgIHZhciBkID0gW107XG4gICAgZC5wdXNoKFxuICAgICAgaWRhdGEuZGF0YVtpZHgrK10sXG4gICAgICBpZGF0YS5kYXRhW2lkeCsrXSxcbiAgICAgIGlkYXRhLmRhdGFbaWR4KytdLFxuICAgICAgaWRhdGEuZGF0YVtpZHgrK11cbiAgICApO1xuICAgIHJldHVybiBkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmdiRGlzdGFuY2UocDEsIHAyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgIE1hdGgucG93KHAxWzBdIC0gcDJbMF0sIDIpICtcbiAgICAgICAgTWF0aC5wb3cocDFbMV0gLSBwMlsxXSwgMikgK1xuICAgICAgICBNYXRoLnBvdyhwMVsyXSAtIHAyWzJdLCAyKVxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiByZ2JNZWFuKHBUYWIpIHtcbiAgICB2YXIgbSA9IFswLCAwLCAwXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcFRhYi5sZW5ndGg7IGkrKykge1xuICAgICAgbVswXSArPSBwVGFiW2ldWzBdO1xuICAgICAgbVsxXSArPSBwVGFiW2ldWzFdO1xuICAgICAgbVsyXSArPSBwVGFiW2ldWzJdO1xuICAgIH1cblxuICAgIG1bMF0gLz0gcFRhYi5sZW5ndGg7XG4gICAgbVsxXSAvPSBwVGFiLmxlbmd0aDtcbiAgICBtWzJdIC89IHBUYWIubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBmdW5jdGlvbiBiYWNrZ3JvdW5kTWFzayhpZGF0YSwgdGhyZXNob2xkKSB7XG4gICAgdmFyIHJnYnZfbm8gPSBwaXhlbEF0KGlkYXRhLCAwLCAwKTtcbiAgICB2YXIgcmdidl9uZSA9IHBpeGVsQXQoaWRhdGEsIGlkYXRhLndpZHRoIC0gMSwgMCk7XG4gICAgdmFyIHJnYnZfc28gPSBwaXhlbEF0KGlkYXRhLCAwLCBpZGF0YS5oZWlnaHQgLSAxKTtcbiAgICB2YXIgcmdidl9zZSA9IHBpeGVsQXQoaWRhdGEsIGlkYXRhLndpZHRoIC0gMSwgaWRhdGEuaGVpZ2h0IC0gMSk7XG5cbiAgICB2YXIgdGhyZXMgPSB0aHJlc2hvbGQgfHwgMTA7XG4gICAgaWYgKFxuICAgICAgcmdiRGlzdGFuY2Uocmdidl9ubywgcmdidl9uZSkgPCB0aHJlcyAmJlxuICAgICAgcmdiRGlzdGFuY2Uocmdidl9uZSwgcmdidl9zZSkgPCB0aHJlcyAmJlxuICAgICAgcmdiRGlzdGFuY2Uocmdidl9zZSwgcmdidl9zbykgPCB0aHJlcyAmJlxuICAgICAgcmdiRGlzdGFuY2Uocmdidl9zbywgcmdidl9ubykgPCB0aHJlc1xuICAgICkge1xuICAgICAgLy8gTWVhbiBjb2xvclxuICAgICAgdmFyIG1lYW4gPSByZ2JNZWFuKFtyZ2J2X25lLCByZ2J2X25vLCByZ2J2X3NlLCByZ2J2X3NvXSk7XG5cbiAgICAgIC8vIE1hc2sgYmFzZWQgb24gY29sb3IgZGlzdGFuY2VcbiAgICAgIHZhciBtYXNrID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlkYXRhLndpZHRoICogaWRhdGEuaGVpZ2h0OyBpKyspIHtcbiAgICAgICAgdmFyIGQgPSByZ2JEaXN0YW5jZShtZWFuLCBbXG4gICAgICAgICAgaWRhdGEuZGF0YVtpICogNF0sXG4gICAgICAgICAgaWRhdGEuZGF0YVtpICogNCArIDFdLFxuICAgICAgICAgIGlkYXRhLmRhdGFbaSAqIDQgKyAyXVxuICAgICAgICBdKTtcbiAgICAgICAgbWFza1tpXSA9IGQgPCB0aHJlcyA/IDAgOiAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtYXNrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5TWFzayhpZGF0YSwgbWFzaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRhdGEud2lkdGggKiBpZGF0YS5oZWlnaHQ7IGkrKykge1xuICAgICAgaWRhdGEuZGF0YVs0ICogaSArIDNdID0gbWFza1tpXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlcm9kZU1hc2sobWFzaywgc3csIHNoKSB7XG4gICAgdmFyIHdlaWdodHMgPSBbMSwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMV07XG4gICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuICAgIHZhciBoYWxmU2lkZSA9IE1hdGguZmxvb3Ioc2lkZSAvIDIpO1xuXG4gICAgdmFyIG1hc2tSZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNoOyB5KyspIHtcbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc3c7IHgrKykge1xuICAgICAgICB2YXIgc28gPSB5ICogc3cgKyB4O1xuICAgICAgICB2YXIgYSA9IDA7XG4gICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY3ggPSAwOyBjeCA8IHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgIHZhciBzY3kgPSB5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgIHZhciBzY3ggPSB4ICsgY3ggLSBoYWxmU2lkZTtcblxuICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG4gICAgICAgICAgICAgIHZhciBzcmNPZmYgPSBzY3kgKiBzdyArIHNjeDtcbiAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG5cbiAgICAgICAgICAgICAgYSArPSBtYXNrW3NyY09mZl0gKiB3dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtYXNrUmVzdWx0W3NvXSA9IGEgPT09IDI1NSAqIDggPyAyNTUgOiAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXNrUmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZGlsYXRlTWFzayhtYXNrLCBzdywgc2gpIHtcbiAgICB2YXIgd2VpZ2h0cyA9IFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXTtcbiAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG4gICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgZm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgdmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuICAgICAgICAgICAgICB2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICBhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tSZXN1bHRbc29dID0gYSA+PSAyNTUgKiA0ID8gMjU1IDogMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFza1Jlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNtb290aEVkZ2VNYXNrKG1hc2ssIHN3LCBzaCkge1xuICAgIHZhciB3ZWlnaHRzID0gW1xuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5LFxuICAgICAgMSAvIDksXG4gICAgICAxIC8gOSxcbiAgICAgIDEgLyA5XG4gICAgXTtcbiAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG4gICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgICB2YXIgbWFza1Jlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2g7IHkrKykge1xuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBzdzsgeCsrKSB7XG4gICAgICAgIHZhciBzbyA9IHkgKiBzdyArIHg7XG4gICAgICAgIHZhciBhID0gMDtcbiAgICAgICAgZm9yICh2YXIgY3kgPSAwOyBjeSA8IHNpZGU7IGN5KyspIHtcbiAgICAgICAgICBmb3IgKHZhciBjeCA9IDA7IGN4IDwgc2lkZTsgY3grKykge1xuICAgICAgICAgICAgdmFyIHNjeSA9IHkgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgdmFyIHNjeCA9IHggKyBjeCAtIGhhbGZTaWRlO1xuXG4gICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IHNjeSAqIHN3ICsgc2N4O1xuICAgICAgICAgICAgICB2YXIgd3QgPSB3ZWlnaHRzW2N5ICogc2lkZSArIGN4XTtcblxuICAgICAgICAgICAgICBhICs9IG1hc2tbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1hc2tSZXN1bHRbc29dID0gYTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWFza1Jlc3VsdDtcbiAgfVxuXG4gIC8qKlxuXHQgKiBNYXNrIEZpbHRlclxuXHQgKiBAZnVuY3Rpb25cblx0ICogQG5hbWUgTWFza1xuXHQgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuXHQgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG5cdCAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5NYXNrXSk7XG4gICAgICogbm9kZS50aHJlc2hvbGQoMjAwKTtcblx0ICovXG4gIEtvbnZhLkZpbHRlcnMuTWFzayA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIC8vIERldGVjdCBwaXhlbHMgY2xvc2UgdG8gdGhlIGJhY2tncm91bmQgY29sb3JcbiAgICB2YXIgdGhyZXNob2xkID0gdGhpcy50aHJlc2hvbGQoKSxcbiAgICAgIG1hc2sgPSBiYWNrZ3JvdW5kTWFzayhpbWFnZURhdGEsIHRocmVzaG9sZCk7XG4gICAgaWYgKG1hc2spIHtcbiAgICAgIC8vIEVyb2RlXG4gICAgICBtYXNrID0gZXJvZGVNYXNrKG1hc2ssIGltYWdlRGF0YS53aWR0aCwgaW1hZ2VEYXRhLmhlaWdodCk7XG5cbiAgICAgIC8vIERpbGF0ZVxuICAgICAgbWFzayA9IGRpbGF0ZU1hc2sobWFzaywgaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcblxuICAgICAgLy8gR3JhZGllbnRcbiAgICAgIG1hc2sgPSBzbW9vdGhFZGdlTWFzayhtYXNrLCBpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuXG4gICAgICAvLyBBcHBseSBtYXNrXG4gICAgICBhcHBseU1hc2soaW1hZ2VEYXRhLCBtYXNrKTtcblxuICAgICAgLy8gdG9kbyA6IFVwZGF0ZSBoaXQgcmVnaW9uIGZ1bmN0aW9uIGFjY29yZGluZyB0byBtYXNrXG4gICAgfVxuXG4gICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICd0aHJlc2hvbGQnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogUkdCIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQlxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JdKTtcbiAgICAgKiBub2RlLmJsdWUoMTIwKTtcbiAgICAgKiBub2RlLmdyZWVuKDIwMCk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuUkdCID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgIHJlZCA9IHRoaXMucmVkKCksXG4gICAgICBncmVlbiA9IHRoaXMuZ3JlZW4oKSxcbiAgICAgIGJsdWUgPSB0aGlzLmJsdWUoKSxcbiAgICAgIGksXG4gICAgICBicmlnaHRuZXNzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgYnJpZ2h0bmVzcyA9XG4gICAgICAgICgwLjM0ICogZGF0YVtpXSArIDAuNSAqIGRhdGFbaSArIDFdICsgMC4xNiAqIGRhdGFbaSArIDJdKSAvIDI1NTtcbiAgICAgIGRhdGFbaV0gPSBicmlnaHRuZXNzICogcmVkOyAvLyByXG4gICAgICBkYXRhW2kgKyAxXSA9IGJyaWdodG5lc3MgKiBncmVlbjsgLy8gZ1xuICAgICAgZGF0YVtpICsgMl0gPSBicmlnaHRuZXNzICogYmx1ZTsgLy8gYlxuICAgICAgZGF0YVtpICsgM10gPSBkYXRhW2kgKyAzXTsgLy8gYWxwaGFcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ3JlZCcsIDAsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgcmV0dXJuIDI1NTtcbiAgICB9IGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgcmVkIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICAqIEBuYW1lIHJlZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IHJlZCB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZ3JlZW4nLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIGdyZWVuIHZhbHVlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5SR0J9IGZpbHRlci5cbiAgICAqIEBuYW1lIGdyZWVuXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZ3JlZW4gdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYmx1ZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBibHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gYmx1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDI1NVxuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBSR0JBIEZpbHRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFJHQkFcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAYXV0aG9yIGNvZGVmb1xuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5SR0JBXSk7XG4gICAgICogbm9kZS5ibHVlKDEyMCk7XG4gICAgICogbm9kZS5ncmVlbigyMDApO1xuICAgICAqIG5vZGUuYWxwaGEoMC4zKTtcbiAgICAgKi9cbiAgS29udmEuRmlsdGVycy5SR0JBID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgIHJlZCA9IHRoaXMucmVkKCksXG4gICAgICBncmVlbiA9IHRoaXMuZ3JlZW4oKSxcbiAgICAgIGJsdWUgPSB0aGlzLmJsdWUoKSxcbiAgICAgIGFscGhhID0gdGhpcy5hbHBoYSgpLFxuICAgICAgaSxcbiAgICAgIGlhO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgaWEgPSAxIC0gYWxwaGE7XG5cbiAgICAgIGRhdGFbaV0gPSByZWQgKiBhbHBoYSArIGRhdGFbaV0gKiBpYTsgLy8gclxuICAgICAgZGF0YVtpICsgMV0gPSBncmVlbiAqIGFscGhhICsgZGF0YVtpICsgMV0gKiBpYTsgLy8gZ1xuICAgICAgZGF0YVtpICsgMl0gPSBibHVlICogYWxwaGEgKyBkYXRhW2kgKyAyXSAqIGlhOyAvLyBiXG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdyZWQnLCAwLCBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9maWx0ZXJVcFRvRGF0ZSA9IGZhbHNlO1xuICAgIGlmICh2YWwgPiAyNTUpIHtcbiAgICAgIHJldHVybiAyNTU7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICAqIGdldC9zZXQgZmlsdGVyIHJlZCB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgcmVkXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcmVkIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1XG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdncmVlbicsIDAsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMuX2ZpbHRlclVwVG9EYXRlID0gZmFsc2U7XG4gICAgaWYgKHZhbCA+IDI1NSkge1xuICAgICAgcmV0dXJuIDI1NTtcbiAgICB9IGVsc2UgaWYgKHZhbCA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwpO1xuICAgIH1cbiAgfSk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgZ3JlZW4gdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLlJHQkF9IGZpbHRlci5cbiAgICAqIEBuYW1lIGdyZWVuXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZ3JlZW4gdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnYmx1ZScsXG4gICAgMCxcbiAgICBLb252YS5WYWxpZGF0b3JzLlJHQkNvbXBvbmVudCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBmaWx0ZXIgYmx1ZSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICogQG5hbWUgYmx1ZVxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0ludGVnZXJ9IGJsdWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAyNTVcbiAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2FscGhhJywgMSwgZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fZmlsdGVyVXBUb0RhdGUgPSBmYWxzZTtcbiAgICBpZiAodmFsID4gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh2YWwgPCAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGZpbHRlciBhbHBoYSB2YWx1ZS4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUkdCQX0gZmlsdGVyLlxuICAgICAqIEBuYW1lIGFscGhhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7RmxvYXR9IGFscGhhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAqIEhTViBGaWx0ZXIuIEFkanVzdHMgdGhlIGh1ZSwgc2F0dXJhdGlvbiBhbmQgdmFsdWVcbiAgICAqIEBmdW5jdGlvblxuICAgICogQG5hbWUgSFNWXG4gICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICogQGF1dGhvciBpcHBvNjE1XG4gICAgKiBAZXhhbXBsZVxuICAgICogaW1hZ2UuZmlsdGVycyhbS29udmEuRmlsdGVycy5IU1ZdKTtcbiAgICAqIGltYWdlLnZhbHVlKDIwMCk7XG4gICAgKi9cblxuICBLb252YS5GaWx0ZXJzLkhTViA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICB2ID0gTWF0aC5wb3coMiwgdGhpcy52YWx1ZSgpKSxcbiAgICAgIHMgPSBNYXRoLnBvdygyLCB0aGlzLnNhdHVyYXRpb24oKSksXG4gICAgICBoID0gTWF0aC5hYnModGhpcy5odWUoKSArIDM2MCkgJSAzNjAsXG4gICAgICBpO1xuXG4gICAgLy8gQmFzaXMgZm9yIHRoZSB0ZWNobmlxdWUgdXNlZDpcbiAgICAvLyBodHRwOi8vYmVlc2J1enouYml6L2NvZGUvaHN2X2NvbG9yX3RyYW5zZm9ybXMucGhwXG4gICAgLy8gViBpcyB0aGUgdmFsdWUgbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgLy8gUyBpcyB0aGUgc2F0dXJhdGlvbiBtdWx0aXBsaWVyICgxIGZvciBub25lLCAyIGZvciBkb3VibGUsIDAuNSBmb3IgaGFsZilcbiAgICAvLyBIIGlzIHRoZSBodWUgc2hpZnQgaW4gZGVncmVlcyAoMCB0byAzNjApXG4gICAgLy8gdnN1ID0gVipTKmNvcyhIKlBJLzE4MCk7XG4gICAgLy8gdnN3ID0gVipTKnNpbihIKlBJLzE4MCk7XG4gICAgLy9bIC4yOTlWKy43MDF2c3UrLjE2OHZzdyAgICAuNTg3Vi0uNTg3dnN1Ky4zMzB2c3cgICAgLjExNFYtLjExNHZzdS0uNDk3dnN3IF0gW1JdXG4gICAgLy9bIC4yOTlWLS4yOTl2c3UtLjMyOHZzdyAgICAuNTg3VisuNDEzdnN1Ky4wMzV2c3cgICAgLjExNFYtLjExNHZzdSsuMjkydnN3IF0qW0ddXG4gICAgLy9bIC4yOTlWLS4zMDB2c3UrMS4yNXZzdyAgICAuNTg3Vi0uNTg4dnN1LTEuMDV2c3cgICAgLjExNFYrLjg4NnZzdS0uMjAzdnN3IF0gW0JdXG5cbiAgICAvLyBQcmVjb21wdXRlIHRoZSB2YWx1ZXMgaW4gdGhlIG1hdHJpeDpcbiAgICB2YXIgdnN1ID0gdiAqIHMgKiBNYXRoLmNvcyhoICogTWF0aC5QSSAvIDE4MCksXG4gICAgICB2c3cgPSB2ICogcyAqIE1hdGguc2luKGggKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAvLyAocmVzdWx0IHNwb3QpKHNvdXJjZSBzcG90KVxuICAgIHZhciByciA9IDAuMjk5ICogdiArIDAuNzAxICogdnN1ICsgMC4xNjcgKiB2c3csXG4gICAgICByZyA9IDAuNTg3ICogdiAtIDAuNTg3ICogdnN1ICsgMC4zMzAgKiB2c3csXG4gICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgdmFyIGdyID0gMC4yOTkgKiB2IC0gMC4yOTkgKiB2c3UgLSAwLjMyOCAqIHZzdyxcbiAgICAgIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdyxcbiAgICAgIGdiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgKyAwLjI5MyAqIHZzdztcbiAgICB2YXIgYnIgPSAwLjI5OSAqIHYgLSAwLjMwMCAqIHZzdSArIDEuMjUwICogdnN3LFxuICAgICAgYmcgPSAwLjU4NyAqIHYgLSAwLjU4NiAqIHZzdSAtIDEuMDUwICogdnN3LFxuICAgICAgYmIgPSAwLjExNCAqIHYgKyAwLjg4NiAqIHZzdSAtIDAuMjAwICogdnN3O1xuXG4gICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgIGRhdGFbaSArIDBdID0gcnIgKiByICsgcmcgKiBnICsgcmIgKiBiO1xuICAgICAgZGF0YVtpICsgMV0gPSBnciAqIHIgKyBnZyAqIGcgKyBnYiAqIGI7XG4gICAgICBkYXRhW2kgKyAyXSA9IGJyICogciArIGJnICogZyArIGJiICogYjtcbiAgICAgIGRhdGFbaSArIDNdID0gYTsgLy8gYWxwaGFcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnaHVlJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgICogQG5hbWUgaHVlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBodWUgdmFsdWUgYmV0d2VlbiAwIGFuZCAzNTlcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdzYXR1cmF0aW9uJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgaHN2IHNhdHVyYXRpb24uIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gb3Ige0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNMfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBzYXR1cmF0aW9uXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBzYXR1cmF0aW9uIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgc2F0dXJhdGlvbiwgMS4wIGRvdWJsZXMsIGV0Yy4uXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAndmFsdWUnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBoc3YgdmFsdWUuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTVn0gZmlsdGVyLlxuICAgICogQG5hbWUgdmFsdWVcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIDAgaXMgbm8gY2hhbmdlLCAtMS4wIGhhbHZlcyB0aGUgdmFsdWUsIDEuMCBkb3VibGVzLCBldGMuLlxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2h1ZScsXG4gICAgMCxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgaHN2IGh1ZSBpbiBkZWdyZWVzLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5IU1Z9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgKiBAbmFtZSBodWVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGh1ZSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDM1OVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdzYXR1cmF0aW9uJyxcbiAgICAwLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBoc3Ygc2F0dXJhdGlvbi4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuSFNWfSBvciB7QGxpbmsgS29udmEuRmlsdGVycy5IU0x9IGZpbHRlci5cbiAgICogQG5hbWUgc2F0dXJhdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gc2F0dXJhdGlvbiAwIGlzIG5vIGNoYW5nZSwgLTEuMCBoYWx2ZXMgdGhlIHNhdHVyYXRpb24sIDEuMCBkb3VibGVzLCBldGMuLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdsdW1pbmFuY2UnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGhzbCBsdW1pbmFuY2UuIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkhTTH0gZmlsdGVyLlxuICAgKiBAbmFtZSB2YWx1ZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgZnJvbSAtMSB0byAxXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBIU0wgRmlsdGVyLiBBZGp1c3RzIHRoZSBodWUsIHNhdHVyYXRpb24gYW5kIGx1bWluYW5jZSAob3IgbGlnaHRuZXNzKVxuICAgKiBAZnVuY3Rpb25cbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogaW1hZ2UuZmlsdGVycyhbS29udmEuRmlsdGVycy5IU0xdKTtcbiAgICogaW1hZ2UubHVtaW5hbmNlKDIwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuSFNMID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIG5QaXhlbHMgPSBkYXRhLmxlbmd0aCxcbiAgICAgIHYgPSAxLFxuICAgICAgcyA9IE1hdGgucG93KDIsIHRoaXMuc2F0dXJhdGlvbigpKSxcbiAgICAgIGggPSBNYXRoLmFicyh0aGlzLmh1ZSgpICsgMzYwKSAlIDM2MCxcbiAgICAgIGwgPSB0aGlzLmx1bWluYW5jZSgpICogMTI3LFxuICAgICAgaTtcblxuICAgIC8vIEJhc2lzIGZvciB0aGUgdGVjaG5pcXVlIHVzZWQ6XG4gICAgLy8gaHR0cDovL2JlZXNidXp6LmJpei9jb2RlL2hzdl9jb2xvcl90cmFuc2Zvcm1zLnBocFxuICAgIC8vIFYgaXMgdGhlIHZhbHVlIG11bHRpcGxpZXIgKDEgZm9yIG5vbmUsIDIgZm9yIGRvdWJsZSwgMC41IGZvciBoYWxmKVxuICAgIC8vIFMgaXMgdGhlIHNhdHVyYXRpb24gbXVsdGlwbGllciAoMSBmb3Igbm9uZSwgMiBmb3IgZG91YmxlLCAwLjUgZm9yIGhhbGYpXG4gICAgLy8gSCBpcyB0aGUgaHVlIHNoaWZ0IGluIGRlZ3JlZXMgKDAgdG8gMzYwKVxuICAgIC8vIHZzdSA9IFYqUypjb3MoSCpQSS8xODApO1xuICAgIC8vIHZzdyA9IFYqUypzaW4oSCpQSS8xODApO1xuICAgIC8vWyAuMjk5VisuNzAxdnN1Ky4xNjh2c3cgICAgLjU4N1YtLjU4N3ZzdSsuMzMwdnN3ICAgIC4xMTRWLS4xMTR2c3UtLjQ5N3ZzdyBdIFtSXVxuICAgIC8vWyAuMjk5Vi0uMjk5dnN1LS4zMjh2c3cgICAgLjU4N1YrLjQxM3ZzdSsuMDM1dnN3ICAgIC4xMTRWLS4xMTR2c3UrLjI5MnZzdyBdKltHXVxuICAgIC8vWyAuMjk5Vi0uMzAwdnN1KzEuMjV2c3cgICAgLjU4N1YtLjU4OHZzdS0xLjA1dnN3ICAgIC4xMTRWKy44ODZ2c3UtLjIwM3ZzdyBdIFtCXVxuXG4gICAgLy8gUHJlY29tcHV0ZSB0aGUgdmFsdWVzIGluIHRoZSBtYXRyaXg6XG4gICAgdmFyIHZzdSA9IHYgKiBzICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApLFxuICAgICAgdnN3ID0gdiAqIHMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgLy8gKHJlc3VsdCBzcG90KShzb3VyY2Ugc3BvdClcbiAgICB2YXIgcnIgPSAwLjI5OSAqIHYgKyAwLjcwMSAqIHZzdSArIDAuMTY3ICogdnN3LFxuICAgICAgcmcgPSAwLjU4NyAqIHYgLSAwLjU4NyAqIHZzdSArIDAuMzMgKiB2c3csXG4gICAgICByYiA9IDAuMTE0ICogdiAtIDAuMTE0ICogdnN1IC0gMC40OTcgKiB2c3c7XG4gICAgdmFyIGdyID0gMC4yOTkgKiB2IC0gMC4yOTkgKiB2c3UgLSAwLjMyOCAqIHZzdyxcbiAgICAgIGdnID0gMC41ODcgKiB2ICsgMC40MTMgKiB2c3UgKyAwLjAzNSAqIHZzdyxcbiAgICAgIGdiID0gMC4xMTQgKiB2IC0gMC4xMTQgKiB2c3UgKyAwLjI5MyAqIHZzdztcbiAgICB2YXIgYnIgPSAwLjI5OSAqIHYgLSAwLjMgKiB2c3UgKyAxLjI1ICogdnN3LFxuICAgICAgYmcgPSAwLjU4NyAqIHYgLSAwLjU4NiAqIHZzdSAtIDEuMDUgKiB2c3csXG4gICAgICBiYiA9IDAuMTE0ICogdiArIDAuODg2ICogdnN1IC0gMC4yICogdnN3O1xuXG4gICAgdmFyIHIsIGcsIGIsIGE7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgblBpeGVsczsgaSArPSA0KSB7XG4gICAgICByID0gZGF0YVtpICsgMF07XG4gICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICBiID0gZGF0YVtpICsgMl07XG4gICAgICBhID0gZGF0YVtpICsgM107XG5cbiAgICAgIGRhdGFbaSArIDBdID0gcnIgKiByICsgcmcgKiBnICsgcmIgKiBiICsgbDtcbiAgICAgIGRhdGFbaSArIDFdID0gZ3IgKiByICsgZ2cgKiBnICsgZ2IgKiBiICsgbDtcbiAgICAgIGRhdGFbaSArIDJdID0gYnIgKiByICsgYmcgKiBnICsgYmIgKiBiICsgbDtcbiAgICAgIGRhdGFbaSArIDNdID0gYTsgLy8gYWxwaGFcbiAgICB9XG4gIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogRW1ib3NzIEZpbHRlci5cbiAgICAgKiBQaXhhc3RpYyBMaWIgLSBFbWJvc3MgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW1ib3NzXSk7XG4gICAgICogbm9kZS5lbWJvc3NTdHJlbmd0aCgwLjgpO1xuICAgICAqIG5vZGUuZW1ib3NzV2hpdGVMZXZlbCgwLjMpO1xuICAgICAqIG5vZGUuZW1ib3NzRGlyZWN0aW9uKCdyaWdodCcpO1xuICAgICAqIG5vZGUuZW1ib3NzQmxlbmQodHJ1ZSk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuRW1ib3NzID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgLy8gcGl4YXN0aWMgc3RyZW5ndGggaXMgYmV0d2VlbiAwIGFuZCAxMC4gIEkgd2FudCBpdCBiZXR3ZWVuIDAgYW5kIDFcbiAgICAvLyBwaXhhc3RpYyBncmV5TGV2ZWwgaXMgYmV0d2VlbiAwIGFuZCAyNTUuICBJIHdhbnQgaXQgYmV0d2VlbiAwIGFuZCAxLiAgQWxzbyxcbiAgICAvLyBhIG1heCB2YWx1ZSBvZiBncmV5TGV2ZWwgeWllbGRzIGEgd2hpdGUgZW1ib3NzLCBhbmQgdGhlIG1pbiB2YWx1ZSB5aWVsZHMgYSBibGFja1xuICAgIC8vIGVtYm9zcy4gIFRoZXJlZm9yZSwgSSBjaGFuZ2VkIGdyZXlMZXZlbCB0byB3aGl0ZUxldmVsXG4gICAgdmFyIHN0cmVuZ3RoID0gdGhpcy5lbWJvc3NTdHJlbmd0aCgpICogMTAsXG4gICAgICBncmV5TGV2ZWwgPSB0aGlzLmVtYm9zc1doaXRlTGV2ZWwoKSAqIDI1NSxcbiAgICAgIGRpcmVjdGlvbiA9IHRoaXMuZW1ib3NzRGlyZWN0aW9uKCksXG4gICAgICBibGVuZCA9IHRoaXMuZW1ib3NzQmxlbmQoKSxcbiAgICAgIGRpclkgPSAwLFxuICAgICAgZGlyWCA9IDAsXG4gICAgICBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICB3ID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaCA9IGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICB3NCA9IHcgKiA0LFxuICAgICAgeSA9IGg7XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgY2FzZSAndG9wLWxlZnQnOlxuICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgIGRpclggPSAtMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3AnOlxuICAgICAgICBkaXJZID0gLTE7XG4gICAgICAgIGRpclggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcC1yaWdodCc6XG4gICAgICAgIGRpclkgPSAtMTtcbiAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICBkaXJZID0gMDtcbiAgICAgICAgZGlyWCA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYm90dG9tLXJpZ2h0JzpcbiAgICAgICAgZGlyWSA9IDE7XG4gICAgICAgIGRpclggPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgIGRpclkgPSAxO1xuICAgICAgICBkaXJYID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgIGRpclkgPSAxO1xuICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgIGRpclkgPSAwO1xuICAgICAgICBkaXJYID0gLTE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgS29udmEuVXRpbC5lcnJvcignVW5rbm93biBlbWJvc3MgZGlyZWN0aW9uOiAnICsgZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICB2YXIgb2Zmc2V0WSA9ICh5IC0gMSkgKiB3NDtcblxuICAgICAgdmFyIG90aGVyWSA9IGRpclk7XG4gICAgICBpZiAoeSArIG90aGVyWSA8IDEpIHtcbiAgICAgICAgb3RoZXJZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh5ICsgb3RoZXJZID4gaCkge1xuICAgICAgICBvdGhlclkgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2Zmc2V0WU90aGVyID0gKHkgLSAxICsgb3RoZXJZKSAqIHcgKiA0O1xuXG4gICAgICB2YXIgeCA9IHc7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXRZICsgKHggLSAxKSAqIDQ7XG5cbiAgICAgICAgdmFyIG90aGVyWCA9IGRpclg7XG4gICAgICAgIGlmICh4ICsgb3RoZXJYIDwgMSkge1xuICAgICAgICAgIG90aGVyWCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggKyBvdGhlclggPiB3KSB7XG4gICAgICAgICAgb3RoZXJYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXRPdGhlciA9IG9mZnNldFlPdGhlciArICh4IC0gMSArIG90aGVyWCkgKiA0O1xuXG4gICAgICAgIHZhciBkUiA9IGRhdGFbb2Zmc2V0XSAtIGRhdGFbb2Zmc2V0T3RoZXJdO1xuICAgICAgICB2YXIgZEcgPSBkYXRhW29mZnNldCArIDFdIC0gZGF0YVtvZmZzZXRPdGhlciArIDFdO1xuICAgICAgICB2YXIgZEIgPSBkYXRhW29mZnNldCArIDJdIC0gZGF0YVtvZmZzZXRPdGhlciArIDJdO1xuXG4gICAgICAgIHZhciBkaWYgPSBkUjtcbiAgICAgICAgdmFyIGFic0RpZiA9IGRpZiA+IDAgPyBkaWYgOiAtZGlmO1xuXG4gICAgICAgIHZhciBhYnNHID0gZEcgPiAwID8gZEcgOiAtZEc7XG4gICAgICAgIHZhciBhYnNCID0gZEIgPiAwID8gZEIgOiAtZEI7XG5cbiAgICAgICAgaWYgKGFic0cgPiBhYnNEaWYpIHtcbiAgICAgICAgICBkaWYgPSBkRztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWJzQiA+IGFic0RpZikge1xuICAgICAgICAgIGRpZiA9IGRCO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlmICo9IHN0cmVuZ3RoO1xuXG4gICAgICAgIGlmIChibGVuZCkge1xuICAgICAgICAgIHZhciByID0gZGF0YVtvZmZzZXRdICsgZGlmO1xuICAgICAgICAgIHZhciBnID0gZGF0YVtvZmZzZXQgKyAxXSArIGRpZjtcbiAgICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl0gKyBkaWY7XG5cbiAgICAgICAgICBkYXRhW29mZnNldF0gPSByID4gMjU1ID8gMjU1IDogciA8IDAgPyAwIDogcjtcbiAgICAgICAgICBkYXRhW29mZnNldCArIDFdID0gZyA+IDI1NSA/IDI1NSA6IGcgPCAwID8gMCA6IGc7XG4gICAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGIgPiAyNTUgPyAyNTUgOiBiIDwgMCA/IDAgOiBiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBncmV5ID0gZ3JleUxldmVsIC0gZGlmO1xuICAgICAgICAgIGlmIChncmV5IDwgMCkge1xuICAgICAgICAgICAgZ3JleSA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChncmV5ID4gMjU1KSB7XG4gICAgICAgICAgICBncmV5ID0gMjU1O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFbb2Zmc2V0XSA9IGRhdGFbb2Zmc2V0ICsgMV0gPSBkYXRhW29mZnNldCArIDJdID0gZ3JleTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS14KTtcbiAgICB9IHdoaWxlICgtLXkpO1xuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VtYm9zc1N0cmVuZ3RoJyxcbiAgICAwLjUsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3Mgc3RyZW5ndGguIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkVtYm9zc30gZmlsdGVyLlxuICAgICogQG5hbWUgZW1ib3NzU3RyZW5ndGhcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMS4gIERlZmF1bHQgaXMgMC41XG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnZW1ib3NzV2hpdGVMZXZlbCcsXG4gICAgMC41LFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICAqIGdldC9zZXQgZW1ib3NzIHdoaXRlIGxldmVsLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVtYm9zc1doaXRlTGV2ZWxcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGVtYm9zc1doaXRlTGV2ZWwgYmV0d2VlbiAwIGFuZCAxLiAgRGVmYXVsdCBpcyAwLjVcbiAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdlbWJvc3NEaXJlY3Rpb24nLFxuICAgICd0b3AtbGVmdCcsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG4gIC8qKlxuICAgICogZ2V0L3NldCBlbWJvc3MgZGlyZWN0aW9uLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbWJvc3N9IGZpbHRlci5cbiAgICAqIEBuYW1lIGVtYm9zc0RpcmVjdGlvblxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gZW1ib3NzRGlyZWN0aW9uIGNhbiBiZSB0b3AtbGVmdCwgdG9wLCB0b3AtcmlnaHQsIHJpZ2h0LCBib3R0b20tcmlnaHQsIGJvdHRvbSwgYm90dG9tLWxlZnQgb3IgbGVmdFxuICAgICogICBUaGUgZGVmYXVsdCBpcyB0b3AtbGVmdFxuICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VtYm9zc0JsZW5kJyxcbiAgICBmYWxzZSxcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcbiAgLyoqXG4gICAgKiBnZXQvc2V0IGVtYm9zcyBibGVuZC4gVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuRW1ib3NzfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBlbWJvc3NCbGVuZFxuICAgICogQG1ldGhvZFxuICAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVtYm9zc0JsZW5kXG4gICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIGZ1bmN0aW9uIHJlbWFwKGZyb21WYWx1ZSwgZnJvbU1pbiwgZnJvbU1heCwgdG9NaW4sIHRvTWF4KSB7XG4gICAgLy8gQ29tcHV0ZSB0aGUgcmFuZ2Ugb2YgdGhlIGRhdGFcbiAgICB2YXIgZnJvbVJhbmdlID0gZnJvbU1heCAtIGZyb21NaW4sXG4gICAgICB0b1JhbmdlID0gdG9NYXggLSB0b01pbixcbiAgICAgIHRvVmFsdWU7XG5cbiAgICAvLyBJZiBlaXRoZXIgcmFuZ2UgaXMgMCwgdGhlbiB0aGUgdmFsdWUgY2FuIG9ubHkgYmUgbWFwcGVkIHRvIDEgdmFsdWVcbiAgICBpZiAoZnJvbVJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm4gdG9NaW4gKyB0b1JhbmdlIC8gMjtcbiAgICB9XG4gICAgaWYgKHRvUmFuZ2UgPT09IDApIHtcbiAgICAgIHJldHVybiB0b01pbjtcbiAgICB9XG5cbiAgICAvLyAoMSkgdW50cmFuc2xhdGUsICgyKSB1bnNjYWxlLCAoMykgcmVzY2FsZSwgKDQpIHJldHJhbnNsYXRlXG4gICAgdG9WYWx1ZSA9IChmcm9tVmFsdWUgLSBmcm9tTWluKSAvIGZyb21SYW5nZTtcbiAgICB0b1ZhbHVlID0gdG9SYW5nZSAqIHRvVmFsdWUgKyB0b01pbjtcblxuICAgIHJldHVybiB0b1ZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuaGFuY2UgRmlsdGVyLiBBZGp1c3RzIHRoZSBjb2xvcnMgc28gdGhhdCB0aGV5IHNwYW4gdGhlIHdpZGVzdFxuICAgKiAgcG9zc2libGUgcmFuZ2UgKGllIDAtMjU1KS4gUGVyZm9ybXMgdypoIHBpeGVsIHJlYWRzIGFuZCB3KmggcGl4ZWxcbiAgICogIHdyaXRlcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIEVuaGFuY2VcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuRW5oYW5jZV0pO1xuICAgKiBub2RlLmVuaGFuY2UoMC40KTtcbiAgICovXG4gIEtvbnZhLkZpbHRlcnMuRW5oYW5jZSA9IGZ1bmN0aW9uKGltYWdlRGF0YSkge1xuICAgIHZhciBkYXRhID0gaW1hZ2VEYXRhLmRhdGEsXG4gICAgICBuU3ViUGl4ZWxzID0gZGF0YS5sZW5ndGgsXG4gICAgICByTWluID0gZGF0YVswXSxcbiAgICAgIHJNYXggPSByTWluLFxuICAgICAgcixcbiAgICAgIGdNaW4gPSBkYXRhWzFdLFxuICAgICAgZ01heCA9IGdNaW4sXG4gICAgICBnLFxuICAgICAgYk1pbiA9IGRhdGFbMl0sXG4gICAgICBiTWF4ID0gYk1pbixcbiAgICAgIGIsXG4gICAgICBpO1xuXG4gICAgLy8gSWYgd2UgYXJlIG5vdCBlbmhhbmNpbmcgYW55dGhpbmcgLSBkb24ndCBkbyBhbnkgY29tcHV0YXRpb25cbiAgICB2YXIgZW5oYW5jZUFtb3VudCA9IHRoaXMuZW5oYW5jZSgpO1xuICAgIGlmIChlbmhhbmNlQW1vdW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gMXN0IFBhc3MgLSBmaW5kIHRoZSBtaW4gYW5kIG1heCBmb3IgZWFjaCBjaGFubmVsOlxuICAgIGZvciAoaSA9IDA7IGkgPCBuU3ViUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHIgPSBkYXRhW2kgKyAwXTtcbiAgICAgIGlmIChyIDwgck1pbikge1xuICAgICAgICByTWluID0gcjtcbiAgICAgIH0gZWxzZSBpZiAociA+IHJNYXgpIHtcbiAgICAgICAgck1heCA9IHI7XG4gICAgICB9XG4gICAgICBnID0gZGF0YVtpICsgMV07XG4gICAgICBpZiAoZyA8IGdNaW4pIHtcbiAgICAgICAgZ01pbiA9IGc7XG4gICAgICB9IGVsc2UgaWYgKGcgPiBnTWF4KSB7XG4gICAgICAgIGdNYXggPSBnO1xuICAgICAgfVxuICAgICAgYiA9IGRhdGFbaSArIDJdO1xuICAgICAgaWYgKGIgPCBiTWluKSB7XG4gICAgICAgIGJNaW4gPSBiO1xuICAgICAgfSBlbHNlIGlmIChiID4gYk1heCkge1xuICAgICAgICBiTWF4ID0gYjtcbiAgICAgIH1cbiAgICAgIC8vYSA9IGRhdGFbaSArIDNdO1xuICAgICAgLy9pZiAoYSA8IGFNaW4pIHsgYU1pbiA9IGE7IH0gZWxzZVxuICAgICAgLy9pZiAoYSA+IGFNYXgpIHsgYU1heCA9IGE7IH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IDEgbGV2ZWwgLSBkb24ndCByZW1hcFxuICAgIGlmIChyTWF4ID09PSByTWluKSB7XG4gICAgICByTWF4ID0gMjU1O1xuICAgICAgck1pbiA9IDA7XG4gICAgfVxuICAgIGlmIChnTWF4ID09PSBnTWluKSB7XG4gICAgICBnTWF4ID0gMjU1O1xuICAgICAgZ01pbiA9IDA7XG4gICAgfVxuICAgIGlmIChiTWF4ID09PSBiTWluKSB7XG4gICAgICBiTWF4ID0gMjU1O1xuICAgICAgYk1pbiA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHJNaWQsXG4gICAgICByR29hbE1heCxcbiAgICAgIHJHb2FsTWluLFxuICAgICAgZ01pZCxcbiAgICAgIGdHb2FsTWF4LFxuICAgICAgZ0dvYWxNaW4sXG4gICAgICBiTWlkLFxuICAgICAgYkdvYWxNYXgsXG4gICAgICBiR29hbE1pbjtcblxuICAgIC8vIElmIHRoZSBlbmhhbmNlbWVudCBpcyBwb3NpdGl2ZSAtIHN0cmV0Y2ggdGhlIGhpc3RvZ3JhbVxuICAgIGlmIChlbmhhbmNlQW1vdW50ID4gMCkge1xuICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSByTWF4KTtcbiAgICAgIHJHb2FsTWluID0gck1pbiAtIGVuaGFuY2VBbW91bnQgKiAock1pbiAtIDApO1xuICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBnTWF4KTtcbiAgICAgIGdHb2FsTWluID0gZ01pbiAtIGVuaGFuY2VBbW91bnQgKiAoZ01pbiAtIDApO1xuICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqICgyNTUgLSBiTWF4KTtcbiAgICAgIGJHb2FsTWluID0gYk1pbiAtIGVuaGFuY2VBbW91bnQgKiAoYk1pbiAtIDApO1xuICAgICAgLy8gSWYgdGhlIGVuaGFuY2VtZW50IGlzIG5lZ2F0aXZlIC0gICBjb21wcmVzcyB0aGUgaGlzdG9ncmFtXG4gICAgfSBlbHNlIHtcbiAgICAgIHJNaWQgPSAock1heCArIHJNaW4pICogMC41O1xuICAgICAgckdvYWxNYXggPSByTWF4ICsgZW5oYW5jZUFtb3VudCAqIChyTWF4IC0gck1pZCk7XG4gICAgICByR29hbE1pbiA9IHJNaW4gKyBlbmhhbmNlQW1vdW50ICogKHJNaW4gLSByTWlkKTtcbiAgICAgIGdNaWQgPSAoZ01heCArIGdNaW4pICogMC41O1xuICAgICAgZ0dvYWxNYXggPSBnTWF4ICsgZW5oYW5jZUFtb3VudCAqIChnTWF4IC0gZ01pZCk7XG4gICAgICBnR29hbE1pbiA9IGdNaW4gKyBlbmhhbmNlQW1vdW50ICogKGdNaW4gLSBnTWlkKTtcbiAgICAgIGJNaWQgPSAoYk1heCArIGJNaW4pICogMC41O1xuICAgICAgYkdvYWxNYXggPSBiTWF4ICsgZW5oYW5jZUFtb3VudCAqIChiTWF4IC0gYk1pZCk7XG4gICAgICBiR29hbE1pbiA9IGJNaW4gKyBlbmhhbmNlQW1vdW50ICogKGJNaW4gLSBiTWlkKTtcbiAgICB9XG5cbiAgICAvLyBQYXNzIDIgLSByZW1hcCBldmVyeXRoaW5nLCBleGNlcHQgdGhlIGFscGhhXG4gICAgZm9yIChpID0gMDsgaSA8IG5TdWJQaXhlbHM7IGkgKz0gNCkge1xuICAgICAgZGF0YVtpICsgMF0gPSByZW1hcChkYXRhW2kgKyAwXSwgck1pbiwgck1heCwgckdvYWxNaW4sIHJHb2FsTWF4KTtcbiAgICAgIGRhdGFbaSArIDFdID0gcmVtYXAoZGF0YVtpICsgMV0sIGdNaW4sIGdNYXgsIGdHb2FsTWluLCBnR29hbE1heCk7XG4gICAgICBkYXRhW2kgKyAyXSA9IHJlbWFwKGRhdGFbaSArIDJdLCBiTWluLCBiTWF4LCBiR29hbE1pbiwgYkdvYWxNYXgpO1xuICAgICAgLy9kYXRhW2kgKyAzXSA9IHJlbWFwKGRhdGFbaSArIDNdLCBhTWluLCBhTWF4LCBhR29hbE1pbiwgYUdvYWxNYXgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0L3NldCBlbmhhbmNlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5FbmhhbmNlfSBmaWx0ZXIuIC0xIHRvIDEgdmFsdWVzXG4gICAqIEBuYW1lIGVuaGFuY2VcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGbG9hdH0gYW1vdW50XG4gICAqIEByZXR1cm5zIHtGbG9hdH1cbiAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ2VuaGFuY2UnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogUG9zdGVyaXplIEZpbHRlci4gQWRqdXN0cyB0aGUgY2hhbm5lbHMgc28gdGhhdCB0aGVyZSBhcmUgbm8gbW9yZVxuICAgICAqICB0aGFuIG4gZGlmZmVyZW50IHZhbHVlcyBmb3IgdGhhdCBjaGFubmVsLiBUaGlzIGlzIGFsc28gYXBwbGllZFxuICAgICAqICB0byB0aGUgYWxwaGEgY2hhbm5lbC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBQb3N0ZXJpemVcbiAgICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIG5vZGUuY2FjaGUoKTtcbiAgICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUG9zdGVyaXplXSk7XG4gICAgICogbm9kZS5sZXZlbHMoMC44KTsgLy8gYmV0d2VlbiAwIGFuZCAxXG4gICAgICovXG5cbiAgS29udmEuRmlsdGVycy5Qb3N0ZXJpemUgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICAvLyBsZXZlbCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMjU1XG4gICAgdmFyIGxldmVscyA9IE1hdGgucm91bmQodGhpcy5sZXZlbHMoKSAqIDI1NCkgKyAxLFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgbGVuID0gZGF0YS5sZW5ndGgsXG4gICAgICBzY2FsZSA9IDI1NSAvIGxldmVscyxcbiAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGRhdGFbaV0gPSBNYXRoLmZsb29yKGRhdGFbaV0gLyBzY2FsZSkgKiBzY2FsZTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAnbGV2ZWxzJyxcbiAgICAwLjUsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG5cbiAgLyoqXG4gICAgKiBnZXQvc2V0IGxldmVscy4gIE11c3QgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLiAgVXNlIHdpdGgge0BsaW5rIEtvbnZhLkZpbHRlcnMuUG9zdGVyaXplfSBmaWx0ZXIuXG4gICAgKiBAbmFtZSBsZXZlbHNcbiAgICAqIEBtZXRob2RcbiAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtOdW1iZXJ9IGxldmVsIGJldHdlZW4gMCBhbmQgMVxuICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBOb2lzZSBGaWx0ZXIuIFJhbmRvbWx5IGFkZHMgb3Igc3Vic3RyYWN0cyB0byB0aGUgY29sb3IgY2hhbm5lbHNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBuYW1lIE5vaXNlXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGF1dGhvciBpcHBvNjE1XG4gICAqIEBleGFtcGxlXG4gICAqIG5vZGUuY2FjaGUoKTtcbiAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLk5vaXNlXSk7XG4gICAqIG5vZGUubm9pc2UoMC44KTtcbiAgICovXG4gIEtvbnZhLkZpbHRlcnMuTm9pc2UgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5ub2lzZSgpICogMjU1LFxuICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgaGFsZiA9IGFtb3VudCAvIDIsXG4gICAgICBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5QaXhlbHM7IGkgKz0gNCkge1xuICAgICAgZGF0YVtpICsgMF0gKz0gaGFsZiAtIDIgKiBoYWxmICogTWF0aC5yYW5kb20oKTtcbiAgICAgIGRhdGFbaSArIDFdICs9IGhhbGYgLSAyICogaGFsZiAqIE1hdGgucmFuZG9tKCk7XG4gICAgICBkYXRhW2kgKyAyXSArPSBoYWxmIC0gMiAqIGhhbGYgKiBNYXRoLnJhbmRvbSgpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdub2lzZScsXG4gICAgMC4yLFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBub2lzZSBhbW91bnQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5Ob2lzZX0gZmlsdGVyLlxuICAgKiBAbmFtZSBub2lzZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gbm9pc2VcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG59KSgpO1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1kZXB0aCAqL1xuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBQaXhlbGF0ZSBGaWx0ZXIuIEF2ZXJhZ2VzIGdyb3VwcyBvZiBwaXhlbHMgYW5kIHJlZHJhd3NcbiAgICogIHRoZW0gYXMgbGFyZ2VyIHBpeGVsc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQG5hbWUgUGl4ZWxhdGVcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuUGl4ZWxhdGVdKTtcbiAgICogbm9kZS5waXhlbFNpemUoMTApO1xuICAgKi9cblxuICBLb252YS5GaWx0ZXJzLlBpeGVsYXRlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIHBpeGVsU2l6ZSA9IE1hdGguY2VpbCh0aGlzLnBpeGVsU2l6ZSgpKSxcbiAgICAgIHdpZHRoID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIC8vcGl4ZWxzUGVyQmluID0gcGl4ZWxTaXplICogcGl4ZWxTaXplLFxuICAgICAgcmVkLFxuICAgICAgZ3JlZW4sXG4gICAgICBibHVlLFxuICAgICAgYWxwaGEsXG4gICAgICBuQmluc1ggPSBNYXRoLmNlaWwod2lkdGggLyBwaXhlbFNpemUpLFxuICAgICAgbkJpbnNZID0gTWF0aC5jZWlsKGhlaWdodCAvIHBpeGVsU2l6ZSksXG4gICAgICB4QmluU3RhcnQsXG4gICAgICB4QmluRW5kLFxuICAgICAgeUJpblN0YXJ0LFxuICAgICAgeUJpbkVuZCxcbiAgICAgIHhCaW4sXG4gICAgICB5QmluLFxuICAgICAgcGl4ZWxzSW5CaW47XG4gICAgaW1hZ2VEYXRhID0gaW1hZ2VEYXRhLmRhdGE7XG5cbiAgICBpZiAocGl4ZWxTaXplIDw9IDApIHtcbiAgICAgIEtvbnZhLlV0aWwuZXJyb3IoJ3BpeGVsU2l6ZSB2YWx1ZSBjYW4gbm90IGJlIDw9IDAnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHhCaW4gPSAwOyB4QmluIDwgbkJpbnNYOyB4QmluICs9IDEpIHtcbiAgICAgIGZvciAoeUJpbiA9IDA7IHlCaW4gPCBuQmluc1k7IHlCaW4gKz0gMSkge1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBjb2xvciBhY2N1bWxhdG9ycyB0byAwXG4gICAgICAgIHJlZCA9IDA7XG4gICAgICAgIGdyZWVuID0gMDtcbiAgICAgICAgYmx1ZSA9IDA7XG4gICAgICAgIGFscGhhID0gMDtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggcGl4ZWxzIGFyZSBpbmNsdWRlZCBpbiB0aGlzIGJpblxuICAgICAgICB4QmluU3RhcnQgPSB4QmluICogcGl4ZWxTaXplO1xuICAgICAgICB4QmluRW5kID0geEJpblN0YXJ0ICsgcGl4ZWxTaXplO1xuICAgICAgICB5QmluU3RhcnQgPSB5QmluICogcGl4ZWxTaXplO1xuICAgICAgICB5QmluRW5kID0geUJpblN0YXJ0ICsgcGl4ZWxTaXplO1xuXG4gICAgICAgIC8vIEFkZCBhbGwgb2YgdGhlIHBpeGVscyB0byB0aGlzIGJpbiFcbiAgICAgICAgcGl4ZWxzSW5CaW4gPSAwO1xuICAgICAgICBmb3IgKHggPSB4QmluU3RhcnQ7IHggPCB4QmluRW5kOyB4ICs9IDEpIHtcbiAgICAgICAgICBpZiAoeCA+PSB3aWR0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoeSA9IHlCaW5TdGFydDsgeSA8IHlCaW5FbmQ7IHkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSA9ICh3aWR0aCAqIHkgKyB4KSAqIDQ7XG4gICAgICAgICAgICByZWQgKz0gaW1hZ2VEYXRhW2kgKyAwXTtcbiAgICAgICAgICAgIGdyZWVuICs9IGltYWdlRGF0YVtpICsgMV07XG4gICAgICAgICAgICBibHVlICs9IGltYWdlRGF0YVtpICsgMl07XG4gICAgICAgICAgICBhbHBoYSArPSBpbWFnZURhdGFbaSArIDNdO1xuICAgICAgICAgICAgcGl4ZWxzSW5CaW4gKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYW5uZWxzIGFyZSBiZXR3ZWVuIDAtMjU1XG4gICAgICAgIHJlZCA9IHJlZCAvIHBpeGVsc0luQmluO1xuICAgICAgICBncmVlbiA9IGdyZWVuIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgIGJsdWUgPSBibHVlIC8gcGl4ZWxzSW5CaW47XG4gICAgICAgIGFscGhhID0gYWxwaGEgLyBwaXhlbHNJbkJpbjtcblxuICAgICAgICAvLyBEcmF3IHRoaXMgYmluXG4gICAgICAgIGZvciAoeCA9IHhCaW5TdGFydDsgeCA8IHhCaW5FbmQ7IHggKz0gMSkge1xuICAgICAgICAgIGlmICh4ID49IHdpZHRoKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh5ID0geUJpblN0YXJ0OyB5IDwgeUJpbkVuZDsgeSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoeSA+PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpID0gKHdpZHRoICogeSArIHgpICogNDtcbiAgICAgICAgICAgIGltYWdlRGF0YVtpICsgMF0gPSByZWQ7XG4gICAgICAgICAgICBpbWFnZURhdGFbaSArIDFdID0gZ3JlZW47XG4gICAgICAgICAgICBpbWFnZURhdGFbaSArIDJdID0gYmx1ZTtcbiAgICAgICAgICAgIGltYWdlRGF0YVtpICsgM10gPSBhbHBoYTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAncGl4ZWxTaXplJyxcbiAgICA4LFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBwaXhlbCBzaXplLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5QaXhlbGF0ZX0gZmlsdGVyLlxuICAgKiBAbmFtZSBwaXhlbFNpemVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBwaXhlbFNpemVcbiAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAqL1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBUaHJlc2hvbGQgRmlsdGVyLiBQdXNoZXMgYW55IHZhbHVlIGFib3ZlIHRoZSBtaWQgcG9pbnQgdG9cbiAgICogIHRoZSBtYXggYW5kIGFueSB2YWx1ZSBiZWxvdyB0aGUgbWlkIHBvaW50IHRvIHRoZSBtaW4uXG4gICAqICBUaGlzIGFmZmVjdHMgdGhlIGFscGhhIGNoYW5uZWwuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAbmFtZSBUaHJlc2hvbGRcbiAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgKiBAYXV0aG9yIGlwcG82MTVcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuVGhyZXNob2xkXSk7XG4gICAqIG5vZGUudGhyZXNob2xkKDAuMSk7XG4gICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuVGhyZXNob2xkID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGxldmVsID0gdGhpcy50aHJlc2hvbGQoKSAqIDI1NSxcbiAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIGxlbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZGF0YVtpXSA9IGRhdGFbaV0gPCBsZXZlbCA/IDAgOiAyNTU7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLk5vZGUsXG4gICAgJ3RocmVzaG9sZCcsXG4gICAgMC41LFxuICAgIG51bGwsXG4gICAgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlclxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCB0aHJlc2hvbGQuICBNdXN0IGJlIGEgdmFsdWUgYmV0d2VlbiAwIGFuZCAxLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5UaHJlc2hvbGR9IG9yIHtAbGluayBLb252YS5GaWx0ZXJzLk1hc2t9IGZpbHRlci5cbiAgICogQG5hbWUgdGhyZXNob2xkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aHJlc2hvbGRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogU2VwaWEgRmlsdGVyXG4gICAgICogQmFzZWQgb246IFBpeGFzdGljIExpYiAtIFNlcGlhIGZpbHRlciAtIHYwLjEuMFxuICAgICAqIENvcHlyaWdodCAoYykgMjAwOCBKYWNvYiBTZWlkZWxpbiwganNlaWRlbGluQG5paGlsb2dpYy5kaywgaHR0cDovL2Jsb2cubmloaWxvZ2ljLmRrL1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFNlcGlhXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW1hZ2VEYXRhXG4gICAgICogQGF1dGhvciBKYWNvYiBTZWlkZWxpbiA8anNlaWRlbGluQG5paGlsb2dpYy5kaz5cbiAgICAgKiBAbGljZW5zZSBNUEwgdjEuMSBbaHR0cDovL3d3dy5waXhhc3RpYy5jb20vbGliL2xpY2Vuc2UudHh0XVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5TZXBpYV0pO1xuICAgICAqL1xuICBLb252YS5GaWx0ZXJzLlNlcGlhID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICB5ID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHc0ID0gdyAqIDQsXG4gICAgICBvZmZzZXRZLFxuICAgICAgeCxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9yLFxuICAgICAgb2csXG4gICAgICBvYixcbiAgICAgIHIsXG4gICAgICBnLFxuICAgICAgYjtcblxuICAgIGRvIHtcbiAgICAgIG9mZnNldFkgPSAoeSAtIDEpICogdzQ7XG4gICAgICB4ID0gdztcbiAgICAgIGRvIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuXG4gICAgICAgIG9yID0gZGF0YVtvZmZzZXRdO1xuICAgICAgICBvZyA9IGRhdGFbb2Zmc2V0ICsgMV07XG4gICAgICAgIG9iID0gZGF0YVtvZmZzZXQgKyAyXTtcblxuICAgICAgICByID0gb3IgKiAwLjM5MyArIG9nICogMC43NjkgKyBvYiAqIDAuMTg5O1xuICAgICAgICBnID0gb3IgKiAwLjM0OSArIG9nICogMC42ODYgKyBvYiAqIDAuMTY4O1xuICAgICAgICBiID0gb3IgKiAwLjI3MiArIG9nICogMC41MzQgKyBvYiAqIDAuMTMxO1xuXG4gICAgICAgIGRhdGFbb2Zmc2V0XSA9IHIgPiAyNTUgPyAyNTUgOiByO1xuICAgICAgICBkYXRhW29mZnNldCArIDFdID0gZyA+IDI1NSA/IDI1NSA6IGc7XG4gICAgICAgIGRhdGFbb2Zmc2V0ICsgMl0gPSBiID4gMjU1ID8gMjU1IDogYjtcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAzXSA9IGRhdGFbb2Zmc2V0ICsgM107XG4gICAgICB9IHdoaWxlICgtLXgpO1xuICAgIH0gd2hpbGUgKC0teSk7XG4gIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogU29sYXJpemUgRmlsdGVyXG4gICAgICogUGl4YXN0aWMgTGliIC0gU29sYXJpemUgZmlsdGVyIC0gdjAuMS4wXG4gICAgICogQ29weXJpZ2h0IChjKSAyMDA4IEphY29iIFNlaWRlbGluLCBqc2VpZGVsaW5AbmloaWxvZ2ljLmRrLCBodHRwOi8vYmxvZy5uaWhpbG9naWMuZGsvXG4gICAgICogTGljZW5zZTogW2h0dHA6Ly93d3cucGl4YXN0aWMuY29tL2xpYi9saWNlbnNlLnR4dF1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBTb2xhcml6ZVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlRGF0YVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbm9kZS5jYWNoZSgpO1xuICAgICAqIG5vZGUuZmlsdGVycyhbS29udmEuRmlsdGVycy5Tb2xhcml6ZV0pO1xuICAgICAqL1xuICBLb252YS5GaWx0ZXJzLlNvbGFyaXplID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgIHcgPSBpbWFnZURhdGEud2lkdGgsXG4gICAgICBoID0gaW1hZ2VEYXRhLmhlaWdodCxcbiAgICAgIHc0ID0gdyAqIDQsXG4gICAgICB5ID0gaDtcblxuICAgIGRvIHtcbiAgICAgIHZhciBvZmZzZXRZID0gKHkgLSAxKSAqIHc0O1xuICAgICAgdmFyIHggPSB3O1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0WSArICh4IC0gMSkgKiA0O1xuICAgICAgICB2YXIgciA9IGRhdGFbb2Zmc2V0XTtcbiAgICAgICAgdmFyIGcgPSBkYXRhW29mZnNldCArIDFdO1xuICAgICAgICB2YXIgYiA9IGRhdGFbb2Zmc2V0ICsgMl07XG5cbiAgICAgICAgaWYgKHIgPiAxMjcpIHtcbiAgICAgICAgICByID0gMjU1IC0gcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZyA+IDEyNykge1xuICAgICAgICAgIGcgPSAyNTUgLSBnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiID4gMTI3KSB7XG4gICAgICAgICAgYiA9IDI1NSAtIGI7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW29mZnNldF0gPSByO1xuICAgICAgICBkYXRhW29mZnNldCArIDFdID0gZztcbiAgICAgICAgZGF0YVtvZmZzZXQgKyAyXSA9IGI7XG4gICAgICB9IHdoaWxlICgtLXgpO1xuICAgIH0gd2hpbGUgKC0teSk7XG4gIH07XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLypcbiAgICogVG9Qb2xhciBGaWx0ZXIuIENvbnZlcnRzIGltYWdlIGRhdGEgdG8gcG9sYXIgY29vcmRpbmF0ZXMuIFBlcmZvcm1zXG4gICAqICB3KmgqNCBwaXhlbCByZWFkcyBhbmQgdypoIHBpeGVsIHdyaXRlcy4gVGhlIHIgYXhpcyBpcyBwbGFjZWQgYWxvbmdcbiAgICogIHdoYXQgd291bGQgYmUgdGhlIHkgYXhpcyBhbmQgdGhlIHRoZXRhIGF4aXMgYWxvbmcgdGhlIHggYXhpcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBhdXRob3IgaXBwbzYxNVxuICAgKiBAbWVtYmVyb2YgS29udmEuRmlsdGVyc1xuICAgKiBAcGFyYW0ge0ltYWdlRGF0YX0gc3JjLCB0aGUgc291cmNlIGltYWdlIGRhdGEgKHdoYXQgd2lsbCBiZSB0cmFuc2Zvcm1lZClcbiAgICogQHBhcmFtIHtJbWFnZURhdGF9IGRzdCwgdGhlIGRlc3RpbmF0aW9uIGltYWdlIGRhdGEgKHdoZXJlIGl0IHdpbGwgYmUgc2F2ZWQpXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJYXSBob3Jpem9udGFsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHQucG9sYXJDZW50ZXJZXSB2ZXJ0aWNhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgKiAgZGVmYXVsdCBpcyBpbiB0aGUgbWlkZGxlXG4gICAqL1xuXG4gIHZhciBUb1BvbGFyID0gZnVuY3Rpb24oc3JjLCBkc3QsIG9wdCkge1xuICAgIHZhciBzcmNQaXhlbHMgPSBzcmMuZGF0YSxcbiAgICAgIGRzdFBpeGVscyA9IGRzdC5kYXRhLFxuICAgICAgeFNpemUgPSBzcmMud2lkdGgsXG4gICAgICB5U2l6ZSA9IHNyYy5oZWlnaHQsXG4gICAgICB4TWlkID0gb3B0LnBvbGFyQ2VudGVyWCB8fCB4U2l6ZSAvIDIsXG4gICAgICB5TWlkID0gb3B0LnBvbGFyQ2VudGVyWSB8fCB5U2l6ZSAvIDIsXG4gICAgICBpLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICByID0gMCxcbiAgICAgIGcgPSAwLFxuICAgICAgYiA9IDAsXG4gICAgICBhID0gMDtcblxuICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgcmFkaXVzXG4gICAgdmFyIHJhZCxcbiAgICAgIHJNYXggPSBNYXRoLnNxcnQoeE1pZCAqIHhNaWQgKyB5TWlkICogeU1pZCk7XG4gICAgeCA9IHhTaXplIC0geE1pZDtcbiAgICB5ID0geVNpemUgLSB5TWlkO1xuICAgIHJhZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICByTWF4ID0gcmFkID4gck1heCA/IHJhZCA6IHJNYXg7XG5cbiAgICAvLyBXZSdsbCBiZSB1aXNuZyB5IGFzIHRoZSByYWRpdXMsIGFuZCB4IGFzIHRoZSBhbmdsZSAodGhldGE9dClcbiAgICB2YXIgclNpemUgPSB5U2l6ZSxcbiAgICAgIHRTaXplID0geFNpemUsXG4gICAgICByYWRpdXMsXG4gICAgICB0aGV0YTtcblxuICAgIC8vIFdlIHdhbnQgdG8gY292ZXIgYWxsIGFuZ2xlcyAoMC0zNjApIGFuZCB3ZSBuZWVkIHRvIGNvbnZlcnQgdG9cbiAgICAvLyByYWRpYW5zICgqUEkvMTgwKVxuICAgIHZhciBjb252ZXJzaW9uID0gMzYwIC8gdFNpemUgKiBNYXRoLlBJIC8gMTgwLFxuICAgICAgc2luLFxuICAgICAgY29zO1xuXG4gICAgLy8gdmFyIHgxLCB4MiwgeDFpLCB4MmksIHkxLCB5MiwgeTFpLCB5MmksIHNjYWxlO1xuXG4gICAgZm9yICh0aGV0YSA9IDA7IHRoZXRhIDwgdFNpemU7IHRoZXRhICs9IDEpIHtcbiAgICAgIHNpbiA9IE1hdGguc2luKHRoZXRhICogY29udmVyc2lvbik7XG4gICAgICBjb3MgPSBNYXRoLmNvcyh0aGV0YSAqIGNvbnZlcnNpb24pO1xuICAgICAgZm9yIChyYWRpdXMgPSAwOyByYWRpdXMgPCByU2l6ZTsgcmFkaXVzICs9IDEpIHtcbiAgICAgICAgeCA9IE1hdGguZmxvb3IoeE1pZCArIHJNYXggKiByYWRpdXMgLyByU2l6ZSAqIGNvcyk7XG4gICAgICAgIHkgPSBNYXRoLmZsb29yKHlNaWQgKyByTWF4ICogcmFkaXVzIC8gclNpemUgKiBzaW4pO1xuICAgICAgICBpID0gKHkgKiB4U2l6ZSArIHgpICogNDtcbiAgICAgICAgciA9IHNyY1BpeGVsc1tpICsgMF07XG4gICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICBiID0gc3JjUGl4ZWxzW2kgKyAyXTtcbiAgICAgICAgYSA9IHNyY1BpeGVsc1tpICsgM107XG5cbiAgICAgICAgLy8gU3RvcmUgaXRcbiAgICAgICAgLy9pID0gKHRoZXRhICogeFNpemUgICsgIHJhZGl1cykgKiA0O1xuICAgICAgICBpID0gKHRoZXRhICsgcmFkaXVzICogeFNpemUpICogNDtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAwXSA9IHI7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMV0gPSBnO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDJdID0gYjtcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAzXSA9IGE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qXG4gICAgICogRnJvbVBvbGFyIEZpbHRlci4gQ29udmVydHMgaW1hZ2UgZGF0YSBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzIGJhY2sgdG8gcmVjdGFuZ3VsYXIuXG4gICAgICogIFBlcmZvcm1zIHcqaCo0IHBpeGVsIHJlYWRzIGFuZCB3KmggcGl4ZWwgd3JpdGVzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IHNyYywgdGhlIHNvdXJjZSBpbWFnZSBkYXRhICh3aGF0IHdpbGwgYmUgdHJhbnNmb3JtZWQpXG4gICAgICogQHBhcmFtIHtJbWFnZURhdGF9IGRzdCwgdGhlIGRlc3RpbmF0aW9uIGltYWdlIGRhdGEgKHdoZXJlIGl0IHdpbGwgYmUgc2F2ZWQpXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyQ2VudGVyWF0gaG9yaXpvbnRhbCBsb2NhdGlvbiBmb3IgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlLFxuICAgICAqICBkZWZhdWx0IGlzIGluIHRoZSBtaWRkbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdC5wb2xhckNlbnRlclldIHZlcnRpY2FsIGxvY2F0aW9uIGZvciB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGUsXG4gICAgICogIGRlZmF1bHQgaXMgaW4gdGhlIG1pZGRsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0LnBvbGFyUm90YXRpb25dIGFtb3VudCB0byByb3RhdGUgdGhlIGltYWdlIGNvdW50ZXJjbG9ja3dpcyxcbiAgICAgKiAgMCBpcyBubyByb3RhdGlvbiwgMzYwIGRlZ3JlZXMgaXMgYSBmdWxsIHJvdGF0aW9uXG4gICAgICovXG5cbiAgdmFyIEZyb21Qb2xhciA9IGZ1bmN0aW9uKHNyYywgZHN0LCBvcHQpIHtcbiAgICB2YXIgc3JjUGl4ZWxzID0gc3JjLmRhdGEsXG4gICAgICBkc3RQaXhlbHMgPSBkc3QuZGF0YSxcbiAgICAgIHhTaXplID0gc3JjLndpZHRoLFxuICAgICAgeVNpemUgPSBzcmMuaGVpZ2h0LFxuICAgICAgeE1pZCA9IG9wdC5wb2xhckNlbnRlclggfHwgeFNpemUgLyAyLFxuICAgICAgeU1pZCA9IG9wdC5wb2xhckNlbnRlclkgfHwgeVNpemUgLyAyLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHIgPSAwLFxuICAgICAgZyA9IDAsXG4gICAgICBiID0gMCxcbiAgICAgIGEgPSAwO1xuXG4gICAgLy8gRmluZCB0aGUgbGFyZ2VzdCByYWRpdXNcbiAgICB2YXIgcmFkLFxuICAgICAgck1heCA9IE1hdGguc3FydCh4TWlkICogeE1pZCArIHlNaWQgKiB5TWlkKTtcbiAgICB4ID0geFNpemUgLSB4TWlkO1xuICAgIHkgPSB5U2l6ZSAtIHlNaWQ7XG4gICAgcmFkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgIHJNYXggPSByYWQgPiByTWF4ID8gcmFkIDogck1heDtcblxuICAgIC8vIFdlJ2xsIGJlIHVpc25nIHggYXMgdGhlIHJhZGl1cywgYW5kIHkgYXMgdGhlIGFuZ2xlICh0aGV0YT10KVxuICAgIHZhciByU2l6ZSA9IHlTaXplLFxuICAgICAgdFNpemUgPSB4U2l6ZSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIHRoZXRhLFxuICAgICAgcGhhc2VTaGlmdCA9IG9wdC5wb2xhclJvdGF0aW9uIHx8IDA7XG5cbiAgICAvLyBXZSBuZWVkIHRvIGNvbnZlcnQgdG8gZGVncmVlcyBhbmQgd2UgbmVlZCB0byBtYWtlIHN1cmVcbiAgICAvLyBpdCdzIGJldHdlZW4gKDAtMzYwKVxuICAgIC8vIHZhciBjb252ZXJzaW9uID0gdFNpemUvMzYwKjE4MC9NYXRoLlBJO1xuICAgIC8vdmFyIGNvbnZlcnNpb24gPSB0U2l6ZS8zNjAqMTgwL01hdGguUEk7XG5cbiAgICB2YXIgeDEsIHkxO1xuXG4gICAgZm9yICh4ID0gMDsgeCA8IHhTaXplOyB4ICs9IDEpIHtcbiAgICAgIGZvciAoeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxKSB7XG4gICAgICAgIGR4ID0geCAtIHhNaWQ7XG4gICAgICAgIGR5ID0geSAtIHlNaWQ7XG4gICAgICAgIHJhZGl1cyA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgKiByU2l6ZSAvIHJNYXg7XG4gICAgICAgIHRoZXRhID0gKE1hdGguYXRhbjIoZHksIGR4KSAqIDE4MCAvIE1hdGguUEkgKyAzNjAgKyBwaGFzZVNoaWZ0KSAlIDM2MDtcbiAgICAgICAgdGhldGEgPSB0aGV0YSAqIHRTaXplIC8gMzYwO1xuICAgICAgICB4MSA9IE1hdGguZmxvb3IodGhldGEpO1xuICAgICAgICB5MSA9IE1hdGguZmxvb3IocmFkaXVzKTtcbiAgICAgICAgaSA9ICh5MSAqIHhTaXplICsgeDEpICogNDtcbiAgICAgICAgciA9IHNyY1BpeGVsc1tpICsgMF07XG4gICAgICAgIGcgPSBzcmNQaXhlbHNbaSArIDFdO1xuICAgICAgICBiID0gc3JjUGl4ZWxzW2kgKyAyXTtcbiAgICAgICAgYSA9IHNyY1BpeGVsc1tpICsgM107XG5cbiAgICAgICAgLy8gU3RvcmUgaXRcbiAgICAgICAgaSA9ICh5ICogeFNpemUgKyB4KSAqIDQ7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgMF0gPSByO1xuICAgICAgICBkc3RQaXhlbHNbaSArIDFdID0gZztcbiAgICAgICAgZHN0UGl4ZWxzW2kgKyAyXSA9IGI7XG4gICAgICAgIGRzdFBpeGVsc1tpICsgM10gPSBhO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvL0tvbnZhLkZpbHRlcnMuVG9Qb2xhciA9IEtvbnZhLlV0aWwuX0ZpbHRlcldyYXBEb3VibGVCdWZmZXIoVG9Qb2xhcik7XG4gIC8vS29udmEuRmlsdGVycy5Gcm9tUG9sYXIgPSBLb252YS5VdGlsLl9GaWx0ZXJXcmFwRG91YmxlQnVmZmVyKEZyb21Qb2xhcik7XG5cbiAgLy8gY3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyBmb3Igd29ya2luZyAtIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzXG5cbiAgLypcbiAgICAgKiBLYWxlaWRvc2NvcGUgRmlsdGVyLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIEthbGVpZG9zY29wZVxuICAgICAqIEBhdXRob3IgaXBwbzYxNVxuICAgICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBub2RlLmNhY2hlKCk7XG4gICAgICogbm9kZS5maWx0ZXJzKFtLb252YS5GaWx0ZXJzLkthbGVpZG9zY29wZV0pO1xuICAgICAqIG5vZGUua2FsZWlkb3Njb3BlUG93ZXIoMyk7XG4gICAgICogbm9kZS5rYWxlaWRvc2NvcGVBbmdsZSg0NSk7XG4gICAgICovXG4gIEtvbnZhLkZpbHRlcnMuS2FsZWlkb3Njb3BlID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdmFyIHhTaXplID0gaW1hZ2VEYXRhLndpZHRoLFxuICAgICAgeVNpemUgPSBpbWFnZURhdGEuaGVpZ2h0O1xuXG4gICAgdmFyIHgsIHksIHhvZmYsIGksIHIsIGcsIGIsIGEsIHNyY1BvcywgZHN0UG9zO1xuICAgIHZhciBwb3dlciA9IE1hdGgucm91bmQodGhpcy5rYWxlaWRvc2NvcGVQb3dlcigpKTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLnJvdW5kKHRoaXMua2FsZWlkb3Njb3BlQW5nbGUoKSk7XG4gICAgdmFyIG9mZnNldCA9IE1hdGguZmxvb3IoeFNpemUgKiAoYW5nbGUgJSAzNjApIC8gMzYwKTtcblxuICAgIGlmIChwb3dlciA8IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBXb3JrIHdpdGggb3VyIHNoYXJlZCBidWZmZXIgY2FudmFzXG4gICAgdmFyIHRlbXBDYW52YXMgPSBLb252YS5VdGlsLmNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICB0ZW1wQ2FudmFzLndpZHRoID0geFNpemU7XG4gICAgdGVtcENhbnZhcy5oZWlnaHQgPSB5U2l6ZTtcbiAgICB2YXIgc2NyYXRjaERhdGEgPSB0ZW1wQ2FudmFzXG4gICAgICAuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgLmdldEltYWdlRGF0YSgwLCAwLCB4U2l6ZSwgeVNpemUpO1xuXG4gICAgLy8gQ29udmVydCB0aGhlIG9yaWdpbmFsIHRvIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAgVG9Qb2xhcihpbWFnZURhdGEsIHNjcmF0Y2hEYXRhLCB7XG4gICAgICBwb2xhckNlbnRlclg6IHhTaXplIC8gMixcbiAgICAgIHBvbGFyQ2VudGVyWTogeVNpemUgLyAyXG4gICAgfSk7XG5cbiAgICAvLyBEZXRlcm1pbmUgaG93IGJpZyBlYWNoIHNlY3Rpb24gd2lsbCBiZSwgaWYgaXQncyB0b28gc21hbGxcbiAgICAvLyBtYWtlIGl0IGJpZ2dlclxuICAgIHZhciBtaW5TZWN0aW9uU2l6ZSA9IHhTaXplIC8gTWF0aC5wb3coMiwgcG93ZXIpO1xuICAgIHdoaWxlIChtaW5TZWN0aW9uU2l6ZSA8PSA4KSB7XG4gICAgICBtaW5TZWN0aW9uU2l6ZSA9IG1pblNlY3Rpb25TaXplICogMjtcbiAgICAgIHBvd2VyIC09IDE7XG4gICAgfVxuICAgIG1pblNlY3Rpb25TaXplID0gTWF0aC5jZWlsKG1pblNlY3Rpb25TaXplKTtcbiAgICB2YXIgc2VjdGlvblNpemUgPSBtaW5TZWN0aW9uU2l6ZTtcblxuICAgIC8vIENvcHkgdGhlIG9mZnNldCByZWdpb24gdG8gMFxuICAgIC8vIERlcGVuZGluZyBvbiB0aGUgc2l6ZSBvZiBmaWx0ZXIgYW5kIGxvY2F0aW9uIG9mIHRoZSBvZmZzZXQgd2UgbWF5IG5lZWRcbiAgICAvLyB0byBjb3B5IHRoZSBzZWN0aW9uIGJhY2t3YXJkcyB0byBwcmV2ZW50IGl0IGZyb20gcmV3cml0aW5nIGl0c2VsZlxuICAgIHZhciB4U3RhcnQgPSAwLFxuICAgICAgeEVuZCA9IHNlY3Rpb25TaXplLFxuICAgICAgeERlbHRhID0gMTtcbiAgICBpZiAob2Zmc2V0ICsgbWluU2VjdGlvblNpemUgPiB4U2l6ZSkge1xuICAgICAgeFN0YXJ0ID0gc2VjdGlvblNpemU7XG4gICAgICB4RW5kID0gMDtcbiAgICAgIHhEZWx0YSA9IC0xO1xuICAgIH1cbiAgICBmb3IgKHkgPSAwOyB5IDwgeVNpemU7IHkgKz0gMSkge1xuICAgICAgZm9yICh4ID0geFN0YXJ0OyB4ICE9PSB4RW5kOyB4ICs9IHhEZWx0YSkge1xuICAgICAgICB4b2ZmID0gTWF0aC5yb3VuZCh4ICsgb2Zmc2V0KSAlIHhTaXplO1xuICAgICAgICBzcmNQb3MgPSAoeFNpemUgKiB5ICsgeG9mZikgKiA0O1xuICAgICAgICByID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAwXTtcbiAgICAgICAgZyA9IHNjcmF0Y2hEYXRhLmRhdGFbc3JjUG9zICsgMV07XG4gICAgICAgIGIgPSBzY3JhdGNoRGF0YS5kYXRhW3NyY1BvcyArIDJdO1xuICAgICAgICBhID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAzXTtcbiAgICAgICAgZHN0UG9zID0gKHhTaXplICogeSArIHgpICogNDtcbiAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAwXSA9IHI7XG4gICAgICAgIHNjcmF0Y2hEYXRhLmRhdGFbZHN0UG9zICsgMV0gPSBnO1xuICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDJdID0gYjtcbiAgICAgICAgc2NyYXRjaERhdGEuZGF0YVtkc3RQb3MgKyAzXSA9IGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSB0aGUgYWN0dWFsIGVmZmVjdFxuICAgIGZvciAoeSA9IDA7IHkgPCB5U2l6ZTsgeSArPSAxKSB7XG4gICAgICBzZWN0aW9uU2l6ZSA9IE1hdGguZmxvb3IobWluU2VjdGlvblNpemUpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHBvd2VyOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IHNlY3Rpb25TaXplICsgMTsgeCArPSAxKSB7XG4gICAgICAgICAgc3JjUG9zID0gKHhTaXplICogeSArIHgpICogNDtcbiAgICAgICAgICByID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAwXTtcbiAgICAgICAgICBnID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAxXTtcbiAgICAgICAgICBiID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAyXTtcbiAgICAgICAgICBhID0gc2NyYXRjaERhdGEuZGF0YVtzcmNQb3MgKyAzXTtcbiAgICAgICAgICBkc3RQb3MgPSAoeFNpemUgKiB5ICsgc2VjdGlvblNpemUgKiAyIC0geCAtIDEpICogNDtcbiAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDBdID0gcjtcbiAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDFdID0gZztcbiAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDJdID0gYjtcbiAgICAgICAgICBzY3JhdGNoRGF0YS5kYXRhW2RzdFBvcyArIDNdID0gYTtcbiAgICAgICAgfVxuICAgICAgICBzZWN0aW9uU2l6ZSAqPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgYmFjayBmcm9tIHBvbGFyIGNvb3JkaW5hdGVzXG4gICAgRnJvbVBvbGFyKHNjcmF0Y2hEYXRhLCBpbWFnZURhdGEsIHsgcG9sYXJSb3RhdGlvbjogMCB9KTtcbiAgfTtcblxuICAvKipcbiAgICAqIGdldC9zZXQga2FsZWlkb3Njb3BlIHBvd2VyLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGV9IGZpbHRlci5cbiAgICAqIEBuYW1lIGthbGVpZG9zY29wZVBvd2VyXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcG93ZXIgb2Yga2FsZWlkb3Njb3BlXG4gICAgKiBAcmV0dXJucyB7SW50ZWdlcn1cbiAgICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5Ob2RlLFxuICAgICdrYWxlaWRvc2NvcGVQb3dlcicsXG4gICAgMixcbiAgICBudWxsLFxuICAgIEtvbnZhLkZhY3RvcnkuYWZ0ZXJTZXRGaWx0ZXJcbiAgKTtcblxuICAvKipcbiAgICAqIGdldC9zZXQga2FsZWlkb3Njb3BlIGFuZ2xlLiBVc2Ugd2l0aCB7QGxpbmsgS29udmEuRmlsdGVycy5LYWxlaWRvc2NvcGV9IGZpbHRlci5cbiAgICAqIEBuYW1lIGthbGVpZG9zY29wZUFuZ2xlXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZGVncmVlc1xuICAgICogQHJldHVybnMge0ludGVnZXJ9XG4gICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuTm9kZSxcbiAgICAna2FsZWlkb3Njb3BlQW5nbGUnLFxuICAgIDAsXG4gICAgbnVsbCxcbiAgICBLb252YS5GYWN0b3J5LmFmdGVyU2V0RmlsdGVyXG4gICk7XG59KSgpO1xuXG4oZnVuY3Rpb24gKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIENvbnRyYXN0IEZpbHRlci5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBtZW1iZXJvZiBLb252YS5GaWx0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbWFnZURhdGFcbiAgICogQGV4YW1wbGVcbiAgICogbm9kZS5jYWNoZSgpO1xuICAgKiBub2RlLmZpbHRlcnMoW0tvbnZhLkZpbHRlcnMuQ29udHJhc3RdKTtcbiAgICogbm9kZS5jb250cmFzdCgxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZpbHRlcnMuQ29udHJhc3QgPSBmdW5jdGlvbiAoaW1hZ2VEYXRhKSB7XG4gICAgdmFyIGFkanVzdCA9IE1hdGgucG93KChwYXJzZUludCh0aGlzLmNvbnRyYXN0KCkpICsgMTAwKSAvIDEwMCwgMik7XG5cbiAgICB2YXIgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgblBpeGVscyA9IGRhdGEubGVuZ3RoLFxuICAgICAgcmVkID0gMTUwLFxuICAgICAgZ3JlZW4gPSAxNTAsXG4gICAgICBibHVlID0gMTUwLFxuICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuUGl4ZWxzOyBpICs9IDQpIHtcbiAgICAgIHJlZCA9IGRhdGFbaV07XG4gICAgICBncmVlbiA9IGRhdGFbaSArIDFdO1xuICAgICAgYmx1ZSA9IGRhdGFbaSArIDJdO1xuXG4gICAgICAvL1JlZCBjaGFubmVsXG4gICAgICByZWQgLz0gMjU1O1xuICAgICAgcmVkIC09IDAuNTtcbiAgICAgIHJlZCAqPSBhZGp1c3Q7XG4gICAgICByZWQgKz0gMC41O1xuICAgICAgcmVkICo9IDI1NTtcblxuICAgICAgLy9HcmVlbiBjaGFubmVsXG4gICAgICBncmVlbiAvPSAyNTU7XG4gICAgICBncmVlbiAtPSAwLjU7XG4gICAgICBncmVlbiAqPSBhZGp1c3Q7XG4gICAgICBncmVlbiArPSAwLjU7XG4gICAgICBncmVlbiAqPSAyNTU7XG5cbiAgICAgIC8vQmx1ZSBjaGFubmVsXG4gICAgICBibHVlIC89IDI1NTtcbiAgICAgIGJsdWUgLT0gMC41O1xuICAgICAgYmx1ZSAqPSBhZGp1c3Q7XG4gICAgICBibHVlICs9IDAuNTtcbiAgICAgIGJsdWUgKj0gMjU1O1xuXG4gICAgICByZWQgPSAocmVkIDwgMCA/IDAgOiAocmVkID4gMjU1ID8gMjU1IDogcmVkKSk7XG4gICAgICBncmVlbiA9IChncmVlbiA8IDAgPyAwIDogKGdyZWVuID4gMjU1ID8gMjU1IDogZ3JlZW4pKTtcbiAgICAgIGJsdWUgPSAoYmx1ZSA8IDAgPyAwIDogKGJsdWUgPiAyNTUgPyAyNTUgOiBibHVlKSk7XG5cbiAgICAgIGRhdGFbaV0gPSByZWQ7XG4gICAgICBkYXRhW2kgKyAxXSA9IGdyZWVuO1xuICAgICAgZGF0YVtpICsgMl0gPSBibHVlO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWx0ZXIgY29udHJhc3QuICBUaGUgY29udHJhc3QgaXMgYSBudW1iZXIgYmV0d2VlbiAtMTAwIGFuZCAxMDAuXG4gICAqIFVzZSB3aXRoIHtAbGluayBLb252YS5GaWx0ZXJzLkNvbnRyYXN0fSBmaWx0ZXIuXG4gICAqIEBuYW1lIGNvbnRyYXN0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLk5vZGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb250cmFzdCB2YWx1ZSBiZXR3ZWVuIC0xMDAgYW5kIDEwMFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTm9kZSwgJ2NvbnRyYXN0JywgMCwgbnVsbCwgS29udmEuRmFjdG9yeS5hZnRlclNldEZpbHRlcik7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQ29udGFpbmVyIGNvbnN0cnVjdG9yLiZuYnNwOyBDb250YWluZXJzIGFyZSB1c2VkIHRvIGNvbnRhaW4gbm9kZXMgb3Igb3RoZXIgY29udGFpbmVyc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgKi9cbiAgS29udmEuQ29udGFpbmVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuQ29udGFpbmVyLCB7XG4gICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgS29udmEuTm9kZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIGEge0BsaW5rIEtvbnZhLkNvbGxlY3Rpb259IG9mIGRpcmVjdCBkZXNjZW5kYW50IG5vZGVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlckZ1bmNdIGZpbHRlciBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtLb252YS5Db2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFsbCBjaGlsZHJlblxuICAgICAqIHZhciBjaGlsZHJlbiA9IGxheWVyLmdldENoaWxkcmVuKCk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgb25seSBjaXJjbGVzXG4gICAgICogdmFyIGNpcmNsZXMgPSBsYXllci5nZXRDaGlsZHJlbihmdW5jdGlvbihub2RlKXtcbiAgICAgKiAgICByZXR1cm4gbm9kZS5nZXRDbGFzc05hbWUoKSA9PT0gJ0NpcmNsZSc7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKGZpbHRlckZ1bmMpIHtcbiAgICAgIGlmICghZmlsdGVyRnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdHMgPSBuZXcgS29udmEuQ29sbGVjdGlvbigpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmIChmaWx0ZXJGdW5jKGNoaWxkKSkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmUgaWYgbm9kZSBoYXMgY2hpbGRyZW5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDA7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZW1vdmUgYWxsIGNoaWxkcmVuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gS29udmEuQ29sbGVjdGlvbi50b0NvbGxlY3Rpb24odGhpcy5jaGlsZHJlbik7XG4gICAgICB2YXIgY2hpbGQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIC8vIHJlc2V0IHBhcmVudCB0byBwcmV2ZW50IG1hbnkgX3NldENoaWxkcmVuSW5kaWNlcyBjYWxsc1xuICAgICAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuICAgICAgICBjaGlsZC5pbmRleCA9IDA7XG4gICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4gPSBudWxsO1xuICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBLb252YS5Db2xsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgYWxsIGNoaWxkcmVuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZGVzdHJveUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IEtvbnZhLkNvbGxlY3Rpb24udG9Db2xsZWN0aW9uKHRoaXMuY2hpbGRyZW4pO1xuICAgICAgdmFyIGNoaWxkO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAvLyByZXNldCBwYXJlbnQgdG8gcHJldmVudCBtYW55IF9zZXRDaGlsZHJlbkluZGljZXMgY2FsbHNcbiAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcbiAgICAgICAgY2hpbGQuaW5kZXggPSAwO1xuICAgICAgICBjaGlsZC5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IEtvbnZhLkNvbGxlY3Rpb24oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQWRkIG5vZGUgb3Igbm9kZXMgdG8gY29udGFpbmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Li4uS29udmEuTm9kZX0gY2hpbGRcbiAgICAgKiBAcmV0dXJucyB7Q29udGFpbmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGF5ZXIuYWRkKHNoYXBlMSwgc2hhcGUyLCBzaGFwZTMpO1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQuZ2V0UGFyZW50KCkpIHtcbiAgICAgICAgY2hpbGQubW92ZVRvKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICB0aGlzLl92YWxpZGF0ZUFkZChjaGlsZCk7XG4gICAgICBjaGlsZC5pbmRleCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIHRoaXMuX2ZpcmUoJ2FkZCcsIHtcbiAgICAgICAgY2hpbGQ6IGNoaWxkXG4gICAgICB9KTtcblxuICAgICAgLy8gaWYgbm9kZSB1bmRlciBkcmFnIHdlIG5lZWQgdG8gdXBkYXRlIGRyYWcgYW5pbWF0aW9uXG4gICAgICBpZiAoS29udmEuREQgJiYgY2hpbGQuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgIEtvbnZhLkRELmFuaW0uc2V0TGF5ZXJzKGNoaWxkLmdldExheWVyKCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGFpbmFibGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBkZXN0cm95IGNoaWxkcmVuXG4gICAgICBpZiAodGhpcy5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveUNoaWxkcmVuKCk7XG4gICAgICB9XG4gICAgICAvLyB0aGVuIGRlc3Ryb3kgc2VsZlxuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiByZXR1cm4gYSB7QGxpbmsgS29udmEuQ29sbGVjdGlvbn0gb2Ygbm9kZXMgdGhhdCBtYXRjaCB0aGUgc2VsZWN0b3IuXG4gICAgICogWW91IGNhbiBwcm92aWRlIGEgc3RyaW5nIHdpdGggJyMnIGZvciBpZCBzZWxlY3Rpb25zIGFuZCAnLicgZm9yIG5hbWUgc2VsZWN0aW9ucy5cbiAgICAgKiBPciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCByZXR1cm4gdHJ1ZS9mYWxzZSB3aGVuIGEgbm9kZSBpcyBwYXNzZWQgdGhyb3VnaC4gIFNlZSBleGFtcGxlIGJlbG93LlxuICAgICAqIFdpdGggc3RyaW5ncyB5b3UgY2FuIGFsc28gc2VsZWN0IGJ5IHR5cGUgb3IgY2xhc3MgbmFtZS4gUGFzcyBtdWx0aXBsZSBzZWxlY3RvcnNcbiAgICAgKiBzZXBhcmF0ZWQgYnkgYSBzcGFjZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtDb2xsZWN0aW9ufVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBQYXNzaW5nIGEgc3RyaW5nIGFzIGEgc2VsZWN0b3JcbiAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGlkIGZvb1xuICAgICAqIHZhciBub2RlID0gc3RhZ2UuZmluZCgnI2ZvbycpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IG5vZGVzIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnLmJhcicpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IGFsbCBncm91cHMgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZCgnR3JvdXAnKTtcbiAgICAgKlxuICAgICAqIC8vIHNlbGVjdCBhbGwgcmVjdGFuZ2xlcyBpbnNpZGUgbGF5ZXJcbiAgICAgKiB2YXIgbm9kZXMgPSBsYXllci5maW5kKCdSZWN0Jyk7XG4gICAgICpcbiAgICAgKiAvLyBzZWxlY3Qgbm9kZSB3aXRoIGFuIGlkIG9mIGZvbyBvciBhIG5hbWUgb2YgYmFyIGluc2lkZSBsYXllclxuICAgICAqIHZhciBub2RlcyA9IGxheWVyLmZpbmQoJyNmb28sIC5iYXInKTtcbiAgICAgKlxuICAgICAqIFBhc3NpbmcgYSBmdW5jdGlvbiBhcyBhIHNlbGVjdG9yXG4gICAgICpcbiAgICAgKiAvLyBnZXQgYWxsIEdyb3Vwc1xuICAgICAqIHZhciBncm91cHMgPSBzdGFnZS5maW5kKG5vZGUgPT4ge1xuICAgICAqICByZXR1cm4gbm9kZS5nZXRUeXBlKCkgPT09ICdHcm91cCc7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBnZXQgb25seSBOb2RlcyB3aXRoIHBhcnRpYWwgb3BhY2l0eVxuICAgICAqIHZhciBhbHBoYU5vZGVzID0gbGF5ZXIuZmluZChub2RlID0+IHtcbiAgICAgKiAgcmV0dXJuIG5vZGUuZ2V0VHlwZSgpID09PSAnTm9kZScgJiYgbm9kZS5nZXRBYnNvbHV0ZU9wYWNpdHkoKSA8IDE7XG4gICAgICogfSk7XG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIC8vIHByb3RlY3RpbmcgX2dlbmVyYWxGaW5kIHRvIHByZXZlbnQgdXNlciBmcm9tIGFjY2lkZW50YWxseSBhZGRpbmdcbiAgICAgIC8vIHNlY29uZCBhcmd1bWVudCBhbmQgZ2V0dGluZyB1bmV4cGVjdGVkIGBmaW5kT25lYCByZXN1bHRcbiAgICAgIHJldHVybiB0aGlzLl9nZW5lcmFsRmluZChzZWxlY3RvciwgZmFsc2UpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIGEgZmlyc3Qgbm9kZSBmcm9tIGBmaW5kYCBtZXRob2RcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZyB8IEZ1bmN0aW9ufSBzZWxlY3RvclxuICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlIHwgVW5kZWZpbmVkfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gc2VsZWN0IG5vZGUgd2l0aCBpZCBmb29cbiAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUoJyNmb28nKTtcbiAgICAgKlxuICAgICAqIC8vIHNlbGVjdCBub2RlIHdpdGggbmFtZSBiYXIgaW5zaWRlIGxheWVyXG4gICAgICogdmFyIG5vZGVzID0gbGF5ZXIuZmluZE9uZSgnLmJhcicpO1xuICAgICAqXG4gICAgICogLy8gc2VsZWN0IHRoZSBmaXJzdCBub2RlIHRvIHJldHVybiB0cnVlIGluIGEgZnVuY3Rpb25cbiAgICAgKiB2YXIgbm9kZSA9IHN0YWdlLmZpbmRPbmUobm9kZSA9PiB7XG4gICAgICogIHJldHVybiBub2RlLmdldFR5cGUoKSA9PT0gJ1NoYXBlJ1xuICAgICAqIH0pXG4gICAgICovXG4gICAgZmluZE9uZTogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGlzLl9nZW5lcmFsRmluZChzZWxlY3RvciwgdHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDAgPyByZXN1bHRbMF0gOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBfZ2VuZXJhbEZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yLCBmaW5kT25lKSB7XG4gICAgICB2YXIgcmV0QXJyID0gW107XG5cbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldEFyciA9IHRoaXMuX2ZpbmRCeVN0cmluZyhzZWxlY3RvciwgZmluZE9uZSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXRBcnIgPSB0aGlzLl9maW5kQnlGdW5jdGlvbihzZWxlY3RvciwgZmluZE9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBLb252YS5Db2xsZWN0aW9uLnRvQ29sbGVjdGlvbihyZXRBcnIpO1xuICAgIH0sXG4gICAgX2ZpbmRCeVN0cmluZzogZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXSxcbiAgICAgICAgc2VsZWN0b3JBcnIgPSBzZWxlY3Rvci5yZXBsYWNlKC8gL2csICcnKS5zcGxpdCgnLCcpLFxuICAgICAgICBsZW4gPSBzZWxlY3RvckFyci5sZW5ndGgsXG4gICAgICAgIG4sXG4gICAgICAgIGksXG4gICAgICAgIHNlbCxcbiAgICAgICAgYXJyLFxuICAgICAgICBub2RlLFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgY2xlbjtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHNlbCA9IHNlbGVjdG9yQXJyW25dO1xuICAgICAgICBpZiAoIUtvbnZhLlV0aWwuaXNWYWxpZFNlbGVjdG9yKHNlbCkpIHtcbiAgICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgICAnU2VsZWN0b3IgXCInICtcbiAgICAgICAgICAgICAgc2VsICtcbiAgICAgICAgICAgICAgJ1wiIGlzIGludmFsaWQuIEFsbG93ZWQgc2VsZWN0b3JzIGV4YW1wbGVzIGFyZSBcIiNmb29cIiwgXCIuYmFyXCIgb3IgXCJHcm91cFwiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdJZiB5b3UgaGF2ZSBhIGN1c3RvbSBzaGFwZSB3aXRoIHN1Y2ggY2xhc3NOYW1lLCBwbGVhc2UgY2hhbmdlIGl0IHRvIHN0YXJ0IHdpdGggdXBwZXIgbGV0dGVyIGxpa2UgXCJUcmlhbmdsZVwiLidcbiAgICAgICAgICApO1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybignS29udmEgaXMgYXdlc29tZSwgcmlnaHQ/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWQgc2VsZWN0b3JcbiAgICAgICAgaWYgKHNlbC5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl9nZXROb2RlQnlJZChzZWwuc2xpY2UoMSkpO1xuICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICByZXRBcnIucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2VsLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgLy8gbmFtZSBzZWxlY3RvclxuICAgICAgICAgIGFyciA9IHRoaXMuX2dldE5vZGVzQnlOYW1lKHNlbC5zbGljZSgxKSk7XG4gICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChhcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVucmVjb2duaXplZCBzZWxlY3RvciwgcGFzcyB0byBjaGlsZHJlblxuICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgIGNsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNsZW47IGkrKykge1xuICAgICAgICAgICAgcmV0QXJyID0gcmV0QXJyLmNvbmNhdChjaGlsZHJlbltpXS5fZ2V0KHNlbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0QXJyO1xuICAgIH0sXG4gICAgLy8gKGZuOiAoKE5vZGUpID0+IGJvb2xlYW4sIGZpbmRPbmU/OiBib29sZWFuKVxuICAgIF9maW5kQnlGdW5jdGlvbjogZnVuY3Rpb24oZm4sIGZpbmRPbmUpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXTtcblxuICAgICAgdmFyIGFkZEl0ZW1zID0gZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgLy8gZXNjYXBlIGZ1bmN0aW9uIGlmIHdlJ3ZlIGFscmVhZHkgZm91bmQgb25lLlxuICAgICAgICBpZiAoZmluZE9uZSAmJiByZXRBcnIubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHZhciBjbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIGlmIChmbihlbCkpIHtcbiAgICAgICAgICByZXRBcnIgPSByZXRBcnIuY29uY2F0KGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xlbjsgaSsrKSB7XG4gICAgICAgICAgYWRkSXRlbXMoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBhZGRJdGVtcyh0aGlzKTtcblxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9LFxuICAgIF9nZXROb2RlQnlJZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgbm9kZSA9IEtvbnZhLmlkc1trZXldO1xuXG4gICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaXNBbmNlc3Rvck9mKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBfZ2V0Tm9kZXNCeU5hbWU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGFyciA9IEtvbnZhLm5hbWVzW2tleV0gfHwgW107XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0RGVzY2VuZGFudHMoYXJyKTtcbiAgICB9LFxuICAgIF9nZXQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgcmV0QXJyID0gS29udmEuTm9kZS5wcm90b3R5cGUuX2dldC5jYWxsKHRoaXMsIHNlbGVjdG9yKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIHZhciBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIHJldEFyciA9IHJldEFyci5jb25jYXQoY2hpbGRyZW5bbl0uX2dldChzZWxlY3RvcikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9LFxuICAgIC8vIGV4dGVuZGVyc1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSBLb252YS5Ob2RlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBvYmouY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbGVuOyBuKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbl07XG4gICAgICAgIG9iai5jaGlsZHJlbi5wdXNoKGNoaWxkLnRvT2JqZWN0KCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgX2dldERlc2NlbmRhbnRzOiBmdW5jdGlvbihhcnIpIHtcbiAgICAgIHZhciByZXRBcnIgPSBbXTtcbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICB2YXIgbm9kZSA9IGFycltuXTtcbiAgICAgICAgaWYgKHRoaXMuaXNBbmNlc3Rvck9mKG5vZGUpKSB7XG4gICAgICAgICAgcmV0QXJyLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldEFycjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpZiBub2RlIGlzIGFuIGFuY2VzdG9yXG4gICAgICogb2YgZGVzY2VuZGFudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7S29udmEuTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGlzQW5jZXN0b3JPZjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQuX2lkID09PSB0aGlzLl9pZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgLy8gY2FsbCBzdXBlciBtZXRob2RcbiAgICAgIHZhciBub2RlID0gS29udmEuTm9kZS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihubykge1xuICAgICAgICBub2RlLmFkZChuby5jbG9uZSgpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgYWxsIHNoYXBlcyB0aGF0IGludGVyc2VjdCBhIHBvaW50LiAgTm90ZTogYmVjYXVzZSB0aGlzIG1ldGhvZCBtdXN0IGNsZWFyIGEgdGVtcG9yYXJ5XG4gICAgICogY2FudmFzIGFuZCByZWRyYXcgZXZlcnkgc2hhcGUgaW5zaWRlIHRoZSBjb250YWluZXIsIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIHNwZWNpYWwgc2l0YXRpb25zXG4gICAgICogYmVjYXVzZSBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseS4gIFBsZWFzZSB1c2UgdGhlIHtAbGluayBLb252YS5TdGFnZSNnZXRJbnRlcnNlY3Rpb259IG1ldGhvZCBpZiBhdCBhbGwgcG9zc2libGVcbiAgICAgKiBiZWNhdXNlIGl0IHBlcmZvcm1zIG11Y2ggYmV0dGVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gYXJyYXkgb2Ygc2hhcGVzXG4gICAgICovXG4gICAgZ2V0QWxsSW50ZXJzZWN0aW9uczogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgYXJyID0gW107XG5cbiAgICAgIHRoaXMuZmluZCgnU2hhcGUnKS5lYWNoKGZ1bmN0aW9uKHNoYXBlKSB7XG4gICAgICAgIGlmIChzaGFwZS5pc1Zpc2libGUoKSAmJiBzaGFwZS5pbnRlcnNlY3RzKHBvcykpIHtcbiAgICAgICAgICBhcnIucHVzaChzaGFwZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG4gICAgX3NldENoaWxkcmVuSW5kaWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmVhY2goZnVuY3Rpb24oY2hpbGQsIG4pIHtcbiAgICAgICAgY2hpbGQuaW5kZXggPSBuO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgIGNhbnZhcyA9IGNhbiB8fCAobGF5ZXIgJiYgbGF5ZXIuZ2V0Q2FudmFzKCkpLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgY2FjaGVkU2NlbmVDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLnNjZW5lO1xuXG4gICAgICBpZiAodGhpcy5pc1Zpc2libGUoKSB8fCBjYWNoaW5nKSB7XG4gICAgICAgIGlmICghY2FjaGluZyAmJiBjYWNoZWRTY2VuZUNhbnZhcykge1xuICAgICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgIHRoaXMuX2RyYXdDYWNoZWRTY2VuZUNhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oY2FudmFzLCAnZHJhd1NjZW5lJywgdG9wLCBmYWxzZSwgY2FjaGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5oaXRDYW52YXMpLFxuICAgICAgICBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgY2FjaGVkSGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzICYmIGNhY2hlZENhbnZhcy5oaXQ7XG5cbiAgICAgIGlmICh0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSB8fCBjYWNoaW5nKSB7XG4gICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgIGxheWVyLmNsZWFySGl0Q2FjaGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhY2hpbmcgJiYgY2FjaGVkSGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kcmF3Q2hpbGRyZW4oY2FudmFzLCAnZHJhd0hpdCcsIHRvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgX2RyYXdDaGlsZHJlbjogZnVuY3Rpb24oY2FudmFzLCBkcmF3TWV0aG9kLCB0b3AsIGNhY2hpbmcsIHNraXBCdWZmZXIpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCgpLFxuICAgICAgICBjbGlwV2lkdGggPSB0aGlzLmdldENsaXBXaWR0aCgpLFxuICAgICAgICBjbGlwSGVpZ2h0ID0gdGhpcy5nZXRDbGlwSGVpZ2h0KCksXG4gICAgICAgIGNsaXBGdW5jID0gdGhpcy5nZXRDbGlwRnVuYygpLFxuICAgICAgICBoYXNDbGlwID0gKGNsaXBXaWR0aCAmJiBjbGlwSGVpZ2h0KSB8fCBjbGlwRnVuYyxcbiAgICAgICAgY2xpcFgsXG4gICAgICAgIGNsaXBZO1xuXG4gICAgICBpZiAoaGFzQ2xpcCAmJiBsYXllcikge1xuICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKTtcbiAgICAgICAgdmFyIG0gPSB0cmFuc2Zvcm0uZ2V0TWF0cml4KCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoY2xpcEZ1bmMpIHtcbiAgICAgICAgICBjbGlwRnVuYy5jYWxsKHRoaXMsIGNvbnRleHQsIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaXBYID0gdGhpcy5nZXRDbGlwWCgpO1xuICAgICAgICAgIGNsaXBZID0gdGhpcy5nZXRDbGlwWSgpO1xuICAgICAgICAgIGNvbnRleHQucmVjdChjbGlwWCwgY2xpcFksIGNsaXBXaWR0aCwgY2xpcEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jbGlwKCk7XG4gICAgICAgIG0gPSB0cmFuc2Zvcm1cbiAgICAgICAgICAuY29weSgpXG4gICAgICAgICAgLmludmVydCgpXG4gICAgICAgICAgLmdldE1hdHJpeCgpO1xuICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkW2RyYXdNZXRob2RdKGNhbnZhcywgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaGFzQ2xpcCkge1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3VsZERyYXdIaXQ6IGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpO1xuICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICB2YXIgbGF5ZXJVbmRlckRyYWcgPVxuICAgICAgICBkZCAmJlxuICAgICAgICBLb252YS5pc0RyYWdnaW5nKCkgJiZcbiAgICAgICAgS29udmEuREQuYW5pbS5nZXRMYXllcnMoKS5pbmRleE9mKGxheWVyKSAhPT0gLTE7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY2FudmFzICYmIGNhbnZhcy5pc0NhY2hlKSB8fFxuICAgICAgICAobGF5ZXIgJiZcbiAgICAgICAgICBsYXllci5oaXRHcmFwaEVuYWJsZWQoKSAmJlxuICAgICAgICAgIHRoaXMuaXNWaXNpYmxlKCkgJiZcbiAgICAgICAgICAhbGF5ZXJVbmRlckRyYWcpXG4gICAgICApO1xuICAgIH0sXG4gICAgZ2V0Q2xpZW50UmVjdDogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICB2YXIgc2tpcFRyYW5zZm9ybSA9IGF0dHJzLnNraXBUcmFuc2Zvcm07XG4gICAgICB2YXIgcmVsYXRpdmVUbyA9IGF0dHJzLnJlbGF0aXZlVG87XG5cbiAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZO1xuICAgICAgdmFyIHNlbGZSZWN0ID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgdGhpcy5jaGlsZHJlbi5lYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIC8vIHNraXAgaW52aXNpYmxlIGNoaWxkcmVuXG4gICAgICAgIGlmICghY2hpbGQuZ2V0VmlzaWJsZSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlY3QgPSBjaGlsZC5nZXRDbGllbnRSZWN0KHsgcmVsYXRpdmVUbzogdGhhdCB9KTtcblxuICAgICAgICAvLyBza2lwIGludmlzaWJsZSBjaGlsZHJlbiAobGlrZSBlbXB0eSBncm91cHMpXG4gICAgICAgIC8vIG9yIGRvbid0IHNraXAuLi4gaG1tbS4uLlxuICAgICAgICAvLyBpZiAocmVjdC53aWR0aCA9PT0gMCAmJiByZWN0LmhlaWdodCA9PT0gMCkge1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIGluaXRpYWwgdmFsdWUgZm9yIGZpcnN0IGNoaWxkXG4gICAgICAgICAgbWluWCA9IHJlY3QueDtcbiAgICAgICAgICBtaW5ZID0gcmVjdC55O1xuICAgICAgICAgIG1heFggPSByZWN0LnggKyByZWN0LndpZHRoO1xuICAgICAgICAgIG1heFkgPSByZWN0LnkgKyByZWN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgcmVjdC54KTtcbiAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgcmVjdC55KTtcbiAgICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgcmVjdC54ICsgcmVjdC53aWR0aCk7XG4gICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHJlY3QueSArIHJlY3QuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGlmIGNoaWxkIGlzIGdyb3VwIHdlIG5lZWQgdG8gbWFrZSBzdXJlIGl0IGhhcyB2aXNpYmxlIHNoYXBlcyBpbnNpZGVcbiAgICAgIHZhciBzaGFwZXMgPSB0aGlzLmZpbmQoJ1NoYXBlJyk7XG4gICAgICB2YXIgaGFzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNoYXBlID0gc2hhcGVzW2ldO1xuICAgICAgICBpZiAoc2hhcGUuZ2V0VmlzaWJsZSgpKSB7XG4gICAgICAgICAgaGFzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc1Zpc2libGUpIHtcbiAgICAgICAgc2VsZlJlY3QgPSB7XG4gICAgICAgICAgeDogbWluWCxcbiAgICAgICAgICB5OiBtaW5ZLFxuICAgICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCxcbiAgICAgICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHNlbGZSZWN0LCByZWxhdGl2ZVRvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmUmVjdDtcbiAgICB9XG4gIH0pO1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkNvbnRhaW5lciwgS29udmEuTm9kZSk7XG4gIC8vIGRlcHJlY2F0ZWQgbWV0aG9kc1xuICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmdldCA9IEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZmluZDtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwJywgW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3dpZHRoJyxcbiAgICAnaGVpZ2h0J1xuICBdKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcFxuICAgKiBAbWV0aG9kXG4gICAqIEBuYW1lIGNsaXBcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNsaXBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNsaXAueFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2xpcC55XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLndpZHRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjbGlwLmhlaWdodFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcFxuICAgKiB2YXIgY2xpcCA9IGNvbnRhaW5lci5jbGlwKCk7XG4gICAqXG4gICAqIC8vIHNldCBjbGlwXG4gICAqIGNvbnRhaW5lci5zZXRDbGlwKHtcbiAgICogICB4OiAyMCxcbiAgICogICB5OiAyMCxcbiAgICogICB3aWR0aDogMjAsXG4gICAqICAgaGVpZ2h0OiAyMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQ29udGFpbmVyLCAnY2xpcFgnKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcCB4XG4gICAqIEBuYW1lIGNsaXBYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsaXAgeFxuICAgKiB2YXIgY2xpcFggPSBjb250YWluZXIuY2xpcFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgeFxuICAgKiBjb250YWluZXIuY2xpcFgoMTApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Db250YWluZXIsICdjbGlwWScpO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGlwIHlcbiAgICogQG5hbWUgY2xpcFlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcCB5XG4gICAqIHZhciBjbGlwWSA9IGNvbnRhaW5lci5jbGlwWSgpO1xuICAgKlxuICAgKiAvLyBzZXQgY2xpcCB5XG4gICAqIGNvbnRhaW5lci5jbGlwWSgxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBXaWR0aCcpO1xuICAvKipcbiAgICogZ2V0L3NldCBjbGlwIHdpZHRoXG4gICAqIEBuYW1lIGNsaXBXaWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xpcCB3aWR0aFxuICAgKiB2YXIgY2xpcFdpZHRoID0gY29udGFpbmVyLmNsaXBXaWR0aCgpO1xuICAgKlxuICAgKiAvLyBzZXQgY2xpcCB3aWR0aFxuICAgKiBjb250YWluZXIuY2xpcFdpZHRoKDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBIZWlnaHQnKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xpcCBoZWlnaHRcbiAgICogQG5hbWUgY2xpcEhlaWdodFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Db250YWluZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsaXAgaGVpZ2h0XG4gICAqIHZhciBjbGlwSGVpZ2h0ID0gY29udGFpbmVyLmNsaXBIZWlnaHQoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAqIGNvbnRhaW5lci5jbGlwSGVpZ2h0KDEwMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkNvbnRhaW5lciwgJ2NsaXBGdW5jJyk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGNsaXAgZnVuY3Rpb25cbiAgICogQG5hbWUgY2xpcEZ1bmNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jdGlvblxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBjbGlwIGZ1bmN0aW9uXG4gICAqIHZhciBjbGlwRnVuY3Rpb24gPSBjb250YWluZXIuY2xpcEZ1bmMoKTtcbiAgICpcbiAgICogLy8gc2V0IGNsaXAgaGVpZ2h0XG4gICAqIGNvbnRhaW5lci5jbGlwRnVuYyhmdW5jdGlvbihjdHgpIHtcbiAgICogICBjdHgucmVjdCgwLCAwLCAxMDAsIDEwMCk7XG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ29udGFpbmVyKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBIQVNfU0hBRE9XID0gJ2hhc1NoYWRvdyc7XG4gIHZhciBTSEFET1dfUkdCQSA9ICdzaGFkb3dSR0JBJztcblxuICBmdW5jdGlvbiBfZmlsbEZ1bmMoY29udGV4dCkge1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZSgpO1xuICB9XG4gIGZ1bmN0aW9uIF9maWxsRnVuY0hpdChjb250ZXh0KSB7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgZnVuY3Rpb24gX3N0cm9rZUZ1bmNIaXQoY29udGV4dCkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBfY2xlYXJIYXNTaGFkb3dDYWNoZSgpIHtcbiAgICB0aGlzLl9jbGVhckNhY2hlKEhBU19TSEFET1cpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlKCkge1xuICAgIHRoaXMuX2NsZWFyQ2FjaGUoU0hBRE9XX1JHQkEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNoYXBlIGNvbnN0cnVjdG9yLiAgU2hhcGVzIGFyZSBwcmltaXRpdmUgb2JqZWN0cyBzdWNoIGFzIHJlY3RhbmdsZXMsXG4gICAqICBjaXJjbGVzLCB0ZXh0LCBsaW5lcywgZXRjLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5Ob2RlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBjdXN0b21TaGFwZSA9IG5ldyBLb252YS5TaGFwZSh7XG4gICAqICAgeDogNSxcbiAgICogICB5OiAxMCxcbiAgICogICBmaWxsOiAncmVkJyxcbiAgICogICAvLyBhIEtvbnZhLkNhbnZhcyByZW5kZXJlciBpcyBwYXNzZWQgaW50byB0aGUgZHJhd0Z1bmMgZnVuY3Rpb25cbiAgICogICBkcmF3RnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgKiAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICogICAgIGNvbnRleHQubW92ZVRvKDIwMCwgNTApO1xuICAgKiAgICAgY29udGV4dC5saW5lVG8oNDIwLCA4MCk7XG4gICAqICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMzAwLCAxMDAsIDI2MCwgMTcwKTtcbiAgICogICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAqICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICogICB9XG4gICAqfSk7XG4gICAqL1xuICBLb252YS5TaGFwZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLlNoYXBlLCB7XG4gICAgX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnU2hhcGUnO1xuICAgICAgdGhpcy5fZmlsbEZ1bmMgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jID0gX3N0cm9rZUZ1bmM7XG4gICAgICB0aGlzLl9maWxsRnVuY0hpdCA9IF9maWxsRnVuY0hpdDtcbiAgICAgIHRoaXMuX3N0cm9rZUZ1bmNIaXQgPSBfc3Ryb2tlRnVuY0hpdDtcblxuICAgICAgLy8gc2V0IGNvbG9yS2V5XG4gICAgICB2YXIgc2hhcGVzID0gS29udmEuc2hhcGVzO1xuICAgICAgdmFyIGtleTtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAga2V5ID0gS29udmEuVXRpbC5nZXRSYW5kb21Db2xvcigpO1xuICAgICAgICBpZiAoa2V5ICYmICEoa2V5IGluIHNoYXBlcykpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbG9yS2V5ID0ga2V5O1xuICAgICAgc2hhcGVzW2tleV0gPSB0aGlzO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5Ob2RlLmNhbGwodGhpcywgY29uZmlnKTtcblxuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3NoYWRvd0NvbG9yQ2hhbmdlLmtvbnZhIHNoYWRvd0JsdXJDaGFuZ2Uua29udmEgc2hhZG93T2Zmc2V0Q2hhbmdlLmtvbnZhIHNoYWRvd09wYWNpdHlDaGFuZ2Uua29udmEgc2hhZG93RW5hYmxlZENoYW5nZS5rb252YScsXG4gICAgICAgIF9jbGVhckhhc1NoYWRvd0NhY2hlXG4gICAgICApO1xuXG4gICAgICB0aGlzLm9uKFxuICAgICAgICAnc2hhZG93Q29sb3JDaGFuZ2Uua29udmEgc2hhZG93T3BhY2l0eUNoYW5nZS5rb252YSBzaGFkb3dFbmFibGVkQ2hhbmdlLmtvbnZhJyxcbiAgICAgICAgX2NsZWFyR2V0U2hhZG93UkdCQUNhY2hlXG4gICAgICApO1xuICAgIH0sXG4gICAgaGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNhbnZhcyBjb250ZXh0IHRpZWQgdG8gdGhlIGxheWVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuQ29udGV4dH1cbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExheWVyKCkuZ2V0Q29udGV4dCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGNhbnZhcyByZW5kZXJlciB0aWVkIHRvIHRoZSBsYXllci4gIE5vdGUgdGhhdCB0aGlzIHJldHVybnMgYSBjYW52YXMgcmVuZGVyZXIsIG5vdCBhIGNhbnZhcyBlbGVtZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuQ2FudmFzfVxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXllcigpLmdldENhbnZhcygpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNoYWRvdyB3aWxsIGJlIHJlbmRlcmVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldENhY2hlKEhBU19TSEFET1csIHRoaXMuX2hhc1NoYWRvdyk7XG4gICAgfSxcbiAgICBfaGFzU2hhZG93OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuZ2V0U2hhZG93RW5hYmxlZCgpICYmXG4gICAgICAgICh0aGlzLmdldFNoYWRvd09wYWNpdHkoKSAhPT0gMCAmJlxuICAgICAgICAgICEhKFxuICAgICAgICAgICAgdGhpcy5nZXRTaGFkb3dDb2xvcigpIHx8XG4gICAgICAgICAgICB0aGlzLmdldFNoYWRvd0JsdXIoKSB8fFxuICAgICAgICAgICAgdGhpcy5nZXRTaGFkb3dPZmZzZXRYKCkgfHxcbiAgICAgICAgICAgIHRoaXMuZ2V0U2hhZG93T2Zmc2V0WSgpXG4gICAgICAgICAgKSlcbiAgICAgICk7XG4gICAgfSxcbiAgICBnZXRTaGFkb3dSR0JBOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDYWNoZShTSEFET1dfUkdCQSwgdGhpcy5fZ2V0U2hhZG93UkdCQSk7XG4gICAgfSxcbiAgICBfZ2V0U2hhZG93UkdCQTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5oYXNTaGFkb3coKSkge1xuICAgICAgICB2YXIgcmdiYSA9IEtvbnZhLlV0aWwuY29sb3JUb1JHQkEodGhpcy5zaGFkb3dDb2xvcigpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAncmdiYSgnICtcbiAgICAgICAgICByZ2JhLnIgK1xuICAgICAgICAgICcsJyArXG4gICAgICAgICAgcmdiYS5nICtcbiAgICAgICAgICAnLCcgK1xuICAgICAgICAgIHJnYmEuYiArXG4gICAgICAgICAgJywnICtcbiAgICAgICAgICByZ2JhLmEgKiAodGhpcy5nZXRTaGFkb3dPcGFjaXR5KCkgfHwgMSkgK1xuICAgICAgICAgICcpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgc2hhcGUgd2lsbCBiZSBmaWxsZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEhKFxuICAgICAgICB0aGlzLmdldEZpbGwoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxQYXR0ZXJuSW1hZ2UoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSB8fFxuICAgICAgICB0aGlzLmdldEZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHNoYXBlIHdpbGwgYmUgc3Ryb2tlZFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuc3Ryb2tlRW5hYmxlZCgpICYmXG4gICAgICAgICEhKHRoaXMuc3Ryb2tlKCkgfHwgdGhpcy5nZXRTdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoKSlcbiAgICAgICAgLy8gVE9ETzogZG8gd2UgbmVlZCByYWRpYWwgZ3JhZGllbnRcbiAgICAgICAgLy8gdGhpcy5nZXRTdHJva2VSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgaWYgcG9pbnQgaXMgaW4gdGhlIHNoYXBlLCByZWdhcmRsZXNzIGlmIG90aGVyIHNoYXBlcyBhcmUgb24gdG9wIG9mIGl0LiAgTm90ZTogYmVjYXVzZVxuICAgICAqICB0aGlzIG1ldGhvZCBjbGVhcnMgYSB0ZW1wb3JhcnkgY2FudmFzIGFuZCB0aGVuIHJlZHJhd3MgdGhlIHNoYXBlLCBpdCBwZXJmb3JtcyB2ZXJ5IHBvb3JseSBpZiBleGVjdXRlZCBtYW55IHRpbWVzXG4gICAgICogIGNvbnNlY3V0aXZlbHkuICBQbGVhc2UgdXNlIHRoZSB7QGxpbmsgS29udmEuU3RhZ2UjZ2V0SW50ZXJzZWN0aW9ufSBtZXRob2QgaWYgYXQgYWxsIHBvc3NpYmxlXG4gICAgICogIGJlY2F1c2UgaXQgcGVyZm9ybXMgbXVjaCBiZXR0ZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50LnlcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpLFxuICAgICAgICBidWZmZXJIaXRDYW52YXMgPSBzdGFnZS5idWZmZXJIaXRDYW52YXMsXG4gICAgICAgIHA7XG5cbiAgICAgIGJ1ZmZlckhpdENhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgIHRoaXMuZHJhd0hpdChidWZmZXJIaXRDYW52YXMpO1xuICAgICAgcCA9IGJ1ZmZlckhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC54KSxcbiAgICAgICAgTWF0aC5yb3VuZChwb2ludC55KSxcbiAgICAgICAgMSxcbiAgICAgICAgMVxuICAgICAgKS5kYXRhO1xuICAgICAgcmV0dXJuIHBbM10gPiAwO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kcyBOb2RlLnByb3RvdHlwZS5kZXN0cm95XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gICAgICBkZWxldGUgS29udmEuc2hhcGVzW3RoaXMuY29sb3JLZXldO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBfdXNlQnVmZmVyQ2FudmFzOiBmdW5jdGlvbihjYWNoaW5nKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoIWNhY2hpbmcgJiZcbiAgICAgICAgICAodGhpcy5wZXJmZWN0RHJhd0VuYWJsZWQoKSAmJlxuICAgICAgICAgICAgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSAmJlxuICAgICAgICAgICAgdGhpcy5oYXNGaWxsKCkgJiZcbiAgICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICAgIHRoaXMuZ2V0U3RhZ2UoKSkpIHx8XG4gICAgICAgICh0aGlzLnBlcmZlY3REcmF3RW5hYmxlZCgpICYmXG4gICAgICAgICAgdGhpcy5oYXNTaGFkb3coKSAmJlxuICAgICAgICAgIHRoaXMuZ2V0QWJzb2x1dGVPcGFjaXR5KCkgIT09IDEgJiZcbiAgICAgICAgICB0aGlzLmhhc0ZpbGwoKSAmJlxuICAgICAgICAgIHRoaXMuaGFzU3Ryb2tlKCkgJiZcbiAgICAgICAgICB0aGlzLmdldFN0YWdlKCkpXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHNlbGYgcmVjdGFuZ2xlICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSBvZiBzaGFwZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBhcmUgbm90IHRha2VuIGludG8gYWNjb3VudCB0cmFuc2Zvcm1hdGlvbiBhbmQgc3R5bGVzLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gcmVjdCB3aXRoIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBwcm9wZXJ0aWVzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHJlY3QuZ2V0U2VsZlJlY3QoKTsgIC8vIHJldHVybiB7eDowLCB5OjAsIHdpZHRoOnJlY3Qud2lkdGgoKSwgaGVpZ2h0OnJlY3QuaGVpZ2h0KCl9XG4gICAgICogY2lyY2xlLmdldFNlbGZSZWN0KCk7ICAvLyByZXR1cm4ge3g6IC0gY2lyY2xlLndpZHRoKCkgLyAyLCB5OiAtIGNpcmNsZS5oZWlnaHQoKSAvIDIsIHdpZHRoOmNpcmNsZS53aWR0aCgpLCBoZWlnaHQ6Y2lyY2xlLmhlaWdodCgpfVxuICAgICAqXG4gICAgICovXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLmdldFNpemUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMuX2NlbnRyb2lkID8gTWF0aC5yb3VuZCgtc2l6ZS53aWR0aCAvIDIpIDogMCxcbiAgICAgICAgeTogdGhpcy5fY2VudHJvaWQgPyBNYXRoLnJvdW5kKC1zaXplLmhlaWdodCAvIDIpIDogMCxcbiAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgIGhlaWdodDogc2l6ZS5oZWlnaHRcbiAgICAgIH07XG4gICAgfSxcbiAgICBnZXRDbGllbnRSZWN0OiBmdW5jdGlvbihhdHRycykge1xuICAgICAgYXR0cnMgPSBhdHRycyB8fCB7fTtcbiAgICAgIHZhciBza2lwVHJhbnNmb3JtID0gYXR0cnMuc2tpcFRyYW5zZm9ybTtcbiAgICAgIHZhciByZWxhdGl2ZVRvID0gYXR0cnMucmVsYXRpdmVUbztcblxuICAgICAgdmFyIGZpbGxSZWN0ID0gdGhpcy5nZXRTZWxmUmVjdCgpO1xuXG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSAodGhpcy5oYXNTdHJva2UoKSAmJiB0aGlzLnN0cm9rZVdpZHRoKCkpIHx8IDA7XG4gICAgICB2YXIgZmlsbEFuZFN0cm9rZVdpZHRoID0gZmlsbFJlY3Qud2lkdGggKyBzdHJva2VXaWR0aDtcbiAgICAgIHZhciBmaWxsQW5kU3Ryb2tlSGVpZ2h0ID0gZmlsbFJlY3QuaGVpZ2h0ICsgc3Ryb2tlV2lkdGg7XG5cbiAgICAgIHZhciBzaGFkb3dPZmZzZXRYID0gdGhpcy5oYXNTaGFkb3coKSA/IHRoaXMuc2hhZG93T2Zmc2V0WCgpIDogMDtcbiAgICAgIHZhciBzaGFkb3dPZmZzZXRZID0gdGhpcy5oYXNTaGFkb3coKSA/IHRoaXMuc2hhZG93T2Zmc2V0WSgpIDogMDtcblxuICAgICAgdmFyIHByZVdpZHRoID0gZmlsbEFuZFN0cm9rZVdpZHRoICsgTWF0aC5hYnMoc2hhZG93T2Zmc2V0WCk7XG4gICAgICB2YXIgcHJlSGVpZ2h0ID0gZmlsbEFuZFN0cm9rZUhlaWdodCArIE1hdGguYWJzKHNoYWRvd09mZnNldFkpO1xuXG4gICAgICB2YXIgYmx1clJhZGl1cyA9ICh0aGlzLmhhc1NoYWRvdygpICYmIHRoaXMuc2hhZG93Qmx1cigpKSB8fCAwO1xuXG4gICAgICB2YXIgd2lkdGggPSBwcmVXaWR0aCArIGJsdXJSYWRpdXMgKiAyO1xuICAgICAgdmFyIGhlaWdodCA9IHByZUhlaWdodCArIGJsdXJSYWRpdXMgKiAyO1xuXG4gICAgICAvLyBpZiBzdHJva2UsIGZvciBleGFtcGxlID0gM1xuICAgICAgLy8gd2UgbmVlZCB0byBzZXQgeCB0byAxLjUsIGJ1dCBhZnRlciBNYXRoLnJvdW5kIGl0IHdpbGwgYmUgMlxuICAgICAgLy8gYXMgd2UgaGF2ZSBhZGRpdGlvbmFsIG9mZnNldCB3ZSBuZWVkIHRvIGluY3JlYXNlIHdpZHRoIGFuZCBoZWlnaHQgYnkgMSBwaXhlbFxuICAgICAgdmFyIHJvdW5kaW5nT2Zmc2V0ID0gMDtcbiAgICAgIGlmIChNYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMikgIT09IHN0cm9rZVdpZHRoIC8gMikge1xuICAgICAgICByb3VuZGluZ09mZnNldCA9IDE7XG4gICAgICB9XG4gICAgICB2YXIgcmVjdCA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgcm91bmRpbmdPZmZzZXQsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgcm91bmRpbmdPZmZzZXQsXG4gICAgICAgIHg6XG4gICAgICAgICAgLU1hdGgucm91bmQoc3Ryb2tlV2lkdGggLyAyICsgYmx1clJhZGl1cykgK1xuICAgICAgICAgIE1hdGgubWluKHNoYWRvd09mZnNldFgsIDApICtcbiAgICAgICAgICBmaWxsUmVjdC54LFxuICAgICAgICB5OlxuICAgICAgICAgIC1NYXRoLnJvdW5kKHN0cm9rZVdpZHRoIC8gMiArIGJsdXJSYWRpdXMpICtcbiAgICAgICAgICBNYXRoLm1pbihzaGFkb3dPZmZzZXRZLCAwKSArXG4gICAgICAgICAgZmlsbFJlY3QueVxuICAgICAgfTtcbiAgICAgIGlmICghc2tpcFRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRSZWN0KHJlY3QsIHJlbGF0aXZlVG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbiwgdG9wLCBjYWNoaW5nLCBza2lwQnVmZmVyKSB7XG4gICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCksXG4gICAgICAgIGNhbnZhcyA9IGNhbiB8fCBsYXllci5nZXRDYW52YXMoKSxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGNhY2hlZENhbnZhcyA9IHRoaXMuX2NhY2hlLmNhbnZhcyxcbiAgICAgICAgZHJhd0Z1bmMgPSB0aGlzLnNjZW5lRnVuYygpLFxuICAgICAgICBoYXNTaGFkb3cgPSB0aGlzLmhhc1NoYWRvdygpLFxuICAgICAgICBoYXNTdHJva2UgPSB0aGlzLmhhc1N0cm9rZSgpLFxuICAgICAgICBzdGFnZSxcbiAgICAgICAgYnVmZmVyQ2FudmFzLFxuICAgICAgICBidWZmZXJDb250ZXh0O1xuXG4gICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKCkgJiYgIWNhY2hpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVkQ2FudmFzKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgdGhpcy5fZHJhd0NhY2hlZFNjZW5lQ2FudmFzKGNvbnRleHQpO1xuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoIWRyYXdGdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAvLyBpZiBidWZmZXIgY2FudmFzIGlzIG5lZWRlZFxuICAgICAgaWYgKHRoaXMuX3VzZUJ1ZmZlckNhbnZhcyhjYWNoaW5nKSAmJiAhc2tpcEJ1ZmZlcikge1xuICAgICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgYnVmZmVyQ2FudmFzID0gc3RhZ2UuYnVmZmVyQ2FudmFzO1xuICAgICAgICBidWZmZXJDb250ZXh0ID0gYnVmZmVyQ2FudmFzLmdldENvbnRleHQoKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5jbGVhcigpO1xuICAgICAgICBidWZmZXJDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgICAgLy8gbGF5ZXIgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIHdlIGFyZSB1c2luZyBjYWNoZSBiZWZvcmUgYWRkaW5nIHRvIGxheWVyXG4gICAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICAgIGlmIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIuX2FwcGx5VHJhbnNmb3JtKHRoaXMsIGJ1ZmZlckNvbnRleHQsIHRvcCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtID0gdGhpcy5nZXRBYnNvbHV0ZVRyYW5zZm9ybSh0b3ApLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgY29udGV4dC50cmFuc2Zvcm0obVswXSwgbVsxXSwgbVsyXSwgbVszXSwgbVs0XSwgbVs1XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBidWZmZXJDb250ZXh0KTtcbiAgICAgICAgYnVmZmVyQ29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgICAgdmFyIHJhdGlvID0gYnVmZmVyQ2FudmFzLnBpeGVsUmF0aW87XG4gICAgICAgIGlmIChoYXNTaGFkb3cgJiYgIWNhbnZhcy5oaXRDYW52YXMpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgICAgIGNvbnRleHQuX2FwcGx5U2hhZG93KHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICBjb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5fY2FudmFzLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBidWZmZXJDYW52YXMud2lkdGggLyByYXRpbyxcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy5oZWlnaHQgLyByYXRpb1xuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlPcGFjaXR5KHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgYnVmZmVyQ2FudmFzLl9jYW52YXMsXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGJ1ZmZlckNhbnZhcy53aWR0aCAvIHJhdGlvLFxuICAgICAgICAgICAgYnVmZmVyQ2FudmFzLmhlaWdodCAvIHJhdGlvXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgYnVmZmVyIGNhbnZhcyBpcyBub3QgbmVlZGVkXG4gICAgICAgIGNvbnRleHQuX2FwcGx5TGluZUpvaW4odGhpcyk7XG4gICAgICAgIC8vIGxheWVyIG1pZ2h0IGJlIHVuZGVmaW5lZCBpZiB3ZSBhcmUgdXNpbmcgY2FjaGUgYmVmb3JlIGFkZGluZyB0byBsYXllclxuICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGxheWVyLl9hcHBseVRyYW5zZm9ybSh0aGlzLCBjb250ZXh0LCB0b3ApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNmb3JtKG9bMF0sIG9bMV0sIG9bMl0sIG9bM10sIG9bNF0sIG9bNV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNTaGFkb3cgJiYgaGFzU3Ryb2tlICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgLy8gYXBwbHkgc2hhZG93XG4gICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG5cbiAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICAgIC8vIGlmIHNoYXBlIGhhcyBzdHJva2Ugd2UgbmVlZCB0byByZWRyYXcgc2hhcGVcbiAgICAgICAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBzZWUgYSBzaGFkb3cgdW5kZXIgc3Ryb2tlIChhbmQgb3ZlciBmaWxsKVxuICAgICAgICAgIC8vIGJ1dCBJIHRoaW5rIHRoaXMgaXMgdW5leHBlY3RlZCBiZWhhdmlvclxuICAgICAgICAgIGlmICh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmdldFNoYWRvd0ZvclN0cm9rZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzU2hhZG93ICYmICFjYW52YXMuaGl0Q2FudmFzKSB7XG4gICAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgaWYgKCFjYWNoaW5nKSB7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseU9wYWNpdHkodGhpcyk7XG4gICAgICAgICAgICBjb250ZXh0Ll9hcHBseUdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbih0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGV4dC5fYXBwbHlTaGFkb3codGhpcyk7XG4gICAgICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNhY2hpbmcpIHtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5T3BhY2l0eSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FwcGx5R2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkcmF3RnVuYy5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhd0hpdDogZnVuY3Rpb24oY2FuLCB0b3AsIGNhY2hpbmcpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSxcbiAgICAgICAgY2FudmFzID0gY2FuIHx8IGxheWVyLmhpdENhbnZhcyxcbiAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGRyYXdGdW5jID0gdGhpcy5oaXRGdW5jKCkgfHwgdGhpcy5zY2VuZUZ1bmMoKSxcbiAgICAgICAgY2FjaGVkQ2FudmFzID0gdGhpcy5fY2FjaGUuY2FudmFzLFxuICAgICAgICBjYWNoZWRIaXRDYW52YXMgPSBjYWNoZWRDYW52YXMgJiYgY2FjaGVkQ2FudmFzLmhpdDtcblxuICAgICAgaWYgKCF0aGlzLnNob3VsZERyYXdIaXQoY2FudmFzKSAmJiAhY2FjaGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGlmIChsYXllcikge1xuICAgICAgICBsYXllci5jbGVhckhpdENhY2hlKCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FjaGVkSGl0Q2FudmFzKSB7XG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgdGhpcy5fZHJhd0NhY2hlZEhpdENhbnZhcyhjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgaWYgKCFkcmF3RnVuYykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC5fYXBwbHlMaW5lSm9pbih0aGlzKTtcbiAgICAgIGlmICghY2FjaGluZykge1xuICAgICAgICBpZiAobGF5ZXIpIHtcbiAgICAgICAgICBsYXllci5fYXBwbHlUcmFuc2Zvcm0odGhpcywgY29udGV4dCwgdG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbyA9IHRoaXMuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zZm9ybShvWzBdLCBvWzFdLCBvWzJdLCBvWzNdLCBvWzRdLCBvWzVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZHJhd0Z1bmMuY2FsbCh0aGlzLCBjb250ZXh0KTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBkcmF3IGhpdCBncmFwaCB1c2luZyB0aGUgY2FjaGVkIHNjZW5lIGNhbnZhc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBhbHBoYVRocmVzaG9sZCBhbHBoYSBjaGFubmVsIHRocmVzaG9sZCB0aGF0IGRldGVybWluZXMgd2hldGhlciBvciBub3RcbiAgICAgKiAgYSBwaXhlbCBzaG91bGQgYmUgZHJhd24gb250byB0aGUgaGl0IGdyYXBoLiAgTXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMjU1LlxuICAgICAqICBUaGUgZGVmYXVsdCBpcyAwXG4gICAgICogQHJldHVybnMge0tvbnZhLlNoYXBlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogc2hhcGUuY2FjaGUoKTtcbiAgICAgKiBzaGFwZS5kcmF3SGl0RnJvbUNhY2hlKCk7XG4gICAgICovXG4gICAgZHJhd0hpdEZyb21DYWNoZTogZnVuY3Rpb24oYWxwaGFUaHJlc2hvbGQpIHtcbiAgICAgIHZhciB0aHJlc2hvbGQgPSBhbHBoYVRocmVzaG9sZCB8fCAwLFxuICAgICAgICBjYWNoZWRDYW52YXMgPSB0aGlzLl9jYWNoZS5jYW52YXMsXG4gICAgICAgIHNjZW5lQ2FudmFzID0gdGhpcy5fZ2V0Q2FjaGVkU2NlbmVDYW52YXMoKSxcbiAgICAgICAgaGl0Q2FudmFzID0gY2FjaGVkQ2FudmFzLmhpdCxcbiAgICAgICAgaGl0Q29udGV4dCA9IGhpdENhbnZhcy5nZXRDb250ZXh0KCksXG4gICAgICAgIGhpdFdpZHRoID0gaGl0Q2FudmFzLmdldFdpZHRoKCksXG4gICAgICAgIGhpdEhlaWdodCA9IGhpdENhbnZhcy5nZXRIZWlnaHQoKSxcbiAgICAgICAgaGl0SW1hZ2VEYXRhLFxuICAgICAgICBoaXREYXRhLFxuICAgICAgICBsZW4sXG4gICAgICAgIHJnYkNvbG9yS2V5LFxuICAgICAgICBpLFxuICAgICAgICBhbHBoYTtcblxuICAgICAgaGl0Q29udGV4dC5jbGVhcigpO1xuICAgICAgaGl0Q29udGV4dC5kcmF3SW1hZ2Uoc2NlbmVDYW52YXMuX2NhbnZhcywgMCwgMCwgaGl0V2lkdGgsIGhpdEhlaWdodCk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhpdEltYWdlRGF0YSA9IGhpdENvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGhpdFdpZHRoLCBoaXRIZWlnaHQpO1xuICAgICAgICBoaXREYXRhID0gaGl0SW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgIGxlbiA9IGhpdERhdGEubGVuZ3RoO1xuICAgICAgICByZ2JDb2xvcktleSA9IEtvbnZhLlV0aWwuX2hleFRvUmdiKHRoaXMuY29sb3JLZXkpO1xuXG4gICAgICAgIC8vIHJlcGxhY2Ugbm9uIHRyYW5zcGFyZW50IHBpeGVscyB3aXRoIGNvbG9yIGtleVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICAgICAgICBhbHBoYSA9IGhpdERhdGFbaSArIDNdO1xuICAgICAgICAgIGlmIChhbHBoYSA+IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgaGl0RGF0YVtpXSA9IHJnYkNvbG9yS2V5LnI7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAxXSA9IHJnYkNvbG9yS2V5Lmc7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAyXSA9IHJnYkNvbG9yS2V5LmI7XG4gICAgICAgICAgICBoaXREYXRhW2kgKyAzXSA9IDI1NTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGl0RGF0YVtpICsgM10gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoaXRDb250ZXh0LnB1dEltYWdlRGF0YShoaXRJbWFnZURhdGEsIDAsIDApO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAgICdVbmFibGUgdG8gZHJhdyBoaXQgZ3JhcGggZnJvbSBjYWNoZWQgc2NlbmUgY2FudmFzLiAnICsgZS5tZXNzYWdlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlNoYXBlLCBLb252YS5Ob2RlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBjb2xvclxuICAgKiBAbmFtZSBzdHJva2VcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGNvbG9yXG4gICAqIHZhciBzdHJva2UgPSBzaGFwZS5zdHJva2UoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIGNvbG9yIHN0cmluZ1xuICAgKiBzaGFwZS5zdHJva2UoJ2dyZWVuJyk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCBoZXhcbiAgICogc2hhcGUuc3Ryb2tlKCcjMDBmZjAwJyk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgY29sb3Igd2l0aCByZ2JcbiAgICogc2hhcGUuc3Ryb2tlKCdyZ2IoMCwyNTUsMCknKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBjb2xvciB3aXRoIHJnYmEgYW5kIG1ha2UgaXQgNTAlIG9wYXF1ZVxuICAgKiBzaGFwZS5zdHJva2UoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VXaWR0aCcsIDIpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSB3aWR0aFxuICAgKiBAbmFtZSBzdHJva2VXaWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0cm9rZVdpZHRoXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2Ugd2lkdGhcbiAgICogdmFyIHN0cm9rZVdpZHRoID0gc2hhcGUuc3Ryb2tlV2lkdGgoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSB3aWR0aFxuICAgKiBzaGFwZS5zdHJva2VXaWR0aCgpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3N0cm9rZUhpdEVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2VIaXRFbmFibGVkIHByb3BlcnR5LiBVc2VmdWwgZm9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cbiAgICogWW91IG1heSBzZXQgYHNoYXBlLnN0cm9rZUhpdEVuYWJsZWQoZmFsc2UpYC4gSW4gdGhpcyBjYXNlIHN0cm9rZSB3aWxsIGJlIG5vIGRyYXcgb24gaGl0IGNhbnZhcywgc28gaGl0IGFyZWFcbiAgICogb2Ygc2hhcGUgd2lsbCBiZSBkZWNyZWFzZWQgKGJ5IGxpbmVXaWR0aCAvIDIpLiBSZW1lbWJlciB0aGF0IG5vbiBjbG9zZWQgbGluZSB3aXRoIGBzdHJva2VIaXRFbmFibGVkID0gZmFsc2VgXG4gICAqIHdpbGwgYmUgbm90IGRyYXduIG9uIGhpdCBjYW52YXMsIHRoYXQgaXMgbWVhbiBsaW5lIHdpbGwgbm8gdHJpZ2dlciBwb2ludGVyIGV2ZW50cyAobGlrZSBtb3VzZW92ZXIpXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAbmFtZSBzdHJva2VIaXRFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHN0cm9rZUhpdEVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2VIaXRFbmFibGVkXG4gICAqIHZhciBzdHJva2VIaXRFbmFibGVkID0gc2hhcGUuc3Ryb2tlSGl0RW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc3Ryb2tlSGl0RW5hYmxlZFxuICAgKiBzaGFwZS5zdHJva2VIaXRFbmFibGVkKCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAncGVyZmVjdERyYXdFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgcGVyZmVjdERyYXdFbmFibGVkLiBJZiBhIHNoYXBlIGhhcyBmaWxsLCBzdHJva2UgYW5kIG9wYWNpdHkgeW91IG1heSBzZXQgYHBlcmZlY3REcmF3RW5hYmxlZGAgdG8gZmFsc2UgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAgICogU2VlIGh0dHA6Ly9rb252YWpzLmdpdGh1Yi5pby9kb2NzL3BlcmZvcm1hbmNlL0Rpc2FibGVfUGVyZmVjdF9EcmF3Lmh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAbmFtZSBwZXJmZWN0RHJhd0VuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gcGVyZmVjdERyYXdFbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcGVyZmVjdERyYXdFbmFibGVkXG4gICAqIHZhciBwZXJmZWN0RHJhd0VuYWJsZWQgPSBzaGFwZS5wZXJmZWN0RHJhd0VuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gc2V0IHBlcmZlY3REcmF3RW5hYmxlZFxuICAgKiBzaGFwZS5wZXJmZWN0RHJhd0VuYWJsZWQoKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dGb3JTdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZC4gVXNlZnVsIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqIFlvdSBtYXkgc2V0IGBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKGZhbHNlKWAuIEluIHRoaXMgY2FzZSBzdHJva2Ugd2lsbCBiZSBubyBkcmF3IHNoYWRvdyBmb3Igc3Ryb2tlLlxuICAgKiBSZW1lbWJlciBpZiB5b3Ugc2V0IGBzaGFkb3dGb3JTdHJva2VFbmFibGVkID0gZmFsc2VgIGZvciBub24gY2xvc2VkIGxpbmUgLSB0aGF0IGxpbmUgd2l0aCBoYXZlIG5vIHNoYWRvdyEuXG4gICAqIERlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAbmFtZSBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWRvd0ZvclN0cm9rZUVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzaGFkb3dGb3JTdHJva2VFbmFibGVkXG4gICAqIHZhciBzaGFkb3dGb3JTdHJva2VFbmFibGVkID0gc2hhcGUuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZFxuICAgKiBzaGFwZS5zaGFkb3dGb3JTdHJva2VFbmFibGVkKCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnbGluZUpvaW4nKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBsaW5lIGpvaW4uICBDYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZVxuICAgKiAgZGVmYXVsdCBpcyBtaXRlclxuICAgKiBAbmFtZSBsaW5lSm9pblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGxpbmVKb2luXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBsaW5lIGpvaW5cbiAgICogdmFyIGxpbmVKb2luID0gc2hhcGUubGluZUpvaW4oKTtcbiAgICpcbiAgICogLy8gc2V0IGxpbmUgam9pblxuICAgKiBzaGFwZS5saW5lSm9pbigncm91bmQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdsaW5lQ2FwJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgbGluZSBjYXAuICBDYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxdWFyZVxuICAgKiBAbmFtZSBsaW5lQ2FwXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGluZUNhcFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgbGluZSBjYXBcbiAgICogdmFyIGxpbmVDYXAgPSBzaGFwZS5saW5lQ2FwKCk7XG4gICAqXG4gICAqIC8vIHNldCBsaW5lIGNhcFxuICAgKiBzaGFwZS5saW5lQ2FwKCdyb3VuZCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NjZW5lRnVuYycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICogQG5hbWUgc2NlbmVGdW5jXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmF3RnVuYyBkcmF3aW5nIGZ1bmN0aW9uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNjZW5lIGRyYXcgZnVuY3Rpb25cbiAgICogdmFyIHNjZW5lRnVuYyA9IHNoYXBlLnNjZW5lRnVuYygpO1xuICAgKlxuICAgKiAvLyBzZXQgc2NlbmUgZHJhdyBmdW5jdGlvblxuICAgKiBzaGFwZS5zY2VuZUZ1bmMoZnVuY3Rpb24oY29udGV4dCkge1xuICAgKiAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAqICAgY29udGV4dC5yZWN0KDAsIDAsIHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG4gICAqICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICogICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnaGl0RnVuYycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGhpdCBkcmF3IGZ1bmN0aW9uXG4gICAqIEBuYW1lIGhpdEZ1bmNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYXdGdW5jIGRyYXdpbmcgZnVuY3Rpb25cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgaGl0IGRyYXcgZnVuY3Rpb25cbiAgICogdmFyIGhpdEZ1bmMgPSBzaGFwZS5oaXRGdW5jKCk7XG4gICAqXG4gICAqIC8vIHNldCBoaXQgZHJhdyBmdW5jdGlvblxuICAgKiBzaGFwZS5oaXRGdW5jKGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICogICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgKiAgIGNvbnRleHQucmVjdCgwLCAwLCB0aGlzLndpZHRoKCksIHRoaXMuaGVpZ2h0KCkpO1xuICAgKiAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAqICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2Rhc2gnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkYXNoIGFycmF5IGZvciBzdHJva2UuXG4gICAqIEBuYW1lIGRhc2hcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGRhc2hcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gYXBwbHkgZGFzaGVkIHN0cm9rZSB0aGF0IGlzIDEwcHggbG9uZyBhbmQgNSBwaXhlbHMgYXBhcnRcbiAgICogIGxpbmUuZGFzaChbMTAsIDVdKTtcbiAgICogIC8vIGFwcGx5IGRhc2hlZCBzdHJva2UgdGhhdCBpcyBtYWRlIHVwIG9mIGFsdGVybmF0aW5nIGRhc2hlZFxuICAgKiAgLy8gbGluZXMgdGhhdCBhcmUgMTBweCBsb25nIGFuZCAyMHB4IGFwYXJ0LCBhbmQgZG90cyB0aGF0IGhhdmVcbiAgICogIC8vIGEgcmFkaXVzIG9mIDVweCBhbmQgYXJlIDIwcHggYXBhcnRcbiAgICogIGxpbmUuZGFzaChbMTAsIDIwLCAwLjAwMSwgMjBdKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdkYXNoT2Zmc2V0JywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZGFzaCBvZmZzZXQgZm9yIHN0cm9rZS5cbiAgICogQG5hbWUgZGFzaFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGRhc2ggb2Zmc2V0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBhcHBseSBkYXNoZWQgc3Ryb2tlIHRoYXQgaXMgMTBweCBsb25nIGFuZCA1IHBpeGVscyBhcGFydCB3aXRoIGFuIG9mZnNldCBvZiA1cHhcbiAgICogIGxpbmUuZGFzaChbMTAsIDVdKTtcbiAgICogIGxpbmUuZGFzaE9mZnNldCg1KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dDb2xvcicpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBjb2xvclxuICAgKiBAbmFtZSBzaGFkb3dDb2xvclxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzaGFkb3cgY29sb3JcbiAgICogdmFyIHNoYWRvdyA9IHNoYXBlLnNoYWRvd0NvbG9yKCk7XG4gICAqXG4gICAqIC8vIHNldCBzaGFkb3cgY29sb3Igd2l0aCBjb2xvciBzdHJpbmdcbiAgICogc2hhcGUuc2hhZG93Q29sb3IoJ2dyZWVuJyk7XG4gICAqXG4gICAqIC8vIHNldCBzaGFkb3cgY29sb3Igd2l0aCBoZXhcbiAgICogc2hhcGUuc2hhZG93Q29sb3IoJyMwMGZmMDAnKTtcbiAgICpcbiAgICogLy8gc2V0IHNoYWRvdyBjb2xvciB3aXRoIHJnYlxuICAgKiBzaGFwZS5zaGFkb3dDb2xvcigncmdiKDAsMjU1LDApJyk7XG4gICAqXG4gICAqIC8vIHNldCBzaGFkb3cgY29sb3Igd2l0aCByZ2JhIGFuZCBtYWtlIGl0IDUwJSBvcGFxdWVcbiAgICogc2hhcGUuc2hhZG93Q29sb3IoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzaGFkb3dCbHVyJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hhZG93IGJsdXJcbiAgICogQG5hbWUgc2hhZG93Qmx1clxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJsdXJcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBibHVyXG4gICAqIHZhciBzaGFkb3dCbHVyID0gc2hhcGUuc2hhZG93Qmx1cigpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IGJsdXJcbiAgICogc2hhcGUuc2hhZG93Qmx1cigxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T3BhY2l0eScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBvcGFjaXR5LiAgbXVzdCBiZSBhIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxuICAgKiBAbmFtZSBzaGFkb3dPcGFjaXR5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93IG9wYWNpdHlcbiAgICogdmFyIHNoYWRvd09wYWNpdHkgPSBzaGFwZS5zaGFkb3dPcGFjaXR5KCk7XG4gICAqXG4gICAqIC8vIHNldCBzaGFkb3cgb3BhY2l0eVxuICAgKiBzaGFwZS5zaGFkb3dPcGFjaXR5KDAuNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd09mZnNldCcsIFtcbiAgICAneCcsXG4gICAgJ3knXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXRcbiAgICogQG5hbWUgc2hhZG93T2Zmc2V0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0LnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBvZmZzZXRcbiAgICogdmFyIHNoYWRvd09mZnNldCA9IHNoYXBlLnNoYWRvd09mZnNldCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldFxuICAgKiBzaGFwZS5zaGFkb3dPZmZzZXQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0WCcsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeFxuICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB4XG4gICAqIHZhciBzaGFkb3dPZmZzZXRYID0gc2hhcGUuc2hhZG93T2Zmc2V0WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB4XG4gICAqIHNoYXBlLnNoYWRvd09mZnNldFgoNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2hhZG93T2Zmc2V0WScsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHNoYWRvdyBvZmZzZXQgeVxuICAgKiBAbmFtZSBzaGFkb3dPZmZzZXRZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc2hhZG93IG9mZnNldCB5XG4gICAqIHZhciBzaGFkb3dPZmZzZXRZID0gc2hhcGUuc2hhZG93T2Zmc2V0WSgpO1xuICAgKlxuICAgKiAvLyBzZXQgc2hhZG93IG9mZnNldCB5XG4gICAqIHNoYXBlLnNoYWRvd09mZnNldFkoNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5JbWFnZScpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBpbWFnZVxuICAgKiBAbmFtZSBmaWxsUGF0dGVybkltYWdlXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSBvYmplY3RcbiAgICogQHJldHVybnMge0ltYWdlfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAqIHZhciBmaWxsUGF0dGVybkltYWdlID0gc2hhcGUuZmlsbFBhdHRlcm5JbWFnZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAqIHZhciBpbWFnZU9iaiA9IG5ldyBJbWFnZSgpO1xuICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICogICBzaGFwZS5maWxsUGF0dGVybkltYWdlKGltYWdlT2JqKTtcbiAgICogfTtcbiAgICogaW1hZ2VPYmouc3JjID0gJ3BhdGgvdG8vaW1hZ2UvanBnJztcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBjb2xvclxuICAgKiBAbmFtZSBmaWxsXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29sb3JcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgY29sb3JcbiAgICogdmFyIGZpbGwgPSBzaGFwZS5maWxsKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggY29sb3Igc3RyaW5nXG4gICAqIHNoYXBlLmZpbGwoJ2dyZWVuJyk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggaGV4XG4gICAqIHNoYXBlLmZpbGwoJyMwMGZmMDAnKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgY29sb3Igd2l0aCByZ2JcbiAgICogc2hhcGUuZmlsbCgncmdiKDAsMjU1LDApJyk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGNvbG9yIHdpdGggcmdiYSBhbmQgbWFrZSBpdCA1MCUgb3BhcXVlXG4gICAqIHNoYXBlLmZpbGwoJ3JnYmEoMCwyNTUsMCwwLjUnKTtcbiAgICpcbiAgICogLy8gc2hhcGUgd2l0aG91dCBmaWxsXG4gICAqIHNoYXBlLmZpbGwobnVsbCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5YJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBwYXR0ZXJuIHhcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5YXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHhcbiAgICogdmFyIGZpbGxQYXR0ZXJuWCA9IHNoYXBlLmZpbGxQYXR0ZXJuWCgpO1xuICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHhcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5YKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblknLCAwKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4geVxuICAgKiBAbmFtZSBmaWxsUGF0dGVybllcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4geVxuICAgKiB2YXIgZmlsbFBhdHRlcm5ZID0gc2hhcGUuZmlsbFBhdHRlcm5ZKCk7XG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4geVxuICAgKiBzaGFwZS5maWxsUGF0dGVyblkoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBjb2xvclN0b3BzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gY29sb3JTdG9wc1xuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgY29sb3Igc3RvcHNcbiAgICogdmFyIGNvbG9yU3RvcHMgPSBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhIGxpbmVhciBncmFkaWVudCB0aGF0IHN0YXJ0cyB3aXRoIHJlZCwgY2hhbmdlcyB0byBibHVlXG4gICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKDAsICdyZWQnLCAwLjUsICdibHVlJywgMSwgJ2dyZWVuJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlTGluZWFyR3JhZGllbnRDb2xvclN0b3BzJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgKiBAbmFtZSBzdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbG9yU3RvcHNcbiAgICogQHJldHVybnMge0FycmF5fSBjb2xvclN0b3BzXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IGNvbG9yIHN0b3BzXG4gICAqIHZhciBjb2xvclN0b3BzID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRDb2xvclN0b3BzKCk7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSBhIGxpbmVhciBncmFkaWVudCB0aGF0IHN0YXJ0cyB3aXRoIHJlZCwgY2hhbmdlcyB0byBibHVlXG4gICAqIC8vIGhhbGZ3YXkgdGhyb3VnaCwgYW5kIHRoZW4gY2hhbmdlcyB0byBncmVlblxuICAgKiBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudENvbG9yU3RvcHMoWzAsICdyZWQnLCAwLjUsICdibHVlJywgMSwgJ2dyZWVuJ10pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMnLFxuICAgIDBcbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcbiAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcbiAgICogdmFyIHN0YXJ0UmFkaXVzID0gc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoKTtcbiAgICpcbiAgICogLy8gc2V0IHJhZGlhbCBncmFkaWVudCBzdGFydCByYWRpdXNcbiAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXMoMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHJhZGl1c1xuICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAqIHZhciBlbmRSYWRpdXMgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXMoKTtcbiAgICpcbiAgICogLy8gc2V0IHJhZGlhbCBncmFkaWVudCBlbmQgcmFkaXVzXG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1cygxMDApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgKiBAbmFtZSBmaWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gY29sb3JTdG9wc1xuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBjb2xvciBzdG9wc1xuICAgKiB2YXIgY29sb3JTdG9wcyA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoKTtcbiAgICpcbiAgICogLy8gY3JlYXRlIGEgcmFkaWFsIGdyYWRpZW50IHRoYXQgc3RhcnRzIHdpdGggcmVkLCBjaGFuZ2VzIHRvIGJsdWVcbiAgICogLy8gaGFsZndheSB0aHJvdWdoLCBhbmQgdGhlbiBjaGFuZ2VzIHRvIGdyZWVuXG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHMoMCwgJ3JlZCcsIDAuNSwgJ2JsdWUnLCAxLCAnZ3JlZW4nKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblJlcGVhdCcsICdyZXBlYXQnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gcmVwZWF0LiAgQ2FuIGJlICdyZXBlYXQnLCAncmVwZWF0LXgnLCAncmVwZWF0LXknLCBvciAnbm8tcmVwZWF0Jy4gIFRoZSBkZWZhdWx0IGlzICdyZXBlYXQnXG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuUmVwZWF0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcmVwZWF0XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcmVwZWF0XG4gICAqIHZhciByZXBlYXQgPSBzaGFwZS5maWxsUGF0dGVyblJlcGVhdCgpO1xuICAgKlxuICAgKiAvLyByZXBlYXQgcGF0dGVybiBpbiB4IGRpcmVjdGlvbiBvbmx5XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdyZXBlYXQteCcpO1xuICAgKlxuICAgKiAvLyBkbyBub3QgcmVwZWF0IHRoZSBwYXR0ZXJuXG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuUmVwZWF0KCdubyByZXBlYXQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsRW5hYmxlZCcsIHRydWUpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgZW5hYmxlZCBmbGFnXG4gICAqIEBuYW1lIGZpbGxFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIGVuYWJsZWQgZmxhZ1xuICAgKiB2YXIgZmlsbEVuYWJsZWQgPSBzaGFwZS5maWxsRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIGZpbGxcbiAgICogc2hhcGUuZmlsbEVuYWJsZWQoZmFsc2UpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgZmlsbFxuICAgKiBzaGFwZS5maWxsRW5hYmxlZCh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdzdHJva2VFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc3Ryb2tlIGVuYWJsZWQgZmxhZ1xuICAgKiBAbmFtZSBzdHJva2VFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2UgZW5hYmxlZCBmbGFnXG4gICAqIHZhciBzdHJva2VFbmFibGVkID0gc2hhcGUuc3Ryb2tlRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIHN0cm9rZVxuICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKGZhbHNlKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIHN0cm9rZVxuICAgKiBzaGFwZS5zdHJva2VFbmFibGVkKHRydWUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ3NoYWRvd0VuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzaGFkb3cgZW5hYmxlZCBmbGFnXG4gICAqIEBuYW1lIHNoYWRvd0VuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZW5hYmxlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHNoYWRvdyBlbmFibGVkIGZsYWdcbiAgICogdmFyIHNoYWRvd0VuYWJsZWQgPSBzaGFwZS5zaGFkb3dFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgc2hhZG93XG4gICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQoZmFsc2UpO1xuICAgKlxuICAgKiAvLyBlbmFibGUgc2hhZG93XG4gICAqIHNoYXBlLnNoYWRvd0VuYWJsZWQodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZGFzaEVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkYXNoIGVuYWJsZWQgZmxhZ1xuICAgKiBAbmFtZSBkYXNoRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZGFzaCBlbmFibGVkIGZsYWdcbiAgICogdmFyIGRhc2hFbmFibGVkID0gc2hhcGUuZGFzaEVuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gZGlzYWJsZSBkYXNoXG4gICAqIHNoYXBlLmRhc2hFbmFibGVkKGZhbHNlKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIGRhc2hcbiAgICogc2hhcGUuZGFzaEVuYWJsZWQodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc3Ryb2tlU2NhbGVFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc3Ryb2tlU2NhbGUgZW5hYmxlZCBmbGFnXG4gICAqIEBuYW1lIHN0cm9rZVNjYWxlRW5hYmxlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBlbmFibGVkXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIHNjYWxlIGVuYWJsZWQgZmxhZ1xuICAgKiB2YXIgc3Ryb2tlU2NhbGVFbmFibGVkID0gc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgc3Ryb2tlIHNjYWxlXG4gICAqIHNoYXBlLnN0cm9rZVNjYWxlRW5hYmxlZChmYWxzZSk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBzdHJva2Ugc2NhbGVcbiAgICogc2hhcGUuc3Ryb2tlU2NhbGVFbmFibGVkKHRydWUpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQcmlvcml0eScsICdjb2xvcicpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcHJpb3JpdHkuICBjYW4gYmUgY29sb3IsIHBhdHRlcm4sIGxpbmVhci1ncmFkaWVudCwgb3IgcmFkaWFsLWdyYWRpZW50LiAgVGhlIGRlZmF1bHQgaXMgY29sb3IuXG4gICAqICAgVGhpcyBpcyBoYW5keSBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy5cbiAgICogQG5hbWUgZmlsbFByaW9yaXR5XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpb3JpdHlcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcHJpb3JpdHlcbiAgICogdmFyIGZpbGxQcmlvcml0eSA9IHNoYXBlLmZpbGxQcmlvcml0eSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBwcmlvcml0eVxuICAgKiBzaGFwZS5maWxsUHJpb3JpdHkoJ2xpbmVhci1ncmFkaWVudCcpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldCcsIFtcbiAgICAneCcsXG4gICAgJ3knXG4gIF0pO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXRcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldFxuICAgKiB2YXIgcGF0dGVybk9mZnNldCA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0KHtcbiAgICogICB4OiAyMFxuICAgKiAgIHk6IDEwXG4gICAqIH0pO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuT2Zmc2V0WCcsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBvZmZzZXQgeFxuICAgKiBAbmFtZSBmaWxsUGF0dGVybk9mZnNldFhcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICogdmFyIHBhdHRlcm5PZmZzZXRYID0gc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHhcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5PZmZzZXRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVybk9mZnNldFknLCAwKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gb2Zmc2V0IHlcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5PZmZzZXRZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB5XG4gICAqIHZhciBwYXR0ZXJuT2Zmc2V0WSA9IHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIG9mZnNldCB5XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuT2Zmc2V0WSgxMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxQYXR0ZXJuU2NhbGUnLCBbXG4gICAgJ3gnLFxuICAgICd5J1xuICBdKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICogQG5hbWUgZmlsbFBhdHRlcm5TY2FsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjYWxlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZS55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gc2NhbGVcbiAgICogdmFyIHBhdHRlcm5TY2FsZSA9IHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGUoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZVxuICAgKiBzaGFwZS5maWxsUGF0dGVyblNjYWxlKHtcbiAgICogICB4OiAyXG4gICAqICAgeTogMlxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsUGF0dGVyblNjYWxlWCcsIDEpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB4XG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuU2NhbGVYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICogdmFyIHBhdHRlcm5TY2FsZVggPSBzaGFwZS5maWxsUGF0dGVyblNjYWxlWCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBwYXR0ZXJuIHNjYWxlIHhcbiAgICogc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVgoMik7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5TY2FsZVknLCAxKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHBhdHRlcm4gc2NhbGUgeVxuICAgKiBAbmFtZSBmaWxsUGF0dGVyblNjYWxlWVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAqIHZhciBwYXR0ZXJuU2NhbGVZID0gc2hhcGUuZmlsbFBhdHRlcm5TY2FsZVkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiBzY2FsZSB5XG4gICAqIHNoYXBlLmZpbGxQYXR0ZXJuU2NhbGVZKDIpO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludFxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhcnRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC54XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydFBvaW50LnlcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdzdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHZhciBzdGFydFBvaW50ID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYJyxcbiAgICAwXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICogdmFyIHN0YXJ0UG9pbnRYID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHhcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WCcsXG4gICAgMFxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBAbmFtZSBsaW5lYXJMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAqIHZhciBzdGFydFBvaW50WCA9IHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50U3RhcnRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ2ZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZJyxcbiAgICAwXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogdmFyIHN0YXJ0UG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFkoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WScsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogQG5hbWUgc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5zdHJva2VMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IHN0YXJ0IHBvaW50IHlcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCcsXG4gICAgWyd4JywgJ3knXVxuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogdmFyIGVuZFBvaW50ID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCgpO1xuICAgKlxuICAgKiAvLyBzZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludCh7XG4gICAqICAgeDogMjBcbiAgICogICB5OiAxMFxuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU2hhcGUsICdmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFgnLCAwKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogQG5hbWUgZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogdmFyIGVuZFBvaW50WCA9IHNoYXBlLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuU2hhcGUsXG4gICAgJ3N0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRYJyxcbiAgICAwXG4gICk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIEBuYW1lIHN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeFxuICAgKiB2YXIgZW5kUG9pbnRYID0gc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHhcbiAgICogc2hhcGUuc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFgoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TaGFwZSwgJ2ZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WScsIDApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBAbmFtZSBmaWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiB2YXIgZW5kUG9pbnRZID0gc2hhcGUuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBzaGFwZS5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFkoMjApO1xuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnc3Ryb2tlTGluZWFyR3JhZGllbnRFbmRQb2ludFknLFxuICAgIDBcbiAgKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgc3Ryb2tlIGxpbmVhciBncmFkaWVudCBlbmQgcG9pbnQgeVxuICAgKiBAbmFtZSBzdHJva2VMaW5lYXJHcmFkaWVudEVuZFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHN0cm9rZSBsaW5lYXIgZ3JhZGllbnQgZW5kIHBvaW50IHlcbiAgICogdmFyIGVuZFBvaW50WSA9IHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRZKCk7XG4gICAqXG4gICAqIC8vIHNldCBzdHJva2UgbGluZWFyIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHNoYXBlLnN0cm9rZUxpbmVhckdyYWRpZW50RW5kUG9pbnRZKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50JyxcbiAgICBbJ3gnLCAneSddXG4gICk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnRcbiAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXJ0UG9pbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0UG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRQb2ludC55XG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludFxuICAgKiB2YXIgc3RhcnRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IHN0YXJ0IHBvaW50XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCcsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB4XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiB2YXIgc3RhcnRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeFxuICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKFxuICAgIEtvbnZhLlNoYXBlLFxuICAgICdmaWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WScsXG4gICAgMFxuICApO1xuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBzdGFydCBwb2ludCB5XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlNoYXBlLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiB2YXIgc3RhcnRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgc3RhcnQgcG9pbnQgeVxuICAgKiBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkQ29tcG9uZW50c0dldHRlclNldHRlcihcbiAgICBLb252YS5TaGFwZSxcbiAgICAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQnLFxuICAgIFsneCcsICd5J11cbiAgKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogQG5hbWUgZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmRQb2ludFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueFxuICAgKiBAcGFyYW0ge051bWJlcn0gZW5kUG9pbnQueVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZmlsbCByYWRpYWwgZ3JhZGllbnQgZW5kIHBvaW50XG4gICAqIHZhciBlbmRQb2ludCA9IHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50KCk7XG4gICAqXG4gICAqIC8vIHNldCBmaWxsIHJhZGlhbCBncmFkaWVudCBlbmQgcG9pbnRcbiAgICogc2hhcGUuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnQoe1xuICAgKiAgIHg6IDIwXG4gICAqICAgeTogMTBcbiAgICogfSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYJywgMCk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIHZhciBlbmRQb2ludFggPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFgoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB4XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WCgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZJywgMCk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIEBuYW1lIGZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5TaGFwZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHZhciBlbmRQb2ludFkgPSBzaGFwZS5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcmFkaWFsIGdyYWRpZW50IGVuZCBwb2ludCB5XG4gICAqIHNoYXBlLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WSgyMCk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnZmlsbFBhdHRlcm5Sb3RhdGlvbicsIDApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAqIEBuYW1lIGZpbGxQYXR0ZXJuUm90YXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU2hhcGUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByb3RhdGlvblxuICAgKiBAcmV0dXJucyB7S29udmEuU2hhcGV9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmaWxsIHBhdHRlcm4gcm90YXRpb25cbiAgICogdmFyIHBhdHRlcm5Sb3RhdGlvbiA9IHNoYXBlLmZpbGxQYXR0ZXJuUm90YXRpb24oKTtcbiAgICpcbiAgICogLy8gc2V0IGZpbGwgcGF0dGVybiByb3RhdGlvblxuICAgKiBzaGFwZS5maWxsUGF0dGVyblJvdGF0aW9uKDIwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNoYXBlLCB7XG4gICAgZGFzaEFycmF5OiAnZGFzaCcsXG4gICAgZ2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG4gICAgc2V0RGFzaEFycmF5OiAnZ2V0RGFzaCcsXG5cbiAgICBkcmF3RnVuYzogJ3NjZW5lRnVuYycsXG4gICAgZ2V0RHJhd0Z1bmM6ICdnZXRTY2VuZUZ1bmMnLFxuICAgIHNldERyYXdGdW5jOiAnc2V0U2NlbmVGdW5jJyxcblxuICAgIGRyYXdIaXRGdW5jOiAnaGl0RnVuYycsXG4gICAgZ2V0RHJhd0hpdEZ1bmM6ICdnZXRIaXRGdW5jJyxcbiAgICBzZXREcmF3SGl0RnVuYzogJ3NldEhpdEZ1bmMnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TaGFwZSk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBDT05TVEFOVFNcbiAgdmFyIFNUQUdFID0gJ1N0YWdlJyxcbiAgICBTVFJJTkcgPSAnc3RyaW5nJyxcbiAgICBQWCA9ICdweCcsXG4gICAgTU9VU0VPVVQgPSAnbW91c2VvdXQnLFxuICAgIE1PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZScsXG4gICAgTU9VU0VPVkVSID0gJ21vdXNlb3ZlcicsXG4gICAgTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJyxcbiAgICBNT1VTRU1PVkUgPSAnbW91c2Vtb3ZlJyxcbiAgICBNT1VTRURPV04gPSAnbW91c2Vkb3duJyxcbiAgICBNT1VTRVVQID0gJ21vdXNldXAnLFxuICAgIENPTlRFWFRNRU5VID0gJ2NvbnRleHRtZW51JyxcbiAgICBDTElDSyA9ICdjbGljaycsXG4gICAgREJMX0NMSUNLID0gJ2RibGNsaWNrJyxcbiAgICBUT1VDSFNUQVJUID0gJ3RvdWNoc3RhcnQnLFxuICAgIFRPVUNIRU5EID0gJ3RvdWNoZW5kJyxcbiAgICBUQVAgPSAndGFwJyxcbiAgICBEQkxfVEFQID0gJ2RibHRhcCcsXG4gICAgVE9VQ0hNT1ZFID0gJ3RvdWNobW92ZScsXG4gICAgV0hFRUwgPSAnd2hlZWwnLFxuICAgIENPTlRFTlRfTU9VU0VPVVQgPSAnY29udGVudE1vdXNlb3V0JyxcbiAgICBDT05URU5UX01PVVNFT1ZFUiA9ICdjb250ZW50TW91c2VvdmVyJyxcbiAgICBDT05URU5UX01PVVNFTU9WRSA9ICdjb250ZW50TW91c2Vtb3ZlJyxcbiAgICBDT05URU5UX01PVVNFRE9XTiA9ICdjb250ZW50TW91c2Vkb3duJyxcbiAgICBDT05URU5UX01PVVNFVVAgPSAnY29udGVudE1vdXNldXAnLFxuICAgIENPTlRFTlRfQ09OVEVYVE1FTlUgPSAnY29udGVudENvbnRleHRtZW51JyxcbiAgICBDT05URU5UX0NMSUNLID0gJ2NvbnRlbnRDbGljaycsXG4gICAgQ09OVEVOVF9EQkxfQ0xJQ0sgPSAnY29udGVudERibGNsaWNrJyxcbiAgICBDT05URU5UX1RPVUNIU1RBUlQgPSAnY29udGVudFRvdWNoc3RhcnQnLFxuICAgIENPTlRFTlRfVE9VQ0hFTkQgPSAnY29udGVudFRvdWNoZW5kJyxcbiAgICBDT05URU5UX0RCTF9UQVAgPSAnY29udGVudERibHRhcCcsXG4gICAgQ09OVEVOVF9UQVAgPSAnY29udGVudFRhcCcsXG4gICAgQ09OVEVOVF9UT1VDSE1PVkUgPSAnY29udGVudFRvdWNobW92ZScsXG4gICAgQ09OVEVOVF9XSEVFTCA9ICdjb250ZW50V2hlZWwnLFxuICAgIERJViA9ICdkaXYnLFxuICAgIFJFTEFUSVZFID0gJ3JlbGF0aXZlJyxcbiAgICBLT05WQV9DT05URU5UID0gJ2tvbnZhanMtY29udGVudCcsXG4gICAgU1BBQ0UgPSAnICcsXG4gICAgVU5ERVJTQ09SRSA9ICdfJyxcbiAgICBDT05UQUlORVIgPSAnY29udGFpbmVyJyxcbiAgICBFTVBUWV9TVFJJTkcgPSAnJyxcbiAgICBFVkVOVFMgPSBbXG4gICAgICBNT1VTRURPV04sXG4gICAgICBNT1VTRU1PVkUsXG4gICAgICBNT1VTRVVQLFxuICAgICAgTU9VU0VPVVQsXG4gICAgICBUT1VDSFNUQVJULFxuICAgICAgVE9VQ0hNT1ZFLFxuICAgICAgVE9VQ0hFTkQsXG4gICAgICBNT1VTRU9WRVIsXG4gICAgICBXSEVFTCxcbiAgICAgIENPTlRFWFRNRU5VXG4gICAgXSxcbiAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgZXZlbnRzTGVuZ3RoID0gRVZFTlRTLmxlbmd0aDtcblxuICBmdW5jdGlvbiBhZGRFdmVudChjdHgsIGV2ZW50TmFtZSkge1xuICAgIGN0eC5jb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBldmVudE5hbWUsXG4gICAgICBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgY3R4W1VOREVSU0NPUkUgKyBldmVudE5hbWVdKGV2dCk7XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YWdlIGNvbnN0cnVjdG9yLiAgQSBzdGFnZSBpcyB1c2VkIHRvIGNvbnRhaW4gbXVsdGlwbGUgbGF5ZXJzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR9IGNvbmZpZy5jb250YWluZXIgQ29udGFpbmVyIHNlbGVjdG9yIG9yIERPTSBlbGVtZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBzdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XG4gICAqICAgd2lkdGg6IDUwMCxcbiAgICogICBoZWlnaHQ6IDgwMCxcbiAgICogICBjb250YWluZXI6ICdjb250YWluZXJJZCcgLy8gb3IgXCIjY29udGFpbmVySWRcIiBvciBcIi5jb250YWluZXJDbGFzc1wiXG4gICAqIH0pO1xuICAgKi9cbiAgS29udmEuU3RhZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuU3RhZ2UsIHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSBTVEFHRTtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9pZCA9IEtvbnZhLmlkQ291bnRlcisrO1xuICAgICAgdGhpcy5fYnVpbGRET00oKTtcbiAgICAgIHRoaXMuX2JpbmRDb250ZW50RXZlbnRzKCk7XG4gICAgICB0aGlzLl9lbmFibGVOZXN0ZWRUcmFuc2Zvcm1zID0gZmFsc2U7XG4gICAgICBLb252YS5zdGFnZXMucHVzaCh0aGlzKTtcbiAgICB9LFxuICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5nZXRUeXBlKCkgIT09ICdMYXllcicpIHtcbiAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBsYXllcnMgdG8gdGhlIHN0YWdlLicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IGNvbnRhaW5lciBkb20gZWxlbWVudCB3aGljaCBjb250YWlucyB0aGUgc3RhZ2Ugd3JhcHBlciBkaXYgZWxlbWVudFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtEb21FbGVtZW50fSBjb250YWluZXIgY2FuIHBhc3MgaW4gYSBkb20gZWxlbWVudCBvciBpZCBzdHJpbmdcbiAgICAgKi9cbiAgICBzZXRDb250YWluZXI6IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBjb250YWluZXIgPT09IFNUUklORykge1xuICAgICAgICBpZiAoY29udGFpbmVyLmNoYXJBdCgwKSA9PT0gJy4nKSB7XG4gICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNvbnRhaW5lci5zbGljZSgxKTtcbiAgICAgICAgICBjb250YWluZXIgPSBLb252YS5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGlkO1xuICAgICAgICAgIGlmIChjb250YWluZXIuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgICAgIGlkID0gY29udGFpbmVyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZCA9IGNvbnRhaW5lci5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgdGhyb3cgJ0NhbiBub3QgZmluZCBjb250YWluZXIgaW4gZG9jdW1lbnQgd2l0aCBpZCAnICsgaWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldEF0dHIoQ09OVEFJTkVSLCBjb250YWluZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzaG91bGREcmF3SGl0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5kcmF3LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRyYXcgbGF5ZXIgc2NlbmUgZ3JhcGhzXG4gICAgICogQG5hbWUgZHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBkcmF3IGxheWVyIGhpdCBncmFwaHNcbiAgICAgKiBAbmFtZSBkcmF3SGl0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIHNldCBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKi9cbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIHRoaXMuX3Jlc2l6ZURPTSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXQgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqL1xuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICB0aGlzLl9yZXNpemVET00oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY2xlYXIgYWxsIGxheWVyc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxheWVycyA9IHRoaXMuY2hpbGRyZW4sXG4gICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgIG47XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBsYXllcnNbbl0uY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgb2JqID0ge307XG4gICAgICB9XG4gICAgICBvYmouY29udGFpbmVyID0gS29udmEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudChESVYpO1xuICAgICAgcmV0dXJuIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzLCBvYmopO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZGVzdHJveSBzdGFnZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudDtcbiAgICAgIEtvbnZhLkNvbnRhaW5lci5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuXG4gICAgICBpZiAoY29udGVudCAmJiBLb252YS5VdGlsLl9pc0luRG9jdW1lbnQoY29udGVudCkpIHtcbiAgICAgICAgdGhpcy5nZXRDb250YWluZXIoKS5yZW1vdmVDaGlsZChjb250ZW50KTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IEtvbnZhLnN0YWdlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgS29udmEuc3RhZ2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCBwb2ludGVyIHBvc2l0aW9uIHdoaWNoIGNhbiBiZSBhIHRvdWNoIHBvc2l0aW9uIG9yIG1vdXNlIHBvc2l0aW9uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGdldFBvaW50ZXJQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wb2ludGVyUG9zO1xuICAgIH0sXG4gICAgZ2V0U3RhZ2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgc3RhZ2UgY29udGVudCBkaXYgZWxlbWVudCB3aGljaCBoYXMgdGhlXG4gICAgICogIHRoZSBjbGFzcyBuYW1lIFwia29udmFqcy1jb250ZW50XCJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGVudDtcbiAgICB9LFxuICAgIHRvRGF0YVVSTDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgIHZhciBtaW1lVHlwZSA9IGNvbmZpZy5taW1lVHlwZSB8fCBudWxsLFxuICAgICAgICBxdWFsaXR5ID0gY29uZmlnLnF1YWxpdHkgfHwgbnVsbCxcbiAgICAgICAgeCA9IGNvbmZpZy54IHx8IDAsXG4gICAgICAgIHkgPSBjb25maWcueSB8fCAwLFxuICAgICAgICBjYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoe1xuICAgICAgICAgIHdpZHRoOiBjb25maWcud2lkdGggfHwgdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCB8fCB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICAgIHBpeGVsUmF0aW86IGNvbmZpZy5waXhlbFJhdGlvIHx8IDFcbiAgICAgICAgfSksXG4gICAgICAgIF9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoKS5fY29udGV4dCxcbiAgICAgICAgbGF5ZXJzID0gdGhpcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKHggfHwgeSkge1xuICAgICAgICBfY29udGV4dC50cmFuc2xhdGUoLTEgKiB4LCAtMSAqIHkpO1xuICAgICAgfVxuXG4gICAgICBsYXllcnMuZWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICB2YXIgd2lkdGggPSBsYXllci5nZXRDYW52YXMoKS5nZXRXaWR0aCgpO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gbGF5ZXIuZ2V0Q2FudmFzKCkuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHZhciByYXRpbyA9IGxheWVyLmdldENhbnZhcygpLmdldFBpeGVsUmF0aW8oKTtcbiAgICAgICAgX2NvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgIGxheWVyLmdldENhbnZhcygpLl9jYW52YXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIHdpZHRoIC8gcmF0aW8sXG4gICAgICAgICAgaGVpZ2h0IC8gcmF0aW9cbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNyYyA9IGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUsIHF1YWxpdHkpO1xuXG4gICAgICBpZiAoY29uZmlnLmNhbGxiYWNrKSB7XG4gICAgICAgIGNvbmZpZy5jYWxsYmFjayhzcmMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3JjO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogY29udmVydHMgc3RhZ2UgaW50byBhbiBpbWFnZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuY2FsbGJhY2sgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgY29tcG9zaXRlIGhhcyBjb21wbGV0ZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5taW1lVHlwZV0gY2FuIGJlIFwiaW1hZ2UvcG5nXCIgb3IgXCJpbWFnZS9qcGVnXCIuXG4gICAgICogIFwiaW1hZ2UvcG5nXCIgaXMgdGhlIGRlZmF1bHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XSB4IHBvc2l0aW9uIG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV0geSBwb3NpdGlvbiBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXSB3aWR0aCBvZiBjYW52YXMgc2VjdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF0gaGVpZ2h0IG9mIGNhbnZhcyBzZWN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucXVhbGl0eV0ganBlZyBxdWFsaXR5LiAgSWYgdXNpbmcgYW4gXCJpbWFnZS9qcGVnXCIgbWltZVR5cGUsXG4gICAgICogIHlvdSBjYW4gc3BlY2lmeSB0aGUgcXVhbGl0eSBmcm9tIDAgdG8gMSwgd2hlcmUgMCBpcyB2ZXJ5IHBvb3IgcXVhbGl0eSBhbmQgMVxuICAgICAqICBpcyB2ZXJ5IGhpZ2ggcXVhbGl0eVxuICAgICAqL1xuICAgIHRvSW1hZ2U6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIGNiID0gY29uZmlnLmNhbGxiYWNrO1xuXG4gICAgICBjb25maWcuY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhVXJsKSB7XG4gICAgICAgIEtvbnZhLlV0aWwuX2dldEltYWdlKGRhdGFVcmwsIGZ1bmN0aW9uKGltZykge1xuICAgICAgICAgIGNiKGltZyk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMudG9EYXRhVVJMKGNvbmZpZyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdmlzaWJsZSBpbnRlcnNlY3Rpb24gc2hhcGUuIFRoaXMgaXMgdGhlIHByZWZlcnJlZFxuICAgICAqICBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIGEgcG9pbnQgaW50ZXJzZWN0cyBhIHNoYXBlIG9yIG5vdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3MueVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdXG4gICAgICogQHJldHVybnMge0tvbnZhLk5vZGV9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgc2hhcGUgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0pO1xuICAgICAqIC8vIG9yIGlmIHlvdSBpbnRlcmVzdGVkIGluIHNoYXBlIHBhcmVudDpcbiAgICAgKiB2YXIgZ3JvdXAgPSBzdGFnZS5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0sICdHcm91cCcpO1xuICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0Q2hpbGRyZW4oKSxcbiAgICAgICAgbGVuID0gbGF5ZXJzLmxlbmd0aCxcbiAgICAgICAgZW5kID0gbGVuIC0gMSxcbiAgICAgICAgbixcbiAgICAgICAgc2hhcGU7XG5cbiAgICAgIGZvciAobiA9IGVuZDsgbiA+PSAwOyBuLS0pIHtcbiAgICAgICAgc2hhcGUgPSBsYXllcnNbbl0uZ2V0SW50ZXJzZWN0aW9uKHBvcywgc2VsZWN0b3IpO1xuICAgICAgICBpZiAoc2hhcGUpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBfcmVzaXplRE9NOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgICAgbGF5ZXJzID0gdGhpcy5nZXRDaGlsZHJlbigpLFxuICAgICAgICAgIGxlbiA9IGxheWVycy5sZW5ndGgsXG4gICAgICAgICAgbixcbiAgICAgICAgICBsYXllcjtcblxuICAgICAgICAvLyBzZXQgY29udGVudCBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgUFg7XG4gICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyBQWDtcblxuICAgICAgICB0aGlzLmJ1ZmZlckNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlckhpdENhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIHNldCBsYXllciBkaW1lbnNpb25zXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGxheWVyID0gbGF5ZXJzW25dO1xuICAgICAgICAgIGxheWVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgbGF5ZXIuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBhZGQgbGF5ZXIgb3IgbGF5ZXJzIHRvIHN0YWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gey4uLktvbnZhLkxheWVyfSBsYXllclxuICAgICAqIEBleGFtcGxlXG4gICAgICogc3RhZ2UuYWRkKGxheWVyMSwgbGF5ZXIyLCBsYXllcjMpO1xuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFyZ3VtZW50c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGxheWVyKTtcbiAgICAgIGxheWVyLl9zZXRDYW52YXNTaXplKHRoaXMud2lkdGgoKSwgdGhpcy5oZWlnaHQoKSk7XG5cbiAgICAgIC8vIGRyYXcgbGF5ZXIgYW5kIGFwcGVuZCBjYW52YXMgdG8gY29udGFpbmVyXG4gICAgICBsYXllci5kcmF3KCk7XG5cbiAgICAgIGlmIChLb252YS5pc0Jyb3dzZXIpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGxheWVyLmNhbnZhcy5fY2FudmFzKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hhaW5hYmxlXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGdldExheWVyOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHtAbGluayBLb252YS5Db2xsZWN0aW9ufSBvZiBsYXllcnNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YWdlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldExheWVyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIH0sXG4gICAgX2JpbmRDb250ZW50RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZXZlbnRzTGVuZ3RoOyBuKyspIHtcbiAgICAgICAgYWRkRXZlbnQodGhpcywgRVZFTlRTW25dKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9tb3VzZW92ZXI6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9NT1VTRU9WRVIsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2VvdXQ6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHZhciB0YXJnZXRTaGFwZSA9IHRoaXMudGFyZ2V0U2hhcGU7XG5cbiAgICAgICAgaWYgKHRhcmdldFNoYXBlICYmICFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRU9VVCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICB0YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRlclBvcyA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vtb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaG1vdmUoZXZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIHdvcmthcm91bmQgZmFrZSBtb3VzZW1vdmUgZXZlbnQgaW4gY2hyb21lIGJyb3dzZXIgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE2MTQ2NFxuICAgICAgaWYgKFxuICAgICAgICAodHlwZW9mIGV2dC5tb3ZlbWVudFggIT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgdHlwZW9mIGV2dC5tb3ZlbWVudFkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICBldnQubW92ZW1lbnRZID09PSAwICYmXG4gICAgICAgIGV2dC5tb3ZlbWVudFggPT09IDBcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmIChLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZTtcblxuICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhS29udmEuaXNEcmFnZ2luZygpICYmXG4gICAgICAgICAgICAoIXRoaXMudGFyZ2V0U2hhcGUgfHwgdGhpcy50YXJnZXRTaGFwZS5faWQgIT09IHNoYXBlLl9pZClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRhcmdldFNoYXBlKSB7XG4gICAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVVQsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFTEVBVkUsIHsgZXZ0OiBldnQgfSwgc2hhcGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VPVkVSLCB7IGV2dDogZXZ0IH0sIHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VFTlRFUiwgeyBldnQ6IGV2dCB9LCB0aGlzLnRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoTU9VU0VNT1ZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIGlmIG5vIHNoYXBlIHdhcyBkZXRlY3RlZCwgY2xlYXIgdGFyZ2V0IHNoYXBlIGFuZCB0cnlcbiAgICAgICAgICAgICAgICAgKiB0byBydW4gbW91c2VvdXQgZnJvbSBwcmV2aW91cyB0YXJnZXQgc2hhcGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICBpZiAodGhpcy50YXJnZXRTaGFwZSAmJiAhS29udmEuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldFNoYXBlLl9maXJlQW5kQnViYmxlKE1PVVNFT1VULCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRUxFQVZFLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgICAgdGhpcy50YXJnZXRTaGFwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ZpcmUoTU9VU0VNT1ZFLCB7XG4gICAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX01PVVNFTU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICBpZiAoZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaHN0YXJ0KGV2dCk7XG4gICAgICB9XG4gICAgICBpZiAoIUtvbnZhLlVBLm1vYmlsZSkge1xuICAgICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSk7XG5cbiAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgICAgdGhpcy5jbGlja1N0YXJ0U2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRURPV04sIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZmlyZShNT1VTRURPV04sIHtcbiAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgICAgY3VycmVudFRhcmdldDogdGhpc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29udGVudCBldmVudFxuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VET1dOLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBhbHdheXMgY2FsbCBwcmV2ZW50RGVmYXVsdCBmb3IgZGVza3RvcCBldmVudHMgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgICAvLyB0cnkgdG8gZHJhZyBhbmQgZHJvcCB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICAgIGlmIChldnQuY2FuY2VsYWJsZSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9tb3VzZXVwOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIG1vYmlsZSBJRSB0byBmb3JjZSB0b3VjaCBldmVudCB3aGVuIHVuaGFuZGxlZCBwb2ludGVyIGV2ZW50IGVsZXZhdGVzIGludG8gYSBtb3VzZSBldmVudFxuICAgICAgaWYgKEtvbnZhLlVBLmllTW9iaWxlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaGVuZChldnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFLb252YS5VQS5tb2JpbGUpIHtcbiAgICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpLFxuICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZSA9IHRoaXMuY2xpY2tTdGFydFNoYXBlLFxuICAgICAgICAgIGNsaWNrRW5kU2hhcGUgPSB0aGlzLmNsaWNrRW5kU2hhcGUsXG4gICAgICAgICAgZmlyZURibENsaWNrID0gZmFsc2UsXG4gICAgICAgICAgZGQgPSBLb252YS5ERDtcblxuICAgICAgICBpZiAoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xuICAgICAgICAgIGZpcmVEYmxDbGljayA9IHRydWU7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZGJsVGltZW91dCk7XG4gICAgICAgICAgLy8gS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCFkZCB8fCAhZGQuanVzdERyYWdnZWQpIHtcbiAgICAgICAgICAvLyBkb24ndCBzZXQgaW5EYmxDbGlja1dpbmRvdyBhZnRlciBkcmFnZ2luZ1xuICAgICAgICAgIEtvbnZhLmluRGJsQ2xpY2tXaW5kb3cgPSB0cnVlO1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRibFRpbWVvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGRkKSB7XG4gICAgICAgICAgZGQuanVzdERyYWdnZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGJsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XG5cbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICB0aGlzLmNsaWNrRW5kU2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShNT1VTRVVQLCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgICAgLy8gZGV0ZWN0IGlmIGNsaWNrIG9yIGRvdWJsZSBjbGljayBvY2N1cnJlZFxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwICYmXG4gICAgICAgICAgICBjbGlja1N0YXJ0U2hhcGUgJiZcbiAgICAgICAgICAgIGNsaWNrU3RhcnRTaGFwZS5faWQgPT09IHNoYXBlLl9pZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ0xJQ0ssIHsgZXZ0OiBldnQgfSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgZmlyZURibENsaWNrICYmXG4gICAgICAgICAgICAgIGNsaWNrRW5kU2hhcGUgJiZcbiAgICAgICAgICAgICAgY2xpY2tFbmRTaGFwZS5faWQgPT09IHNoYXBlLl9pZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKERCTF9DTElDSywgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZmlyZShNT1VTRVVQLCB7IGV2dDogZXZ0LCB0YXJnZXQ6IHRoaXMsIGN1cnJlbnRUYXJnZXQ6IHRoaXMgfSk7XG4gICAgICAgICAgdGhpcy5fZmlyZShDTElDSywgeyBldnQ6IGV2dCwgdGFyZ2V0OiB0aGlzLCBjdXJyZW50VGFyZ2V0OiB0aGlzIH0pO1xuICAgICAgICAgIGlmIChmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoREJMX0NMSUNLLCB7XG4gICAgICAgICAgICAgIGV2dDogZXZ0LFxuICAgICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBjb250ZW50IGV2ZW50c1xuICAgICAgICB0aGlzLl9maXJlKENPTlRFTlRfTU9VU0VVUCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgaWYgKEtvbnZhLmxpc3RlbkNsaWNrVGFwKSB7XG4gICAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX0NMSUNLLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICAgIGlmIChmaXJlRGJsQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfQ0xJQ0ssIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gYWx3YXlzIGNhbGwgcHJldmVudERlZmF1bHQgZm9yIGRlc2t0b3AgZXZlbnRzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgLy8gdHJ5IHRvIGRyYWcgYW5kIGRyb3AgdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgICBpZiAoZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY29udGV4dG1lbnU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICB2YXIgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcblxuICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoQ09OVEVYVE1FTlUsIHsgZXZ0OiBldnQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXJlKENPTlRFWFRNRU5VLCB7XG4gICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfQ09OVEVYVE1FTlUsIHsgZXZ0OiBldnQgfSk7XG4gICAgfSxcbiAgICBfdG91Y2hzdGFydDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICBLb252YS5saXN0ZW5DbGlja1RhcCA9IHRydWU7XG5cbiAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgIHRoaXMudGFwU3RhcnRTaGFwZSA9IHNoYXBlO1xuICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSFNUQVJULCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgIC8vIG9ubHkgY2FsbCBwcmV2ZW50RGVmYXVsdCBpZiB0aGUgc2hhcGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgICAgaWYgKHNoYXBlLmlzTGlzdGVuaW5nKCkgJiYgc2hhcGUucHJldmVudERlZmF1bHQoKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXJlKFRPVUNIU1RBUlQsIHtcbiAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnRlbnQgZXZlbnRcbiAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9UT1VDSFNUQVJULCB7IGV2dDogZXZ0IH0pO1xuICAgIH0sXG4gICAgX3RvdWNoZW5kOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgdmFyIHNoYXBlID0gdGhpcy5nZXRJbnRlcnNlY3Rpb24odGhpcy5nZXRQb2ludGVyUG9zaXRpb24oKSksXG4gICAgICAgIGZpcmVEYmxDbGljayA9IGZhbHNlO1xuXG4gICAgICBpZiAoS29udmEuaW5EYmxDbGlja1dpbmRvdykge1xuICAgICAgICBmaXJlRGJsQ2xpY2sgPSB0cnVlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kYmxUaW1lb3V0KTtcbiAgICAgICAgLy8gS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgS29udmEuaW5EYmxDbGlja1dpbmRvdyA9IHRydWU7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRibFRpbWVvdXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRibFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBLb252YS5pbkRibENsaWNrV2luZG93ID0gZmFsc2U7XG4gICAgICB9LCBLb252YS5kYmxDbGlja1dpbmRvdyk7XG5cbiAgICAgIGlmIChzaGFwZSAmJiBzaGFwZS5pc0xpc3RlbmluZygpKSB7XG4gICAgICAgIHNoYXBlLl9maXJlQW5kQnViYmxlKFRPVUNIRU5ELCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgIC8vIGRldGVjdCBpZiB0YXAgb3IgZG91YmxlIHRhcCBvY2N1cnJlZFxuICAgICAgICBpZiAoXG4gICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgJiZcbiAgICAgICAgICB0aGlzLnRhcFN0YXJ0U2hhcGUgJiZcbiAgICAgICAgICBzaGFwZS5faWQgPT09IHRoaXMudGFwU3RhcnRTaGFwZS5faWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoVEFQLCB7IGV2dDogZXZ0IH0pO1xuXG4gICAgICAgICAgaWYgKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgICAgc2hhcGUuX2ZpcmVBbmRCdWJibGUoREJMX1RBUCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICBpZiAoc2hhcGUuaXNMaXN0ZW5pbmcoKSAmJiBzaGFwZS5wcmV2ZW50RGVmYXVsdCgpICYmIGV2dC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoVE9VQ0hFTkQsIHsgZXZ0OiBldnQsIHRhcmdldDogdGhpcywgY3VycmVudFRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgdGhpcy5fZmlyZShUQVAsIHsgZXZ0OiBldnQsIHRhcmdldDogdGhpcywgY3VycmVudFRhcmdldDogdGhpcyB9KTtcbiAgICAgICAgaWYgKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoREJMX1RBUCwge1xuICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnRlbnQgZXZlbnRzXG4gICAgICB0aGlzLl9maXJlKENPTlRFTlRfVE9VQ0hFTkQsIHsgZXZ0OiBldnQgfSk7XG4gICAgICBpZiAoS29udmEubGlzdGVuQ2xpY2tUYXApIHtcbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RBUCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgICAgaWYgKGZpcmVEYmxDbGljaykge1xuICAgICAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9EQkxfVEFQLCB7IGV2dDogZXZ0IH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEtvbnZhLmxpc3RlbkNsaWNrVGFwID0gZmFsc2U7XG4gICAgfSxcbiAgICBfdG91Y2htb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHRoaXMuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgIHNoYXBlO1xuICAgICAgaWYgKCFLb252YS5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLmdldEludGVyc2VjdGlvbih0aGlzLmdldFBvaW50ZXJQb3NpdGlvbigpKTtcbiAgICAgICAgaWYgKHNoYXBlICYmIHNoYXBlLmlzTGlzdGVuaW5nKCkpIHtcbiAgICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShUT1VDSE1PVkUsIHsgZXZ0OiBldnQgfSk7XG4gICAgICAgICAgLy8gb25seSBjYWxsIHByZXZlbnREZWZhdWx0IGlmIHRoZSBzaGFwZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAgICAgIGlmIChzaGFwZS5pc0xpc3RlbmluZygpICYmIHNoYXBlLnByZXZlbnREZWZhdWx0KCkgJiYgZXZ0LmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9maXJlKFRPVUNITU9WRSwge1xuICAgICAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiB0aGlzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmlyZShDT05URU5UX1RPVUNITU9WRSwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChkZCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgS29udmEuaXNEcmFnZ2luZygpICYmXG4gICAgICAgICAgS29udmEuREQubm9kZS5wcmV2ZW50RGVmYXVsdCgpICYmXG4gICAgICAgICAgZXZ0LmNhbmNlbGFibGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIF93aGVlbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLl9zZXRQb2ludGVyUG9zaXRpb24oZXZ0KTtcbiAgICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuZ2V0UG9pbnRlclBvc2l0aW9uKCkpO1xuXG4gICAgICBpZiAoc2hhcGUgJiYgc2hhcGUuaXNMaXN0ZW5pbmcoKSkge1xuICAgICAgICBzaGFwZS5fZmlyZUFuZEJ1YmJsZShXSEVFTCwgeyBldnQ6IGV2dCB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2ZpcmUoV0hFRUwsIHtcbiAgICAgICAgICBldnQ6IGV2dCxcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMsXG4gICAgICAgICAgY3VycmVudFRhcmdldDogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZpcmUoQ09OVEVOVF9XSEVFTCwgeyBldnQ6IGV2dCB9KTtcbiAgICB9LFxuICAgIF9zZXRQb2ludGVyUG9zaXRpb246IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGNvbnRlbnRQb3NpdGlvbiA9IHRoaXMuX2dldENvbnRlbnRQb3NpdGlvbigpLFxuICAgICAgICB4ID0gbnVsbCxcbiAgICAgICAgeSA9IG51bGw7XG4gICAgICBldnQgPSBldnQgPyBldnQgOiB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIC8vIHRvdWNoIGV2ZW50c1xuICAgICAgaWYgKGV2dC50b3VjaGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gY3VycmVudGx5LCBvbmx5IGhhbmRsZSBvbmUgZmluZ2VyXG4gICAgICAgIGlmIChldnQudG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIHRvdWNoID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgICAgICAgLy8gZ2V0IHRoZSBpbmZvcm1hdGlvbiBmb3IgZmluZ2VyICMxXG4gICAgICAgICAgeCA9IHRvdWNoLmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgICB5ID0gdG91Y2guY2xpZW50WSAtIGNvbnRlbnRQb3NpdGlvbi50b3A7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdXNlIGV2ZW50c1xuICAgICAgICB4ID0gZXZ0LmNsaWVudFggLSBjb250ZW50UG9zaXRpb24ubGVmdDtcbiAgICAgICAgeSA9IGV2dC5jbGllbnRZIC0gY29udGVudFBvc2l0aW9uLnRvcDtcbiAgICAgIH1cbiAgICAgIGlmICh4ICE9PSBudWxsICYmIHkgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5wb2ludGVyUG9zID0ge1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG4gICAgX2dldENvbnRlbnRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVjdCA9IHRoaXMuY29udGVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgPyB0aGlzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgOiB7IHRvcDogMCwgbGVmdDogMCB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0XG4gICAgICB9O1xuICAgIH0sXG4gICAgX2J1aWxkRE9NOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIHRoZSBidWZmZXIgY2FudmFzIHBpeGVsIHJhdGlvIG11c3QgYmUgMSBiZWNhdXNlIGl0IGlzIHVzZWQgYXMgYW5cbiAgICAgIC8vIGludGVybWVkaWF0ZSBjYW52YXMgYmVmb3JlIGNvcHlpbmcgdGhlIHJlc3VsdCBvbnRvIGEgc2NlbmUgY2FudmFzLlxuICAgICAgLy8gbm90IHNldHRpbmcgaXQgdG8gMSB3aWxsIHJlc3VsdCBpbiBhbiBvdmVyIGNvbXBlbnNhdGlvblxuICAgICAgdGhpcy5idWZmZXJDYW52YXMgPSBuZXcgS29udmEuU2NlbmVDYW52YXMoKTtcbiAgICAgIHRoaXMuYnVmZmVySGl0Q2FudmFzID0gbmV3IEtvbnZhLkhpdENhbnZhcyh7IHBpeGVsUmF0aW86IDEgfSk7XG5cbiAgICAgIGlmICghS29udmEuaXNCcm93c2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcigpO1xuICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgdGhyb3cgJ1N0YWdlIGhhcyBubyBjb250YWluZXIuIEEgY29udGFpbmVyIGlzIHJlcXVpcmVkLic7XG4gICAgICB9XG4gICAgICAvLyBjbGVhciBjb250ZW50IGluc2lkZSBjb250YWluZXJcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBFTVBUWV9TVFJJTkc7XG5cbiAgICAgIC8vIGNvbnRlbnRcbiAgICAgIHRoaXMuY29udGVudCA9IEtvbnZhLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoRElWKTtcbiAgICAgIHRoaXMuY29udGVudC5zdHlsZS5wb3NpdGlvbiA9IFJFTEFUSVZFO1xuICAgICAgdGhpcy5jb250ZW50LmNsYXNzTmFtZSA9IEtPTlZBX0NPTlRFTlQ7XG4gICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xuXG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcblxuICAgICAgdGhpcy5fcmVzaXplRE9NKCk7XG4gICAgfSxcbiAgICBfb25Db250ZW50OiBmdW5jdGlvbih0eXBlc1N0ciwgaGFuZGxlcikge1xuICAgICAgdmFyIHR5cGVzID0gdHlwZXNTdHIuc3BsaXQoU1BBQ0UpLFxuICAgICAgICBsZW4gPSB0eXBlcy5sZW5ndGgsXG4gICAgICAgIG4sXG4gICAgICAgIGJhc2VFdmVudDtcblxuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGJhc2VFdmVudCA9IHR5cGVzW25dO1xuICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlRXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGN1cnJlbnRseSBjYWNoZSBmdW5jdGlvbiBpcyBub3cgd29ya2luZyBmb3Igc3RhZ2UsIGJlY2F1c2Ugc3RhZ2UgaGFzIG5vIGl0cyBvd24gY2FudmFzIGVsZW1lbnRcbiAgICAvLyBUT0RPOiBtYXkgYmUgaXQgaXMgYmV0dGVyIHRvIGNhY2hlIGFsbCBjaGlsZHJlbiBsYXllcnM/XG4gICAgY2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuVXRpbC53YXJuKFxuICAgICAgICAnQ2FjaGUgZnVuY3Rpb24gaXMgbm90IGFsbG93ZWQgZm9yIHN0YWdlLiBZb3UgbWF5IHVzZSBjYWNoZSBvbmx5IGZvciBsYXllcnMsIGdyb3VwcyBhbmQgc2hhcGVzLidcbiAgICAgICk7XG4gICAgfSxcbiAgICBjbGVhckNhY2hlOiBmdW5jdGlvbigpIHt9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5TdGFnZSwgS29udmEuQ29udGFpbmVyKTtcblxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5TdGFnZSwgJ2NvbnRhaW5lcicpO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhZ2UsICdjb250YWluZXInKTtcblxuICAvKipcbiAgICogZ2V0IGNvbnRhaW5lciBET00gZWxlbWVudFxuICAgKiBAbmFtZSBjb250YWluZXJcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuU3RhZ2UucHJvdG90eXBlXG4gICAqIEByZXR1cm5zIHtEb21FbGVtZW50fSBjb250YWluZXJcbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNvbnRhaW5lclxuICAgKiB2YXIgY29udGFpbmVyID0gc3RhZ2UuY29udGFpbmVyKCk7XG4gICAqIC8vIHNldCBjb250YWluZXJcbiAgICogdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgKiBib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAqIHN0YWdlLmNvbnRhaW5lcihjb250YWluZXIpO1xuICAgKi9cbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgKiBCYXNlTGF5ZXIgY29uc3RydWN0b3IuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLkNvbnRhaW5lclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuY2xpcF0gc2V0IGNsaXBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWF0gc2V0IGNsaXAgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBZXSBzZXQgY2xpcCB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFdpZHRoXSBzZXQgY2xpcCB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBIZWlnaHRdIHNldCBjbGlwIGhlaWdodFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuY2xpcEZ1bmNdIHNldCBjbGlwIGZ1bmNcblxuICAgKi9cbiAgS29udmEuQmFzZUxheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVXRpbC5hZGRNZXRob2RzKEtvbnZhLkJhc2VMYXllciwge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdGhpcy5ub2RlVHlwZSA9ICdMYXllcic7XG4gICAgICBLb252YS5Db250YWluZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIH0sXG4gICAgY3JlYXRlUE5HU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5fY2FudmFzLmNyZWF0ZVBOR1N0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IGxheWVyIGNhbnZhc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgbGF5ZXIgaGl0IGNhbnZhc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEhpdENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaXRDYW52YXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgbGF5ZXIgY2FudmFzIGNvbnRleHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGNsZWFyIHNjZW5lIGFuZCBoaXQgY2FudmFzIGNvbnRleHRzIHRpZWQgdG8gdGhlIGxheWVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtib3VuZHNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtib3VuZHMueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2JvdW5kcy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbYm91bmRzLmhlaWdodF1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGxheWVyLmNsZWFyKCk7XG4gICAgICogbGF5ZXIuY2xlYXIoe1xuICAgICAqICAgeCA6IDAsXG4gICAgICogICB5IDogMCxcbiAgICAgKiAgIHdpZHRoIDogMTAwLFxuICAgICAqICAgaGVpZ2h0IDogMTAwXG4gICAgICogfSk7XG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgdGhpcy5nZXRDb250ZXh0KCkuY2xlYXIoYm91bmRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xlYXJIaXRDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0WkluZGV4XG4gICAgc2V0WkluZGV4OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0WkluZGV4LmNhbGwodGhpcywgaW5kZXgpO1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgaWYgKHN0YWdlKSB7XG4gICAgICAgIHN0YWdlLmNvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcblxuICAgICAgICBpZiAoaW5kZXggPCBzdGFnZS5nZXRDaGlsZHJlbigpLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyxcbiAgICAgICAgICAgIHN0YWdlLmdldENoaWxkcmVuKClbaW5kZXggKyAxXS5nZXRDYW52YXMoKS5fY2FudmFzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFnZS5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVUb1RvcFxuICAgIG1vdmVUb1RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVG9Ub3AuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgIHN0YWdlLmNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5nZXRDYW52YXMoKS5fY2FudmFzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLm1vdmVVcFxuICAgIG1vdmVVcDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbW92ZWQgPSBLb252YS5Ob2RlLnByb3RvdHlwZS5tb3ZlVXAuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICBpZiAoIXN0YWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuXG4gICAgICBpZiAodGhpcy5pbmRleCA8IHN0YWdlLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMSkge1xuICAgICAgICBzdGFnZS5jb250ZW50Lmluc2VydEJlZm9yZShcbiAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMsXG4gICAgICAgICAgc3RhZ2UuZ2V0Q2hpbGRyZW4oKVt0aGlzLmluZGV4ICsgMV0uZ2V0Q2FudmFzKCkuX2NhbnZhc1xuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhZ2UuY29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUubW92ZURvd25cbiAgICBtb3ZlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoS29udmEuTm9kZS5wcm90b3R5cGUubW92ZURvd24uY2FsbCh0aGlzKSkge1xuICAgICAgICB2YXIgc3RhZ2UgPSB0aGlzLmdldFN0YWdlKCk7XG4gICAgICAgIGlmIChzdGFnZSkge1xuICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHN0YWdlLmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5yZW1vdmVDaGlsZCh0aGlzLmdldENhbnZhcygpLl9jYW52YXMpO1xuICAgICAgICAgIHN0YWdlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5fY2FudmFzLFxuICAgICAgICAgICAgY2hpbGRyZW5bdGhpcy5pbmRleCArIDFdLmdldENhbnZhcygpLl9jYW52YXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8vIGV4dGVuZCBOb2RlLnByb3RvdHlwZS5tb3ZlVG9Cb3R0b21cbiAgICBtb3ZlVG9Cb3R0b206IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEtvbnZhLk5vZGUucHJvdG90eXBlLm1vdmVUb0JvdHRvbS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHZhciBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKTtcbiAgICAgICAgaWYgKHN0YWdlKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gc3RhZ2UuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgICBzdGFnZS5jb250ZW50LnJlbW92ZUNoaWxkKHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcyk7XG4gICAgICAgICAgc3RhZ2UuY29udGVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMsXG4gICAgICAgICAgICBjaGlsZHJlblsxXS5nZXRDYW52YXMoKS5fY2FudmFzXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRMYXllcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2NhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcztcblxuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG5cbiAgICAgIGlmIChfY2FudmFzICYmIF9jYW52YXMucGFyZW50Tm9kZSAmJiBLb252YS5VdGlsLl9pc0luRG9jdW1lbnQoX2NhbnZhcykpIHtcbiAgICAgICAgX2NhbnZhcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9jYW52YXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRTdGFnZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbnZhcy5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQvc2V0IHdpZHRoIG9mIGxheWVyLmdldHRlciByZXR1cm4gd2lkdGggb2Ygc3RhZ2UuIHNldHRlciBkb2luZyBub3RoaW5nLlxuICAgICAqIGlmIHlvdSB3YW50IGNoYW5nZSB3aWR0aCB1c2UgYHN0YWdlLndpZHRoKHZhbHVlKTtgXG4gICAgICogQG5hbWUgd2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHdpZHRoID0gbGF5ZXIud2lkdGgoKTtcbiAgICAgKi9cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICdDYW4gbm90IGNoYW5nZSB3aWR0aCBvZiBsYXllci4gVXNlIFwic3RhZ2Uud2lkdGgodmFsdWUpXCIgZnVuY3Rpb24gaW5zdGVhZC4nXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0L3NldCBoZWlnaHQgb2YgbGF5ZXIuZ2V0dGVyIHJldHVybiBoZWlnaHQgb2Ygc3RhZ2UuIHNldHRlciBkb2luZyBub3RoaW5nLlxuICAgICAqIGlmIHlvdSB3YW50IGNoYW5nZSBoZWlnaHQgdXNlIGBzdGFnZS5oZWlnaHQodmFsdWUpO2BcbiAgICAgKiBAbmFtZSBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkJhc2VMYXllci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGhlaWdodCA9IGxheWVyLmhlaWdodCgpO1xuICAgICAqL1xuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldEhlaWdodCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgJ0NhbiBub3QgY2hhbmdlIGhlaWdodCBvZiBsYXllci4gVXNlIFwic3RhZ2UuaGVpZ2h0KHZhbHVlKVwiIGZ1bmN0aW9uIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9LFxuICAgIC8vIHRoZSBhcHBseSB0cmFuc2Zvcm0gbWV0aG9kIGlzIGhhbmRsZWQgYnkgdGhlIExheWVyIGFuZCBGYXN0TGF5ZXIgY2xhc3NcbiAgICAvLyBiZWNhdXNlIGl0IGlzIHVwIHRvIHRoZSBsYXllciB0byBkZWNpZGUgaWYgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgdHJhbnNmb3JtXG4gICAgLy8gc2hvdWxkIGJlIHVzZWRcbiAgICBfYXBwbHlUcmFuc2Zvcm06IGZ1bmN0aW9uKHNoYXBlLCBjb250ZXh0LCB0b3ApIHtcbiAgICAgIHZhciBtID0gc2hhcGUuZ2V0QWJzb2x1dGVUcmFuc2Zvcm0odG9wKS5nZXRNYXRyaXgoKTtcbiAgICAgIGNvbnRleHQudHJhbnNmb3JtKG1bMF0sIG1bMV0sIG1bMl0sIG1bM10sIG1bNF0sIG1bNV0pO1xuICAgIH1cbiAgfSk7XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkJhc2VMYXllciwgS29udmEuQ29udGFpbmVyKTtcblxuICAvLyBhZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5CYXNlTGF5ZXIsICdjbGVhckJlZm9yZURyYXcnLCB0cnVlKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgY2xlYXJCZWZvcmVEcmF3IGZsYWcgd2hpY2ggZGV0ZXJtaW5lcyBpZiB0aGUgbGF5ZXIgaXMgY2xlYXJlZCBvciBub3RcbiAgICogIGJlZm9yZSBkcmF3aW5nXG4gICAqIEBuYW1lIGNsZWFyQmVmb3JlRHJhd1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xlYXJCZWZvcmVEcmF3XG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgY2xlYXJCZWZvcmVEcmF3IGZsYWdcbiAgICogdmFyIGNsZWFyQmVmb3JlRHJhdyA9IGxheWVyLmNsZWFyQmVmb3JlRHJhdygpO1xuICAgKlxuICAgKiAvLyBkaXNhYmxlIGNsZWFyIGJlZm9yZSBkcmF3XG4gICAqIGxheWVyLmNsZWFyQmVmb3JlRHJhdyhmYWxzZSk7XG4gICAqXG4gICAqIC8vIGVuYWJsZSBjbGVhciBiZWZvcmUgZHJhd1xuICAgKiBsYXllci5jbGVhckJlZm9yZURyYXcodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5CYXNlTGF5ZXIpO1xufSkoS29udmEpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLy8gY29uc3RhbnRzXG4gIHZhciBIQVNIID0gJyMnLFxuICAgIEJFRk9SRV9EUkFXID0gJ2JlZm9yZURyYXcnLFxuICAgIERSQVcgPSAnZHJhdycsXG4gICAgLypcbiAgICAgICAgICogMiAtIDMgLSA0XG4gICAgICAgICAqIHwgICAgICAgfFxuICAgICAgICAgKiAxIC0gMCAgIDVcbiAgICAgICAgICogICAgICAgICB8XG4gICAgICAgICAqIDggLSA3IC0gNlxuICAgICAgICAgKi9cbiAgICBJTlRFUlNFQ1RJT05fT0ZGU0VUUyA9IFtcbiAgICAgIHsgeDogMCwgeTogMCB9LCAvLyAwXG4gICAgICB7IHg6IC0xLCB5OiAwIH0sIC8vIDFcbiAgICAgIHsgeDogLTEsIHk6IC0xIH0sIC8vIDJcbiAgICAgIHsgeDogMCwgeTogLTEgfSwgLy8gM1xuICAgICAgeyB4OiAxLCB5OiAtMSB9LCAvLyA0XG4gICAgICB7IHg6IDEsIHk6IDAgfSwgLy8gNVxuICAgICAgeyB4OiAxLCB5OiAxIH0sIC8vIDZcbiAgICAgIHsgeDogMCwgeTogMSB9LCAvLyA3XG4gICAgICB7IHg6IC0xLCB5OiAxIH0gLy8gOFxuICAgIF0sXG4gICAgSU5URVJTRUNUSU9OX09GRlNFVFNfTEVOID0gSU5URVJTRUNUSU9OX09GRlNFVFMubGVuZ3RoO1xuXG4gIC8qKlxuICAgICAqIExheWVyIGNvbnN0cnVjdG9yLiAgTGF5ZXJzIGFyZSB0aWVkIHRvIHRoZWlyIG93biBjYW52YXMgZWxlbWVudCBhbmQgYXJlIHVzZWRcbiAgICAgKiB0byBjb250YWluIGdyb3VwcyBvciBzaGFwZXMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLkJhc2VMYXllclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xlYXJCZWZvcmVEcmF3XSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBmYWxzZSBpZiB5b3UgZG9uJ3Qgd2FudFxuICAgICAqIHRvIGNsZWFyIHRoZSBjYW52YXMgYmVmb3JlIGVhY2ggbGF5ZXIgZHJhdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsYXllciA9IG5ldyBLb252YS5MYXllcigpO1xuICAgICAqL1xuICBLb252YS5MYXllciA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuTGF5ZXIsIHtcbiAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICB0aGlzLmhpdENhbnZhcyA9IG5ldyBLb252YS5IaXRDYW52YXMoe1xuICAgICAgICBwaXhlbFJhdGlvOiAxXG4gICAgICB9KTtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkJhc2VMYXllci5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgfSxcbiAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuaGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcbiAgICBfdmFsaWRhdGVBZGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICB2YXIgdHlwZSA9IGNoaWxkLmdldFR5cGUoKTtcbiAgICAgIGlmICh0eXBlICE9PSAnR3JvdXAnICYmIHR5cGUgIT09ICdTaGFwZScpIHtcbiAgICAgICAgS29udmEuVXRpbC50aHJvdygnWW91IG1heSBvbmx5IGFkZCBncm91cHMgYW5kIHNoYXBlcyB0byBhIGxheWVyLicpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCB2aXNpYmxlIGludGVyc2VjdGlvbiBzaGFwZS4gVGhpcyBpcyB0aGUgcHJlZmVycmVkXG4gICAgICAgICAqIG1ldGhvZCBmb3IgZGV0ZXJtaW5pbmcgaWYgYSBwb2ludCBpbnRlcnNlY3RzIGEgc2hhcGUgb3Igbm90XG4gICAgICAgICAqIGFsc28geW91IG1heSBwYXNzIG9wdGlvbmFsIHNlbGVjdG9yIHBhcmFtZXRyIHRvIHJldHVybiBhbmNlc3RvciBvZiBpbnRlcnNlY3RlZCBzaGFwZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcG9zLnhcbiAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvcy55XG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbc2VsZWN0b3JdXG4gICAgICAgICAqIEByZXR1cm5zIHtLb252YS5Ob2RlfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB2YXIgc2hhcGUgPSBsYXllci5nZXRJbnRlcnNlY3Rpb24oe3g6IDUwLCB5OiA1MH0pO1xuICAgICAgICAgKiAvLyBvciBpZiB5b3UgaW50ZXJlc3RlZCBpbiBzaGFwZSBwYXJlbnQ6XG4gICAgICAgICAqIHZhciBncm91cCA9IGxheWVyLmdldEludGVyc2VjdGlvbih7eDogNTAsIHk6IDUwfSwgJ0dyb3VwJyk7XG4gICAgICAgICAqL1xuICAgIGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zLCBzZWxlY3Rvcikge1xuICAgICAgdmFyIG9iaiwgaSwgaW50ZXJzZWN0aW9uT2Zmc2V0LCBzaGFwZTtcblxuICAgICAgaWYgKCF0aGlzLmhpdEdyYXBoRW5hYmxlZCgpIHx8ICF0aGlzLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gaW4gc29tZSBjYXNlcyBhbnRpYWxpYXNlZCBhcmVhIG1heSBiZSBiaWdnZXIgdGhhbiAxcHhcbiAgICAgIC8vIGl0IGlzIHBvc3NpYmxlIGlmIHdlIHdpbGwgY2FjaGUgbm9kZSwgdGhlbiBzY2FsZSBpdCBhIGxvdFxuICAgICAgLy8gVE9ETzogY2hlY2sgeyAwOyAwIH0gcG9pbnQgYmVmb3JlIGxvb3AsIGFuZCByZW1vdmUgaXQgZnJvbSBJTlRFUlNFQ1RJT05fT0ZGU0VUUy5cbiAgICAgIHZhciBzcGlyYWxTZWFyY2hEaXN0YW5jZSA9IDE7XG4gICAgICB2YXIgY29udGludWVTZWFyY2ggPSBmYWxzZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBJTlRFUlNFQ1RJT05fT0ZGU0VUU19MRU47IGkrKykge1xuICAgICAgICAgIGludGVyc2VjdGlvbk9mZnNldCA9IElOVEVSU0VDVElPTl9PRkZTRVRTW2ldO1xuICAgICAgICAgIG9iaiA9IHRoaXMuX2dldEludGVyc2VjdGlvbih7XG4gICAgICAgICAgICB4OiBwb3MueCArIGludGVyc2VjdGlvbk9mZnNldC54ICogc3BpcmFsU2VhcmNoRGlzdGFuY2UsXG4gICAgICAgICAgICB5OiBwb3MueSArIGludGVyc2VjdGlvbk9mZnNldC55ICogc3BpcmFsU2VhcmNoRGlzdGFuY2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzaGFwZSA9IG9iai5zaGFwZTtcbiAgICAgICAgICBpZiAoc2hhcGUgJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZS5maW5kQW5jZXN0b3Ioc2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2Ugc2hvdWxkIGNvbnRpbnVlIHNlYXJjaCBpZiB3ZSBmb3VuZCBhbnRpYWxpYXNlZCBwaXhlbFxuICAgICAgICAgIC8vIHRoYXQgbWVhbnMgb3VyIG5vZGUgc29tZXdoZXJlIHZlcnkgY2xvc2VcbiAgICAgICAgICBjb250aW51ZVNlYXJjaCA9ICEhb2JqLmFudGlhbGlhc2VkO1xuICAgICAgICAgIC8vIHN0b3Agc2VhcmNoIGlmIGZvdW5kIGVtcHR5IHBpeGVsXG4gICAgICAgICAgaWYgKCFvYmouYW50aWFsaWFzZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBubyBzaGFwZSwgYW5kIG5vIGFudGlhbGlhc2VkIHBpeGVsLCB3ZSBzaG91bGQgZW5kIHNlYXJjaGluZ1xuICAgICAgICBpZiAoY29udGludWVTZWFyY2gpIHtcbiAgICAgICAgICBzcGlyYWxTZWFyY2hEaXN0YW5jZSArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZ2V0SW1hZ2VEYXRhOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmhpdENhbnZhcy53aWR0aCB8fCAxLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmhpdENhbnZhcy5oZWlnaHQgfHwgMSxcbiAgICAgICAgaW5kZXggPSBNYXRoLnJvdW5kKHkpICogd2lkdGggKyBNYXRoLnJvdW5kKHgpO1xuXG4gICAgICBpZiAoIXRoaXMuX2hpdEltYWdlRGF0YSkge1xuICAgICAgICB0aGlzLl9oaXRJbWFnZURhdGEgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgICAwLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDBdLCAvLyBSZWRcbiAgICAgICAgdGhpcy5faGl0SW1hZ2VEYXRhLmRhdGFbNCAqIGluZGV4ICsgMV0sIC8vIEdyZWVuXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDJdLCAvLyBCbHVlXG4gICAgICAgIHRoaXMuX2hpdEltYWdlRGF0YS5kYXRhWzQgKiBpbmRleCArIDNdIC8vIEFscGhhXG4gICAgICBdO1xuICAgIH0sXG4gICAgX2dldEludGVyc2VjdGlvbjogZnVuY3Rpb24ocG9zKSB7XG4gICAgICB2YXIgcmF0aW8gPSB0aGlzLmhpdENhbnZhcy5waXhlbFJhdGlvO1xuICAgICAgdmFyIHAgPSB0aGlzLmhpdENhbnZhcy5jb250ZXh0LmdldEltYWdlRGF0YShcbiAgICAgICAgTWF0aC5yb3VuZChwb3MueCAqIHJhdGlvKSxcbiAgICAgICAgTWF0aC5yb3VuZChwb3MueSAqIHJhdGlvKSxcbiAgICAgICAgMSxcbiAgICAgICAgMVxuICAgICAgKS5kYXRhLFxuICAgICAgICBwMyA9IHBbM10sXG4gICAgICAgIGNvbG9yS2V5LFxuICAgICAgICBzaGFwZTtcbiAgICAgIC8vIGZ1bGx5IG9wYXF1ZSBwaXhlbFxuICAgICAgaWYgKHAzID09PSAyNTUpIHtcbiAgICAgICAgY29sb3JLZXkgPSBLb252YS5VdGlsLl9yZ2JUb0hleChwWzBdLCBwWzFdLCBwWzJdKTtcbiAgICAgICAgc2hhcGUgPSBLb252YS5zaGFwZXNbSEFTSCArIGNvbG9yS2V5XTtcbiAgICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNoYXBlOiBzaGFwZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChwMyA+IDApIHtcbiAgICAgICAgLy8gYW50aWFsaWFzZWQgcGl4ZWxcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhbnRpYWxpYXNlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gZW1wdHkgcGl4ZWxcbiAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIGRyYXdTY2VuZTogZnVuY3Rpb24oY2FuLCB0b3ApIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKSwgY2FudmFzID0gY2FuIHx8IChsYXllciAmJiBsYXllci5nZXRDYW52YXMoKSk7XG5cbiAgICAgIHRoaXMuX2ZpcmUoQkVGT1JFX0RSQVcsIHtcbiAgICAgICAgbm9kZTogdGhpc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmdldENsZWFyQmVmb3JlRHJhdygpKSB7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kcmF3U2NlbmUuY2FsbCh0aGlzLCBjYW52YXMsIHRvcCk7XG5cbiAgICAgIHRoaXMuX2ZpcmUoRFJBVywge1xuICAgICAgICBub2RlOiB0aGlzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkcmF3SGl0OiBmdW5jdGlvbihjYW4sIHRvcCkge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmhpdENhbnZhcyk7XG5cbiAgICAgIGlmIChsYXllciAmJiBsYXllci5nZXRDbGVhckJlZm9yZURyYXcoKSkge1xuICAgICAgICBsYXllci5nZXRIaXRDYW52YXMoKS5nZXRDb250ZXh0KCkuY2xlYXIoKTtcbiAgICAgIH1cblxuICAgICAgS29udmEuQ29udGFpbmVyLnByb3RvdHlwZS5kcmF3SGl0LmNhbGwodGhpcywgY2FudmFzLCB0b3ApO1xuICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBpbWFnZURhdGEgY2FjaGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgY2xlYXI6IGZ1bmN0aW9uKGJvdW5kcykge1xuICAgICAgS29udmEuQmFzZUxheWVyLnByb3RvdHlwZS5jbGVhci5jYWxsKHRoaXMsIGJvdW5kcyk7XG4gICAgICB0aGlzLmdldEhpdENhbnZhcygpLmdldENvbnRleHQoKS5jbGVhcihib3VuZHMpO1xuICAgICAgdGhpcy5pbWFnZURhdGEgPSBudWxsOyAvLyBDbGVhciBnZXRJbWFnZURhdGEgY2FjaGVcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLy8gZXh0ZW5kIE5vZGUucHJvdG90eXBlLnNldFZpc2libGVcbiAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRWaXNpYmxlLmNhbGwodGhpcywgdmlzaWJsZSk7XG4gICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMuaGl0Q2FudmFzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldENhbnZhcygpLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5oaXRDYW52YXMuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZW5hYmxlIGhpdCBncmFwaFxuICAgICAgICAgKiBAbmFtZSBlbmFibGVIaXRHcmFwaFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0xheWVyfVxuICAgICAgICAgKi9cbiAgICBlbmFibGVIaXRHcmFwaDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEhpdEdyYXBoRW5hYmxlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRpc2FibGUgaGl0IGdyYXBoXG4gICAgICAgICAqIEBuYW1lIGRpc2FibGVIaXRHcmFwaFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge0xheWVyfVxuICAgICAgICAgKi9cbiAgICBkaXNhYmxlSGl0R3JhcGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRIaXRHcmFwaEVuYWJsZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLnNldFNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuaGl0Q2FudmFzLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYXllciwgS29udmEuQmFzZUxheWVyKTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5MYXllciwgJ2hpdEdyYXBoRW5hYmxlZCcsIHRydWUpO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGhpdEdyYXBoRW5hYmxlZCBmbGFnLiAgRGlzYWJsaW5nIHRoZSBoaXQgZ3JhcGggd2lsbCBncmVhdGx5IGluY3JlYXNlXG4gICAgICogIGRyYXcgcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGUgaGl0IGdyYXBoIHdpbGwgbm90IGJlIHJlZHJhd24gZWFjaCB0aW1lIHRoZSBsYXllciBpc1xuICAgICAqICBkcmF3bi4gIFRoaXMsIGhvd2V2ZXIsIGFsc28gZGlzYWJsZXMgbW91c2UvdG91Y2ggZXZlbnQgZGV0ZWN0aW9uXG4gICAgICogQG5hbWUgaGl0R3JhcGhFbmFibGVkXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5MYXllci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBoaXRHcmFwaEVuYWJsZWQgZmxhZ1xuICAgICAqIHZhciBoaXRHcmFwaEVuYWJsZWQgPSBsYXllci5oaXRHcmFwaEVuYWJsZWQoKTtcbiAgICAgKlxuICAgICAqIC8vIGRpc2FibGUgaGl0IGdyYXBoXG4gICAgICogbGF5ZXIuaGl0R3JhcGhFbmFibGVkKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGVuYWJsZSBoaXQgZ3JhcGhcbiAgICAgKiBsYXllci5oaXRHcmFwaEVuYWJsZWQodHJ1ZSk7XG4gICAgICovXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYXllcik7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAgICogRmFzdExheWVyIGNvbnN0cnVjdG9yLiBMYXllcnMgYXJlIHRpZWQgdG8gdGhlaXIgb3duIGNhbnZhcyBlbGVtZW50IGFuZCBhcmUgdXNlZFxuICAgICAqIHRvIGNvbnRhaW4gc2hhcGVzIG9ubHkuICBJZiB5b3UgZG9uJ3QgbmVlZCBub2RlIG5lc3RpbmcsIG1vdXNlIGFuZCB0b3VjaCBpbnRlcmFjdGlvbnMsXG4gICAgICogb3IgZXZlbnQgcHViL3N1YiwgeW91IHNob3VsZCB1c2UgRmFzdExheWVyIGluc3RlYWQgb2YgTGF5ZXIgdG8gY3JlYXRlIHlvdXIgbGF5ZXJzLlxuICAgICAqIEl0IHJlbmRlcnMgYWJvdXQgMnggZmFzdGVyIHRoYW4gbm9ybWFsIGxheWVycy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQmFzZUxheWVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbGVhckJlZm9yZURyYXddIHNldCB0aGlzIHByb3BlcnR5IHRvIGZhbHNlIGlmIHlvdSBkb24ndCB3YW50XG4gICAgICogdG8gY2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgZWFjaCBsYXllciBkcmF3LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZS5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmNsaXBdIHNldCBjbGlwXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFhdIHNldCBjbGlwIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwWV0gc2V0IGNsaXAgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBXaWR0aF0gc2V0IGNsaXAgd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwSGVpZ2h0XSBzZXQgY2xpcCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmNsaXBGdW5jXSBzZXQgY2xpcCBmdW5jXG5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBsYXllciA9IG5ldyBLb252YS5GYXN0TGF5ZXIoKTtcbiAgICAgKi9cbiAgS29udmEuRmFzdExheWVyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlV0aWwuYWRkTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIsIHtcbiAgICBfX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLm5vZGVUeXBlID0gJ0xheWVyJztcbiAgICAgIHRoaXMuY2FudmFzID0gbmV3IEtvbnZhLlNjZW5lQ2FudmFzKCk7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5CYXNlTGF5ZXIuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgIH0sXG4gICAgX3ZhbGlkYXRlQWRkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgdmFyIHR5cGUgPSBjaGlsZC5nZXRUeXBlKCk7XG4gICAgICBpZiAodHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIHNoYXBlcyB0byBhIGZhc3QgbGF5ZXIuJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2V0Q2FudmFzU2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgdGhpcy5jYW52YXMuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuICAgIGhpdEdyYXBoRW5hYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBkcmF3U2NlbmU6IGZ1bmN0aW9uKGNhbikge1xuICAgICAgdmFyIGxheWVyID0gdGhpcy5nZXRMYXllcigpLCBjYW52YXMgPSBjYW4gfHwgKGxheWVyICYmIGxheWVyLmdldENhbnZhcygpKTtcblxuICAgICAgaWYgKHRoaXMuZ2V0Q2xlYXJCZWZvcmVEcmF3KCkpIHtcbiAgICAgICAgY2FudmFzLmdldENvbnRleHQoKS5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICBLb252YS5Db250YWluZXIucHJvdG90eXBlLmRyYXdTY2VuZS5jYWxsKHRoaXMsIGNhbnZhcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRyYXdTY2VuZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvLyBleHRlbmQgTm9kZS5wcm90b3R5cGUuc2V0VmlzaWJsZVxuICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFZpc2libGUuY2FsbCh0aGlzLCB2aXNpYmxlKTtcbiAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0Q2FudmFzKCkuX2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuRmFzdExheWVyLCBLb252YS5CYXNlTGF5ZXIpO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5GYXN0TGF5ZXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIEdyb3VwIGNvbnN0cnVjdG9yLiAgR3JvdXBzIGFyZSB1c2VkIHRvIGNvbnRhaW4gc2hhcGVzIG9yIG90aGVyIGdyb3Vwcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuQ29udGFpbmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jbGlwXSBzZXQgY2xpcFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNsaXBYXSBzZXQgY2xpcCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcFldIHNldCBjbGlwIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5jbGlwV2lkdGhdIHNldCBjbGlwIHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuY2xpcEhlaWdodF0gc2V0IGNsaXAgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5jbGlwRnVuY10gc2V0IGNsaXAgZnVuY1xuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZ3JvdXAgPSBuZXcgS29udmEuR3JvdXAoKTtcbiAgICAgKi9cbiAgS29udmEuR3JvdXAgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5VdGlsLmFkZE1ldGhvZHMoS29udmEuR3JvdXAsIHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIHRoaXMubm9kZVR5cGUgPSAnR3JvdXAnO1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuQ29udGFpbmVyLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICB9LFxuICAgIF92YWxpZGF0ZUFkZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgIHZhciB0eXBlID0gY2hpbGQuZ2V0VHlwZSgpO1xuICAgICAgaWYgKHR5cGUgIT09ICdHcm91cCcgJiYgdHlwZSAhPT0gJ1NoYXBlJykge1xuICAgICAgICBLb252YS5VdGlsLnRocm93KCdZb3UgbWF5IG9ubHkgYWRkIGdyb3VwcyBhbmQgc2hhcGVzIHRvIGdyb3Vwcy4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5Hcm91cCwgS29udmEuQ29udGFpbmVyKTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuR3JvdXApO1xufSkoKTtcblxuKGZ1bmN0aW9uKEtvbnZhKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgdmFyIG5vdyA9IChmdW5jdGlvbigpIHtcbiAgICBpZiAoS29udmEuZ2xvYmFsLnBlcmZvcm1hbmNlICYmIEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZS5ub3cpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEtvbnZhLmdsb2JhbC5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgZnVuY3Rpb24gRlJBRihjYWxsYmFjaykge1xuICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gIH1cblxuICB2YXIgUkFGID0gKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoXG4gICAgICBLb252YS5nbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBLb252YS5nbG9iYWwud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBLb252YS5nbG9iYWwubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBLb252YS5nbG9iYWwub1JlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICAgICAgS29udmEuZ2xvYmFsLm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICBGUkFGXG4gICAgKTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiByZXF1ZXN0QW5pbUZyYW1lKCkge1xuICAgIHJldHVybiBSQUYuYXBwbHkoS29udmEuZ2xvYmFsLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAgICogQW5pbWF0aW9uIGNvbnN0cnVjdG9yLiAgQSBzdGFnZSBpcyB1c2VkIHRvIGNvbnRhaW4gbXVsdGlwbGUgbGF5ZXJzIGFuZCBoYW5kbGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIGZ1bmN0aW9uIGV4ZWN1dGVkIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lLiAgVGhlIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGZyYW1lIG9iamVjdCwgd2hpY2ggY29udGFpbnNcbiAgICAgKiAgdGltZURpZmYsIGxhc3RUaW1lLCB0aW1lLCBhbmQgZnJhbWVSYXRlIHByb3BlcnRpZXMuICBUaGUgdGltZURpZmYgcHJvcGVydHkgaXMgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdGhhdCBoYXZlIHBhc3NlZFxuICAgICAqICBzaW5jZSB0aGUgbGFzdCBhbmltYXRpb24gZnJhbWUuICBUaGUgbGFzdFRpbWUgcHJvcGVydHkgaXMgdGltZSBpbiBtaWxsaXNlY29uZHMgdGhhdCBlbGFwc2VkIGZyb20gdGhlIG1vbWVudCB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWRcbiAgICAgKiAgdG8gdGhlIGxhc3QgYW5pbWF0aW9uIGZyYW1lLiAgVGhlIHRpbWUgcHJvcGVydHkgaXMgdGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIHRoYXQgZWxsYXBzZWQgZnJvbSB0aGUgbW9tZW50IHRoZSBhbmltYXRpb24gc3RhcnRlZFxuICAgICAqICB0byB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUuICBUaGUgZnJhbWVSYXRlIHByb3BlcnR5IGlzIHRoZSBjdXJyZW50IGZyYW1lIHJhdGUgaW4gZnJhbWVzIC8gc2Vjb25kLiBSZXR1cm4gZmFsc2UgZnJvbSBmdW5jdGlvbixcbiAgICAgKiAgaWYgeW91IGRvbid0IG5lZWQgdG8gcmVkcmF3IGxheWVyL2xheWVycyBvbiBzb21lIGZyYW1lcy5cbiAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfEFycmF5fSBbbGF5ZXJzXSBsYXllcihzKSB0byBiZSByZWRyYXduIG9uIGVhY2ggYW5pbWF0aW9uIGZyYW1lLiBDYW4gYmUgYSBsYXllciwgYW4gYXJyYXkgb2YgbGF5ZXJzLCBvciBudWxsLlxuICAgICAqICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gbW92ZSBhIG5vZGUgdG8gdGhlIHJpZ2h0IGF0IDUwIHBpeGVscyAvIHNlY29uZFxuICAgICAqIHZhciB2ZWxvY2l0eSA9IDUwO1xuICAgICAqXG4gICAgICogdmFyIGFuaW0gPSBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICogICB2YXIgZGlzdCA9IHZlbG9jaXR5ICogKGZyYW1lLnRpbWVEaWZmIC8gMTAwMCk7XG4gICAgICogICBub2RlLm1vdmUoZGlzdCwgMCk7XG4gICAgICogfSwgbGF5ZXIpO1xuICAgICAqXG4gICAgICogYW5pbS5zdGFydCgpO1xuICAgICAqL1xuICBLb252YS5BbmltYXRpb24gPSBmdW5jdGlvbihmdW5jLCBsYXllcnMpIHtcbiAgICB2YXIgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcbiAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIHRoaXMuc2V0TGF5ZXJzKGxheWVycyk7XG4gICAgdGhpcy5pZCA9IEFuaW0uYW5pbUlkQ291bnRlcisrO1xuICAgIHRoaXMuZnJhbWUgPSB7XG4gICAgICB0aW1lOiAwLFxuICAgICAgdGltZURpZmY6IDAsXG4gICAgICBsYXN0VGltZTogbm93KClcbiAgICB9O1xuICB9O1xuICAvKlxuICAgICAqIEFuaW1hdGlvbiBtZXRob2RzXG4gICAgICovXG4gIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICAgICAqIHNldCBsYXllcnMgdG8gYmUgcmVkcmF3biBvbiBlYWNoIGFuaW1hdGlvbiBmcmFtZVxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5BbmltYXRpb24ucHJvdG90eXBlXG4gICAgICAgICAqIEBwYXJhbSB7S29udmEuTGF5ZXJ8QXJyYXl9IFtsYXllcnNdIGxheWVyKHMpIHRvIGJlIHJlZHJhd24uJm5ic3A7IENhbiBiZSBhIGxheWVyLCBhbiBhcnJheSBvZiBsYXllcnMsIG9yIG51bGwuICBOb3Qgc3BlY2lmeWluZyBhIG5vZGUgd2lsbCByZXN1bHQgaW4gbm8gcmVkcmF3LlxuICAgICAgICAgKiBAcmV0dXJuIHtLb252YS5BbmltYXRpb259IHRoaXNcbiAgICAgICAgICovXG4gICAgc2V0TGF5ZXJzOiBmdW5jdGlvbihsYXllcnMpIHtcbiAgICAgIHZhciBsYXlzID0gW107XG4gICAgICAvLyBpZiBwYXNzaW5nIGluIG5vIGxheWVyc1xuICAgICAgaWYgKCFsYXllcnMpIHtcbiAgICAgICAgbGF5cyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsYXllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBpZiBwYXNzaW5nIGluIGFuIGFycmF5IG9mIExheWVyc1xuICAgICAgICAvLyBOT1RFOiBsYXllcnMgY291bGQgYmUgYW4gYXJyYXkgb3IgS29udmEuQ29sbGVjdGlvbi4gIGZvciBzaW1wbGljaXR5LCBJJ20ganVzdCBpbnNwZWN0aW5nXG4gICAgICAgIC8vIHRoZSBsZW5ndGggcHJvcGVydHkgdG8gY2hlY2sgZm9yIGJvdGggY2FzZXNcbiAgICAgICAgbGF5cyA9IGxheWVycztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmIHBhc3NpbmcgaW4gYSBMYXllclxuICAgICAgICBsYXlzID0gW2xheWVyc107XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGF5ZXJzID0gbGF5cztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBsYXllcnNcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgS29udmEuTGF5ZXJcbiAgICAgICAgICovXG4gICAgZ2V0TGF5ZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheWVycztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBhZGQgbGF5ZXIuICBSZXR1cm5zIHRydWUgaWYgdGhlIGxheWVyIHdhcyBhZGRlZCwgYW5kIGZhbHNlIGlmIGl0IHdhcyBub3RcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0tvbnZhLkxheWVyfSBsYXllciB0byBhZGRcbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gdHJ1ZSBpZiBsYXllciBpcyBhZGRlZCB0byBhbmltYXRpb24sIG90aGVyd2lzZSBmYWxzZVxuICAgICAgICAgKi9cbiAgICBhZGRMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgIHZhciBsYXllcnMgPSB0aGlzLmxheWVycywgbGVuID0gbGF5ZXJzLmxlbmd0aCwgbjtcblxuICAgICAgLy8gZG9uJ3QgYWRkIHRoZSBsYXllciBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgZm9yIChuID0gMDsgbiA8IGxlbjsgbisrKSB7XG4gICAgICAgIGlmIChsYXllcnNbbl0uX2lkID09PSBsYXllci5faWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBkZXRlcm1pbmUgaWYgYW5pbWF0aW9uIGlzIHJ1bm5pbmcgb3Igbm90LiAgcmV0dXJucyB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybiB7Qm9vbH0gaXMgYW5pbWF0aW9uIHJ1bm5pbmc/XG4gICAgICAgICAqL1xuICAgIGlzUnVubmluZzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IEtvbnZhLkFuaW1hdGlvbixcbiAgICAgICAgYW5pbWF0aW9ucyA9IGEuYW5pbWF0aW9ucyxcbiAgICAgICAgbGVuID0gYW5pbWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIG47XG5cbiAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICBpZiAoYW5pbWF0aW9uc1tuXS5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc3RhcnQgYW5pbWF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybiB7S29udmEuQW5pbWF0aW9ufSB0aGlzXG4gICAgICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBBbmltID0gS29udmEuQW5pbWF0aW9uO1xuICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB0aGlzLmZyYW1lLnRpbWVEaWZmID0gMDtcbiAgICAgIHRoaXMuZnJhbWUubGFzdFRpbWUgPSBub3coKTtcbiAgICAgIEFuaW0uX2FkZEFuaW1hdGlvbih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHN0b3AgYW5pbWF0aW9uXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkFuaW1hdGlvbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybiB7S29udmEuQW5pbWF0aW9ufSB0aGlzXG4gICAgICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgS29udmEuQW5pbWF0aW9uLl9yZW1vdmVBbmltYXRpb24odGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIF91cGRhdGVGcmFtZU9iamVjdDogZnVuY3Rpb24odGltZSkge1xuICAgICAgdGhpcy5mcmFtZS50aW1lRGlmZiA9IHRpbWUgLSB0aGlzLmZyYW1lLmxhc3RUaW1lO1xuICAgICAgdGhpcy5mcmFtZS5sYXN0VGltZSA9IHRpbWU7XG4gICAgICB0aGlzLmZyYW1lLnRpbWUgKz0gdGhpcy5mcmFtZS50aW1lRGlmZjtcbiAgICAgIHRoaXMuZnJhbWUuZnJhbWVSYXRlID0gMTAwMCAvIHRoaXMuZnJhbWUudGltZURpZmY7XG4gICAgfVxuICB9O1xuICBLb252YS5BbmltYXRpb24uYW5pbWF0aW9ucyA9IFtdO1xuICBLb252YS5BbmltYXRpb24uYW5pbUlkQ291bnRlciA9IDA7XG4gIEtvbnZhLkFuaW1hdGlvbi5hbmltUnVubmluZyA9IGZhbHNlO1xuXG4gIEtvbnZhLkFuaW1hdGlvbi5fYWRkQW5pbWF0aW9uID0gZnVuY3Rpb24oYW5pbSkge1xuICAgIHRoaXMuYW5pbWF0aW9ucy5wdXNoKGFuaW0pO1xuICAgIHRoaXMuX2hhbmRsZUFuaW1hdGlvbigpO1xuICB9O1xuICBLb252YS5BbmltYXRpb24uX3JlbW92ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uKGFuaW0pIHtcbiAgICB2YXIgaWQgPSBhbmltLmlkLCBhbmltYXRpb25zID0gdGhpcy5hbmltYXRpb25zLCBsZW4gPSBhbmltYXRpb25zLmxlbmd0aCwgbjtcblxuICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgaWYgKGFuaW1hdGlvbnNbbl0uaWQgPT09IGlkKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5zcGxpY2UobiwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5BbmltYXRpb24uX3J1bkZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsYXllckhhc2ggPSB7fSxcbiAgICAgIGFuaW1hdGlvbnMgPSB0aGlzLmFuaW1hdGlvbnMsXG4gICAgICBhbmltLFxuICAgICAgbGF5ZXJzLFxuICAgICAgZnVuYyxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgbGF5ZXJzTGVuLFxuICAgICAgbGF5ZXIsXG4gICAgICBrZXksXG4gICAgICBuZWVkUmVkcmF3O1xuICAgIC8qXG4gICAgICAgICAqIGxvb3AgdGhyb3VnaCBhbGwgYW5pbWF0aW9ucyBhbmQgZXhlY3V0ZSBhbmltYXRpb25cbiAgICAgICAgICogIGZ1bmN0aW9uLiAgaWYgdGhlIGFuaW1hdGlvbiBvYmplY3QgaGFzIHNwZWNpZmllZCBub2RlLFxuICAgICAgICAgKiAgd2UgY2FuIGFkZCB0aGUgbm9kZSB0byB0aGUgbm9kZXMgaGFzaCB0byBlbGltaW5hdGVcbiAgICAgICAgICogIGRyYXdpbmcgdGhlIHNhbWUgbm9kZSBtdWx0aXBsZSB0aW1lcy4gIFRoZSBub2RlIHByb3BlcnR5XG4gICAgICAgICAqICBjYW4gYmUgdGhlIHN0YWdlIGl0c2VsZiBvciBhIGxheWVyXG4gICAgICAgICAqL1xuICAgIC8qXG4gICAgICAgICAqIFdBUk5JTkc6IGRvbid0IGNhY2hlIGFuaW1hdGlvbnMubGVuZ3RoIGJlY2F1c2UgaXQgY291bGQgY2hhbmdlIHdoaWxlXG4gICAgICAgICAqIHRoZSBmb3IgbG9vcCBpcyBydW5uaW5nLCBjYXVzaW5nIGEgSlMgZXJyb3JcbiAgICAgICAgICovXG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgYW5pbWF0aW9ucy5sZW5ndGg7IG4rKykge1xuICAgICAgYW5pbSA9IGFuaW1hdGlvbnNbbl07XG4gICAgICBsYXllcnMgPSBhbmltLmxheWVycztcbiAgICAgIGZ1bmMgPSBhbmltLmZ1bmM7XG5cbiAgICAgIGFuaW0uX3VwZGF0ZUZyYW1lT2JqZWN0KG5vdygpKTtcbiAgICAgIGxheWVyc0xlbiA9IGxheWVycy5sZW5ndGg7XG5cbiAgICAgIC8vIGlmIGFuaW1hdGlvbiBvYmplY3QgaGFzIGEgZnVuY3Rpb24sIGV4ZWN1dGUgaXRcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIC8vIGFsbG93IGFuaW0gYnlwYXNzaW5nIGRyYXdpbmdcbiAgICAgICAgbmVlZFJlZHJhdyA9IGZ1bmMuY2FsbChhbmltLCBhbmltLmZyYW1lKSAhPT0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkUmVkcmF3ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghbmVlZFJlZHJhdykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnNMZW47IGkrKykge1xuICAgICAgICBsYXllciA9IGxheWVyc1tpXTtcblxuICAgICAgICBpZiAobGF5ZXIuX2lkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBsYXllckhhc2hbbGF5ZXIuX2lkXSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gbGF5ZXJIYXNoKSB7XG4gICAgICBpZiAoIWxheWVySGFzaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGF5ZXJIYXNoW2tleV0uZHJhdygpO1xuICAgIH1cbiAgfTtcbiAgS29udmEuQW5pbWF0aW9uLl9hbmltYXRpb25Mb29wID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEFuaW0gPSBLb252YS5BbmltYXRpb247XG4gICAgaWYgKEFuaW0uYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIEFuaW0uX3J1bkZyYW1lcygpO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZShBbmltLl9hbmltYXRpb25Mb29wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQW5pbS5hbmltUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgS29udmEuQW5pbWF0aW9uLl9oYW5kbGVBbmltYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuYW5pbVJ1bm5pbmcpIHtcbiAgICAgIHRoaXMuYW5pbVJ1bm5pbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRpb25Mb29wKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAgICogYmF0Y2ggZHJhdy4gdGhpcyBmdW5jdGlvbiB3aWxsIG5vdCBkbyBpbW1lZGlhdGUgZHJhd1xuICAgICAqIGJ1dCBpdCB3aWxsIHNjaGVkdWxlIGRyYXdpbmcgdG8gbmV4dCB0aWNrIChyZXF1ZXN0QW5pbUZyYW1lKVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtLb252YS5MYXllcn0gdGhpc1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5CYXNlLnByb3RvdHlwZVxuICAgICAqL1xuICBLb252YS5CYXNlTGF5ZXIucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcywgQW5pbSA9IEtvbnZhLkFuaW1hdGlvbjtcblxuICAgIGlmICghdGhpcy5iYXRjaEFuaW0pIHtcbiAgICAgIHRoaXMuYmF0Y2hBbmltID0gbmV3IEFuaW0oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHN0b3AgYW5pbWF0aW9uIGFmdGVyIGZpcnN0IHRpY2tcbiAgICAgICAgdGhhdC5iYXRjaEFuaW0uc3RvcCgpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmJhdGNoQW5pbS5pc1J1bm5pbmcoKSkge1xuICAgICAgdGhpcy5iYXRjaEFuaW0uc3RhcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAgICogYmF0Y2ggZHJhd1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtLb252YS5TdGFnZX0gdGhpc1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFnZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgS29udmEuU3RhZ2UucHJvdG90eXBlLmJhdGNoRHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICBsYXllci5iYXRjaERyYXcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIHZhciBibGFja2xpc3QgPSB7XG4gICAgbm9kZTogMSxcbiAgICBkdXJhdGlvbjogMSxcbiAgICBlYXNpbmc6IDEsXG4gICAgb25GaW5pc2g6IDEsXG4gICAgeW95bzogMVxuICB9LFxuICAgIFBBVVNFRCA9IDEsXG4gICAgUExBWUlORyA9IDIsXG4gICAgUkVWRVJTSU5HID0gMyxcbiAgICBpZENvdW50ZXIgPSAwLFxuICAgIGNvbG9yQXR0cnMgPSBbJ2ZpbGwnLCAnc3Ryb2tlJywgJ3NoYWRvd0NvbG9yJ107XG5cbiAgdmFyIFR3ZWVuID0gZnVuY3Rpb24ocHJvcCwgcHJvcEZ1bmMsIGZ1bmMsIGJlZ2luLCBmaW5pc2gsIGR1cmF0aW9uLCB5b3lvKSB7XG4gICAgdGhpcy5wcm9wID0gcHJvcDtcbiAgICB0aGlzLnByb3BGdW5jID0gcHJvcEZ1bmM7XG4gICAgdGhpcy5iZWdpbiA9IGJlZ2luO1xuICAgIHRoaXMuX3BvcyA9IGJlZ2luO1xuICAgIHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICB0aGlzLl9jaGFuZ2UgPSAwO1xuICAgIHRoaXMucHJldlBvcyA9IDA7XG4gICAgdGhpcy55b3lvID0geW95bztcbiAgICB0aGlzLl90aW1lID0gMDtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5fc3RhcnRUaW1lID0gMDtcbiAgICB0aGlzLl9maW5pc2ggPSAwO1xuICAgIHRoaXMuZnVuYyA9IGZ1bmM7XG4gICAgdGhpcy5fY2hhbmdlID0gZmluaXNoIC0gdGhpcy5iZWdpbjtcbiAgICB0aGlzLnBhdXNlKCk7XG4gIH07XG4gIC8qXG4gICAgICogVHdlZW4gbWV0aG9kc1xuICAgICAqL1xuICBUd2Vlbi5wcm90b3R5cGUgPSB7XG4gICAgZmlyZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHRoaXNbc3RyXTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGhhbmRsZXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFRpbWU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgIGlmICh0ID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICBpZiAodGhpcy55b3lvKSB7XG4gICAgICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICBpZiAodGhpcy55b3lvKSB7XG4gICAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRpbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RpbWU7XG4gICAgfSxcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocCkge1xuICAgICAgdGhpcy5wcmV2UG9zID0gdGhpcy5fcG9zO1xuICAgICAgdGhpcy5wcm9wRnVuYyhwKTtcbiAgICAgIHRoaXMuX3BvcyA9IHA7XG4gICAgfSxcbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24odCkge1xuICAgICAgaWYgKHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ID0gdGhpcy5fdGltZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZ1bmModCwgdGhpcy5iZWdpbiwgdGhpcy5fY2hhbmdlLCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9LFxuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBMQVlJTkc7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgIHRoaXMuZmlyZSgnb25QbGF5Jyk7XG4gICAgfSxcbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBSRVZFUlNJTkc7XG4gICAgICB0aGlzLl90aW1lID0gdGhpcy5kdXJhdGlvbiAtIHRoaXMuX3RpbWU7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5vbkVudGVyRnJhbWUoKTtcbiAgICAgIHRoaXMuZmlyZSgnb25SZXZlcnNlJyk7XG4gICAgfSxcbiAgICBzZWVrOiBmdW5jdGlvbih0KSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICB0aGlzLl90aW1lID0gdDtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB0aGlzLmZpcmUoJ29uU2VlaycpO1xuICAgIH0sXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdvblJlc2V0Jyk7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5fdGltZSA9IHRoaXMuZHVyYXRpb247XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5maXJlKCdvbkZpbmlzaCcpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0UG9zaXRpb24odGhpcy5nZXRQb3NpdGlvbih0aGlzLl90aW1lKSk7XG4gICAgfSxcbiAgICBvbkVudGVyRnJhbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQgPSB0aGlzLmdldFRpbWVyKCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gUExBWUlORykge1xuICAgICAgICB0aGlzLnNldFRpbWUodCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFJFVkVSU0lORykge1xuICAgICAgICB0aGlzLnNldFRpbWUodGhpcy5kdXJhdGlvbiAtIHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFBBVVNFRDtcbiAgICAgIHRoaXMuZmlyZSgnb25QYXVzZScpO1xuICAgIH0sXG4gICAgZ2V0VGltZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICAgKiBUd2VlbiBjb25zdHJ1Y3Rvci4gIFR3ZWVucyBlbmFibGUgeW91IHRvIGFuaW1hdGUgYSBub2RlIGJldHdlZW4gdGhlIGN1cnJlbnQgc3RhdGUgYW5kIGEgbmV3IHN0YXRlLlxuICAgICAqICBZb3UgY2FuIHBsYXksIHBhdXNlLCByZXZlcnNlLCBzZWVrLCByZXNldCwgYW5kIGZpbmlzaCB0d2VlbnMuICBCeSBkZWZhdWx0LCB0d2VlbnMgYXJlIGFuaW1hdGVkIHVzaW5nXG4gICAgICogIGEgbGluZWFyIGVhc2luZy4gIEZvciBtb3JlIHR3ZWVuaW5nIG9wdGlvbnMsIGNoZWNrIG91dCB7QGxpbmsgS29udmEuRWFzaW5nc31cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGluc3RhbnRpYXRlIG5ldyB0d2VlbiB3aGljaCBmdWxseSByb3RhdGVzIGEgbm9kZSBpbiAxIHNlY29uZFxuICAgICAqIHZhciB0d2VlbiA9IG5ldyBLb252YS5Ud2Vlbih7XG4gICAgICogICBub2RlOiBub2RlLFxuICAgICAqICAgcm90YXRpb25EZWc6IDM2MCxcbiAgICAgKiAgIGR1cmF0aW9uOiAxLFxuICAgICAqICAgZWFzaW5nOiBLb252YS5FYXNpbmdzLkVhc2VJbk91dFxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gcGxheSB0d2VlblxuICAgICAqIHR3ZWVuLnBsYXkoKTtcbiAgICAgKlxuICAgICAqIC8vIHBhdXNlIHR3ZWVuXG4gICAgICogdHdlZW4ucGF1c2UoKTtcbiAgICAgKi9cbiAgS29udmEuVHdlZW4gPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICBub2RlID0gY29uZmlnLm5vZGUsXG4gICAgICBub2RlSWQgPSBub2RlLl9pZCxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgZWFzaW5nID0gY29uZmlnLmVhc2luZyB8fCBLb252YS5FYXNpbmdzLkxpbmVhcixcbiAgICAgIHlveW8gPSAhIWNvbmZpZy55b3lvLFxuICAgICAga2V5O1xuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuZHVyYXRpb24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkdXJhdGlvbiA9IDE7XG4gICAgfSBlbHNlIGlmIChjb25maWcuZHVyYXRpb24gPT09IDApIHtcbiAgICAgIC8vIHplcm8gaXMgYmFkIHZhbHVlIGZvciBkdXJhdGlvblxuICAgICAgZHVyYXRpb24gPSAwLjAwMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZHVyYXRpb24gPSBjb25maWcuZHVyYXRpb247XG4gICAgfVxuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5faWQgPSBpZENvdW50ZXIrKztcblxuICAgIHZhciBsYXllcnMgPVxuICAgICAgbm9kZS5nZXRMYXllcigpIHx8XG4gICAgICAobm9kZSBpbnN0YW5jZW9mIEtvbnZhLlN0YWdlID8gbm9kZS5nZXRMYXllcnMoKSA6IG51bGwpO1xuICAgIGlmICghbGF5ZXJzKSB7XG4gICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAnVHdlZW4gY29uc3RydWN0b3IgaGF2ZSBgbm9kZWAgdGhhdCBpcyBub3QgaW4gYSBsYXllci4gUGxlYXNlIGFkZCBub2RlIGludG8gbGF5ZXIgZmlyc3QuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5hbmltID0gbmV3IEtvbnZhLkFuaW1hdGlvbihmdW5jdGlvbigpIHtcbiAgICAgIHRoYXQudHdlZW4ub25FbnRlckZyYW1lKCk7XG4gICAgfSwgbGF5ZXJzKTtcblxuICAgIHRoaXMudHdlZW4gPSBuZXcgVHdlZW4oXG4gICAgICBrZXksXG4gICAgICBmdW5jdGlvbihpKSB7XG4gICAgICAgIHRoYXQuX3R3ZWVuRnVuYyhpKTtcbiAgICAgIH0sXG4gICAgICBlYXNpbmcsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIGR1cmF0aW9uICogMTAwMCxcbiAgICAgIHlveW9cbiAgICApO1xuXG4gICAgdGhpcy5fYWRkTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBpbml0IGF0dHJzIG1hcFxuICAgIGlmICghS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSkge1xuICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXSA9IHt9O1xuICAgIH1cbiAgICBpZiAoIUtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdGhpcy5faWRdKSB7XG4gICAgICBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXMuX2lkXSA9IHt9O1xuICAgIH1cbiAgICAvLyBpbml0IHR3ZWVucyBtYXBcbiAgICBpZiAoIUtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdKSB7XG4gICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXSA9IHt9O1xuICAgIH1cblxuICAgIGZvciAoa2V5IGluIGNvbmZpZykge1xuICAgICAgaWYgKGJsYWNrbGlzdFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fYWRkQXR0cihrZXksIGNvbmZpZ1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICAvLyBjYWxsYmFja3NcbiAgICB0aGlzLm9uRmluaXNoID0gY29uZmlnLm9uRmluaXNoO1xuICAgIHRoaXMub25SZXNldCA9IGNvbmZpZy5vblJlc2V0O1xuICB9O1xuXG4gIC8vIHN0YXJ0L2RpZmYgb2JqZWN0ID0gYXR0cnMubm9kZUlkLnR3ZWVuSWQuYXR0clxuICBLb252YS5Ud2Vlbi5hdHRycyA9IHt9O1xuICAvLyB0d2VlbklkID0gdHdlZW5zLm5vZGVJZC5hdHRyXG4gIEtvbnZhLlR3ZWVuLnR3ZWVucyA9IHt9O1xuXG4gIEtvbnZhLlR3ZWVuLnByb3RvdHlwZSA9IHtcbiAgICBfYWRkQXR0cjogZnVuY3Rpb24oa2V5LCBlbmQpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlLFxuICAgICAgICBub2RlSWQgPSBub2RlLl9pZCxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGRpZmYsXG4gICAgICAgIHR3ZWVuSWQsXG4gICAgICAgIG4sXG4gICAgICAgIGxlbixcbiAgICAgICAgdHJ1ZUVuZCxcbiAgICAgICAgdHJ1ZVN0YXJ0O1xuXG4gICAgICAvLyByZW1vdmUgY29uZmxpY3QgZnJvbSB0d2VlbiBtYXAgaWYgaXQgZXhpc3RzXG4gICAgICB0d2VlbklkID0gS29udmEuVHdlZW4udHdlZW5zW25vZGVJZF1ba2V5XTtcblxuICAgICAgaWYgKHR3ZWVuSWQpIHtcbiAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLmF0dHJzW25vZGVJZF1bdHdlZW5JZF1ba2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRvIHR3ZWVuIG1hcFxuICAgICAgc3RhcnQgPSBub2RlLmdldEF0dHIoa2V5KTtcblxuICAgICAgaWYgKEtvbnZhLlV0aWwuX2lzQXJyYXkoZW5kKSkge1xuICAgICAgICBkaWZmID0gW107XG4gICAgICAgIGxlbiA9IE1hdGgubWF4KGVuZC5sZW5ndGgsIHN0YXJ0Lmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycgJiYgZW5kLmxlbmd0aCAhPT0gc3RhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gYmVmb3JlIHR3ZWVuaW5nIHBvaW50cyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHN0YXJ0Lmxlbmd0aCA9PT0gZW5kLmxlbmd0aFxuICAgICAgICAgIC8vIEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuIHRoaW5raW5nIHRoYXQgZW5kLmxlbmd0aCA+IHN0YXJ0Lmxlbmd0aFxuXG4gICAgICAgICAgaWYgKGVuZC5sZW5ndGggPiBzdGFydC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNvIGluIHRoaXMgY2FzZSB3ZSB3aWxsIGluY3JlYXNlIG51bWJlciBvZiBzdGFydGluZyBwb2ludHNcbiAgICAgICAgICAgIHRydWVTdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSBLb252YS5VdGlsLl9wcmVwYXJlQXJyYXlGb3JUd2VlbihzdGFydCwgZW5kLCBub2RlLmNsb3NlZCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHdlIHdpbGwgaW5jcmVhc2UgbnVtYmVyIG9mIGVkaW5nIHBvaW50c1xuICAgICAgICAgICAgdHJ1ZUVuZCA9IGVuZDtcbiAgICAgICAgICAgIGVuZCA9IEtvbnZhLlV0aWwuX3ByZXBhcmVBcnJheUZvclR3ZWVuKGVuZCwgc3RhcnQsIG5vZGUuY2xvc2VkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgIGRpZmYucHVzaChlbmRbbl0gLSBzdGFydFtuXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29sb3JBdHRycy5pbmRleE9mKGtleSkgIT09IC0xKSB7XG4gICAgICAgIHN0YXJ0ID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShzdGFydCk7XG4gICAgICAgIHZhciBlbmRSR0JBID0gS29udmEuVXRpbC5jb2xvclRvUkdCQShlbmQpO1xuICAgICAgICBkaWZmID0ge1xuICAgICAgICAgIHI6IGVuZFJHQkEuciAtIHN0YXJ0LnIsXG4gICAgICAgICAgZzogZW5kUkdCQS5nIC0gc3RhcnQuZyxcbiAgICAgICAgICBiOiBlbmRSR0JBLmIgLSBzdGFydC5iLFxuICAgICAgICAgIGE6IGVuZFJHQkEuYSAtIHN0YXJ0LmFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgICAgIH1cblxuICAgICAgS29udmEuVHdlZW4uYXR0cnNbbm9kZUlkXVt0aGlzLl9pZF1ba2V5XSA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBkaWZmOiBkaWZmLFxuICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgdHJ1ZUVuZDogdHJ1ZUVuZCxcbiAgICAgICAgdHJ1ZVN0YXJ0OiB0cnVlU3RhcnRcbiAgICAgIH07XG4gICAgICBLb252YS5Ud2Vlbi50d2VlbnNbbm9kZUlkXVtrZXldID0gdGhpcy5faWQ7XG4gICAgfSxcbiAgICBfdHdlZW5GdW5jOiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZSxcbiAgICAgICAgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhpcy5faWRdLFxuICAgICAgICBrZXksXG4gICAgICAgIGF0dHIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBkaWZmLFxuICAgICAgICBuZXdWYWwsXG4gICAgICAgIG4sXG4gICAgICAgIGxlbixcbiAgICAgICAgZW5kO1xuXG4gICAgICBmb3IgKGtleSBpbiBhdHRycykge1xuICAgICAgICBhdHRyID0gYXR0cnNba2V5XTtcbiAgICAgICAgc3RhcnQgPSBhdHRyLnN0YXJ0O1xuICAgICAgICBkaWZmID0gYXR0ci5kaWZmO1xuICAgICAgICBlbmQgPSBhdHRyLmVuZDtcblxuICAgICAgICBpZiAoS29udmEuVXRpbC5faXNBcnJheShzdGFydCkpIHtcbiAgICAgICAgICBuZXdWYWwgPSBbXTtcbiAgICAgICAgICBsZW4gPSBNYXRoLm1heChzdGFydC5sZW5ndGgsIGVuZC5sZW5ndGgpO1xuICAgICAgICAgIGZvciAobiA9IDA7IG4gPCBsZW47IG4rKykge1xuICAgICAgICAgICAgbmV3VmFsLnB1c2goKHN0YXJ0W25dIHx8IDApICsgZGlmZltuXSAqIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjb2xvckF0dHJzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICBuZXdWYWwgPVxuICAgICAgICAgICAgJ3JnYmEoJyArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKHN0YXJ0LnIgKyBkaWZmLnIgKiBpKSArXG4gICAgICAgICAgICAnLCcgK1xuICAgICAgICAgICAgTWF0aC5yb3VuZChzdGFydC5nICsgZGlmZi5nICogaSkgK1xuICAgICAgICAgICAgJywnICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoc3RhcnQuYiArIGRpZmYuYiAqIGkpICtcbiAgICAgICAgICAgICcsJyArXG4gICAgICAgICAgICAoc3RhcnQuYSArIGRpZmYuYSAqIGkpICtcbiAgICAgICAgICAgICcpJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdWYWwgPSBzdGFydCArIGRpZmYgKiBpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zZXRBdHRyKGtleSwgbmV3VmFsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9hZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAvLyBzdGFydCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMudHdlZW4ub25QbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMudHdlZW4ub25SZXZlcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuYW5pbS5zdGFydCgpO1xuICAgICAgfTtcblxuICAgICAgLy8gc3RvcCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMudHdlZW4ub25QYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmFuaW0uc3RvcCgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMudHdlZW4ub25GaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGF0Lm5vZGU7XG5cbiAgICAgICAgLy8gYWZ0ZXIgdHdlZW5pbmcgIHBvaW50cyBvZiBsaW5lIHdlIG5lZWQgdG8gc2V0IG9yaWdpbmFsIGVuZFxuICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhhdC5faWRdO1xuICAgICAgICBpZiAoYXR0cnMucG9pbnRzICYmIGF0dHJzLnBvaW50cy50cnVlRW5kKSB7XG4gICAgICAgICAgbm9kZS5wb2ludHMoYXR0cnMucG9pbnRzLnRydWVFbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoYXQub25GaW5pc2gpIHtcbiAgICAgICAgICB0aGF0Lm9uRmluaXNoLmNhbGwodGhhdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnR3ZWVuLm9uUmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGF0Lm5vZGU7XG4gICAgICAgIC8vIGFmdGVyIHR3ZWVuaW5nICBwb2ludHMgb2YgbGluZSB3ZSBuZWVkIHRvIHNldCBvcmlnaW5hbCBzdGFydFxuICAgICAgICB2YXIgYXR0cnMgPSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlLl9pZF1bdGhhdC5faWRdO1xuICAgICAgICBpZiAoYXR0cnMucG9pbnRzICYmIGF0dHJzLnBvaW50cy50cnVlU3RhcnQpIHtcbiAgICAgICAgICBub2RlLnBvaW50cyhhdHRycy5wb2ludHMudHJ1ZVN0YXJ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGF0Lm9uUmVzZXQpIHtcbiAgICAgICAgICB0aGF0Lm9uUmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBwbGF5XG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50d2Vlbi5wbGF5KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXZlcnNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50d2Vlbi5yZXZlcnNlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiByZXNldFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnR3ZWVuLnJlc2V0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAgKiBzZWVrXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHQgdGltZSBpbiBzZWNvbmRzIGJldHdlZW4gMCBhbmQgdGhlIGR1cmF0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHtUd2Vlbn1cbiAgICAgICAgICovXG4gICAgc2VlazogZnVuY3Rpb24odCkge1xuICAgICAgdGhpcy50d2Vlbi5zZWVrKHQgKiAxMDAwKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHBhdXNlXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQG1lbWJlcm9mIEtvbnZhLlR3ZWVuLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7VHdlZW59XG4gICAgICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHdlZW4ucGF1c2UoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGZpbmlzaFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5Ud2Vlbi5wcm90b3R5cGVcbiAgICAgICAgICogQHJldHVybnMge1R3ZWVufVxuICAgICAgICAgKi9cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50d2Vlbi5maW5pc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGRlc3Ryb3lcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuVHdlZW4ucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vZGVJZCA9IHRoaXMubm9kZS5faWQsXG4gICAgICAgIHRoaXNJZCA9IHRoaXMuX2lkLFxuICAgICAgICBhdHRycyA9IEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdLFxuICAgICAgICBrZXk7XG5cbiAgICAgIHRoaXMucGF1c2UoKTtcblxuICAgICAgZm9yIChrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZGVsZXRlIEtvbnZhLlR3ZWVuLnR3ZWVuc1tub2RlSWRdW2tleV07XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSBLb252YS5Ud2Vlbi5hdHRyc1tub2RlSWRdW3RoaXNJZF07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgICAqIFR3ZWVuIG5vZGUgcHJvcGVydGllcy4gU2hvcnRlciB1c2FnZSBvZiB7QGxpbmsgS29udmEuVHdlZW59IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgS29udmEuTm9kZSN0b1xuICAgICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXNdIHR3ZWVuIHBhcmFtc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBjaXJjbGUudG8oe1xuICAgICAqICB4IDogNTAsXG4gICAgICogIGR1cmF0aW9uIDogMC41XG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnRvID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIG9uRmluaXNoID0gcGFyYW1zLm9uRmluaXNoO1xuICAgIHBhcmFtcy5ub2RlID0gdGhpcztcbiAgICBwYXJhbXMub25GaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICAgIG9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgdHdlZW4gPSBuZXcgS29udmEuVHdlZW4ocGFyYW1zKTtcbiAgICB0d2Vlbi5wbGF5KCk7XG4gIH07XG5cbiAgLypcbiAgICAqIFRoZXNlIGVhc2VzIHdlcmUgcG9ydGVkIGZyb20gYW4gQWRvYmUgRmxhc2ggdHdlZW5pbmcgbGlicmFyeSB0byBKYXZhU2NyaXB0XG4gICAgKiBieSBYYXJpY1xuICAgICovXG5cbiAgLyoqXG4gICAgICogQG5hbWVzcGFjZSBFYXNpbmdzXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICovXG4gIEtvbnZhLkVhc2luZ3MgPSB7XG4gICAgLyoqXG4gICAgICAgICogYmFjayBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBCYWNrRWFzZUluOiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqICgocyArIDEpICogdCAtIHMpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGJhY2sgZWFzZSBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEJhY2tFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBiYWNrIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBCYWNrRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgICBpZiAoKHQgLz0gZCAvIDIpIDwgMSkge1xuICAgICAgICByZXR1cm4gYyAvIDIgKiAodCAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCAtIHMpKSArIGI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyAvIDIgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgKyBzKSArIDIpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpblxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgRWxhc3RpY0Vhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCwgYSwgcCkge1xuICAgICAgLy8gYWRkZWQgcyA9IDBcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIGlmICh0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgaWYgKCh0IC89IGQpID09PSAxKSB7XG4gICAgICAgIHJldHVybiBiICsgYztcbiAgICAgIH1cbiAgICAgIGlmICghcCkge1xuICAgICAgICBwID0gZCAqIDAuMztcbiAgICAgIH1cbiAgICAgIGlmICghYSB8fCBhIDwgTWF0aC5hYnMoYykpIHtcbiAgICAgICAgYSA9IGM7XG4gICAgICAgIHMgPSBwIC8gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbihjIC8gYSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICAtKGEgKlxuICAgICAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgICAgICBNYXRoLnNpbigodCAqIGQgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSkgKyBiXG4gICAgICApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZWxhc3RpYyBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgRWxhc3RpY0Vhc2VPdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgIC8vIGFkZGVkIHMgPSAwXG4gICAgICB2YXIgcyA9IDA7XG4gICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGlmICgodCAvPSBkKSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYiArIGM7XG4gICAgICB9XG4gICAgICBpZiAoIXApIHtcbiAgICAgICAgcCA9IGQgKiAwLjM7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgIGEgPSBjO1xuICAgICAgICBzID0gcCAvIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgK1xuICAgICAgICBjICtcbiAgICAgICAgYlxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGVsYXN0aWMgZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEVsYXN0aWNFYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIGEsIHApIHtcbiAgICAgIC8vIGFkZGVkIHMgPSAwXG4gICAgICB2YXIgcyA9IDA7XG4gICAgICBpZiAodCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGlmICgodCAvPSBkIC8gMikgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGIgKyBjO1xuICAgICAgfVxuICAgICAgaWYgKCFwKSB7XG4gICAgICAgIHAgPSBkICogKDAuMyAqIDEuNSk7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgYSA8IE1hdGguYWJzKGMpKSB7XG4gICAgICAgIGEgPSBjO1xuICAgICAgICBzID0gcCAvIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oYyAvIGEpO1xuICAgICAgfVxuICAgICAgaWYgKHQgPCAxKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgLTAuNSAqXG4gICAgICAgICAgICAoYSAqXG4gICAgICAgICAgICAgIE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICpcbiAgICAgICAgICAgICAgTWF0aC5zaW4oKHQgKiBkIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpICtcbiAgICAgICAgICBiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICBhICpcbiAgICAgICAgICBNYXRoLnBvdygyLCAtMTAgKiAodCAtPSAxKSkgKlxuICAgICAgICAgIE1hdGguc2luKCh0ICogZCAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICpcbiAgICAgICAgICAwLjUgK1xuICAgICAgICBjICtcbiAgICAgICAgYlxuICAgICAgKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGJvdW5jZSBlYXNlIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgQm91bmNlRWFzZU91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgaWYgKCh0IC89IGQpIDwgMSAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogdCAqIHQpICsgYjtcbiAgICAgIH0gZWxzZSBpZiAodCA8IDIgLyAyLjc1KSB7XG4gICAgICAgIHJldHVybiBjICogKDcuNTYyNSAqICh0IC09IDEuNSAvIDIuNzUpICogdCArIDAuNzUpICsgYjtcbiAgICAgIH0gZWxzZSBpZiAodCA8IDIuNSAvIDIuNzUpIHtcbiAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMi4yNSAvIDIuNzUpICogdCArIDAuOTM3NSkgKyBiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGMgKiAoNy41NjI1ICogKHQgLT0gMi42MjUgLyAyLjc1KSAqIHQgKyAwLjk4NDM3NSkgKyBiO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogYm91bmNlIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEJvdW5jZUVhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgLSBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VPdXQoZCAtIHQsIDAsIGMsIGQpICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGJvdW5jZSBlYXNlIGluIG91dFxuICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5FYXNpbmdzXG4gICAgICAgICovXG4gICAgQm91bmNlRWFzZUluT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICBpZiAodCA8IGQgLyAyKSB7XG4gICAgICAgIHJldHVybiBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VJbih0ICogMiwgMCwgYywgZCkgKiAwLjUgKyBiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBLb252YS5FYXNpbmdzLkJvdW5jZUVhc2VPdXQodCAqIDIgLSBkLCAwLCBjLCBkKSAqIDAuNSArIGMgKiAwLjUgKyBiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBlYXNlIGluXG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBFYXNlSW46IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICsgYjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICAqIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gLWMgKiAodCAvPSBkKSAqICh0IC0gMikgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogZWFzZSBpbiBvdXRcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIEVhc2VJbk91dDogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgaWYgKCh0IC89IGQgLyAyKSA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGMgLyAyICogdCAqIHQgKyBiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1jIC8gMiAqICgtLXQgKiAodCAtIDIpIC0gMSkgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogc3Ryb25nIGVhc2UgaW5cbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIFN0cm9uZ0Vhc2VJbjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICogdCAqIHQgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogc3Ryb25nIGVhc2Ugb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBTdHJvbmdFYXNlT3V0OiBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSkgKyBiO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICogc3Ryb25nIGVhc2UgaW4gb3V0XG4gICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICogQG1lbWJlcm9mIEtvbnZhLkVhc2luZ3NcbiAgICAgICAgKi9cbiAgICBTdHJvbmdFYXNlSW5PdXQ6IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICAgIGlmICgodCAvPSBkIC8gMikgPCAxKSB7XG4gICAgICAgIHJldHVybiBjIC8gMiAqIHQgKiB0ICogdCAqIHQgKiB0ICsgYjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjIC8gMiAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSArIGI7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgKiBsaW5lYXJcbiAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuRWFzaW5nc1xuICAgICAgICAqL1xuICAgIExpbmVhcjogZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgICAgcmV0dXJuIGMgKiB0IC8gZCArIGI7XG4gICAgfVxuICB9O1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIEtvbnZhLkREID0ge1xuICAgIC8vIHByb3BlcnRpZXNcbiAgICBhbmltOiBuZXcgS29udmEuQW5pbWF0aW9uKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGIgPSB0aGlzLmRpcnR5O1xuICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGI7XG4gICAgfSksXG4gICAgaXNEcmFnZ2luZzogZmFsc2UsXG4gICAganVzdERyYWdnZWQ6IGZhbHNlLFxuICAgIG9mZnNldDoge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9LFxuICAgIG5vZGU6IG51bGwsXG5cbiAgICAvLyBtZXRob2RzXG4gICAgX2RyYWc6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgIG5vZGUgPSBkZC5ub2RlO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKCFkZC5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdmFyIHBvcyA9IG5vZGUuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKTtcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IHBvcyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAvLyByZWF0dGFjaCBpdFxuICAgICAgICAgIGlmICghcG9zKSB7XG4gICAgICAgICAgICBub2RlLmdldFN0YWdlKCkuX3NldFBvaW50ZXJQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgcG9zID0gbm9kZS5nZXRTdGFnZSgpLmdldFBvaW50ZXJQb3NpdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZHJhZ0Rpc3RhbmNlID0gbm9kZS5kcmFnRGlzdGFuY2UoKTtcbiAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLm1heChcbiAgICAgICAgICAgIE1hdGguYWJzKHBvcy54IC0gZGQuc3RhcnRQb2ludGVyUG9zLngpLFxuICAgICAgICAgICAgTWF0aC5hYnMocG9zLnkgLSBkZC5zdGFydFBvaW50ZXJQb3MueSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGRyYWdEaXN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUuZ2V0U3RhZ2UoKS5fc2V0UG9pbnRlclBvc2l0aW9uKGV2dCk7XG4gICAgICAgIG5vZGUuX3NldERyYWdQb3NpdGlvbihldnQpO1xuICAgICAgICBpZiAoIWRkLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICBkZC5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICBub2RlLmZpcmUoXG4gICAgICAgICAgICAnZHJhZ3N0YXJ0JyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2RyYWdzdGFydCcsXG4gICAgICAgICAgICAgIHRhcmdldDogbm9kZSxcbiAgICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cnVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV4ZWN1dGUgb25kcmFnbW92ZSBpZiBkZWZpbmVkXG4gICAgICAgIG5vZGUuZmlyZShcbiAgICAgICAgICAnZHJhZ21vdmUnLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmFnbW92ZScsXG4gICAgICAgICAgICB0YXJnZXQ6IG5vZGUsXG4gICAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAgX2VuZERyYWdCZWZvcmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICAgIG5vZGUgPSBkZC5ub2RlLFxuICAgICAgICBsYXllcjtcblxuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgbGF5ZXIgPSBub2RlLmdldExheWVyKCk7XG4gICAgICAgIGRkLmFuaW0uc3RvcCgpO1xuXG4gICAgICAgIC8vIG9ubHkgZmlyZSBkcmFnZW5kIGV2ZW50IGlmIHRoZSBkcmFnIGFuZCBkcm9wXG4gICAgICAgIC8vIG9wZXJhdGlvbiBhY3R1YWxseSBzdGFydGVkLlxuICAgICAgICBpZiAoZGQuaXNEcmFnZ2luZykge1xuICAgICAgICAgIGRkLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICBkZC5qdXN0RHJhZ2dlZCA9IHRydWU7XG4gICAgICAgICAgS29udmEubGlzdGVuQ2xpY2tUYXAgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChldnQpIHtcbiAgICAgICAgICAgIGV2dC5kcmFnRW5kTm9kZSA9IG5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGVsZXRlIGRkLm5vZGU7XG5cbiAgICAgICAgaWYgKG5vZGUuZ2V0TGF5ZXIoKSB8fCBsYXllciB8fCBub2RlIGluc3RhbmNlb2YgS29udmEuU3RhZ2UpIHtcbiAgICAgICAgICAobGF5ZXIgfHwgbm9kZSkuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBfZW5kRHJhZ0FmdGVyOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIGV2dCA9IGV2dCB8fCB7fTtcbiAgICAgIHZhciBkcmFnRW5kTm9kZSA9IGV2dC5kcmFnRW5kTm9kZTtcblxuICAgICAgaWYgKGV2dCAmJiBkcmFnRW5kTm9kZSkge1xuICAgICAgICBkcmFnRW5kTm9kZS5maXJlKFxuICAgICAgICAgICdkcmFnZW5kJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnZHJhZ2VuZCcsXG4gICAgICAgICAgICB0YXJnZXQ6IGRyYWdFbmROb2RlLFxuICAgICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gTm9kZSBleHRlbmRlcnNcblxuICAvKipcbiAgICogaW5pdGlhdGUgZHJhZyBhbmQgZHJvcFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKi9cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuc3RhcnREcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRkID0gS29udmEuREQsXG4gICAgICBzdGFnZSA9IHRoaXMuZ2V0U3RhZ2UoKSxcbiAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcigpLFxuICAgICAgcG9zID0gc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCksXG4gICAgICBhcCA9IHRoaXMuZ2V0QWJzb2x1dGVQb3NpdGlvbigpO1xuXG4gICAgaWYgKHBvcykge1xuICAgICAgaWYgKGRkLm5vZGUpIHtcbiAgICAgICAgZGQubm9kZS5zdG9wRHJhZygpO1xuICAgICAgfVxuXG4gICAgICBkZC5ub2RlID0gdGhpcztcbiAgICAgIGRkLnN0YXJ0UG9pbnRlclBvcyA9IHBvcztcbiAgICAgIGRkLm9mZnNldC54ID0gcG9zLnggLSBhcC54O1xuICAgICAgZGQub2Zmc2V0LnkgPSBwb3MueSAtIGFwLnk7XG4gICAgICBkZC5hbmltLnNldExheWVycyhsYXllciB8fCB0aGlzLmdldExheWVycygpKTtcbiAgICAgIGRkLmFuaW0uc3RhcnQoKTtcblxuICAgICAgdGhpcy5fc2V0RHJhZ1Bvc2l0aW9uKCk7XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9zZXREcmFnUG9zaXRpb24gPSBmdW5jdGlvbihldnQpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgIHBvcyA9IHRoaXMuZ2V0U3RhZ2UoKS5nZXRQb2ludGVyUG9zaXRpb24oKSxcbiAgICAgIGRiZiA9IHRoaXMuZ2V0RHJhZ0JvdW5kRnVuYygpO1xuICAgIGlmICghcG9zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXdOb2RlUG9zID0ge1xuICAgICAgeDogcG9zLnggLSBkZC5vZmZzZXQueCxcbiAgICAgIHk6IHBvcy55IC0gZGQub2Zmc2V0LnlcbiAgICB9O1xuXG4gICAgaWYgKGRiZiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdOb2RlUG9zID0gZGJmLmNhbGwodGhpcywgbmV3Tm9kZVBvcywgZXZ0KTtcbiAgICB9XG4gICAgdGhpcy5zZXRBYnNvbHV0ZVBvc2l0aW9uKG5ld05vZGVQb3MpO1xuXG4gICAgaWYgKFxuICAgICAgIXRoaXMuX2xhc3RQb3MgfHxcbiAgICAgIHRoaXMuX2xhc3RQb3MueCAhPT0gbmV3Tm9kZVBvcy54IHx8XG4gICAgICB0aGlzLl9sYXN0UG9zLnkgIT09IG5ld05vZGVQb3MueVxuICAgICkge1xuICAgICAgZGQuYW5pbS5kaXJ0eSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fbGFzdFBvcyA9IG5ld05vZGVQb3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIHN0b3AgZHJhZyBhbmQgZHJvcFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5Ob2RlLnByb3RvdHlwZVxuICAgKi9cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuc3RvcERyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERCxcbiAgICAgIGV2dCA9IHt9O1xuICAgIGRkLl9lbmREcmFnQmVmb3JlKGV2dCk7XG4gICAgZGQuX2VuZERyYWdBZnRlcihldnQpO1xuICB9O1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldERyYWdnYWJsZSA9IGZ1bmN0aW9uKGRyYWdnYWJsZSkge1xuICAgIHRoaXMuX3NldEF0dHIoJ2RyYWdnYWJsZScsIGRyYWdnYWJsZSk7XG4gICAgdGhpcy5fZHJhZ0NoYW5nZSgpO1xuICB9O1xuXG4gIHZhciBvcmlnUmVtb3ZlID0gS29udmEuTm9kZS5wcm90b3R5cGUucmVtb3ZlO1xuXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLl9fb3JpZ2luYWxSZW1vdmUgPSBvcmlnUmVtb3ZlO1xuICBLb252YS5Ob2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERDtcblxuICAgIC8vIHN0b3AgRERcbiAgICBpZiAoZGQubm9kZSAmJiBkZC5ub2RlLl9pZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgIHRoaXMuc3RvcERyYWcoKTtcbiAgICB9XG5cbiAgICBvcmlnUmVtb3ZlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIGRldGVybWluZSBpZiBub2RlIGlzIGN1cnJlbnRseSBpbiBkcmFnIGFuZCBkcm9wIG1vZGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICovXG4gIEtvbnZhLk5vZGUucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGQgPSBLb252YS5ERDtcbiAgICByZXR1cm4gISEoZGQubm9kZSAmJiBkZC5ub2RlLl9pZCA9PT0gdGhpcy5faWQgJiYgZGQuaXNEcmFnZ2luZyk7XG4gIH07XG5cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuX2xpc3RlbkRyYWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLl9kcmFnQ2xlYW51cCgpO1xuXG4gICAgaWYgKHRoaXMuZ2V0Q2xhc3NOYW1lKCkgPT09ICdTdGFnZScpIHtcbiAgICAgIHRoaXMub24oJ2NvbnRlbnRNb3VzZWRvd24ua29udmEgY29udGVudFRvdWNoc3RhcnQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCFLb252YS5ERC5ub2RlKSB7XG4gICAgICAgICAgdGhhdC5zdGFydERyYWcoZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24oJ21vdXNlZG93bi5rb252YSB0b3VjaHN0YXJ0LmtvbnZhJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIC8vIGlnbm9yZSByaWdodCBhbmQgbWlkZGxlIGJ1dHRvbnNcbiAgICAgICAgaWYgKGV2dC5ldnQuYnV0dG9uID09PSAxIHx8IGV2dC5ldnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghS29udmEuREQubm9kZSkge1xuICAgICAgICAgIHRoYXQuc3RhcnREcmFnKGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGxpc3RlbmluZyBpcyByZXF1aXJlZCBmb3IgZHJhZyBhbmQgZHJvcFxuICAgIC8qXG4gICAgICAgIHRoaXMuX2xpc3RlbmluZ0VuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9jbGVhclNlbGZBbmRBbmNlc3RvckNhY2hlKCdsaXN0ZW5pbmdFbmFibGVkJyk7XG4gICAgICAgICovXG4gIH07XG5cbiAgS29udmEuTm9kZS5wcm90b3R5cGUuX2RyYWdDaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hdHRycy5kcmFnZ2FibGUpIHtcbiAgICAgIHRoaXMuX2xpc3RlbkRyYWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy5fZHJhZ0NsZWFudXAoKTtcblxuICAgICAgLypcbiAgICAgICAgICAgICAqIGZvcmNlIGRyYWcgYW5kIGRyb3AgdG8gZW5kXG4gICAgICAgICAgICAgKiBpZiB0aGlzIG5vZGUgaXMgY3VycmVudGx5IGluXG4gICAgICAgICAgICAgKiBkcmFnIGFuZCBkcm9wIG1vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgdmFyIHN0YWdlID0gdGhpcy5nZXRTdGFnZSgpO1xuICAgICAgdmFyIGRkID0gS29udmEuREQ7XG4gICAgICBpZiAoc3RhZ2UgJiYgZGQubm9kZSAmJiBkZC5ub2RlLl9pZCA9PT0gdGhpcy5faWQpIHtcbiAgICAgICAgZGQubm9kZS5zdG9wRHJhZygpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5Ob2RlLnByb3RvdHlwZS5fZHJhZ0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5nZXRDbGFzc05hbWUoKSA9PT0gJ1N0YWdlJykge1xuICAgICAgdGhpcy5vZmYoJ2NvbnRlbnRNb3VzZWRvd24ua29udmEnKTtcbiAgICAgIHRoaXMub2ZmKCdjb250ZW50VG91Y2hzdGFydC5rb252YScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm9mZignbW91c2Vkb3duLmtvbnZhJyk7XG4gICAgICB0aGlzLm9mZigndG91Y2hzdGFydC5rb252YScpO1xuICAgIH1cbiAgfTtcblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5Ob2RlLCAnZHJhZ0JvdW5kRnVuYycpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGRyYWcgYm91bmQgZnVuY3Rpb24uICBUaGlzIGlzIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRcbiAgICogIGRyYWcgYW5kIGRyb3AgcG9zaXRpb24uXG4gICAqIEBuYW1lIGRyYWdCb3VuZEZ1bmNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhZ0JvdW5kRnVuY1xuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBkcmFnIGJvdW5kIGZ1bmN0aW9uXG4gICAqIHZhciBkcmFnQm91bmRGdW5jID0gbm9kZS5kcmFnQm91bmRGdW5jKCk7XG4gICAqXG4gICAqIC8vIGNyZWF0ZSB2ZXJ0aWNhbCBkcmFnIGFuZCBkcm9wXG4gICAqIG5vZGUuZHJhZ0JvdW5kRnVuYyhmdW5jdGlvbihwb3Mpe1xuICAgKiAgIC8vIGltcG9ydGFudCBwb3MgLSBpcyBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZVxuICAgKiAgIC8vIHlvdSBzaG91bGQgcmV0dXJuIGFic29sdXRlIHBvc2l0aW9uIHRvb1xuICAgKiAgIHJldHVybiB7XG4gICAqICAgICB4OiB0aGlzLmdldEFic29sdXRlUG9zaXRpb24oKS54LFxuICAgKiAgICAgeTogcG9zLnlcbiAgICogICB9O1xuICAgKiB9KTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXIoS29udmEuTm9kZSwgJ2RyYWdnYWJsZScsIGZhbHNlKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLk5vZGUsICdkcmFnZ2FibGUnKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBkcmFnZ2FibGUgZmxhZ1xuICAgKiBAbmFtZSBkcmFnZ2FibGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTm9kZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBkcmFnZ2FibGVcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBkcmFnZ2FibGUgZmxhZ1xuICAgKiB2YXIgZHJhZ2dhYmxlID0gbm9kZS5kcmFnZ2FibGUoKTtcbiAgICpcbiAgICogLy8gZW5hYmxlIGRyYWcgYW5kIGRyb3BcbiAgICogbm9kZS5kcmFnZ2FibGUodHJ1ZSk7XG4gICAqXG4gICAqIC8vIGRpc2FibGUgZHJhZyBhbmQgZHJvcFxuICAgKiBub2RlLmRyYWdnYWJsZShmYWxzZSk7XG4gICAqL1xuXG4gIGlmIChLb252YS5pc0Jyb3dzZXIpIHtcbiAgICB2YXIgaHRtbCA9IEtvbnZhLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBLb252YS5ERC5fZW5kRHJhZ0JlZm9yZSwgdHJ1ZSk7XG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIEtvbnZhLkRELl9lbmREcmFnQmVmb3JlLCB0cnVlKTtcblxuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgS29udmEuREQuX2RyYWcpO1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgS29udmEuREQuX2RyYWcpO1xuXG4gICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgS29udmEuREQuX2VuZERyYWdBZnRlciwgZmFsc2UpO1xuICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBLb252YS5ERC5fZW5kRHJhZ0FmdGVyLCBmYWxzZSk7XG4gIH1cbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBSZWN0IGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHJlY3QgPSBuZXcgS29udmEuUmVjdCh7XG4gICAgICogICB3aWR0aDogMTAwLFxuICAgICAqICAgaGVpZ2h0OiA1MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snLFxuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuUmVjdCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlJlY3QucHJvdG90eXBlID0ge1xuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmVjdCc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGNvcm5lclJhZGl1cyA9IHRoaXMuZ2V0Q29ybmVyUmFkaXVzKCksXG4gICAgICAgIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICBpZiAoIWNvcm5lclJhZGl1cykge1xuICAgICAgICAvLyBzaW1wbGUgcmVjdCAtIGRvbid0IGJvdGhlciBkb2luZyBhbGwgdGhhdCBjb21wbGljYXRlZCBtYXRocyBzdHVmZi5cbiAgICAgICAgY29udGV4dC5yZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYXJjVG8gd291bGQgYmUgbmljZXIsIGJ1dCBicm93c2VyIHN1cHBvcnQgaXMgcGF0Y2h5IChPcGVyYSlcbiAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4oY29ybmVyUmFkaXVzLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhjb3JuZXJSYWRpdXMsIDApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAtIGNvcm5lclJhZGl1cywgMCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAqIDMgLyAyLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCAtIGNvcm5lclJhZGl1cyk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIHdpZHRoIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBNYXRoLlBJIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyhjb3JuZXJSYWRpdXMsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBoZWlnaHQgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIE1hdGguUEksXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVjdCwgS29udmEuU2hhcGUpO1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlY3QsICdjb3JuZXJSYWRpdXMnLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgY29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SZWN0LnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb3JuZXJSYWRpdXNcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiB2YXIgY29ybmVyUmFkaXVzID0gcmVjdC5jb3JuZXJSYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjb3JuZXIgcmFkaXVzXG4gICAgICogcmVjdC5jb3JuZXJSYWRpdXMoMTApO1xuICAgICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SZWN0KTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHRoZSAwLjAwMDEgb2Zmc2V0IGZpeGVzIGEgYnVnIGluIENocm9tZSAyN1xuICB2YXIgUEl4MiA9IE1hdGguUEkgKiAyIC0gMC4wMDAxLCBDSVJDTEUgPSAnQ2lyY2xlJztcblxuICAvKipcbiAgICAgKiBDaXJjbGUgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gY3JlYXRlIGNpcmNsZVxuICAgICAqIHZhciBjaXJjbGUgPSBuZXcgS29udmEuQ2lyY2xlKHtcbiAgICAgKiAgIHJhZGl1czogNDAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgICAqICAgc3Ryb2tlV2lkdGg6IDVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgS29udmEuQ2lyY2xlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuQ2lyY2xlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IENJUkNMRTtcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQ2lyY2xlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5DaXJjbGUsICdyYWRpdXMnLCAwKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLkNpcmNsZSwgJ3JhZGl1cycpO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgcmFkaXVzXG4gICAgICogQG5hbWUgcmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5DaXJjbGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzXG4gICAgICogdmFyIHJhZGl1cyA9IGNpcmNsZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBjaXJjbGUucmFkaXVzKDEwKTtcbiAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuQ2lyY2xlKTtcbn0pKEtvbnZhKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIHRoZSAwLjAwMDEgb2Zmc2V0IGZpeGVzIGEgYnVnIGluIENocm9tZSAyN1xuICB2YXIgUEl4MiA9IE1hdGguUEkgKiAyIC0gMC4wMDAxLCBFTExJUFNFID0gJ0VsbGlwc2UnO1xuXG4gIC8qKlxuICAgICAqIEVsbGlwc2UgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZy5yYWRpdXMgZGVmaW5lcyB4IGFuZCB5IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgZWxsaXBzZSA9IG5ldyBLb252YS5FbGxpcHNlKHtcbiAgICAgKiAgIHJhZGl1cyA6IHtcbiAgICAgKiAgICAgeCA6IDUwLFxuICAgICAqICAgICB5IDogNTBcbiAgICAgKiAgIH0sXG4gICAgICogICBmaWxsOiAncmVkJ1xuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5FbGxpcHNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuRWxsaXBzZS5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSBFTExJUFNFO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciByeCA9IHRoaXMuZ2V0UmFkaXVzWCgpLCByeSA9IHRoaXMuZ2V0UmFkaXVzWSgpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICBpZiAocnggIT09IHJ5KSB7XG4gICAgICAgIGNvbnRleHQuc2NhbGUoMSwgcnkgLyByeCk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCByeCwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzWCgpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1c1koKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIHRoaXMuc2V0UmFkaXVzKHtcbiAgICAgICAgeDogd2lkdGggLyAyXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICB0aGlzLnNldFJhZGl1cyh7XG4gICAgICAgIHk6IGhlaWdodCAvIDJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuRWxsaXBzZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRDb21wb25lbnRzR2V0dGVyU2V0dGVyKEtvbnZhLkVsbGlwc2UsICdyYWRpdXMnLCBbJ3gnLCAneSddKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1cy55XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCByYWRpdXNcbiAgICAgKiB2YXIgcmFkaXVzID0gZWxsaXBzZS5yYWRpdXMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXNcbiAgICAgKiBlbGxpcHNlLnJhZGl1cyh7XG4gICAgICogICB4OiAyMDAsXG4gICAgICogICB5OiAxMDBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5FbGxpcHNlLCAncmFkaXVzWCcsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1cyB4XG4gICAgICogQG5hbWUgcmFkaXVzWFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuRWxsaXBzZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzIHhcbiAgICAgKiB2YXIgcmFkaXVzWCA9IGVsbGlwc2UucmFkaXVzWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1cyB4XG4gICAgICogZWxsaXBzZS5yYWRpdXNYKDIwMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuRWxsaXBzZSwgJ3JhZGl1c1knLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCByYWRpdXMgeVxuICAgICAqIEBuYW1lIHJhZGl1c1lcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkVsbGlwc2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IHJhZGl1cyB5XG4gICAgICogdmFyIHJhZGl1c1kgPSBlbGxpcHNlLnJhZGl1c1koKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCByYWRpdXMgeVxuICAgICAqIGVsbGlwc2UucmFkaXVzWSgyMDApO1xuICAgICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5FbGxpcHNlKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB0aGUgMC4wMDAxIG9mZnNldCBmaXhlcyBhIGJ1ZyBpbiBDaHJvbWUgMjdcbiAgdmFyIFBJeDIgPSBNYXRoLlBJICogMiAtIDAuMDAwMTtcbiAgLyoqXG4gICAgICogUmluZyBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmlubmVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9ja3dpc2VdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciByaW5nID0gbmV3IEtvbnZhLlJpbmcoe1xuICAgICAqICAgaW5uZXJSYWRpdXM6IDQwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDgwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNVxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5SaW5nID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUmluZy5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnUmluZyc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgMCwgUEl4MiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5tb3ZlVG8odGhpcy5nZXRPdXRlclJhZGl1cygpLCAwKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSwgUEl4MiwgMCwgdHJ1ZSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRIZWlnaHQoKVxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMod2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldEhlaWdodCgpXG4gICAgc2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldEhlaWdodC5jYWxsKHRoaXMsIGhlaWdodCk7XG4gICAgICBpZiAodGhpcy5vdXRlclJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0T3V0ZXJSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRPdXRlclJhZGl1czogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLl9zZXRBdHRyKCdvdXRlclJhZGl1cycsIHZhbCk7XG4gICAgICB0aGlzLnNldFdpZHRoKHZhbCAqIDIpO1xuICAgICAgdGhpcy5zZXRIZWlnaHQodmFsICogMik7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5SaW5nLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5SaW5nLCAnaW5uZXJSYWRpdXMnLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGlubmVyUmFkaXVzXG4gICAgICogQG5hbWUgaW5uZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJpbmcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBpbm5lciByYWRpdXNcbiAgICAgKiB2YXIgaW5uZXJSYWRpdXMgPSByaW5nLmlubmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAgICogcmluZy5pbm5lclJhZGl1cygyMCk7XG4gICAgICovXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlJpbmcsICdvdXRlclJhZGl1cycsIDApO1xuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuUmluZywgJ291dGVyUmFkaXVzJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBvdXRlclJhZGl1c1xuICAgICAqIEBuYW1lIG91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5SaW5nLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogdmFyIG91dGVyUmFkaXVzID0gcmluZy5vdXRlclJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIHJpbmcub3V0ZXJSYWRpdXMoMjApO1xuICAgICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5SaW5nKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBXZWRnZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnJhZGl1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9ja3dpc2VdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRyYXcgYSB3ZWRnZSB0aGF0J3MgcG9pbnRpbmcgZG93bndhcmRzXG4gICAgICogdmFyIHdlZGdlID0gbmV3IEtvbnZhLldlZGdlKHtcbiAgICAgKiAgIHJhZGl1czogNDAsXG4gICAgICogICBmaWxsOiAncmVkJyxcbiAgICAgKiAgIHN0cm9rZTogJ2JsYWNrJ1xuICAgICAqICAgc3Ryb2tlV2lkdGg6IDUsXG4gICAgICogICBhbmdsZURlZzogNjAsXG4gICAgICogICByb3RhdGlvbkRlZzogLTEyMFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5XZWRnZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLldlZGdlLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdXZWRnZSc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQuYXJjKFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICB0aGlzLmdldFJhZGl1cygpLFxuICAgICAgICAwLFxuICAgICAgICBLb252YS5nZXRBbmdsZSh0aGlzLmdldEFuZ2xlKCkpLFxuICAgICAgICB0aGlzLmdldENsb2Nrd2lzZSgpXG4gICAgICApO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgMCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5nZXRXaWR0aCgpXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0V2lkdGgoKVxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0V2lkdGguY2FsbCh0aGlzLCB3aWR0aCk7XG4gICAgICBpZiAodGhpcy5yYWRpdXMoKSAhPT0gd2lkdGggLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IGhlaWdodCAvIDIpIHtcbiAgICAgICAgdGhpcy5zZXRSYWRpdXMoaGVpZ2h0IC8gMik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5XZWRnZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdyYWRpdXMnLCAwKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuV2VkZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgcmFkaXVzXG4gICAgICogdmFyIHJhZGl1cyA9IHdlZGdlLnJhZGl1cygpO1xuICAgICAqXG4gICAgICogLy8gc2V0IHJhZGl1c1xuICAgICAqIHdlZGdlLnJhZGl1cygxMCk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuV2VkZ2UsICdhbmdsZScsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBuYW1lIGFuZ2xlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYW5nbGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuZ2xlXG4gICAgICogdmFyIGFuZ2xlID0gd2VkZ2UuYW5nbGUoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmdsZVxuICAgICAqIHdlZGdlLmFuZ2xlKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5XZWRnZSwgJ2Nsb2Nrd2lzZScsIGZhbHNlKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGNsb2Nrd2lzZSBmbGFnXG4gICAgICogQG5hbWUgY2xvY2t3aXNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5XZWRnZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIHZhciBjbG9ja3dpc2UgPSB3ZWRnZS5jbG9ja3dpc2UoKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgd2VkZ2UgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UoZmFsc2UpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyB3ZWRnZSBjbG9ja3dpc2VcbiAgICAgKiB3ZWRnZS5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLldlZGdlLCB7XG4gICAgYW5nbGVEZWc6ICdhbmdsZScsXG4gICAgZ2V0QW5nbGVEZWc6ICdnZXRBbmdsZScsXG4gICAgc2V0QW5nbGVEZWc6ICdzZXRBbmdsZSdcbiAgfSk7XG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLldlZGdlKTtcbn0pKCk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIEFyYyBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmFuZ2xlIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLmlubmVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5vdXRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5jbG9ja3dpc2VdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGRyYXcgYSBBcmMgdGhhdCdzIHBvaW50aW5nIGRvd253YXJkc1xuICAgICAqIHZhciBhcmMgPSBuZXcgS29udmEuQXJjKHtcbiAgICAgKiAgIGlubmVyUmFkaXVzOiA0MCxcbiAgICAgKiAgIG91dGVyUmFkaXVzOiA4MCxcbiAgICAgKiAgIGZpbGw6ICdyZWQnLFxuICAgICAqICAgc3Ryb2tlOiAnYmxhY2snXG4gICAgICogICBzdHJva2VXaWR0aDogNSxcbiAgICAgKiAgIGFuZ2xlOiA2MCxcbiAgICAgKiAgIHJvdGF0aW9uRGVnOiAtMTIwXG4gICAgICogfSk7XG4gICAgICovXG4gIEtvbnZhLkFyYyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLkFyYy5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnQXJjJztcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgYW5nbGUgPSBLb252YS5nZXRBbmdsZSh0aGlzLmFuZ2xlKCkpLCBjbG9ja3dpc2UgPSB0aGlzLmNsb2Nrd2lzZSgpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpLCAwLCBhbmdsZSwgY2xvY2t3aXNlKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSwgYW5nbGUsIDAsICFjbG9ja3dpc2UpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLmdldE91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuQXJjLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdpbm5lclJhZGl1cycsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgaW5uZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBpbm5lclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogdmFyIGlubmVyUmFkaXVzID0gYXJjLmlubmVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgaW5uZXIgcmFkaXVzXG4gICAgICogYXJjLmlubmVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdvdXRlclJhZGl1cycsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgb3V0ZXJSYWRpdXNcbiAgICAgKiBAbmFtZSBvdXRlclJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclJhZGl1c1xuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogdmFyIG91dGVyUmFkaXVzID0gYXJjLm91dGVyUmFkaXVzKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogYXJjLm91dGVyUmFkaXVzKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdhbmdsZScsIDApO1xuXG4gIC8qKlxuICAgICAqIGdldC9zZXQgYW5nbGUgaW4gZGVncmVlc1xuICAgICAqIEBuYW1lIGFuZ2xlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5BcmMucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGFuZ2xlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmdsZVxuICAgICAqIHZhciBhbmdsZSA9IGFyYy5hbmdsZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGFuZ2xlXG4gICAgICogYXJjLmFuZ2xlKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5BcmMsICdjbG9ja3dpc2UnLCBmYWxzZSk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBjbG9ja3dpc2UgZmxhZ1xuICAgICAqIEBuYW1lIGNsb2Nrd2lzZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuQXJjLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvY2t3aXNlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY2xvY2t3aXNlIGZsYWdcbiAgICAgKiB2YXIgY2xvY2t3aXNlID0gYXJjLmNsb2Nrd2lzZSgpO1xuICAgICAqXG4gICAgICogLy8gZHJhdyBhcmMgY291bnRlci1jbG9ja3dpc2VcbiAgICAgKiBhcmMuY2xvY2t3aXNlKGZhbHNlKTtcbiAgICAgKlxuICAgICAqIC8vIGRyYXcgYXJjIGNsb2Nrd2lzZVxuICAgICAqIGFyYy5jbG9ja3dpc2UodHJ1ZSk7XG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLkFyYyk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyBDT05TVEFOVFNcbiAgdmFyIElNQUdFID0gJ0ltYWdlJztcblxuICAvKipcbiAgICAgKiBJbWFnZSBjb25zdHJ1Y3RvclxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBjb25maWcuaW1hZ2VcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5jcm9wXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgaW1hZ2VPYmogPSBuZXcgSW1hZ2UoKTtcbiAgICAgKiBpbWFnZU9iai5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgKiAgIHZhciBpbWFnZSA9IG5ldyBLb252YS5JbWFnZSh7XG4gICAgICogICAgIHg6IDIwMCxcbiAgICAgKiAgICAgeTogNTAsXG4gICAgICogICAgIGltYWdlOiBpbWFnZU9iaixcbiAgICAgKiAgICAgd2lkdGg6IDEwMCxcbiAgICAgKiAgICAgaGVpZ2h0OiAxMDBcbiAgICAgKiAgIH0pO1xuICAgICAqIH07XG4gICAgICogaW1hZ2VPYmouc3JjID0gJy9wYXRoL3RvL2ltYWdlLmpwZydcbiAgICAgKi9cbiAgS29udmEuSW1hZ2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5JbWFnZS5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IElNQUdFO1xuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICB9LFxuICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRoaXMuaGFzU2hhZG93KCkgfHwgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiZcbiAgICAgICAgdGhpcy5oYXNTdHJva2UoKSAmJlxuICAgICAgICB0aGlzLmdldFN0YWdlKClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksXG4gICAgICAgIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCksXG4gICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpLFxuICAgICAgICBjcm9wV2lkdGgsXG4gICAgICAgIGNyb3BIZWlnaHQsXG4gICAgICAgIHBhcmFtcztcblxuICAgICAgaWYgKGltYWdlKSB7XG4gICAgICAgIGNyb3BXaWR0aCA9IHRoaXMuZ2V0Q3JvcFdpZHRoKCk7XG4gICAgICAgIGNyb3BIZWlnaHQgPSB0aGlzLmdldENyb3BIZWlnaHQoKTtcbiAgICAgICAgaWYgKGNyb3BXaWR0aCAmJiBjcm9wSGVpZ2h0KSB7XG4gICAgICAgICAgcGFyYW1zID0gW1xuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICB0aGlzLmdldENyb3BYKCksXG4gICAgICAgICAgICB0aGlzLmdldENyb3BZKCksXG4gICAgICAgICAgICBjcm9wV2lkdGgsXG4gICAgICAgICAgICBjcm9wSGVpZ2h0LFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodFxuICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFyYW1zID0gW2ltYWdlLCAwLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UuYXBwbHkoY29udGV4dCwgcGFyYW1zKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9oaXRGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdldFdpZHRoKCksIGhlaWdodCA9IHRoaXMuZ2V0SGVpZ2h0KCk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW1hZ2UgPSB0aGlzLmdldEltYWdlKCk7XG4gICAgICByZXR1cm4gdGhpcy5hdHRycy53aWR0aCB8fCAoaW1hZ2UgPyBpbWFnZS53aWR0aCA6IDApO1xuICAgIH0sXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbWFnZSA9IHRoaXMuZ2V0SW1hZ2UoKTtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJzLmhlaWdodCB8fCAoaW1hZ2UgPyBpbWFnZS5oZWlnaHQgOiAwKTtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkltYWdlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2ltYWdlJyk7XG5cbiAgLyoqXG4gICAgICogc2V0IGltYWdlXG4gICAgICogQG5hbWUgc2V0SW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlXG4gICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IGltYWdlXG4gICAgICogQG5hbWUgZ2V0SW1hZ2VcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtJbWFnZX1cbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZENvbXBvbmVudHNHZXR0ZXJTZXR0ZXIoS29udmEuSW1hZ2UsICdjcm9wJywgW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ3dpZHRoJyxcbiAgICAnaGVpZ2h0J1xuICBdKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIGNyb3BcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuSW1hZ2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNyb3BcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY3JvcC54XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AueVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjcm9wLndpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNyb3AuaGVpZ2h0XG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wXG4gICAgICogdmFyIGNyb3AgPSBpbWFnZS5jcm9wKCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcFxuICAgICAqIGltYWdlLmNyb3Aoe1xuICAgICAqICAgeDogMjAsXG4gICAgICogICB5OiAyMCxcbiAgICAgKiAgIHdpZHRoOiAyMCxcbiAgICAgKiAgIGhlaWdodDogMjBcbiAgICAgKiB9KTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BYJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCB4XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBuYW1lIGNyb3BYXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIHhcbiAgICAgKiB2YXIgY3JvcFggPSBpbWFnZS5jcm9wWCgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3AgeFxuICAgICAqIGltYWdlLmNyb3BYKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BZJywgMCk7XG4gIC8qKlxuICAgICAqIGdldC9zZXQgY3JvcCB5XG4gICAgICogQG5hbWUgY3JvcFlcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBjcm9wIHlcbiAgICAgKiB2YXIgY3JvcFkgPSBpbWFnZS5jcm9wWSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGNyb3AgeVxuICAgICAqIGltYWdlLmNyb3BZKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BXaWR0aCcsIDApO1xuICAvKipcbiAgICAgKiBnZXQvc2V0IGNyb3Agd2lkdGhcbiAgICAgKiBAbmFtZSBjcm9wV2lkdGhcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgY3JvcCB3aWR0aFxuICAgICAqIHZhciBjcm9wV2lkdGggPSBpbWFnZS5jcm9wV2lkdGgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBjcm9wIHdpZHRoXG4gICAgICogaW1hZ2UuY3JvcFdpZHRoKDIwKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5JbWFnZSwgJ2Nyb3BIZWlnaHQnLCAwKTtcbiAgLyoqXG4gICAgICogZ2V0L3NldCBjcm9wIGhlaWdodFxuICAgICAqIEBuYW1lIGNyb3BIZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLkltYWdlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGNyb3AgaGVpZ2h0XG4gICAgICogdmFyIGNyb3BIZWlnaHQgPSBpbWFnZS5jcm9wSGVpZ2h0KCk7XG4gICAgICpcbiAgICAgKiAvLyBzZXQgY3JvcCBoZWlnaHRcbiAgICAgKiBpbWFnZS5jcm9wSGVpZ2h0KDIwKTtcbiAgICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuSW1hZ2UpO1xuXG4gIC8qKlxuICAgICAqIGxvYWQgaW1hZ2UgZnJvbSBnaXZlbiB1cmwgYW5kIGNyZWF0ZSBgS29udmEuSW1hZ2VgIGluc3RhbmNlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5JbWFnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgaW1hZ2Ugc291cmNlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgd2l0aCBLb252YS5JbWFnZSBpbnN0YW5jZSBhcyBmaXJzdCBhcmd1bWVudFxuICAgICAqIEBleGFtcGxlXG4gICAgICogIEtvbnZhLkltYWdlLmZyb21VUkwoaW1hZ2VVUkwsIGZ1bmN0aW9uKGltYWdlKXtcbiAgICAgKiAgICAvLyBpbWFnZSBpcyBLb252YS5JbWFnZSBpbnN0YW5jZVxuICAgICAqICAgIGxheWVyLmFkZChpbWFnZSk7XG4gICAgICogICAgbGF5ZXIuZHJhdygpO1xuICAgICAqICB9KTtcbiAgICAgKi9cbiAgS29udmEuSW1hZ2UuZnJvbVVSTCA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGltYWdlID0gbmV3IEtvbnZhLkltYWdlKHtcbiAgICAgICAgaW1hZ2U6IGltZ1xuICAgICAgfSk7XG4gICAgICBjYWxsYmFjayhpbWFnZSk7XG4gICAgfTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICBpbWcuc3JjID0gdXJsO1xuICB9O1xufSkoKTtcblxuLyplc2xpbnQtZGlzYWJsZSBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvLyB2YXIgaXNGaXJlZm94ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2ZpcmVmb3gnKSA+IC0xO1xuICAvLyBjb25zdGFudHNcbiAgdmFyIEFVVE8gPSAnYXV0bycsXG4gICAgLy9DQU5WQVMgPSAnY2FudmFzJyxcbiAgICBDRU5URVIgPSAnY2VudGVyJyxcbiAgICBKVVNUSUZZID0gJ2p1c3RpZnknLFxuICAgIENIQU5HRV9LT05WQSA9ICdDaGFuZ2Uua29udmEnLFxuICAgIENPTlRFWFRfMkQgPSAnMmQnLFxuICAgIERBU0ggPSAnLScsXG4gICAgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgTEVGVCA9ICdsZWZ0JyxcbiAgICBURVhUID0gJ3RleHQnLFxuICAgIFRFWFRfVVBQRVIgPSAnVGV4dCcsXG4gICAgTUlERExFID0gJ21pZGRsZScsXG4gICAgTk9STUFMID0gJ25vcm1hbCcsXG4gICAgUFhfU1BBQ0UgPSAncHggJyxcbiAgICBTUEFDRSA9ICcgJyxcbiAgICBSSUdIVCA9ICdyaWdodCcsXG4gICAgV09SRCA9ICd3b3JkJyxcbiAgICBDSEFSID0gJ2NoYXInLFxuICAgIE5PTkUgPSAnbm9uZScsXG4gICAgRUxMSVBTSVMgPSAn4oCmJyxcbiAgICBBVFRSX0NIQU5HRV9MSVNUID0gW1xuICAgICAgJ2ZvbnRGYW1pbHknLFxuICAgICAgJ2ZvbnRTaXplJyxcbiAgICAgICdmb250U3R5bGUnLFxuICAgICAgJ2ZvbnRWYXJpYW50JyxcbiAgICAgICdwYWRkaW5nJyxcbiAgICAgICdhbGlnbicsXG4gICAgICAnbGluZUhlaWdodCcsXG4gICAgICAndGV4dCcsXG4gICAgICAnd2lkdGgnLFxuICAgICAgJ2hlaWdodCcsXG4gICAgICAnd3JhcCcsXG4gICAgICAnZWxsaXBzaXMnLFxuICAgICAgJ2xldHRlclNwYWNpbmcnXG4gICAgXSxcbiAgICAvLyBjYWNoZWQgdmFyaWFibGVzXG4gICAgYXR0ckNoYW5nZUxpc3RMZW4gPSBBVFRSX0NIQU5HRV9MSVNULmxlbmd0aDtcbiAgdmFyIGR1bW15Q29udGV4dDtcbiAgZnVuY3Rpb24gZ2V0RHVtbXlDb250ZXh0KCkge1xuICAgIGlmIChkdW1teUNvbnRleHQpIHtcbiAgICAgIHJldHVybiBkdW1teUNvbnRleHQ7XG4gICAgfVxuICAgIGR1bW15Q29udGV4dCA9IEtvbnZhLlV0aWwuY3JlYXRlQ2FudmFzRWxlbWVudCgpLmdldENvbnRleHQoQ09OVEVYVF8yRCk7XG4gICAgcmV0dXJuIGR1bW15Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUZXh0IGNvbnN0cnVjdG9yXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZm9udEZhbWlseV0gZGVmYXVsdCBpcyBBcmlhbFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gaW4gcGl4ZWxzLiAgRGVmYXVsdCBpcyAxMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250U3R5bGVdIGNhbiBiZSBub3JtYWwsIGJvbGQsIG9yIGl0YWxpYy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuYWxpZ25dIGNhbiBiZSBsZWZ0LCBjZW50ZXIsIG9yIHJpZ2h0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBhZGRpbmddXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmxpbmVIZWlnaHRdIGRlZmF1bHQgaXMgMVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy53cmFwXSBjYW4gYmUgd29yZCwgY2hhciwgb3Igbm9uZS4gRGVmYXVsdCBpcyB3b3JkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5lbGxpcHNpc10gY2FuIGJlIHRydWUgb3IgZmFsc2UuIERlZmF1bHQgaXMgZmFsc2UuIGlmIEtvbnZhLlRleHQgY29uZmlnIGlzIHNldCB0byB3cmFwPVwibm9uZVwiIGFuZCBlbGxpcHNpcz10cnVlLCB0aGVuIGl0IHdpbGwgYWRkIFwiLi4uXCIgdG8gdGhlIGVuZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRleHQgPSBuZXcgS29udmEuVGV4dCh7XG4gICAqICAgeDogMTAsXG4gICAqICAgeTogMTUsXG4gICAqICAgdGV4dDogJ1NpbXBsZSBUZXh0JyxcbiAgICogICBmb250U2l6ZTogMzAsXG4gICAqICAgZm9udEZhbWlseTogJ0NhbGlicmknLFxuICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5UZXh0ID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG4gIGZ1bmN0aW9uIF9maWxsRnVuYyhjb250ZXh0KSB7XG4gICAgY29udGV4dC5maWxsVGV4dCh0aGlzLnBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgfVxuICBmdW5jdGlvbiBfc3Ryb2tlRnVuYyhjb250ZXh0KSB7XG4gICAgY29udGV4dC5zdHJva2VUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICB9XG5cbiAgS29udmEuVGV4dC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICAgIC8vIHNldCBkZWZhdWx0IGNvbG9yIHRvIGJsYWNrXG4gICAgICBpZiAoXG4gICAgICAgICFjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wcyAmJlxuICAgICAgICAhY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNcbiAgICAgICkge1xuICAgICAgICBjb25maWcuZmlsbCA9IGNvbmZpZy5maWxsIHx8ICdibGFjayc7XG4gICAgICB9XG4gICAgICAvL1xuICAgICAgLy8gaWYgKGNvbmZpZy53aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyAgICAgY29uZmlnLndpZHRoID0gQVVUTztcbiAgICAgIC8vIH1cbiAgICAgIC8vIGlmIChjb25maWcuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vICAgICBjb25maWcuaGVpZ2h0ID0gQVVUTztcbiAgICAgIC8vIH1cblxuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuXG4gICAgICB0aGlzLl9maWxsRnVuYyA9IF9maWxsRnVuYztcbiAgICAgIHRoaXMuX3N0cm9rZUZ1bmMgPSBfc3Ryb2tlRnVuYztcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gVEVYVF9VUFBFUjtcblxuICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgYXR0ckNoYW5nZUxpc3RMZW47IG4rKykge1xuICAgICAgICB0aGlzLm9uKEFUVFJfQ0hBTkdFX0xJU1Rbbl0gKyBDSEFOR0VfS09OVkEsIHRoaXMuX3NldFRleHREYXRhKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0VGV4dERhdGEoKTtcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICB0ZXh0SGVpZ2h0ID0gdGhpcy5nZXRUZXh0SGVpZ2h0KCksXG4gICAgICAgIGxpbmVIZWlnaHRQeCA9IHRoaXMuZ2V0TGluZUhlaWdodCgpICogdGV4dEhlaWdodCxcbiAgICAgICAgdGV4dEFyciA9IHRoaXMudGV4dEFycixcbiAgICAgICAgdGV4dEFyckxlbiA9IHRleHRBcnIubGVuZ3RoLFxuICAgICAgICBhbGlnbiA9IHRoaXMuZ2V0QWxpZ24oKSxcbiAgICAgICAgdG90YWxXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgbGV0dGVyU3BhY2luZyA9IHRoaXMuZ2V0TGV0dGVyU3BhY2luZygpLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMudGV4dERlY29yYXRpb24oKSxcbiAgICAgICAgZmlsbCA9IHRoaXMuZmlsbCgpLFxuICAgICAgICBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKSxcbiAgICAgICAgbjtcblxuICAgICAgY29udGV4dC5zZXRBdHRyKCdmb250JywgdGhpcy5fZ2V0Q29udGV4dEZvbnQoKSk7XG5cbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgTUlERExFKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEFsaWduJywgTEVGVCk7XG4gICAgICBpZiAocGFkZGluZykge1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZShwYWRkaW5nLCAwKTtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgcGFkZGluZyArIGxpbmVIZWlnaHRQeCAvIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4IC8gMik7XG4gICAgICB9XG5cbiAgICAgIC8vIGRyYXcgdGV4dCBsaW5lc1xuICAgICAgZm9yIChuID0gMDsgbiA8IHRleHRBcnJMZW47IG4rKykge1xuICAgICAgICB2YXIgb2JqID0gdGV4dEFycltuXSxcbiAgICAgICAgICB0ZXh0ID0gb2JqLnRleHQsXG4gICAgICAgICAgd2lkdGggPSBvYmoud2lkdGg7XG5cbiAgICAgICAgLy8gaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gUklHSFQpIHtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0b3RhbFdpZHRoIC0gd2lkdGggLSBwYWRkaW5nICogMiwgMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IENFTlRFUikge1xuICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKCh0b3RhbFdpZHRoIC0gd2lkdGggLSBwYWRkaW5nICogMikgLyAyLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCd1bmRlcmxpbmUnKSAhPT0gLTEpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIE1hdGgucm91bmQobGluZUhlaWdodFB4IC8gMikpO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQod2lkdGgpLCBNYXRoLnJvdW5kKGxpbmVIZWlnaHRQeCAvIDIpKTtcbiAgICAgICAgICAvLyBUT0RPOiBJIGhhdmUgbm8gaWRlYSB3aGF0IGlzIHJlYWwgcmF0aW9cbiAgICAgICAgICAvLyBqdXN0IC8xNSBsb29rcyBnb29kIGVub3VnaFxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gZm9udFNpemUgLyAxNTtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbi5pbmRleE9mKCdsaW5lLXRocm91Z2gnKSAhPT0gLTEpIHtcbiAgICAgICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKE1hdGgucm91bmQod2lkdGgpLCAwKTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMTU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyAhPT0gMCB8fCBhbGlnbiA9PT0gSlVTVElGWSkge1xuICAgICAgICAgIC8vICAgdmFyIHdvcmRzID0gdGV4dC5zcGxpdCgnICcpO1xuICAgICAgICAgIHZhciBzcGFjZXNOdW1iZXIgPSB0ZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICAgICAgICBmb3IgKHZhciBsaSA9IDA7IGxpIDwgdGV4dC5sZW5ndGg7IGxpKyspIHtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSB0ZXh0W2xpXTtcbiAgICAgICAgICAgIC8vIHNraXAganVzdGlmeSBmb3IgdGhlIGxhc3QgbGluZVxuICAgICAgICAgICAgaWYgKGxldHRlciA9PT0gJyAnICYmIG4gIT09IHRleHRBcnJMZW4gLSAxICYmIGFsaWduID09PSBKVVNUSUZZKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoKHRvdGFsV2lkdGggLSB3aWR0aCkgLyBzcGFjZXNOdW1iZXIpLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFydGlhbFRleHQgPSBsZXR0ZXI7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKFxuICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRoaXMuX2dldFRleHRTaXplKGxldHRlcikud2lkdGgpICsgbGV0dGVyU3BhY2luZyxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYXJ0aWFsVGV4dCA9IHRleHQ7XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgaWYgKHRleHRBcnJMZW4gPiAxKSB7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoMCwgbGluZUhlaWdodFB4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBzdHIgPSBLb252YS5VdGlsLl9pc1N0cmluZyh0ZXh0KSA/IHRleHQgOiAodGV4dCB8fCAnJykudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuX3NldEF0dHIoVEVYVCwgc3RyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHdpZHRoIG9mIHRleHQgYXJlYSwgd2hpY2ggaW5jbHVkZXMgcGFkZGluZ1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpc0F1dG8gPSB0aGlzLmF0dHJzLndpZHRoID09PSBBVVRPIHx8IHRoaXMuYXR0cnMud2lkdGggPT09IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBpc0F1dG9cbiAgICAgICAgPyB0aGlzLmdldFRleHRXaWR0aCgpICsgdGhpcy5nZXRQYWRkaW5nKCkgKiAyXG4gICAgICAgIDogdGhpcy5hdHRycy53aWR0aDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgaGVpZ2h0IG9mIHRoZSB0ZXh0IGFyZWEsIHdoaWNoIHRha2VzIGludG8gYWNjb3VudCBtdWx0aS1saW5lIHRleHQsIGxpbmUgaGVpZ2h0cywgYW5kIHBhZGRpbmdcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlzQXV0byA9XG4gICAgICAgIHRoaXMuYXR0cnMuaGVpZ2h0ID09PSBBVVRPIHx8IHRoaXMuYXR0cnMuaGVpZ2h0ID09PSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gaXNBdXRvXG4gICAgICAgID8gdGhpcy5nZXRUZXh0SGVpZ2h0KCkgKiB0aGlzLnRleHRBcnIubGVuZ3RoICogdGhpcy5nZXRMaW5lSGVpZ2h0KCkgK1xuICAgICAgICAgICAgdGhpcy5nZXRQYWRkaW5nKCkgKiAyXG4gICAgICAgIDogdGhpcy5hdHRycy5oZWlnaHQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGV4dCB3aWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldFRleHRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0V2lkdGg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnZXQgdGV4dCBoZWlnaHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBnZXRUZXh0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHRIZWlnaHQ7XG4gICAgfSxcbiAgICBfZ2V0VGV4dFNpemU6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBfY29udGV4dCA9IGdldER1bW15Q29udGV4dCgpLFxuICAgICAgICBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKSxcbiAgICAgICAgbWV0cmljcztcblxuICAgICAgX2NvbnRleHQuc2F2ZSgpO1xuICAgICAgX2NvbnRleHQuZm9udCA9IHRoaXMuX2dldENvbnRleHRGb250KCk7XG5cbiAgICAgIG1ldHJpY3MgPSBfY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBtZXRyaWNzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGZvbnRTaXplLCAxMClcbiAgICAgIH07XG4gICAgfSxcbiAgICBfZ2V0Q29udGV4dEZvbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gSUUgZG9uJ3Qgd2FudCB0byB3b3JrIHdpdGggdXN1YWwgZm9udCBzdHlsZVxuICAgICAgLy8gYm9sZCB3YXMgbm90IHdvcmtpbmdcbiAgICAgIC8vIHJlbW92aW5nIGZvbnQgdmFyaWFudCB3aWxsIHNvbHZlXG4gICAgICAvLyBmaXggZm9yOiBodHRwczovL2dpdGh1Yi5jb20va29udmFqcy9rb252YS9pc3N1ZXMvOTRcbiAgICAgIGlmIChLb252YS5VQS5pc0lFKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgdGhpcy5nZXRGb250U3R5bGUoKSArXG4gICAgICAgICAgU1BBQ0UgK1xuICAgICAgICAgIHRoaXMuZ2V0Rm9udFNpemUoKSArXG4gICAgICAgICAgUFhfU1BBQ0UgK1xuICAgICAgICAgIHRoaXMuZ2V0Rm9udEZhbWlseSgpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLmdldEZvbnRTdHlsZSgpICtcbiAgICAgICAgU1BBQ0UgK1xuICAgICAgICB0aGlzLmdldEZvbnRWYXJpYW50KCkgK1xuICAgICAgICBTUEFDRSArXG4gICAgICAgIHRoaXMuZ2V0Rm9udFNpemUoKSArXG4gICAgICAgIFBYX1NQQUNFICtcbiAgICAgICAgdGhpcy5nZXRGb250RmFtaWx5KClcbiAgICAgICk7XG4gICAgfSxcbiAgICBfYWRkVGV4dExpbmU6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICh0aGlzLmFsaWduKCkgPT09IEpVU1RJRlkpIHtcbiAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xuICAgICAgfVxuICAgICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xuICAgICAgcmV0dXJuIHRoaXMudGV4dEFyci5wdXNoKHsgdGV4dDogbGluZSwgd2lkdGg6IHdpZHRoIH0pO1xuICAgIH0sXG4gICAgX2dldFRleHRXaWR0aDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIGxhdHRlclNwYWNpbmcgPSB0aGlzLmdldExldHRlclNwYWNpbmcoKTtcbiAgICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGdldER1bW15Q29udGV4dCgpLm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICtcbiAgICAgICAgKGxlbmd0aCA/IGxhdHRlclNwYWNpbmcgKiAobGVuZ3RoIC0gMSkgOiAwKVxuICAgICAgKTtcbiAgICB9LFxuICAgIF9zZXRUZXh0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZXMgPSB0aGlzLmdldFRleHQoKS5zcGxpdCgnXFxuJyksXG4gICAgICAgIGZvbnRTaXplID0gK3RoaXMuZ2V0Rm9udFNpemUoKSxcbiAgICAgICAgdGV4dFdpZHRoID0gMCxcbiAgICAgICAgbGluZUhlaWdodFB4ID0gdGhpcy5nZXRMaW5lSGVpZ2h0KCkgKiBmb250U2l6ZSxcbiAgICAgICAgd2lkdGggPSB0aGlzLmF0dHJzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmF0dHJzLmhlaWdodCxcbiAgICAgICAgZml4ZWRXaWR0aCA9IHdpZHRoICE9PSBBVVRPLFxuICAgICAgICBmaXhlZEhlaWdodCA9IGhlaWdodCAhPT0gQVVUTyxcbiAgICAgICAgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpLFxuICAgICAgICBtYXhXaWR0aCA9IHdpZHRoIC0gcGFkZGluZyAqIDIsXG4gICAgICAgIG1heEhlaWdodFB4ID0gaGVpZ2h0IC0gcGFkZGluZyAqIDIsXG4gICAgICAgIGN1cnJlbnRIZWlnaHRQeCA9IDAsXG4gICAgICAgIHdyYXAgPSB0aGlzLmdldFdyYXAoKSxcbiAgICAgICAgc2hvdWxkV3JhcCA9IHdyYXAgIT09IE5PTkUsXG4gICAgICAgIHdyYXBBdFdvcmQgPSB3cmFwICE9PSBDSEFSICYmIHNob3VsZFdyYXAsXG4gICAgICAgIHNob3VsZEFkZEVsbGlwc2lzID0gdGhpcy5nZXRFbGxpcHNpcygpICYmICFzaG91bGRXcmFwO1xuXG4gICAgICB0aGlzLnRleHRBcnIgPSBbXTtcbiAgICAgIGdldER1bW15Q29udGV4dCgpLmZvbnQgPSB0aGlzLl9nZXRDb250ZXh0Rm9udCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG1heCA9IGxpbmVzLmxlbmd0aDsgaSA8IG1heDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIHZhciBhZGRpdGlvbmFsV2lkdGggPSBzaG91bGRBZGRFbGxpcHNpc1xuICAgICAgICAgID8gdGhpcy5fZ2V0VGV4dFdpZHRoKEVMTElQU0lTKVxuICAgICAgICAgIDogMDtcblxuICAgICAgICB2YXIgbGluZVdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKGxpbmUpO1xuICAgICAgICBpZiAoZml4ZWRXaWR0aCAmJiBsaW5lV2lkdGggPiBtYXhXaWR0aCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgKiBpZiB3aWR0aCBpcyBmaXhlZCBhbmQgbGluZSBkb2VzIG5vdCBmaXQgZW50aXJlbHlcbiAgICAgICAgICAqIGJyZWFrIHRoZSBsaW5lIGludG8gbXVsdGlwbGUgZml0dGluZyBsaW5lc1xuICAgICAgICAgICovXG4gICAgICAgICAgd2hpbGUgKGxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICogdXNlIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbG9uZ2VzdCBzdWJzdHJpbmcgdGhhdFxuICAgICAgICAgICAgKiB0aGF0IHdvdWxkIGZpdCBpbiB0aGUgc3BlY2lmaWVkIHdpZHRoXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgICAgIGhpZ2ggPSBsaW5lLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWF0Y2ggPSAnJyxcbiAgICAgICAgICAgICAgbWF0Y2hXaWR0aCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICAgIHN1YnN0ciA9IGxpbmUuc2xpY2UoMCwgbWlkICsgMSksXG4gICAgICAgICAgICAgICAgc3Vic3RyV2lkdGggPSB0aGlzLl9nZXRUZXh0V2lkdGgoc3Vic3RyKSArIGFkZGl0aW9uYWxXaWR0aDtcbiAgICAgICAgICAgICAgaWYgKHN1YnN0cldpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHN1YnN0ciArIChzaG91bGRBZGRFbGxpcHNpcyA/IEVMTElQU0lTIDogJycpO1xuICAgICAgICAgICAgICAgIG1hdGNoV2lkdGggPSBzdWJzdHJXaWR0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgKiAnbG93JyBpcyBub3cgdGhlIGluZGV4IG9mIHRoZSBzdWJzdHJpbmcgZW5kXG4gICAgICAgICAgICAqICdtYXRjaCcgaXMgdGhlIHN1YnN0cmluZ1xuICAgICAgICAgICAgKiAnbWF0Y2hXaWR0aCcgaXMgdGhlIHN1YnN0cmluZyB3aWR0aCBpbiBweFxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAvLyBhIGZpdHRpbmcgc3Vic3RyaW5nIHdhcyBmb3VuZFxuICAgICAgICAgICAgICBpZiAod3JhcEF0V29yZCkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSB0byBmaW5kIGEgc3BhY2Ugb3IgZGFzaCB3aGVyZSB3cmFwcGluZyBjb3VsZCBiZSBkb25lXG4gICAgICAgICAgICAgICAgdmFyIHdyYXBJbmRleDtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBsaW5lW21hdGNoLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJc1NwYWNlT3JEYXNoID0gbmV4dENoYXIgPT09IFNQQUNFIHx8IG5leHRDaGFyID09PSBEQVNIO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0SXNTcGFjZU9yRGFzaCAmJiBtYXRjaFdpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICB3cmFwSW5kZXggPSBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHdyYXBJbmRleCA9XG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KFxuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmxhc3RJbmRleE9mKFNQQUNFKSxcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5sYXN0SW5kZXhPZihEQVNIKVxuICAgICAgICAgICAgICAgICAgICApICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHdyYXBJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIHJlLWN1dCB0aGUgc3Vic3RyaW5nIGZvdW5kIGF0IHRoZSBzcGFjZS9kYXNoIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICBsb3cgPSB3cmFwSW5kZXg7XG4gICAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoLnNsaWNlKDAsIGxvdyk7XG4gICAgICAgICAgICAgICAgICBtYXRjaFdpZHRoID0gdGhpcy5fZ2V0VGV4dFdpZHRoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobWF0Y2gpO1xuICAgICAgICAgICAgICB0ZXh0V2lkdGggPSBNYXRoLm1heCh0ZXh0V2lkdGgsIG1hdGNoV2lkdGgpO1xuICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgIXNob3VsZFdyYXAgfHxcbiAgICAgICAgICAgICAgICAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgKiBzdG9wIHdyYXBwaW5nIGlmIHdyYXBwaW5nIGlzIGRpc2FibGVkIG9yIGlmIGFkZGluZ1xuICAgICAgICAgICAgICAgICogb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvdyB0aGUgZml4ZWQgaGVpZ2h0XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsaW5lID0gbGluZS5zbGljZShsb3cpO1xuICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbWFpbmluZyB0ZXh0IHdvdWxkIGZpdCBvbiBvbmUgbGluZVxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuX2dldFRleHRXaWR0aChsaW5lKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZVdpZHRoIDw9IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBpdCBkb2VzLCBhZGQgdGhlIGxpbmUgYW5kIGJyZWFrIG91dCBvZiB0aGUgbG9vcFxuICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkVGV4dExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50SGVpZ2h0UHggKz0gbGluZUhlaWdodFB4O1xuICAgICAgICAgICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBub3QgZXZlbiBvbmUgY2hhcmFjdGVyIGNvdWxkIGZpdCBpbiB0aGUgZWxlbWVudCwgYWJvcnRcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVsZW1lbnQgd2lkdGggaXMgYXV0b21hdGljYWxseSBhZGp1c3RlZCB0byBtYXggbGluZSB3aWR0aFxuICAgICAgICAgIHRoaXMuX2FkZFRleHRMaW5lKGxpbmUpO1xuICAgICAgICAgIGN1cnJlbnRIZWlnaHRQeCArPSBsaW5lSGVpZ2h0UHg7XG4gICAgICAgICAgdGV4dFdpZHRoID0gTWF0aC5tYXgodGV4dFdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGVsZW1lbnQgaGVpZ2h0IGlzIGZpeGVkLCBhYm9ydCBpZiBhZGRpbmcgb25lIG1vcmUgbGluZSB3b3VsZCBvdmVyZmxvd1xuICAgICAgICBpZiAoZml4ZWRIZWlnaHQgJiYgY3VycmVudEhlaWdodFB4ICsgbGluZUhlaWdodFB4ID4gbWF4SGVpZ2h0UHgpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy50ZXh0SGVpZ2h0ID0gZm9udFNpemU7XG4gICAgICAvLyB2YXIgbWF4VGV4dFdpZHRoID0gMDtcbiAgICAgIC8vIGZvcih2YXIgaiA9IDA7IGogPCB0aGlzLnRleHRBcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgIC8vICAgICBtYXhUZXh0V2lkdGggPSBNYXRoLm1heChtYXhUZXh0V2lkdGgsIHRoaXMudGV4dEFycltqXS53aWR0aCk7XG4gICAgICAvLyB9XG4gICAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlRleHQsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250RmFtaWx5JywgJ0FyaWFsJyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZm9udCBmYW1pbHlcbiAgICogQG5hbWUgZm9udEZhbWlseVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udEZhbWlseVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZm9udCBmYW1pbHlcbiAgICogdmFyIGZvbnRGYW1pbHkgPSB0ZXh0LmZvbnRGYW1pbHkoKTtcbiAgICpcbiAgICogLy8gc2V0IGZvbnQgZmFtaWx5XG4gICAqIHRleHQuZm9udEZhbWlseSgnQXJpYWwnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRTaXplJywgMTIpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGZvbnQgc2l6ZSBpbiBwaXhlbHNcbiAgICogQG5hbWUgZm9udFNpemVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGZvbnRTaXplXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmb250IHNpemVcbiAgICogdmFyIGZvbnRTaXplID0gdGV4dC5mb250U2l6ZSgpO1xuICAgKlxuICAgKiAvLyBzZXQgZm9udCBzaXplIHRvIDIycHhcbiAgICogdGV4dC5mb250U2l6ZSgyMik7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdmb250U3R5bGUnLCBOT1JNQUwpO1xuXG4gIC8qKlxuICAgKiBzZXQgZm9udCBzdHlsZS4gIENhbiBiZSAnbm9ybWFsJywgJ2l0YWxpYycsIG9yICdib2xkJy4gICdub3JtYWwnIGlzIHRoZSBkZWZhdWx0LlxuICAgKiBAbmFtZSBmb250U3R5bGVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZm9udCBzdHlsZVxuICAgKiB2YXIgZm9udFN0eWxlID0gdGV4dC5mb250U3R5bGUoKTtcbiAgICpcbiAgICogLy8gc2V0IGZvbnQgc3R5bGVcbiAgICogdGV4dC5mb250U3R5bGUoJ2JvbGQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2ZvbnRWYXJpYW50JywgTk9STUFMKTtcblxuICAvKipcbiAgICogc2V0IGZvbnQgdmFyaWFudC4gIENhbiBiZSAnbm9ybWFsJyBvciAnc21hbGwtY2FwcycuICAnbm9ybWFsJyBpcyB0aGUgZGVmYXVsdC5cbiAgICogQG5hbWUgZm9udFZhcmlhbnRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRWYXJpYW50XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBmb250IHZhcmlhbnRcbiAgICogdmFyIGZvbnRWYXJpYW50ID0gdGV4dC5mb250VmFyaWFudCgpO1xuICAgKlxuICAgKiAvLyBzZXQgZm9udCB2YXJpYW50XG4gICAqIHRleHQuZm9udFZhcmlhbnQoJ3NtYWxsLWNhcHMnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3BhZGRpbmcnLCAwKTtcblxuICAvKipcbiAgICogc2V0IHBhZGRpbmdcbiAgICogQG5hbWUgcGFkZGluZ1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gcGFkZGluZ1xuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgcGFkZGluZ1xuICAgKiB2YXIgcGFkZGluZyA9IHRleHQucGFkZGluZygpO1xuICAgKlxuICAgKiAvLyBzZXQgcGFkZGluZyB0byAxMCBwaXhlbHNcbiAgICogdGV4dC5wYWRkaW5nKDEwKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2FsaWduJywgTEVGVCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgaG9yaXpvbnRhbCBhbGlnbiBvZiB0ZXh0LiAgQ2FuIGJlICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgb3IgJ2p1c3RpZnknXG4gICAqIEBuYW1lIGFsaWduXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgKiB2YXIgYWxpZ24gPSB0ZXh0LmFsaWduKCk7XG4gICAqXG4gICAqIC8vIGNlbnRlciB0ZXh0XG4gICAqIHRleHQuYWxpZ24oJ2NlbnRlcicpO1xuICAgKlxuICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAqIHRleHQuYWxpZ24oJ3JpZ2h0Jyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICdsaW5lSGVpZ2h0JywgMSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgbGluZSBoZWlnaHQuICBUaGUgZGVmYXVsdCBpcyAxLlxuICAgKiBAbmFtZSBsaW5lSGVpZ2h0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsaW5lSGVpZ2h0XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCBsaW5lIGhlaWdodFxuICAgKiB2YXIgbGluZUhlaWdodCA9IHRleHQubGluZUhlaWdodCgpO1xuICAgKlxuICAgKiAvLyBzZXQgdGhlIGxpbmUgaGVpZ2h0XG4gICAqIHRleHQubGluZUhlaWdodCgyKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ3dyYXAnLCBXT1JEKTtcblxuICAvKipcbiAgICogZ2V0L3NldCB3cmFwLiAgQ2FuIGJlIHdvcmQsIGNoYXIsIG9yIG5vbmUuIERlZmF1bHQgaXMgd29yZC5cbiAgICogQG5hbWUgd3JhcFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gd3JhcFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgd3JhcFxuICAgKiB2YXIgd3JhcCA9IHRleHQud3JhcCgpO1xuICAgKlxuICAgKiAvLyBzZXQgd3JhcFxuICAgKiB0ZXh0LndyYXAoJ3dvcmQnKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2VsbGlwc2lzJywgZmFsc2UpO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IGVsbGlwc2lzLiAgQ2FuIGJlIHRydWUgb3IgZmFsc2UuIERlZmF1bHQgaXMgZmFsc2UuXG4gICAqIGlmIEtvbnZhLlRleHQgY29uZmlnIGlzIHNldCB0byB3cmFwPVwibm9uZVwiIGFuZCBlbGxpcHNpcz10cnVlLCB0aGVuIGl0IHdpbGwgYWRkIFwiLi4uXCIgdG8gdGhlIGVuZFxuICAgKiBAbmFtZSBlbGxpcHNpc1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGVsbGlwc2lzXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgZWxsaXBzaXNcbiAgICogdmFyIGVsbGlwc2lzID0gdGV4dC5lbGxpcHNpcygpO1xuICAgKlxuICAgKiAvLyBzZXQgZWxsaXBzaXNcbiAgICogdGV4dC5lbGxpcHNpcyh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dCwgJ2xldHRlclNwYWNpbmcnLCAwKTtcblxuICAvKipcbiAgICogc2V0IGxldHRlciBzcGFjaW5nIHByb3BlcnR5LiBEZWZhdWx0IHZhbHVlIGlzIDAuXG4gICAqIEBuYW1lIGxldHRlclNwYWNpbmdcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0JywgRU1QVFlfU1RSSU5HKTtcbiAgS29udmEuRmFjdG9yeS5hZGRPdmVybG9hZGVkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0Jyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dFxuICAgKiBAbmFtZSBnZXRUZXh0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0XG4gICAqIHZhciB0ZXh0ID0gdGV4dC50ZXh0KCk7XG4gICAqXG4gICAqIC8vIHNldCB0ZXh0XG4gICAqIHRleHQudGV4dCgnSGVsbG8gd29ybGQhJyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHQsICd0ZXh0RGVjb3JhdGlvbicsIEVNUFRZX1NUUklORyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dCBkZWNvcmF0aW9uIG9mIGEgdGV4dC4gIFBvc3NpYmxlIHZhbHVlcyBhcmUgJ3VuZGVybGluZScsICdsaW5lLXRocm91Z2gnIG9yIGNvbWJpbmF0aW9uIG9mIHRoZXNlIHZhbHVlcyBzZXBhcmF0ZWQgYnkgc3BhY2VcbiAgICogQG5hbWUgdGV4dERlY29yYXRpb25cbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHREZWNvcmF0aW9uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZXh0IGRlY29yYXRpb25cbiAgICogdmFyIHRleHREZWNvcmF0aW9uID0gdGV4dC50ZXh0RGVjb3JhdGlvbigpO1xuICAgKlxuICAgKiAvLyB1bmRlcmxpbmUgdGV4dFxuICAgKiB0ZXh0LnRleHREZWNvcmF0aW9uKCd1bmRlcmxpbmUnKTtcbiAgICpcbiAgICogLy8gc3RyaWtlIHRleHRcbiAgICogdGV4dC50ZXh0RGVjb3JhdGlvbignbGluZS10aHJvdWdoJyk7XG4gICAqXG4gICAqIC8vIHVuZGVybGluZSBhbmQgc3RyaWtlIHRleHRcbiAgICogdGV4dC50ZXh0RGVjb3JhdGlvbigndW5kZXJsaW5lIGxpbmUtdGhyb3VnaCcpO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dCk7XG59KSgpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICd1c2Ugc3RyaWN0JztcbiAgLyoqXG4gICAqIExpbmUgY29uc3RydWN0b3IuJm5ic3A7IExpbmVzIGFyZSBkZWZpbmVkIGJ5IGFuIGFycmF5IG9mIHBvaW50cyBhbmRcbiAgICogIGEgdGVuc2lvblxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZy5wb2ludHMgRmxhdCBhcnJheSBvZiBwb2ludHMgY29vcmRpbmF0ZXMuIFlvdSBzaG91bGQgZGVmaW5lIHRoZW0gYXMgW3gxLCB5MSwgeDIsIHkyLCB4MywgeTNdLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy50ZW5zaW9uXSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuY2xvc2VkXSBkZWZpbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBsaW5lIHNoYXBlIGlzIGNsb3NlZCwgY3JlYXRpbmcgYSBwb2x5Z29uIG9yIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmJlemllcl0gaWYgbm8gdGVuc2lvbiBpcyBwcm92aWRlZCBidXQgYmV6aWVyPXRydWUsIHdlIGRyYXcgdGhlIGxpbmUgYXMgYSBiZXppZXIgdXNpbmcgdGhlIHBhc3NlZCBwb2ludHNcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy53aWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5oZWlnaHRdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnZpc2libGVdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmxpc3RlbmluZ10gd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgbGlzdGVuaW5nIGZvciBldmVudHNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5pZF0gdW5pcXVlIGlkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubmFtZV0gbm9uLXVuaXF1ZSBuYW1lXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub3BhY2l0eV0gZGV0ZXJtaW5lcyBub2RlIG9wYWNpdHkuICBDYW4gYmUgYW55IG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zY2FsZV0gc2V0IHNjYWxlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVYXSBzZXQgc2NhbGUgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWV0gc2V0IHNjYWxlIHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5yb3RhdGlvbl0gcm90YXRpb24gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLm9mZnNldF0gb2Zmc2V0IGZyb20gY2VudGVyIHBvaW50IGFuZCByb3RhdGlvbiBwb2ludFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFhdIHNldCBvZmZzZXQgeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9mZnNldFldIHNldCBvZmZzZXQgeVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kcmFnZ2FibGVdIG1ha2VzIHRoZSBub2RlIGRyYWdnYWJsZS4gIFdoZW4gc3RhZ2VzIGFyZSBkcmFnZ2FibGUsIHlvdSBjYW4gZHJhZyBhbmQgZHJvcFxuICAgICAqICB0aGUgZW50aXJlIHN0YWdlIGJ5IGRyYWdnaW5nIGFueSBwb3J0aW9uIG9mIHRoZSBzdGFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmRyYWdEaXN0YW5jZV1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29uZmlnLmRyYWdCb3VuZEZ1bmNdXG4gICAqIEBleGFtcGxlXG4gICAqIHZhciBsaW5lID0gbmV3IEtvbnZhLkxpbmUoe1xuICAgKiAgIHg6IDEwMCxcbiAgICogICB5OiA1MCxcbiAgICogICBwb2ludHM6IFs3MywgNzAsIDM0MCwgMjMsIDQ1MCwgNjAsIDUwMCwgMjBdLFxuICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAqICAgdGVuc2lvbjogMVxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLkxpbmUgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5MaW5lLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ0xpbmUnO1xuXG4gICAgICB0aGlzLm9uKFxuICAgICAgICAncG9pbnRzQ2hhbmdlLmtvbnZhIHRlbnNpb25DaGFuZ2Uua29udmEgY2xvc2VkQ2hhbmdlLmtvbnZhIGJlemllckNoYW5nZS5rb252YScsXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoJ3RlbnNpb25Qb2ludHMnKTtcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpLFxuICAgICAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoLFxuICAgICAgICB0ZW5zaW9uID0gdGhpcy5nZXRUZW5zaW9uKCksXG4gICAgICAgIGNsb3NlZCA9IHRoaXMuZ2V0Q2xvc2VkKCksXG4gICAgICAgIGJlemllciA9IHRoaXMuZ2V0QmV6aWVyKCksXG4gICAgICAgIHRwLFxuICAgICAgICBsZW4sXG4gICAgICAgIG47XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcblxuICAgICAgLy8gdGVuc2lvblxuICAgICAgaWYgKHRlbnNpb24gIT09IDAgJiYgbGVuZ3RoID4gNCkge1xuICAgICAgICB0cCA9IHRoaXMuZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgICBsZW4gPSB0cC5sZW5ndGg7XG4gICAgICAgIG4gPSBjbG9zZWQgPyAwIDogNDtcblxuICAgICAgICBpZiAoIWNsb3NlZCkge1xuICAgICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyh0cFswXSwgdHBbMV0sIHRwWzJdLCB0cFszXSk7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAobiA8IGxlbiAtIDIpIHtcbiAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgICAgICAgICB0cFtuKytdLFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK10sXG4gICAgICAgICAgICB0cFtuKytdLFxuICAgICAgICAgICAgdHBbbisrXSxcbiAgICAgICAgICAgIHRwW24rK11cbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbG9zZWQpIHtcbiAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICB0cFtsZW4gLSAyXSxcbiAgICAgICAgICAgIHRwW2xlbiAtIDFdLFxuICAgICAgICAgICAgcG9pbnRzW2xlbmd0aCAtIDJdLFxuICAgICAgICAgICAgcG9pbnRzW2xlbmd0aCAtIDFdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChiZXppZXIpIHtcbiAgICAgICAgLy8gbm8gdGVuc2lvbiBidXQgYmV6aWVyXG4gICAgICAgIG4gPSAyO1xuXG4gICAgICAgIHdoaWxlIChuIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXSxcbiAgICAgICAgICAgIHBvaW50c1tuKytdLFxuICAgICAgICAgICAgcG9pbnRzW24rK10sXG4gICAgICAgICAgICBwb2ludHNbbisrXSxcbiAgICAgICAgICAgIHBvaW50c1tuKytdXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gdGVuc2lvblxuICAgICAgICBmb3IgKG4gPSAyOyBuIDwgbGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhwb2ludHNbbl0sIHBvaW50c1tuICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNsb3NlZCBlLmcuIHBvbHlnb25zIGFuZCBibG9ic1xuICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9wZW4gZS5nLiBsaW5lcyBhbmQgc3BsaW5lc1xuICAgICAgICBjb250ZXh0LnN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0VGVuc2lvblBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoJ3RlbnNpb25Qb2ludHMnLCB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzKTtcbiAgICB9LFxuICAgIF9nZXRUZW5zaW9uUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmdldENsb3NlZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gS29udmEuVXRpbC5fZXhwYW5kUG9pbnRzKHRoaXMuZ2V0UG9pbnRzKCksIHRoaXMuZ2V0VGVuc2lvbigpKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9nZXRUZW5zaW9uUG9pbnRzQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5nZXRQb2ludHMoKSxcbiAgICAgICAgbGVuID0gcC5sZW5ndGgsXG4gICAgICAgIHRlbnNpb24gPSB0aGlzLmdldFRlbnNpb24oKSxcbiAgICAgICAgdXRpbCA9IEtvbnZhLlV0aWwsXG4gICAgICAgIGZpcnN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgcFtsZW4gLSAyXSxcbiAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgcFsxXSxcbiAgICAgICAgICBwWzJdLFxuICAgICAgICAgIHBbM10sXG4gICAgICAgICAgdGVuc2lvblxuICAgICAgICApLFxuICAgICAgICBsYXN0Q29udHJvbFBvaW50cyA9IHV0aWwuX2dldENvbnRyb2xQb2ludHMoXG4gICAgICAgICAgcFtsZW4gLSA0XSxcbiAgICAgICAgICBwW2xlbiAtIDNdLFxuICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgcFtsZW4gLSAxXSxcbiAgICAgICAgICBwWzBdLFxuICAgICAgICAgIHBbMV0sXG4gICAgICAgICAgdGVuc2lvblxuICAgICAgICApLFxuICAgICAgICBtaWRkbGUgPSBLb252YS5VdGlsLl9leHBhbmRQb2ludHMocCwgdGVuc2lvbiksXG4gICAgICAgIHRwID0gW2ZpcnN0Q29udHJvbFBvaW50c1syXSwgZmlyc3RDb250cm9sUG9pbnRzWzNdXVxuICAgICAgICAgIC5jb25jYXQobWlkZGxlKVxuICAgICAgICAgIC5jb25jYXQoW1xuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMF0sXG4gICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1sxXSxcbiAgICAgICAgICAgIHBbbGVuIC0gMl0sXG4gICAgICAgICAgICBwW2xlbiAtIDFdLFxuICAgICAgICAgICAgbGFzdENvbnRyb2xQb2ludHNbMl0sXG4gICAgICAgICAgICBsYXN0Q29udHJvbFBvaW50c1szXSxcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1swXSxcbiAgICAgICAgICAgIGZpcnN0Q29udHJvbFBvaW50c1sxXSxcbiAgICAgICAgICAgIHBbMF0sXG4gICAgICAgICAgICBwWzFdXG4gICAgICAgICAgXSk7XG5cbiAgICAgIHJldHVybiB0cDtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNlbGZSZWN0KCkud2lkdGg7XG4gICAgfSxcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZlJlY3QoKS5oZWlnaHQ7XG4gICAgfSxcbiAgICAvLyBvdmVybG9hZCBzaXplIGRldGVjdGlvblxuICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHM7XG4gICAgICBpZiAodGhpcy5nZXRUZW5zaW9uKCkgIT09IDApIHtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5fZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICAgIH1cbiAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1heFggPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWluWSA9IHBvaW50c1sxXTtcbiAgICAgIHZhciBtYXhZID0gcG9pbnRzWzFdO1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSxcbiAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSxcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpLFxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQobWF4WSAtIG1pblkpXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuTGluZSwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2Nsb3NlZCcsIGZhbHNlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBjbG9zZWQgZmxhZy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEBuYW1lIGNsb3NlZFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlZFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGNsb3NlZCBmbGFnXG4gICAqIHZhciBjbG9zZWQgPSBsaW5lLmNsb3NlZCgpO1xuICAgKlxuICAgKiAvLyBjbG9zZSB0aGUgc2hhcGVcbiAgICogbGluZS5jbG9zZWQodHJ1ZSk7XG4gICAqXG4gICAqIC8vIG9wZW4gdGhlIHNoYXBlXG4gICAqIGxpbmUuY2xvc2VkKGZhbHNlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuTGluZSwgJ2JlemllcicsIGZhbHNlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBiZXppZXIgZmxhZy4gIFRoZSBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEBuYW1lIGJlemllclxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5MaW5lLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGJlemllclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHdoZXRoZXIgdGhlIGxpbmUgaXMgYSBiZXppZXJcbiAgICogdmFyIGlzQmV6aWVyID0gbGluZS5iZXppZXIoKTtcbiAgICpcbiAgICogLy8gc2V0IHdoZXRoZXIgdGhlIGxpbmUgaXMgYSBiZXppZXJcbiAgICogbGluZS5iZXppZXIodHJ1ZSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICd0ZW5zaW9uJywgMCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGVuc2lvblxuICAgKiBAbmFtZSB0ZW5zaW9uXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkxpbmUucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBIaWdoZXIgdmFsdWVzIHdpbGwgcmVzdWx0IGluIGEgbW9yZSBjdXJ2eSBsaW5lLiAgQSB2YWx1ZSBvZiAwIHdpbGwgcmVzdWx0IGluIG5vIGludGVycG9sYXRpb24uXG4gICAqICAgVGhlIGRlZmF1bHQgaXMgMFxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgdGVuc2lvblxuICAgKiB2YXIgdGVuc2lvbiA9IGxpbmUudGVuc2lvbigpO1xuICAgKlxuICAgKiAvLyBzZXQgdGVuc2lvblxuICAgKiBsaW5lLnRlbnNpb24oMyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkxpbmUsICdwb2ludHMnLCBbXSk7XG4gIC8qKlxuICAgKiBnZXQvc2V0IHBvaW50cyBhcnJheVxuICAgKiBAbmFtZSBwb2ludHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuTGluZS5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzXG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHBvaW50c1xuICAgKiB2YXIgcG9pbnRzID0gbGluZS5wb2ludHMoKTtcbiAgICpcbiAgICogLy8gc2V0IHBvaW50c1xuICAgKiBsaW5lLnBvaW50cyhbMTAsIDIwLCAzMCwgNDAsIDUwLCA2MF0pO1xuICAgKlxuICAgKiAvLyBwdXNoIGEgbmV3IHBvaW50XG4gICAqIGxpbmUucG9pbnRzKGxpbmUucG9pbnRzKCkuY29uY2F0KFs3MCwgODBdKSk7XG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MaW5lKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBTcHJpdGUgY29uc3RydWN0b3JcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAbWVtYmVyb2YgS29udmFcbiAgICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5hbmltYXRpb24gYW5pbWF0aW9uIGtleVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcuYW5pbWF0aW9ucyBhbmltYXRpb24gbWFwXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBbY29uZmlnLmZyYW1lSW5kZXhdIGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGNvbmZpZy5pbWFnZSBpbWFnZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGltYWdlT2JqID0gbmV3IEltYWdlKCk7XG4gICAgICogaW1hZ2VPYmoub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICogICB2YXIgc3ByaXRlID0gbmV3IEtvbnZhLlNwcml0ZSh7XG4gICAgICogICAgIHg6IDIwMCxcbiAgICAgKiAgICAgeTogMTAwLFxuICAgICAqICAgICBpbWFnZTogaW1hZ2VPYmosXG4gICAgICogICAgIGFuaW1hdGlvbjogJ3N0YW5kaW5nJyxcbiAgICAgKiAgICAgYW5pbWF0aW9uczoge1xuICAgICAqICAgICAgIHN0YW5kaW5nOiBbXG4gICAgICogICAgICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgICAgIDAsIDAsIDQ5LCAxMDksXG4gICAgICogICAgICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDEwNSwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDE1OCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgICAgIDI2MiwgMCwgNDksIDEwOVxuICAgICAqICAgICAgIF0sXG4gICAgICogICAgICAga2lja2luZzogW1xuICAgICAqICAgICAgICAgLy8geCwgeSwgd2lkdGgsIGhlaWdodCAoNiBmcmFtZXMpXG4gICAgICogICAgICAgICAwLCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgICAgIDk1LCAxMDksIDYzLCA5OCxcbiAgICAgKiAgICAgICAgIDE1NiwgMTA5LCA3MCwgOTgsXG4gICAgICogICAgICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgICAqICAgICAgICAgMjg3LCAxMDksIDQxLCA5OFxuICAgICAqICAgICAgIF1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgZnJhbWVSYXRlOiA3LFxuICAgICAqICAgICBmcmFtZUluZGV4OiAwXG4gICAgICogICB9KTtcbiAgICAgKiB9O1xuICAgICAqIGltYWdlT2JqLnNyYyA9ICcvcGF0aC90by9pbWFnZS5qcGcnXG4gICAgICovXG4gIEtvbnZhLlNwcml0ZSA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlNwcml0ZS5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdTcHJpdGUnO1xuXG4gICAgICB0aGlzLl91cGRhdGVkID0gdHJ1ZTtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHRoaXMuYW5pbSA9IG5ldyBLb252YS5BbmltYXRpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGlmIHdlIGRvbid0IG5lZWQgdG8gcmVkcmF3IGxheWVyIHdlIHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICAgICAgdmFyIHVwZGF0ZWQgPSB0aGF0Ll91cGRhdGVkO1xuICAgICAgICB0aGF0Ll91cGRhdGVkID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLm9uKCdhbmltYXRpb25DaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gcmVzZXQgaW5kZXggd2hlbiBhbmltYXRpb24gY2hhbmdlc1xuICAgICAgICB0aGlzLmZyYW1lSW5kZXgoMCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMub24oJ2ZyYW1lSW5kZXhDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlZCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIC8vIHNtb290aCBjaGFuZ2UgZm9yIGZyYW1lUmF0ZVxuICAgICAgdGhpcy5vbignZnJhbWVSYXRlQ2hhbmdlLmtvbnZhJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5hbmltLmlzUnVubmluZygpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX3NldEludGVydmFsKCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICAgIHRoaXMuaGl0RnVuYyh0aGlzLl9oaXRGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBhbmltID0gdGhpcy5nZXRBbmltYXRpb24oKSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcbiAgICAgICAgaXg0ID0gaW5kZXggKiA0LFxuICAgICAgICBzZXQgPSB0aGlzLmdldEFuaW1hdGlvbnMoKVthbmltXSxcbiAgICAgICAgb2Zmc2V0cyA9IHRoaXMuZnJhbWVPZmZzZXRzKCksXG4gICAgICAgIHggPSBzZXRbaXg0ICsgMF0sXG4gICAgICAgIHkgPSBzZXRbaXg0ICsgMV0sXG4gICAgICAgIHdpZHRoID0gc2V0W2l4NCArIDJdLFxuICAgICAgICBoZWlnaHQgPSBzZXRbaXg0ICsgM10sXG4gICAgICAgIGltYWdlID0gdGhpcy5nZXRJbWFnZSgpO1xuXG4gICAgICBpZiAodGhpcy5oYXNGaWxsKCkgfHwgdGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0LnJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW1hZ2UpIHtcbiAgICAgICAgaWYgKG9mZnNldHMpIHtcbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXSwgaXgyID0gaW5kZXggKiAyO1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKFxuICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgb2Zmc2V0W2l4MiArIDBdLFxuICAgICAgICAgICAgb2Zmc2V0W2l4MiArIDFdLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBhbmltID0gdGhpcy5nZXRBbmltYXRpb24oKSxcbiAgICAgICAgaW5kZXggPSB0aGlzLmZyYW1lSW5kZXgoKSxcbiAgICAgICAgaXg0ID0gaW5kZXggKiA0LFxuICAgICAgICBzZXQgPSB0aGlzLmdldEFuaW1hdGlvbnMoKVthbmltXSxcbiAgICAgICAgb2Zmc2V0cyA9IHRoaXMuZnJhbWVPZmZzZXRzKCksXG4gICAgICAgIHdpZHRoID0gc2V0W2l4NCArIDJdLFxuICAgICAgICBoZWlnaHQgPSBzZXRbaXg0ICsgM107XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBpZiAob2Zmc2V0cykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0c1thbmltXTtcbiAgICAgICAgdmFyIGl4MiA9IGluZGV4ICogMjtcbiAgICAgICAgY29udGV4dC5yZWN0KG9mZnNldFtpeDIgKyAwXSwgb2Zmc2V0W2l4MiArIDFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIF91c2VCdWZmZXJDYW52YXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRoaXMuaGFzU2hhZG93KCkgfHwgdGhpcy5nZXRBYnNvbHV0ZU9wYWNpdHkoKSAhPT0gMSkgJiZcbiAgICAgICAgdGhpcy5oYXNTdHJva2UoKVxuICAgICAgKTtcbiAgICB9LFxuICAgIF9zZXRJbnRlcnZhbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuX3VwZGF0ZUluZGV4KCk7XG4gICAgICB9LCAxMDAwIC8gdGhpcy5nZXRGcmFtZVJhdGUoKSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogc3RhcnQgc3ByaXRlIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuZ2V0TGF5ZXIoKTtcblxuICAgICAgLypcbiAgICAgICAgICAgICAqIGFuaW1hdGlvbiBvYmplY3QgaGFzIG5vIGV4ZWN1dGFibGUgZnVuY3Rpb24gYmVjYXVzZVxuICAgICAgICAgICAgICogIHRoZSB1cGRhdGVzIGFyZSBkb25lIHdpdGggYSBmaXhlZCBGUFMgd2l0aCB0aGUgc2V0SW50ZXJ2YWxcbiAgICAgICAgICAgICAqICBiZWxvdy4gIFRoZSBhbmltIG9iamVjdCBvbmx5IG5lZWRzIHRoZSBsYXllciByZWZlcmVuY2UgZm9yXG4gICAgICAgICAgICAgKiAgcmVkcmF3XG4gICAgICAgICAgICAgKi9cbiAgICAgIHRoaXMuYW5pbS5zZXRMYXllcnMobGF5ZXIpO1xuICAgICAgdGhpcy5fc2V0SW50ZXJ2YWwoKTtcbiAgICAgIHRoaXMuYW5pbS5zdGFydCgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIHN0b3Agc3ByaXRlIGFuaW1hdGlvblxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5hbmltLnN0b3AoKTtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZGV0ZXJtaW5lIGlmIGFuaW1hdGlvbiBvZiBzcHJpdGUgaXMgcnVubmluZyBvciBub3QuICByZXR1cm5zIHRydWUgb3IgZmFsc2VcbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAbWVtYmVyb2YgS29udmEuQW5pbWF0aW9uLnByb3RvdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgICAgICovXG4gICAgaXNSdW5uaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW0uaXNSdW5uaW5nKCk7XG4gICAgfSxcbiAgICBfdXBkYXRlSW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5mcmFtZUluZGV4KCksXG4gICAgICAgIGFuaW1hdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW9uKCksXG4gICAgICAgIGFuaW1hdGlvbnMgPSB0aGlzLmdldEFuaW1hdGlvbnMoKSxcbiAgICAgICAgYW5pbSA9IGFuaW1hdGlvbnNbYW5pbWF0aW9uXSxcbiAgICAgICAgbGVuID0gYW5pbS5sZW5ndGggLyA0O1xuXG4gICAgICBpZiAoaW5kZXggPCBsZW4gLSAxKSB7XG4gICAgICAgIHRoaXMuZnJhbWVJbmRleChpbmRleCArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mcmFtZUluZGV4KDApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3ByaXRlLCBLb252YS5TaGFwZSk7XG5cbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdhbmltYXRpb24nKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGFuaW1hdGlvbiBrZXlcbiAgICAgKiBAbmFtZSBhbmltYXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYW5pbSBhbmltYXRpb24ga2V5XG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb24ga2V5XG4gICAgICogdmFyIGFuaW1hdGlvbiA9IHNwcml0ZS5hbmltYXRpb24oKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb24ga2V5XG4gICAgICogc3ByaXRlLmFuaW1hdGlvbigna2lja2luZycpO1xuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2FuaW1hdGlvbnMnKTtcblxuICAvKipcbiAgICAgKiBnZXQvc2V0IGFuaW1hdGlvbnMgbWFwXG4gICAgICogQG5hbWUgYW5pbWF0aW9uc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhbmltYXRpb25zXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIGdldCBhbmltYXRpb25zIG1hcFxuICAgICAqIHZhciBhbmltYXRpb25zID0gc3ByaXRlLmFuaW1hdGlvbnMoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb25zIG1hcFxuICAgICAqIHNwcml0ZS5hbmltYXRpb25zKHtcbiAgICAgKiAgIHN0YW5kaW5nOiBbXG4gICAgICogICAgIC8vIHgsIHksIHdpZHRoLCBoZWlnaHQgKDYgZnJhbWVzKVxuICAgICAqICAgICAwLCAwLCA0OSwgMTA5LFxuICAgICAqICAgICA1MiwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMTA1LCAwLCA0OSwgMTA5LFxuICAgICAqICAgICAxNTgsIDAsIDQ5LCAxMDksXG4gICAgICogICAgIDIxMCwgMCwgNDksIDEwOSxcbiAgICAgKiAgICAgMjYyLCAwLCA0OSwgMTA5XG4gICAgICogICBdLFxuICAgICAqICAga2lja2luZzogW1xuICAgICAqICAgICAvLyB4LCB5LCB3aWR0aCwgaGVpZ2h0ICg2IGZyYW1lcylcbiAgICAgKiAgICAgMCwgMTA5LCA0NSwgOTgsXG4gICAgICogICAgIDQ1LCAxMDksIDQ1LCA5OCxcbiAgICAgKiAgICAgOTUsIDEwOSwgNjMsIDk4LFxuICAgICAqICAgICAxNTYsIDEwOSwgNzAsIDk4LFxuICAgICAqICAgICAyMjksIDEwOSwgNjAsIDk4LFxuICAgICAqICAgICAyODcsIDEwOSwgNDEsIDk4XG4gICAgICogICBdXG4gICAgICogfSk7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVPZmZzZXRzJyk7XG5cbiAgLyoqXG4gICAgKiBnZXQvc2V0IG9mZnNldHMgbWFwXG4gICAgKiBAbmFtZSBvZmZzZXRzXG4gICAgKiBAbWV0aG9kXG4gICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICogQHBhcmFtIHtPYmplY3R9IG9mZnNldHNcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKiBAZXhhbXBsZVxuICAgICogLy8gZ2V0IG9mZnNldHMgbWFwXG4gICAgKiB2YXIgb2Zmc2V0cyA9IHNwcml0ZS5vZmZzZXRzKCk7XG4gICAgKlxuICAgICogLy8gc2V0IG9mZnNldHMgbWFwXG4gICAgKiBzcHJpdGUub2Zmc2V0cyh7XG4gICAgKiAgIHN0YW5kaW5nOiBbXG4gICAgKiAgICAgLy8geCwgeSAoNiBmcmFtZXMpXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDUsIDAsXG4gICAgKiAgICAgMCwgMCxcbiAgICAqICAgICAwLCAzLFxuICAgICogICAgIDIsIDBcbiAgICAqICAgXSxcbiAgICAqICAga2lja2luZzogW1xuICAgICogICAgIC8vIHgsIHkgKDYgZnJhbWVzKVxuICAgICogICAgIDAsIDUsXG4gICAgKiAgICAgNSwgMCxcbiAgICAqICAgICAxMCwgMCxcbiAgICAqICAgICAwLCAwLFxuICAgICogICAgIDIsIDEsXG4gICAgKiAgICAgMCwgMFxuICAgICogICBdXG4gICAgKiB9KTtcbiAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNwcml0ZSwgJ2ltYWdlJyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBpbWFnZVxuICAgICAqIEBuYW1lIGltYWdlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TcHJpdGUucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyBnZXQgaW1hZ2VcbiAgICAgKiB2YXIgaW1hZ2UgPSBzcHJpdGUuaW1hZ2UoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBpbWFnZVxuICAgICAqIHNwcml0ZS5pbWFnZShpbWFnZU9iaik7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3ByaXRlLCAnZnJhbWVJbmRleCcsIDApO1xuXG4gIC8qKlxuICAgICAqIHNldC9zZXQgYW5pbWF0aW9uIGZyYW1lIGluZGV4XG4gICAgICogQG5hbWUgZnJhbWVJbmRleFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuU3ByaXRlLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gZnJhbWVJbmRleFxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGFuaW1hdGlvbiBmcmFtZSBpbmRleFxuICAgICAqIHZhciBmcmFtZUluZGV4ID0gc3ByaXRlLmZyYW1lSW5kZXgoKTtcbiAgICAgKlxuICAgICAqIC8vIHNldCBhbmltYXRpb24gZnJhbWUgaW5kZXhcbiAgICAgKiBzcHJpdGUuZnJhbWVJbmRleCgzKTtcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5TcHJpdGUsICdmcmFtZVJhdGUnLCAxNyk7XG5cbiAgLyoqXG4gICAgICogZ2V0L3NldCBmcmFtZSByYXRlIGluIGZyYW1lcyBwZXIgc2Vjb25kLiAgSW5jcmVhc2UgdGhpcyBudW1iZXIgdG8gbWFrZSB0aGUgc3ByaXRlXG4gICAgICogIGFuaW1hdGlvbiBydW4gZmFzdGVyLCBhbmQgZGVjcmVhc2UgdGhlIG51bWJlciB0byBtYWtlIHRoZSBzcHJpdGUgYW5pbWF0aW9uIHJ1biBzbG93ZXJcbiAgICAgKiAgVGhlIGRlZmF1bHQgaXMgMTcgZnJhbWVzIHBlciBzZWNvbmRcbiAgICAgKiBAbmFtZSBmcmFtZVJhdGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlNwcml0ZS5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IGZyYW1lUmF0ZVxuICAgICAqIEByZXR1cm5zIHtJbnRlZ2VyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gZ2V0IGZyYW1lIHJhdGVcbiAgICAgKiB2YXIgZnJhbWVSYXRlID0gc3ByaXRlLmZyYW1lUmF0ZSgpO1xuICAgICAqXG4gICAgICogLy8gc2V0IGZyYW1lIHJhdGUgdG8gMiBmcmFtZXMgcGVyIHNlY29uZFxuICAgICAqIHNwcml0ZS5mcmFtZVJhdGUoMik7XG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5iYWNrQ29tcGF0KEtvbnZhLlNwcml0ZSwge1xuICAgIGluZGV4OiAnZnJhbWVJbmRleCcsXG4gICAgZ2V0SW5kZXg6ICdnZXRGcmFtZUluZGV4JyxcbiAgICBzZXRJbmRleDogJ3NldEZyYW1lSW5kZXgnXG4gIH0pO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5TcHJpdGUpO1xufSkoKTtcblxuLyplc2xpbnQtZGlzYWJsZSAgbm8tc2hhZG93LCBtYXgtbGVuLCBtYXgtZGVwdGggKi9cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogUGF0aCBjb25zdHJ1Y3Rvci5cbiAgICogQGF1dGhvciBKYXNvbiBGb2xsYXNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLmRhdGEgU1ZHIGRhdGEgc3RyaW5nXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgcGF0aCA9IG5ldyBLb252YS5QYXRoKHtcbiAgICogICB4OiAyNDAsXG4gICAqICAgeTogNDAsXG4gICAqICAgZGF0YTogJ00xMi41ODIsOS41NTFDMy4yNTEsMTYuMjM3LDAuOTIxLDI5LjAyMSw3LjA4LDM4LjU2NGwtMi4zNiwxLjY4OWw0Ljg5MywyLjI2Mmw0Ljg5MywyLjI2MmwtMC41NjgtNS4zNmwtMC41NjctNS4zNTlsLTIuMzY1LDEuNjk0Yy00LjY1Ny03LjM3NS0yLjgzLTE3LjE4NSw0LjM1Mi0yMi4zM2M3LjQ1MS01LjMzOCwxNy44MTctMy42MjUsMjMuMTU2LDMuODI0YzUuMzM3LDcuNDQ5LDMuNjI1LDE3LjgxMy0zLjgyMSwyMy4xNTJsMi44NTcsMy45ODhjOS42MTctNi44OTMsMTEuODI3LTIwLjI3Nyw0LjkzNS0yOS44OTZDMzUuNTkxLDQuODcsMjIuMjA0LDIuNjU4LDEyLjU4Miw5LjU1MXonLFxuICAgKiAgIGZpbGw6ICdncmVlbicsXG4gICAqICAgc2NhbGU6IDJcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5QYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuUGF0aC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdQYXRoJztcblxuICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5nZXREYXRhKCkpO1xuICAgICAgdGhpcy5vbignZGF0YUNoYW5nZS5rb252YScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmRhdGFBcnJheSA9IEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSh0aGlzLmdldERhdGEoKSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5zY2VuZUZ1bmModGhpcy5fc2NlbmVGdW5jKTtcbiAgICB9LFxuICAgIF9zY2VuZUZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIHZhciBjYSA9IHRoaXMuZGF0YUFycmF5O1xuXG4gICAgICAvLyBjb250ZXh0IHBvc2l0aW9uXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBjYS5sZW5ndGg7IG4rKykge1xuICAgICAgICB2YXIgYyA9IGNhW25dLmNvbW1hbmQ7XG4gICAgICAgIHZhciBwID0gY2Fbbl0ucG9pbnRzO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHBbMF0sIHBbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhwWzBdLCBwWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHBbMF0sIHBbMV0sIHBbMl0sIHBbM10sIHBbNF0sIHBbNV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocFswXSwgcFsxXSwgcFsyXSwgcFszXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgIHZhciBjeCA9IHBbMF0sXG4gICAgICAgICAgICAgIGN5ID0gcFsxXSxcbiAgICAgICAgICAgICAgcnggPSBwWzJdLFxuICAgICAgICAgICAgICByeSA9IHBbM10sXG4gICAgICAgICAgICAgIHRoZXRhID0gcFs0XSxcbiAgICAgICAgICAgICAgZFRoZXRhID0gcFs1XSxcbiAgICAgICAgICAgICAgcHNpID0gcFs2XSxcbiAgICAgICAgICAgICAgZnMgPSBwWzddO1xuXG4gICAgICAgICAgICB2YXIgciA9IHJ4ID4gcnkgPyByeCA6IHJ5O1xuICAgICAgICAgICAgdmFyIHNjYWxlWCA9IHJ4ID4gcnkgPyAxIDogcnggLyByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG5cbiAgICAgICAgICAgIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gICAgICAgICAgICBjb250ZXh0LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgY29udGV4dC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByLCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIDEgLSBmcyk7XG4gICAgICAgICAgICBjb250ZXh0LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgY29udGV4dC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtY3gsIC1jeSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3onOlxuICAgICAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0U2VsZlJlY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgdGhpcy5kYXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQoZGF0YS5wb2ludHMpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbWluWCA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtYXhYID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1pblkgPSBwb2ludHNbMV07XG4gICAgICB2YXIgbWF4WSA9IHBvaW50c1sxXTtcbiAgICAgIHZhciB4LCB5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICB5ID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCB4KTtcbiAgICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIHgpO1xuICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCB5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IE1hdGgucm91bmQobWluWCksXG4gICAgICAgIHk6IE1hdGgucm91bmQobWluWSksXG4gICAgICAgIHdpZHRoOiBNYXRoLnJvdW5kKG1heFggLSBtaW5YKSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLnJvdW5kKG1heFkgLSBtaW5ZKVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLlBhdGgsIEtvbnZhLlNoYXBlKTtcblxuICBLb252YS5QYXRoLmdldExpbmVMZW5ndGggPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgfTtcbiAgS29udmEuUGF0aC5nZXRQb2ludE9uTGluZSA9IGZ1bmN0aW9uKGRpc3QsIFAxeCwgUDF5LCBQMngsIFAyeSwgZnJvbVgsIGZyb21ZKSB7XG4gICAgaWYgKGZyb21YID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb21YID0gUDF4O1xuICAgIH1cbiAgICBpZiAoZnJvbVkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZnJvbVkgPSBQMXk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSAoUDJ5IC0gUDF5KSAvIChQMnggLSBQMXggKyAwLjAwMDAwMDAxKTtcbiAgICB2YXIgcnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC8gKDEgKyBtICogbSkpO1xuICAgIGlmIChQMnggPCBQMXgpIHtcbiAgICAgIHJ1biAqPSAtMTtcbiAgICB9XG4gICAgdmFyIHJpc2UgPSBtICogcnVuO1xuICAgIHZhciBwdDtcblxuICAgIGlmIChQMnggPT09IFAxeCkge1xuICAgICAgLy8gdmVydGljYWwgbGluZVxuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGZyb21YLFxuICAgICAgICB5OiBmcm9tWSArIHJpc2VcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgoZnJvbVkgLSBQMXkpIC8gKGZyb21YIC0gUDF4ICsgMC4wMDAwMDAwMSkgPT09IG0pIHtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXgsIGl5O1xuXG4gICAgICB2YXIgbGVuID0gdGhpcy5nZXRMaW5lTGVuZ3RoKFAxeCwgUDF5LCBQMngsIFAyeSk7XG4gICAgICBpZiAobGVuIDwgMC4wMDAwMDAwMSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIHUgPSAoZnJvbVggLSBQMXgpICogKFAyeCAtIFAxeCkgKyAoZnJvbVkgLSBQMXkpICogKFAyeSAtIFAxeSk7XG4gICAgICB1ID0gdSAvIChsZW4gKiBsZW4pO1xuICAgICAgaXggPSBQMXggKyB1ICogKFAyeCAtIFAxeCk7XG4gICAgICBpeSA9IFAxeSArIHUgKiAoUDJ5IC0gUDF5KTtcblxuICAgICAgdmFyIHBSaXNlID0gdGhpcy5nZXRMaW5lTGVuZ3RoKGZyb21YLCBmcm9tWSwgaXgsIGl5KTtcbiAgICAgIHZhciBwUnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC0gcFJpc2UgKiBwUmlzZSk7XG4gICAgICBydW4gPSBNYXRoLnNxcnQocFJ1biAqIHBSdW4gLyAoMSArIG0gKiBtKSk7XG4gICAgICBpZiAoUDJ4IDwgUDF4KSB7XG4gICAgICAgIHJ1biAqPSAtMTtcbiAgICAgIH1cbiAgICAgIHJpc2UgPSBtICogcnVuO1xuICAgICAgcHQgPSB7XG4gICAgICAgIHg6IGl4ICsgcnVuLFxuICAgICAgICB5OiBpeSArIHJpc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0O1xuICB9O1xuXG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyID0gZnVuY3Rpb24oXG4gICAgcGN0LFxuICAgIFAxeCxcbiAgICBQMXksXG4gICAgUDJ4LFxuICAgIFAyeSxcbiAgICBQM3gsXG4gICAgUDN5LFxuICAgIFA0eCxcbiAgICBQNHlcbiAgKSB7XG4gICAgZnVuY3Rpb24gQ0IxKHQpIHtcbiAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENCMih0KSB7XG4gICAgICByZXR1cm4gMyAqIHQgKiB0ICogKDEgLSB0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQ0IzKHQpIHtcbiAgICAgIHJldHVybiAzICogdCAqICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDQjQodCkge1xuICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpICogKDEgLSB0KTtcbiAgICB9XG4gICAgdmFyIHggPSBQNHggKiBDQjEocGN0KSArIFAzeCAqIENCMihwY3QpICsgUDJ4ICogQ0IzKHBjdCkgKyBQMXggKiBDQjQocGN0KTtcbiAgICB2YXIgeSA9IFA0eSAqIENCMShwY3QpICsgUDN5ICogQ0IyKHBjdCkgKyBQMnkgKiBDQjMocGN0KSArIFAxeSAqIENCNChwY3QpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfTtcbiAgS29udmEuUGF0aC5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24oXG4gICAgcGN0LFxuICAgIFAxeCxcbiAgICBQMXksXG4gICAgUDJ4LFxuICAgIFAyeSxcbiAgICBQM3gsXG4gICAgUDN5XG4gICkge1xuICAgIGZ1bmN0aW9uIFFCMSh0KSB7XG4gICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFCMih0KSB7XG4gICAgICByZXR1cm4gMiAqIHQgKiAoMSAtIHQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBRQjModCkge1xuICAgICAgcmV0dXJuICgxIC0gdCkgKiAoMSAtIHQpO1xuICAgIH1cbiAgICB2YXIgeCA9IFAzeCAqIFFCMShwY3QpICsgUDJ4ICogUUIyKHBjdCkgKyBQMXggKiBRQjMocGN0KTtcbiAgICB2YXIgeSA9IFAzeSAqIFFCMShwY3QpICsgUDJ5ICogUUIyKHBjdCkgKyBQMXkgKiBRQjMocGN0KTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH07XG4gIEtvbnZhLlBhdGguZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMgPSBmdW5jdGlvbihjeCwgY3ksIHJ4LCByeSwgdGhldGEsIHBzaSkge1xuICAgIHZhciBjb3NQc2kgPSBNYXRoLmNvcyhwc2kpLFxuICAgICAgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICB2YXIgcHQgPSB7XG4gICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgfTtcbiAgfTtcbiAgLypcbiAgICAgKiBnZXQgcGFyc2VkIGRhdGEgYXJyYXkgZnJvbSB0aGUgZGF0YVxuICAgICAqICBzdHJpbmcuICBWLCB2LCBILCBoLCBhbmQgbCBkYXRhIGFyZSBjb252ZXJ0ZWQgdG9cbiAgICAgKiAgTCBkYXRhIGZvciB0aGUgcHVycG9zZSBvZiBoaWdoIHBlcmZvcm1hbmNlIFBhdGhcbiAgICAgKiAgcmVuZGVyaW5nXG4gICAgICovXG4gIEtvbnZhLlBhdGgucGFyc2VQYXRoRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvLyBQYXRoIERhdGEgU2VnbWVudCBtdXN0IGJlZ2luIHdpdGggYSBtb3ZlVG9cbiAgICAvL20gKHggeSkrICBSZWxhdGl2ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAvL00gKHggeSkrICBBYnNvbHV0ZSBtb3ZlVG8gKHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIGxpbmVUbylcbiAgICAvL2wgKHggeSkrICBSZWxhdGl2ZSBsaW5lVG9cbiAgICAvL0wgKHggeSkrICBBYnNvbHV0ZSBMaW5lVG9cbiAgICAvL2ggKHgpKyAgICBSZWxhdGl2ZSBob3Jpem9udGFsIGxpbmVUb1xuICAgIC8vSCAoeCkrICAgIEFic29sdXRlIGhvcml6b250YWwgbGluZVRvXG4gICAgLy92ICh5KSsgICAgUmVsYXRpdmUgdmVydGljYWwgbGluZVRvXG4gICAgLy9WICh5KSsgICAgQWJzb2x1dGUgdmVydGljYWwgbGluZVRvXG4gICAgLy96IChjbG9zZXBhdGgpXG4gICAgLy9aIChjbG9zZXBhdGgpXG4gICAgLy9jICh4MSB5MSB4MiB5MiB4IHkpKyBSZWxhdGl2ZSBCZXppZXIgY3VydmVcbiAgICAvL0MgKHgxIHkxIHgyIHkyIHggeSkrIEFic29sdXRlIEJlemllciBjdXJ2ZVxuICAgIC8vcSAoeDEgeTEgeCB5KSsgICAgICAgUmVsYXRpdmUgUXVhZHJhdGljIEJlemllclxuICAgIC8vUSAoeDEgeTEgeCB5KSsgICAgICAgQWJzb2x1dGUgUXVhZHJhdGljIEJlemllclxuICAgIC8vdCAoeCB5KSsgICAgU2hvcnRoYW5kL1Ntb290aCBSZWxhdGl2ZSBRdWFkcmF0aWMgQmV6aWVyXG4gICAgLy9UICh4IHkpKyAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIFF1YWRyYXRpYyBCZXppZXJcbiAgICAvL3MgKHgyIHkyIHggeSkrICAgICAgIFNob3J0aGFuZC9TbW9vdGggUmVsYXRpdmUgQmV6aWVyIGN1cnZlXG4gICAgLy9TICh4MiB5MiB4IHkpKyAgICAgICBTaG9ydGhhbmQvU21vb3RoIEFic29sdXRlIEJlemllciBjdXJ2ZVxuICAgIC8vYSAocnggcnkgeC1heGlzLXJvdGF0aW9uIGxhcmdlLWFyYy1mbGFnIHN3ZWVwLWZsYWcgeCB5KSsgICAgIFJlbGF0aXZlIEVsbGlwdGljYWwgQXJjXG4gICAgLy9BIChyeCByeSB4LWF4aXMtcm90YXRpb24gbGFyZ2UtYXJjLWZsYWcgc3dlZXAtZmxhZyB4IHkpKyAgQWJzb2x1dGUgRWxsaXB0aWNhbCBBcmNcblxuICAgIC8vIHJldHVybiBlYXJseSBpZiBkYXRhIGlzIG5vdCBkZWZpbmVkXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gY29tbWFuZCBzdHJpbmdcbiAgICB2YXIgY3MgPSBkYXRhO1xuXG4gICAgLy8gY29tbWFuZCBjaGFyc1xuICAgIHZhciBjYyA9IFtcbiAgICAgICdtJyxcbiAgICAgICdNJyxcbiAgICAgICdsJyxcbiAgICAgICdMJyxcbiAgICAgICd2JyxcbiAgICAgICdWJyxcbiAgICAgICdoJyxcbiAgICAgICdIJyxcbiAgICAgICd6JyxcbiAgICAgICdaJyxcbiAgICAgICdjJyxcbiAgICAgICdDJyxcbiAgICAgICdxJyxcbiAgICAgICdRJyxcbiAgICAgICd0JyxcbiAgICAgICdUJyxcbiAgICAgICdzJyxcbiAgICAgICdTJyxcbiAgICAgICdhJyxcbiAgICAgICdBJ1xuICAgIF07XG4gICAgLy8gY29udmVydCB3aGl0ZSBzcGFjZXMgdG8gY29tbWFzXG4gICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoJyAnLCAnZycpLCAnLCcpO1xuICAgIC8vIGNyZWF0ZSBwaXBlcyBzbyB0aGF0IHdlIGNhbiBzcGxpdCB0aGUgZGF0YVxuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgY2MubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNzID0gY3MucmVwbGFjZShuZXcgUmVnRXhwKGNjW25dLCAnZycpLCAnfCcgKyBjY1tuXSk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhcnJheVxuICAgIHZhciBhcnIgPSBjcy5zcGxpdCgnfCcpO1xuICAgIHZhciBjYSA9IFtdO1xuICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICAvLyBpbml0IGNvbnRleHQgcG9pbnRcbiAgICB2YXIgY3B4ID0gMDtcbiAgICB2YXIgY3B5ID0gMDtcblxuICAgIHZhciByZSA9IC8oWy0rXT8oKFxcZCtcXC5cXGQrKXwoKFxcZCspfChcXC5cXGQrKSkpKD86ZVstK10/XFxkKyk/KS9naTtcbiAgICB2YXIgbWF0Y2g7XG4gICAgZm9yIChuID0gMTsgbiA8IGFyci5sZW5ndGg7IG4rKykge1xuICAgICAgdmFyIHN0ciA9IGFycltuXTtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdCgwKTtcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgxKTtcblxuICAgICAgY29vcmRzLmxlbmd0aCA9IDA7XG4gICAgICB3aGlsZSAoKG1hdGNoID0gcmUuZXhlYyhzdHIpKSkge1xuICAgICAgICBjb29yZHMucHVzaChtYXRjaFswXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdoaWxlICgobWF0Y2ggPSByZS5leGVjKHN0cikpKSB7XG4gICAgICAvLyAgIGNvb3Jkcy5wdXNoKG1hdGNoWzBdKTtcbiAgICAgIC8vIH1cbiAgICAgIHZhciBwID0gW107XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbGVuID0gY29vcmRzLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICB2YXIgcGFyc2VkID0gcGFyc2VGbG9hdChjb29yZHNbal0pO1xuICAgICAgICBpZiAoIWlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICBwLnB1c2gocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAocC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChpc05hTihwWzBdKSkge1xuICAgICAgICAgIC8vIGNhc2UgZm9yIGEgdHJhaWxpbmcgY29tbWEgYmVmb3JlIG5leHQgY29tbWFuZFxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNtZCA9IG51bGw7XG4gICAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGNweCxcbiAgICAgICAgICBzdGFydFkgPSBjcHk7XG4gICAgICAgIC8vIE1vdmUgdmFyIGZyb20gd2l0aGluIHRoZSBzd2l0Y2ggdG8gdXAgaGVyZSAoanNoaW50KVxuICAgICAgICB2YXIgcHJldkNtZCwgY3RsUHR4LCBjdGxQdHk7IC8vIFNzLCBUdFxuICAgICAgICB2YXIgcngsIHJ5LCBwc2ksIGZhLCBmcywgeDEsIHkxOyAvLyBBYVxuXG4gICAgICAgIC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICAvLyBOb3RlOiBLZWVwIHRoZSBsaW5lVG8ncyBhYm92ZSB0aGUgbW92ZVRvJ3MgaW4gdGhpcyBzd2l0Y2hcbiAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBOb3RlOiBsaW5lVG8gaGFuZGxlcnMgbmVlZCB0byBiZSBhYm92ZSB0aGlzIHBvaW50XG4gICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICB2YXIgZHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHggKz0gZHg7XG4gICAgICAgICAgICBjcHkgKz0gZHk7XG4gICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICAvLyBBZnRlciBjbG9zaW5nIHRoZSBwYXRoIG1vdmUgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIHRvIHRoZSB0aGUgZmlyc3QgcG9pbnQgb2YgdGhlIHBhdGggKGlmIGFueSkuXG4gICAgICAgICAgICBpZiAoY2EubGVuZ3RoID4gMiAmJiBjYVtjYS5sZW5ndGggLSAxXS5jb21tYW5kID09PSAneicpIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gY2EubGVuZ3RoIC0gMjsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhW2lkeF0uY29tbWFuZCA9PT0gJ00nKSB7XG4gICAgICAgICAgICAgICAgICBjcHggPSBjYVtpZHhdLnBvaW50c1swXSArIGR4O1xuICAgICAgICAgICAgICAgICAgY3B5ID0gY2FbaWR4XS5wb2ludHNbMV0gKyBkeTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYyA9ICdsJztcbiAgICAgICAgICAgIC8vIHN1YnNlcXVlbnQgcG9pbnRzIGFyZSB0cmVhdGVkIGFzIHJlbGF0aXZlIGxpbmVUb1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTSc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBjID0gJ0wnO1xuICAgICAgICAgICAgLy8gc3Vic2VxdWVudCBwb2ludHMgYXJlIHRyZWF0ZWQgYXMgYWJzb2x1dGUgbGluZVRvXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY3B4ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdMJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0wnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnVic6XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnTCc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHAuc2hpZnQoKSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCksIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHgsIGNweSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICAgICAgICBjcHggKyBwLnNoaWZ0KCksXG4gICAgICAgICAgICAgIGNweSArIHAuc2hpZnQoKSxcbiAgICAgICAgICAgICAgY3B4ICsgcC5zaGlmdCgpLFxuICAgICAgICAgICAgICBjcHkgKyBwLnNoaWZ0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ0MnKSB7XG4gICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1syXSk7XG4gICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1szXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgcC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0MnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnQycpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzJdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGN0bFB0eCwgY3RsUHR5LCBjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdDJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1EnOlxuICAgICAgICAgICAgcG9pbnRzLnB1c2gocC5zaGlmdCgpLCBwLnNoaWZ0KCkpO1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICBwb2ludHMucHVzaChjcHggKyBwLnNoaWZ0KCksIGNweSArIHAuc2hpZnQoKSk7XG4gICAgICAgICAgICBjcHggKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ICs9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGNtZCA9ICdRJztcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1QnOlxuICAgICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgICAgcHJldkNtZCA9IGNhW2NhLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDbWQuY29tbWFuZCA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAgIGN0bFB0eCA9IGNweCArIChjcHggLSBwcmV2Q21kLnBvaW50c1swXSk7XG4gICAgICAgICAgICAgIGN0bFB0eSA9IGNweSArIChjcHkgLSBwcmV2Q21kLnBvaW50c1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjcHggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjbWQgPSAnUSc7XG4gICAgICAgICAgICBwb2ludHMucHVzaChjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgICBwcmV2Q21kID0gY2FbY2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldkNtZC5jb21tYW5kID09PSAnUScpIHtcbiAgICAgICAgICAgICAgY3RsUHR4ID0gY3B4ICsgKGNweCAtIHByZXZDbWQucG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgY3RsUHR5ID0gY3B5ICsgKGNweSAtIHByZXZDbWQucG9pbnRzWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ1EnO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goY3RsUHR4LCBjdGxQdHksIGNweCwgY3B5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgcnggPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICByeSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIHBzaSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGZhID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgZnMgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICB4MSA9IGNweDtcbiAgICAgICAgICAgIHkxID0gY3B5O1xuICAgICAgICAgICAgY3B4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY3B5ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0EnO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oXG4gICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgY3B4LFxuICAgICAgICAgICAgICBjcHksXG4gICAgICAgICAgICAgIGZhLFxuICAgICAgICAgICAgICBmcyxcbiAgICAgICAgICAgICAgcngsXG4gICAgICAgICAgICAgIHJ5LFxuICAgICAgICAgICAgICBwc2lcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgIHJ4ID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgcnkgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBwc2kgPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBmYSA9IHAuc2hpZnQoKTtcbiAgICAgICAgICAgIGZzID0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgeDEgPSBjcHg7XG4gICAgICAgICAgICB5MSA9IGNweTtcbiAgICAgICAgICAgIGNweCArPSBwLnNoaWZ0KCk7XG4gICAgICAgICAgICBjcHkgKz0gcC5zaGlmdCgpO1xuICAgICAgICAgICAgY21kID0gJ0EnO1xuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jb252ZXJ0RW5kcG9pbnRUb0NlbnRlclBhcmFtZXRlcml6YXRpb24oXG4gICAgICAgICAgICAgIHgxLFxuICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgY3B4LFxuICAgICAgICAgICAgICBjcHksXG4gICAgICAgICAgICAgIGZhLFxuICAgICAgICAgICAgICBmcyxcbiAgICAgICAgICAgICAgcngsXG4gICAgICAgICAgICAgIHJ5LFxuICAgICAgICAgICAgICBwc2lcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6IGNtZCB8fCBjLFxuICAgICAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICB4OiBzdGFydFgsXG4gICAgICAgICAgICB5OiBzdGFydFlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhdGhMZW5ndGg6IHRoaXMuY2FsY0xlbmd0aChzdGFydFgsIHN0YXJ0WSwgY21kIHx8IGMsIHBvaW50cylcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjID09PSAneicgfHwgYyA9PT0gJ1onKSB7XG4gICAgICAgIGNhLnB1c2goe1xuICAgICAgICAgIGNvbW1hbmQ6ICd6JyxcbiAgICAgICAgICBwb2ludHM6IFtdLFxuICAgICAgICAgIHN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcGF0aExlbmd0aDogMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2E7XG4gIH07XG4gIEtvbnZhLlBhdGguY2FsY0xlbmd0aCA9IGZ1bmN0aW9uKHgsIHksIGNtZCwgcG9pbnRzKSB7XG4gICAgdmFyIGxlbiwgcDEsIHAyLCB0O1xuICAgIHZhciBwYXRoID0gS29udmEuUGF0aDtcblxuICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICBjYXNlICdMJzpcbiAgICAgICAgcmV0dXJuIHBhdGguZ2V0TGluZUxlbmd0aCh4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPbkN1YmljQmV6aWVyKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgeCxcbiAgICAgICAgICB5LFxuICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICBwb2ludHNbNF0sXG4gICAgICAgICAgcG9pbnRzWzVdXG4gICAgICAgICk7XG4gICAgICAgIGZvciAodCA9IDAuMDE7IHQgPD0gMTsgdCArPSAwLjAxKSB7XG4gICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgIHBvaW50c1szXSxcbiAgICAgICAgICAgIHBvaW50c1s0XSxcbiAgICAgICAgICAgIHBvaW50c1s1XVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gMTAwIGxpbmUgc2VnbWVudHNcbiAgICAgICAgbGVuID0gMC4wO1xuICAgICAgICBwMSA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAwLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM11cbiAgICAgICAgKTtcbiAgICAgICAgZm9yICh0ID0gMC4wMTsgdCA8PSAxOyB0ICs9IDAuMDEpIHtcbiAgICAgICAgICBwMiA9IHBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIHBvaW50c1swXSxcbiAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgIHBvaW50c1szXVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsZW47XG4gICAgICBjYXNlICdBJzpcbiAgICAgICAgLy8gQXBwcm94aW1hdGVzIGJ5IGJyZWFraW5nIGN1cnZlIGludG8gbGluZSBzZWdtZW50c1xuICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgIHZhciBzdGFydCA9IHBvaW50c1s0XTtcbiAgICAgICAgLy8gNCA9IHRoZXRhXG4gICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07XG4gICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgdmFyIGVuZCA9IHBvaW50c1s0XSArIGRUaGV0YTtcbiAgICAgICAgdmFyIGluYyA9IE1hdGguUEkgLyAxODAuMDtcbiAgICAgICAgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuICAgICAgICBpZiAoTWF0aC5hYnMoc3RhcnQgLSBlbmQpIDwgaW5jKSB7XG4gICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGZvciBwdXJwb3NlIG9mIGNhbGN1bGF0aW5nIGFyYyBsZW5ndGgsIG5vdCBnb2luZyB0byB3b3JyeSBhYm91dCByb3RhdGluZyBYLWF4aXMgYnkgYW5nbGUgcHNpXG4gICAgICAgIHAxID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgICBpZiAoZFRoZXRhIDwgMCkge1xuICAgICAgICAgIC8vIGNsb2Nrd2lzZVxuICAgICAgICAgIGZvciAodCA9IHN0YXJ0IC0gaW5jOyB0ID4gZW5kOyB0IC09IGluYykge1xuICAgICAgICAgICAgcDIgPSBwYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgICAgIHBvaW50c1sxXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzJdLFxuICAgICAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBsZW4gKz0gcGF0aC5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgcDEgPSBwMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY291bnRlci1jbG9ja3dpc2VcbiAgICAgICAgICBmb3IgKHQgPSBzdGFydCArIGluYzsgdCA8IGVuZDsgdCArPSBpbmMpIHtcbiAgICAgICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICAgICAgcG9pbnRzWzBdLFxuICAgICAgICAgICAgICBwb2ludHNbMV0sXG4gICAgICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICAgICAgcG9pbnRzWzNdLFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAwXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICAgIHAxID0gcDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAyID0gcGF0aC5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhcbiAgICAgICAgICBwb2ludHNbMF0sXG4gICAgICAgICAgcG9pbnRzWzFdLFxuICAgICAgICAgIHBvaW50c1syXSxcbiAgICAgICAgICBwb2ludHNbM10sXG4gICAgICAgICAgZW5kLFxuICAgICAgICAgIDBcbiAgICAgICAgKTtcbiAgICAgICAgbGVuICs9IHBhdGguZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcblxuICAgICAgICByZXR1cm4gbGVuO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9O1xuICBLb252YS5QYXRoLmNvbnZlcnRFbmRwb2ludFRvQ2VudGVyUGFyYW1ldGVyaXphdGlvbiA9IGZ1bmN0aW9uKFxuICAgIHgxLFxuICAgIHkxLFxuICAgIHgyLFxuICAgIHkyLFxuICAgIGZhLFxuICAgIGZzLFxuICAgIHJ4LFxuICAgIHJ5LFxuICAgIHBzaURlZ1xuICApIHtcbiAgICAvLyBEZXJpdmVkIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9pbXBsbm90ZS5odG1sI0FyY0ltcGxlbWVudGF0aW9uTm90ZXNcbiAgICB2YXIgcHNpID0gcHNpRGVnICogKE1hdGguUEkgLyAxODAuMCk7XG4gICAgdmFyIHhwID0gTWF0aC5jb3MocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gICAgdmFyIHlwID1cbiAgICAgIC0xICogTWF0aC5zaW4ocHNpKSAqICh4MSAtIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG5cbiAgICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgICBpZiAobGFtYmRhID4gMSkge1xuICAgICAgcnggKj0gTWF0aC5zcXJ0KGxhbWJkYSk7XG4gICAgICByeSAqPSBNYXRoLnNxcnQobGFtYmRhKTtcbiAgICB9XG5cbiAgICB2YXIgZiA9IE1hdGguc3FydChcbiAgICAgIChyeCAqIHJ4ICogKHJ5ICogcnkpIC0gcnggKiByeCAqICh5cCAqIHlwKSAtIHJ5ICogcnkgKiAoeHAgKiB4cCkpIC9cbiAgICAgICAgKHJ4ICogcnggKiAoeXAgKiB5cCkgKyByeSAqIHJ5ICogKHhwICogeHApKVxuICAgICk7XG5cbiAgICBpZiAoZmEgPT09IGZzKSB7XG4gICAgICBmICo9IC0xO1xuICAgIH1cbiAgICBpZiAoaXNOYU4oZikpIHtcbiAgICAgIGYgPSAwO1xuICAgIH1cblxuICAgIHZhciBjeHAgPSBmICogcnggKiB5cCAvIHJ5O1xuICAgIHZhciBjeXAgPSBmICogLXJ5ICogeHAgLyByeDtcblxuICAgIHZhciBjeCA9ICh4MSArIHgyKSAvIDIuMCArIE1hdGguY29zKHBzaSkgKiBjeHAgLSBNYXRoLnNpbihwc2kpICogY3lwO1xuICAgIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIE1hdGguc2luKHBzaSkgKiBjeHAgKyBNYXRoLmNvcyhwc2kpICogY3lwO1xuXG4gICAgdmFyIHZNYWcgPSBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xuICAgIH07XG4gICAgdmFyIHZSYXRpbyA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xuICAgIH07XG4gICAgdmFyIHZBbmdsZSA9IGZ1bmN0aW9uKHUsIHYpIHtcbiAgICAgIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbiAgICB9O1xuICAgIHZhciB0aGV0YSA9IHZBbmdsZShbMSwgMF0sIFsoeHAgLSBjeHApIC8gcngsICh5cCAtIGN5cCkgLyByeV0pO1xuICAgIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgICB2YXIgdiA9IFsoLTEgKiB4cCAtIGN4cCkgLyByeCwgKC0xICogeXAgLSBjeXApIC8gcnldO1xuICAgIHZhciBkVGhldGEgPSB2QW5nbGUodSwgdik7XG5cbiAgICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgICBkVGhldGEgPSBNYXRoLlBJO1xuICAgIH1cbiAgICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgIGRUaGV0YSA9IDA7XG4gICAgfVxuICAgIGlmIChmcyA9PT0gMCAmJiBkVGhldGEgPiAwKSB7XG4gICAgICBkVGhldGEgPSBkVGhldGEgLSAyICogTWF0aC5QSTtcbiAgICB9XG4gICAgaWYgKGZzID09PSAxICYmIGRUaGV0YSA8IDApIHtcbiAgICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBNYXRoLlBJO1xuICAgIH1cbiAgICByZXR1cm4gW2N4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzXTtcbiAgfTtcbiAgLy8gYWRkIGdldHRlcnMgc2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5QYXRoLCAnZGF0YScpO1xuXG4gIC8qKlxuICAgKiBzZXQgU1ZHIHBhdGggZGF0YSBzdHJpbmcuICBUaGlzIG1ldGhvZFxuICAgKiAgYWxzbyBhdXRvbWF0aWNhbGx5IHBhcnNlcyB0aGUgZGF0YSBzdHJpbmdcbiAgICogIGludG8gYSBkYXRhIGFycmF5LiAgQ3VycmVudGx5IHN1cHBvcnRlZCBTVkcgZGF0YTpcbiAgICogIE0sIG0sIEwsIGwsIEgsIGgsIFYsIHYsIFEsIHEsIFQsIHQsIEMsIGMsIFMsIHMsIEEsIGEsIFosIHpcbiAgICogQG5hbWUgc2V0RGF0YVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5QYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gU1ZHIHBhdGggY29tbWFuZCBzdHJpbmdcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBTVkcgcGF0aCBkYXRhIHN0cmluZ1xuICAgKiBAbmFtZSBnZXREYXRhXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlBhdGgucHJvdG90eXBlXG4gICAqL1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5QYXRoKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICB2YXIgRU1QVFlfU1RSSU5HID0gJycsXG4gICAgLy9DQUxJQlJJID0gJ0NhbGlicmknLFxuICAgIE5PUk1BTCA9ICdub3JtYWwnO1xuXG4gIC8qKlxuICAgKiBQYXRoIGNvbnN0cnVjdG9yLlxuICAgKiBAYXV0aG9yIEphc29uIEZvbGxhc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRGYW1pbHldIGRlZmF1bHQgaXMgQ2FsaWJyaVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5mb250U2l6ZV0gZGVmYXVsdCBpcyAxMlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5mb250U3R5bGVdIGNhbiBiZSBub3JtYWwsIGJvbGQsIG9yIGl0YWxpYy4gIERlZmF1bHQgaXMgbm9ybWFsXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZvbnRWYXJpYW50XSBjYW4gYmUgbm9ybWFsIG9yIHNtYWxsLWNhcHMuICBEZWZhdWx0IGlzIG5vcm1hbFxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29uZmlnLnRleHRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy5kYXRhIFNWRyBkYXRhIHN0cmluZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcuZ2V0S2VybmluZyBhIGdldHRlciBmb3Iga2VybmluZyB2YWx1ZXMgZm9yIHRoZSBzcGVjaWZpZWQgY2hhcmFjdGVyc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIGtlcm5pbmdQYWlycyA9IHtcbiAgICogICAnQSc6IHtcbiAgICogICAgICcgJzogLTAuMDU1MTc1NzgxMjUsXG4gICAqICAgICAnVCc6IC0wLjA3NDIxODc1LFxuICAgKiAgICAgJ1YnOiAtMC4wNzQyMTg3NSxcbiAgICogICB9LFxuICAgKiAgICdWJzoge1xuICAgKiAgICAgJywnOiAtMC4wOTE3OTY4NzUsXG4gICAqICAgICBcIjpcIjogLTAuMDM3MTA5Mzc1LFxuICAgKiAgICAgXCI7XCI6IC0wLjAzNzEwOTM3NSxcbiAgICogICAgIFwiQVwiOiAtMC4wNzQyMTg3NSxcbiAgICogICB9XG4gICAqIH1cbiAgICogdmFyIHRleHRwYXRoID0gbmV3IEtvbnZhLlRleHRQYXRoKHtcbiAgICogICB4OiAxMDAsXG4gICAqICAgeTogNTAsXG4gICAqICAgZmlsbDogJyMzMzMnLFxuICAgKiAgIGZvbnRTaXplOiAnMjQnLFxuICAgKiAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAqICAgdGV4dDogJ0FsbCB0aGUgd29ybGRcXCdzIGEgc3RhZ2UsIGFuZCBhbGwgdGhlIG1lbiBhbmQgd29tZW4gbWVyZWx5IHBsYXllcnMuJyxcbiAgICogICBkYXRhOiAnTTEwLDEwIEMwLDAgMTAsMTUwIDEwMCwxMDAgUzMwMCwxNTAgNDAwLDUwJyxcbiAgICogICBnZXRLZXJuaW5nOiBmdW5jdGlvbihsZWZ0Q2hhciwgcmlnaHRDaGFyKSB7XG4gICAqICAgICByZXR1cm4ga2VybmluZ1BhaXJzLmhhc093blByb3BlcnR5KGxlZnRDaGFyKSA/IHBhaXJzW2xlZnRDaGFyXVtyaWdodENoYXJdIHx8IDAgOiAwXG4gICAqICAgfVxuICAgKiB9KTtcbiAgICovXG4gIEtvbnZhLlRleHRQYXRoID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gX2ZpbGxGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmZpbGxUZXh0KHRoaXMucGFydGlhbFRleHQsIDAsIDApO1xuICB9XG4gIGZ1bmN0aW9uIF9zdHJva2VGdW5jKGNvbnRleHQpIHtcbiAgICBjb250ZXh0LnN0cm9rZVRleHQodGhpcy5wYXJ0aWFsVGV4dCwgMCwgMCk7XG4gIH1cblxuICBLb252YS5UZXh0UGF0aC5wcm90b3R5cGUgPSB7XG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmR1bW15Q2FudmFzID0gS29udmEuVXRpbC5jcmVhdGVDYW52YXNFbGVtZW50KCk7XG4gICAgICB0aGlzLmRhdGFBcnJheSA9IFtdO1xuICAgICAgdGhpcy5nZXRLZXJuaW5nID0gY29uZmlnICYmIGNvbmZpZy5nZXRLZXJuaW5nO1xuXG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIC8vIG92ZXJyaWRlc1xuICAgICAgLy8gVE9ETzogc2hvdWxkbid0IHRoaXMgYmUgb24gdGhlIHByb3RvdHlwZT9cbiAgICAgIHRoaXMuX2ZpbGxGdW5jID0gX2ZpbGxGdW5jO1xuICAgICAgdGhpcy5fc3Ryb2tlRnVuYyA9IF9zdHJva2VGdW5jO1xuICAgICAgdGhpcy5fZmlsbEZ1bmNIaXQgPSBfZmlsbEZ1bmM7XG4gICAgICB0aGlzLl9zdHJva2VGdW5jSGl0ID0gX3N0cm9rZUZ1bmM7XG5cbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RleHRQYXRoJztcblxuICAgICAgdGhpcy5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgIHRoaXMub24oJ2RhdGFDaGFuZ2Uua29udmEnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5kYXRhQXJyYXkgPSBLb252YS5QYXRoLnBhcnNlUGF0aERhdGEodGhpcy5hdHRycy5kYXRhKTtcbiAgICAgICAgdGhhdC5fc2V0VGV4dERhdGEoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyB1cGRhdGUgdGV4dCBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgdGhpcy5vbihcbiAgICAgICAgJ3RleHRDaGFuZ2Uua29udmEgYWxpZ25DaGFuZ2Uua29udmEgbGV0dGVyU3BhY2luZ0NoYW5nZS5rb252YScsXG4gICAgICAgIHRoYXQuX3NldFRleHREYXRhXG4gICAgICApO1xuICAgICAgdGhhdC5fc2V0VGV4dERhdGEoKTtcbiAgICAgIHRoaXMuc2NlbmVGdW5jKHRoaXMuX3NjZW5lRnVuYyk7XG4gICAgICB0aGlzLmhpdEZ1bmModGhpcy5faGl0RnVuYyk7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ2ZvbnQnLCB0aGlzLl9nZXRDb250ZXh0Rm9udCgpKTtcbiAgICAgIGNvbnRleHQuc2V0QXR0cigndGV4dEJhc2VsaW5lJywgdGhpcy5nZXRUZXh0QmFzZWxpbmUoKSk7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ3RleHRBbGlnbicsICdsZWZ0Jyk7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgdmFyIHRleHREZWNvcmF0aW9uID0gdGhpcy50ZXh0RGVjb3JhdGlvbigpO1xuICAgICAgdmFyIGZpbGwgPSB0aGlzLmZpbGwoKTtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZm9udFNpemUoKTtcblxuICAgICAgdmFyIGdseXBoSW5mbyA9IHRoaXMuZ2x5cGhJbmZvO1xuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaEluZm8ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgdmFyIHAwID0gZ2x5cGhJbmZvW2ldLnAwO1xuXG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKHAwLngsIHAwLnkpO1xuICAgICAgICBjb250ZXh0LnJvdGF0ZShnbHlwaEluZm9baV0ucm90YXRpb24pO1xuICAgICAgICB0aGlzLnBhcnRpYWxUZXh0ID0gZ2x5cGhJbmZvW2ldLnRleHQ7XG5cbiAgICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oMCwgZm9udFNpemUgLyAyICsgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5saW5lVG8oZm9udFNpemUsIGZvbnRTaXplIC8gMiArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgIC8vLy8gVG8gYXNzaXN0IHdpdGggZGVidWdnaW5nIHZpc3VhbGx5LCB1bmNvbW1lbnQgZm9sbG93aW5nXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGlmIChpICUgMilcbiAgICAgICAgLy8gY29udGV4dC5zdHJva2VTdHlsZSA9ICdjeWFuJztcbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ2dyZWVuJztcbiAgICAgICAgLy8gdmFyIHAxID0gZ2x5cGhJbmZvW2ldLnAxO1xuICAgICAgICAvLyBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgICAgLy8gY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAgIC8vIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBpZiAodGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBmaWxsO1xuICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGZvbnRTaXplIC8gMjA7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgX2hpdEZ1bmM6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICAgIHZhciBnbHlwaEluZm8gPSB0aGlzLmdseXBoSW5mbztcbiAgICAgIGlmIChnbHlwaEluZm8ubGVuZ3RoID49IDEpIHtcbiAgICAgICAgdmFyIHAwID0gZ2x5cGhJbmZvWzBdLnAwO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IGdseXBoSW5mb1tpXS5wMTtcbiAgICAgICAgY29udGV4dC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ2xpbmVXaWR0aCcsIHRoaXMuZ2V0Rm9udFNpemUoKSk7XG4gICAgICBjb250ZXh0LnNldEF0dHIoJ3N0cm9rZVN0eWxlJywgdGhpcy5jb2xvcktleSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHRleHQgd2lkdGggaW4gcGl4ZWxzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dFdpZHRoO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZ2V0IHRleHQgaGVpZ2h0IGluIHBpeGVsc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0SGVpZ2h0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2V0IHRleHRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gICAgICovXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgS29udmEuVGV4dC5wcm90b3R5cGUuc2V0VGV4dC5jYWxsKHRoaXMsIHRleHQpO1xuICAgIH0sXG4gICAgX2dldFRleHRTaXplOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICB2YXIgZHVtbXlDYW52YXMgPSB0aGlzLmR1bW15Q2FudmFzO1xuICAgICAgdmFyIF9jb250ZXh0ID0gZHVtbXlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgX2NvbnRleHQuc2F2ZSgpO1xuXG4gICAgICBfY29udGV4dC5mb250ID0gdGhpcy5fZ2V0Q29udGV4dEZvbnQoKTtcbiAgICAgIHZhciBtZXRyaWNzID0gX2NvbnRleHQubWVhc3VyZVRleHQodGV4dCk7XG5cbiAgICAgIF9jb250ZXh0LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG1ldHJpY3Mud2lkdGgsXG4gICAgICAgIGhlaWdodDogcGFyc2VJbnQodGhpcy5hdHRycy5mb250U2l6ZSwgMTApXG4gICAgICB9O1xuICAgIH0sXG4gICAgX3NldFRleHREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciBzaXplID0gdGhpcy5fZ2V0VGV4dFNpemUodGhpcy5hdHRycy50ZXh0KTtcbiAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gdGhpcy5nZXRMZXR0ZXJTcGFjaW5nKCk7XG4gICAgICB2YXIgYWxpZ24gPSB0aGlzLmFsaWduKCk7XG5cbiAgICAgIHRoaXMudGV4dFdpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgIHRoaXMudGV4dEhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXG4gICAgICB2YXIgdGV4dEZ1bGxXaWR0aCA9IE1hdGgubWF4KFxuICAgICAgICB0aGlzLnRleHRXaWR0aCArICgodGhpcy5hdHRycy50ZXh0IHx8ICcnKS5sZW5ndGggLSAxKSAqIGxldHRlclNwYWNpbmcsXG4gICAgICAgIDBcbiAgICAgICk7XG5cbiAgICAgIHRoaXMuZ2x5cGhJbmZvID0gW107XG5cbiAgICAgIHZhciBmdWxsUGF0aFdpZHRoID0gMDtcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgdGhhdC5kYXRhQXJyYXkubGVuZ3RoOyBsKyspIHtcbiAgICAgICAgaWYgKHRoYXQuZGF0YUFycmF5W2xdLnBhdGhMZW5ndGggPiAwKSB7XG4gICAgICAgICAgZnVsbFBhdGhXaWR0aCArPSB0aGF0LmRhdGFBcnJheVtsXS5wYXRoTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBmdWxsUGF0aFdpZHRoIC8gMiAtIHRleHRGdWxsV2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heCgwLCBmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFyQXJyID0gdGhpcy5nZXRUZXh0KCkuc3BsaXQoJycpO1xuICAgICAgdmFyIHNwYWNlc051bWJlciA9IHRoaXMuZ2V0VGV4dCgpLnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcblxuICAgICAgdmFyIHAwLCBwMSwgcGF0aENtZDtcblxuICAgICAgdmFyIHBJbmRleCA9IC0xO1xuICAgICAgdmFyIGN1cnJlbnRUID0gMDtcbiAgICAgIC8vIHZhciBzdW1MZW5ndGggPSAwO1xuICAgICAgLy8gZm9yKHZhciBqID0gMDsgaiA8IHRoYXQuZGF0YUFycmF5Lmxlbmd0aDsgaisrKSB7XG4gICAgICAvLyAgIGlmKHRoYXQuZGF0YUFycmF5W2pdLnBhdGhMZW5ndGggPiAwKSB7XG4gICAgICAvL1xuICAgICAgLy8gICAgIGlmIChzdW1MZW5ndGggKyB0aGF0LmRhdGFBcnJheVtqXS5wYXRoTGVuZ3RoID4gb2Zmc2V0KSB7fVxuICAgICAgLy8gICAgICAgZnVsbFBhdGhXaWR0aCArPSB0aGF0LmRhdGFBcnJheVtqXS5wYXRoTGVuZ3RoO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBnZXROZXh0UGF0aFNlZ21lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY3VycmVudFQgPSAwO1xuICAgICAgICB2YXIgcGF0aERhdGEgPSB0aGF0LmRhdGFBcnJheTtcblxuICAgICAgICBmb3IgKHZhciBqID0gcEluZGV4ICsgMTsgaiA8IHBhdGhEYXRhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHBhdGhEYXRhW2pdLnBhdGhMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwSW5kZXggPSBqO1xuXG4gICAgICAgICAgICByZXR1cm4gcGF0aERhdGFbal07XG4gICAgICAgICAgfSBlbHNlIGlmIChwYXRoRGF0YVtqXS5jb21tYW5kID09PSAnTScpIHtcbiAgICAgICAgICAgIHAwID0ge1xuICAgICAgICAgICAgICB4OiBwYXRoRGF0YVtqXS5wb2ludHNbMF0sXG4gICAgICAgICAgICAgIHk6IHBhdGhEYXRhW2pdLnBvaW50c1sxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge307XG4gICAgICB9O1xuXG4gICAgICB2YXIgZmluZFNlZ21lbnRUb0ZpdENoYXJhY3RlciA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgdmFyIGdseXBoV2lkdGggPSB0aGF0Ll9nZXRUZXh0U2l6ZShjKS53aWR0aCArIGxldHRlclNwYWNpbmc7XG5cbiAgICAgICAgaWYgKGMgPT09ICcgJyAmJiBhbGlnbiA9PT0gJ2p1c3RpZnknKSB7XG4gICAgICAgICAgZ2x5cGhXaWR0aCArPSAoZnVsbFBhdGhXaWR0aCAtIHRleHRGdWxsV2lkdGgpIC8gc3BhY2VzTnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJMZW4gPSAwO1xuICAgICAgICB2YXIgYXR0ZW1wdHMgPSAwO1xuXG4gICAgICAgIHAxID0gdW5kZWZpbmVkO1xuICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgTWF0aC5hYnMoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gZ2x5cGhXaWR0aCA+IDAuMDEgJiZcbiAgICAgICAgICBhdHRlbXB0cyA8IDI1XG4gICAgICAgICkge1xuICAgICAgICAgIGF0dGVtcHRzKys7XG4gICAgICAgICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gY3VyckxlbjtcbiAgICAgICAgICB3aGlsZSAocGF0aENtZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXRoQ21kID0gZ2V0TmV4dFBhdGhTZWdtZW50KCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgcGF0aENtZCAmJlxuICAgICAgICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArIHBhdGhDbWQucGF0aExlbmd0aCA8IGdseXBoV2lkdGhcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjdW11bGF0aXZlUGF0aExlbmd0aCArPSBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhdGhDbWQgPT09IHt9IHx8IHAwID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5lZWROZXdTZWdtZW50ID0gZmFsc2U7XG5cbiAgICAgICAgICBzd2l0Y2ggKHBhdGhDbWQuY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBLb252YS5QYXRoLmdldExpbmVMZW5ndGgoXG4gICAgICAgICAgICAgICAgICBwMC54LFxuICAgICAgICAgICAgICAgICAgcDAueSxcbiAgICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgICAgcGF0aENtZC5wb2ludHNbMV1cbiAgICAgICAgICAgICAgICApID4gZ2x5cGhXaWR0aFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAgICAgICAgICAgICBnbHlwaFdpZHRoLFxuICAgICAgICAgICAgICAgICAgcDAueCxcbiAgICAgICAgICAgICAgICAgIHAwLnksXG4gICAgICAgICAgICAgICAgICBwYXRoQ21kLnBvaW50c1swXSxcbiAgICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgICAgcDAueCxcbiAgICAgICAgICAgICAgICAgIHAwLnlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gcGF0aENtZC5wb2ludHNbNF07XG4gICAgICAgICAgICAgIC8vIDQgPSB0aGV0YVxuICAgICAgICAgICAgICB2YXIgZFRoZXRhID0gcGF0aENtZC5wb2ludHNbNV07XG4gICAgICAgICAgICAgIC8vIDUgPSBkVGhldGFcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IHBhdGhDbWQucG9pbnRzWzRdICsgZFRoZXRhO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gc3RhcnQgKyAwLjAwMDAwMDAxO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdseXBoV2lkdGggPiBjdXJyTGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCBpbiBjYXNlIHN0YXJ0IGlzIDBcbiAgICAgICAgICAgICAgICBjdXJyZW50VCArPSBNYXRoLlBJIC8gMTgwLjAgKiBkVGhldGEgLyBNYXRoLmFicyhkVGhldGEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IE1hdGguUEkgLyAzNjAuMCAqIGRUaGV0YSAvIE1hdGguYWJzKGRUaGV0YSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBDcmVkaXQgZm9yIGJ1ZyBmaXg6IEB0aGVydGggaHR0cHM6Ly9naXRodWIuY29tL2VyaWNkcm93ZWxsL0tvbnZhSlMvaXNzdWVzLzI0OVxuICAgICAgICAgICAgICAvLyBPbGQgY29kZSBmYWlsZWQgdG8gcmVuZGVyIHRleHQgYWxvbmcgYXJjIG9mIHRoaXMgcGF0aDogXCJNIDUwIDUwIGEgMTUwIDUwIDAgMCAxIDI1MCA1MCBsIDUwIDBcIlxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGRUaGV0YSA8IDAgJiYgY3VycmVudFQgPCBlbmQpIHx8XG4gICAgICAgICAgICAgICAgKGRUaGV0YSA+PSAwICYmIGN1cnJlbnRUID4gZW5kKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IGVuZDtcbiAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzJdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzNdLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRULFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzZdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaFdpZHRoID4gcGF0aENtZC5wYXRoTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2x5cGhXaWR0aCA+IGN1cnJMZW4pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCArPSAoZ2x5cGhXaWR0aCAtIGN1cnJMZW4pIC8gcGF0aENtZC5wYXRoTGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUIC09IChjdXJyTGVuIC0gZ2x5cGhXaWR0aCkgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoY3VycmVudFQgPiAxLjApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VCA9IDEuMDtcbiAgICAgICAgICAgICAgICBuZWVkTmV3U2VnbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcDEgPSBLb252YS5QYXRoLmdldFBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnN0YXJ0LngsXG4gICAgICAgICAgICAgICAgcGF0aENtZC5zdGFydC55LFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzJdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzNdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzRdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzVdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gZ2x5cGhXaWR0aCAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChnbHlwaFdpZHRoID4gY3Vyckxlbikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUICs9IChnbHlwaFdpZHRoIC0gY3VyckxlbikgLyBwYXRoQ21kLnBhdGhMZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFQgLT0gKGN1cnJMZW4gLSBnbHlwaFdpZHRoKSAvIHBhdGhDbWQucGF0aExlbmd0aDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEuMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUID0gMS4wO1xuICAgICAgICAgICAgICAgIG5lZWROZXdTZWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwMSA9IEtvbnZhLlBhdGguZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihcbiAgICAgICAgICAgICAgICBjdXJyZW50VCxcbiAgICAgICAgICAgICAgICBwYXRoQ21kLnN0YXJ0LngsXG4gICAgICAgICAgICAgICAgcGF0aENtZC5zdGFydC55LFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzBdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzFdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzJdLFxuICAgICAgICAgICAgICAgIHBhdGhDbWQucG9pbnRzWzNdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyTGVuID0gS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWVkTmV3U2VnbWVudCkge1xuICAgICAgICAgICAgbmVlZE5ld1NlZ21lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGhDbWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBmYWtlIHNlYXJjaCBmb3Igb2Zmc2V0LCB0aGlzIGlzIHZlcnkgYmFkIGFwcHJvYWNoXG4gICAgICAvLyBUT0RPOiBmaW5kIG90aGVyIHdheSB0byBhZGQgb2Zmc2V0IGZyb20gc3RhcnQgKGZvciBhbGlnbilcbiAgICAgIHZhciB0ZXN0Q2hhciA9ICdDJztcbiAgICAgIHZhciBnbHlwaFdpZHRoID0gdGhhdC5fZ2V0VGV4dFNpemUodGVzdENoYXIpLndpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb2Zmc2V0IC8gZ2x5cGhXaWR0aDsgaysrKSB7XG4gICAgICAgIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIodGVzdENoYXIpO1xuICAgICAgICBpZiAocDAgPT09IHVuZGVmaW5lZCB8fCBwMSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcDAgPSBwMTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIEZpbmQgcDEgc3VjaCB0aGF0IGxpbmUgc2VnbWVudCBiZXR3ZWVuIHAwIGFuZCBwMSBpcyBhcHByb3guIHdpZHRoIG9mIGdseXBoXG4gICAgICAgIGZpbmRTZWdtZW50VG9GaXRDaGFyYWN0ZXIoY2hhckFycltpXSk7XG5cbiAgICAgICAgaWYgKHAwID09PSB1bmRlZmluZWQgfHwgcDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHdpZHRoID0gS29udmEuUGF0aC5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuXG4gICAgICAgIHZhciBrZXJuID0gMDtcbiAgICAgICAgaWYgKHRoaXMuZ2V0S2VybmluZykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBnZXRLZXJuaW5nIGlzIGEgdXNlciBwcm92aWRlZCBnZXR0ZXIuIE1ha2Ugc3VyZSBpdCBuZXZlciBicmVha3Mgb3VyIGxvZ2ljXG4gICAgICAgICAgICBrZXJuID1cbiAgICAgICAgICAgICAgdGhpcy5nZXRLZXJuaW5nKGNoYXJBcnJbaSAtIDFdLCBjaGFyQXJyW2ldKSAqIHRoaXMuZm9udFNpemUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBrZXJuID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwMC54ICs9IGtlcm47XG4gICAgICAgIHAxLnggKz0ga2VybjtcbiAgICAgICAgdGhpcy50ZXh0V2lkdGggKz0ga2VybjtcblxuICAgICAgICB2YXIgbWlkcG9pbnQgPSBLb252YS5QYXRoLmdldFBvaW50T25MaW5lKFxuICAgICAgICAgIGtlcm4gKyB3aWR0aCAvIDIuMCxcbiAgICAgICAgICBwMC54LFxuICAgICAgICAgIHAwLnksXG4gICAgICAgICAgcDEueCxcbiAgICAgICAgICBwMS55XG4gICAgICAgICk7XG5cbiAgICAgICAgdmFyIHJvdGF0aW9uID0gTWF0aC5hdGFuMihwMS55IC0gcDAueSwgcDEueCAtIHAwLngpO1xuICAgICAgICB0aGlzLmdseXBoSW5mby5wdXNoKHtcbiAgICAgICAgICB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAgIHRyYW5zcG9zZVk6IG1pZHBvaW50LnksXG4gICAgICAgICAgdGV4dDogY2hhckFycltpXSxcbiAgICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgICAgcDA6IHAwLFxuICAgICAgICAgIHAxOiBwMVxuICAgICAgICB9KTtcbiAgICAgICAgcDAgPSBwMTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFNlbGZSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgdGhpcy5nbHlwaEluZm8uZm9yRWFjaChmdW5jdGlvbihpbmZvKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueCk7XG4gICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDAueSk7XG4gICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDEueCk7XG4gICAgICAgIHBvaW50cy5wdXNoKGluZm8ucDEueSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBtaW5YID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIG1heFggPSBwb2ludHNbMF07XG4gICAgICB2YXIgbWluWSA9IHBvaW50c1swXTtcbiAgICAgIHZhciBtYXhZID0gcG9pbnRzWzBdO1xuICAgICAgdmFyIHgsIHk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgeCA9IHBvaW50c1tpICogMl07XG4gICAgICAgIHkgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIHgpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCk7XG4gICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5KTtcbiAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkpO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRTaXplID0gdGhpcy5mb250U2l6ZSgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZChtaW5YKSAtIGZvbnRTaXplIC8gMixcbiAgICAgICAgeTogTWF0aC5yb3VuZChtaW5ZKSAtIGZvbnRTaXplIC8gMixcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQobWF4WCAtIG1pblgpICsgZm9udFNpemUsXG4gICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChtYXhZIC0gbWluWSkgKyBmb250U2l6ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgLy8gbWFwIFRleHRQYXRoIG1ldGhvZHMgdG8gVGV4dFxuICBLb252YS5UZXh0UGF0aC5wcm90b3R5cGUuX2dldENvbnRleHRGb250ID1cbiAgICBLb252YS5UZXh0LnByb3RvdHlwZS5fZ2V0Q29udGV4dEZvbnQ7XG5cbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuVGV4dFBhdGgsIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgc2V0dGVycyBhbmQgZ2V0dGVyc1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRGYW1pbHknLCAnQXJpYWwnKTtcblxuICAvKipcbiAgICogc2V0IGZvbnQgZmFtaWx5XG4gICAqIEBuYW1lIHNldEZvbnRGYW1pbHlcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmb250RmFtaWx5XG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgZm9udCBmYW1pbHlcbiAgICogQG5hbWUgZ2V0Rm9udEZhbWlseVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250U2l6ZScsIDEyKTtcblxuICAvKipcbiAgICogc2V0IGZvbnQgc2l6ZVxuICAgKiBAbmFtZSBzZXRGb250U2l6ZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtpbnR9IGZvbnRTaXplXG4gICAqL1xuXG4gIC8qKlxuICAgKiBnZXQgZm9udCBzaXplXG4gICAqIEBuYW1lIGdldEZvbnRTaXplXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ2ZvbnRTdHlsZScsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAqIHNldCBmb250IHN0eWxlLiAgQ2FuIGJlICdub3JtYWwnLCAnaXRhbGljJywgb3IgJ2JvbGQnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAqIEBuYW1lIHNldEZvbnRTdHlsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGZvbnRTdHlsZVxuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdhbGlnbicsICdsZWZ0Jyk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgaG9yaXpvbnRhbCBhbGlnbiBvZiB0ZXh0LiAgQ2FuIGJlICdsZWZ0JywgJ2NlbnRlcicsICdyaWdodCcgb3IgJ2p1c3RpZnknXG4gICAqIEBuYW1lIGFsaWduXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHQucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhbGlnblxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXQgdGV4dCBhbGlnblxuICAgKiB2YXIgYWxpZ24gPSB0ZXh0LmFsaWduKCk7XG4gICAqXG4gICAqIC8vIGNlbnRlciB0ZXh0XG4gICAqIHRleHQuYWxpZ24oJ2NlbnRlcicpO1xuICAgKlxuICAgKiAvLyBhbGlnbiB0ZXh0IHRvIHJpZ2h0XG4gICAqIHRleHQuYWxpZ24oJ3JpZ2h0Jyk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRleHRQYXRoLCAnbGV0dGVyU3BhY2luZycsIDApO1xuXG4gIC8qKlxuICAgKiBzZXQgbGV0dGVyIHNwYWNpbmcgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICogQG5hbWUgbGV0dGVyU3BhY2luZ1xuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGxldHRlclNwYWNpbmdcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG5cbiAgLyoqXG4gICAqIHNldCB0ZXh0QmFzZWxpbmUgcHJvcGVydHkuIERlZmF1bHQgdmFsdWUgaXMgJ21pZGRsZScuXG4gICAqIENhbiBiZSAndG9wJywgJ2JvdHRvbScsICdtaWRkbGUnLCAnYWxwaGFiZXRpYycsICdoYW5naW5nJ1xuICAgKiBAbmFtZSB0ZXh0QmFzZWxpbmVcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVGV4dFBhdGgucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0ZXh0QmFzZWxpbmVcbiAgICovXG5cbiAgLyoqXG4gICAqIGdldCBmb250IHN0eWxlXG4gICAqIEBuYW1lIGdldEZvbnRTdHlsZVxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0UGF0aC5wcm90b3R5cGVcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGV4dFBhdGgsICdmb250VmFyaWFudCcsIE5PUk1BTCk7XG5cbiAgLyoqXG4gICAqIHNldCBmb250IHZhcmlhbnQuICBDYW4gYmUgJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnLiAgJ25vcm1hbCcgaXMgdGhlIGRlZmF1bHQuXG4gICAqIEBuYW1lIHNldEZvbnRWYXJpYW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZm9udFZhcmlhbnRcbiAgICovXG5cbiAgLyoqXG4gICAqIEBnZXQgZm9udCB2YXJpYW50XG4gICAqIEBuYW1lIGdldEZvbnRWYXJpYW50XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHQnLCBFTVBUWV9TVFJJTkcpO1xuXG4gIC8qKlxuICAgKiBnZXQgdGV4dFxuICAgKiBAbmFtZSBnZXRUZXh0XG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRleHRQYXRoLnByb3RvdHlwZVxuICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UZXh0UGF0aCwgJ3RleHREZWNvcmF0aW9uJywgbnVsbCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdGV4dCBkZWNvcmF0aW9uIG9mIGEgdGV4dC4gIENhbiBiZSAnJyBvciAndW5kZXJsaW5lJ1xuICAgKiBAbmFtZSB0ZXh0RGVjb3JhdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UZXh0LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dERlY29yYXRpb25cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IHRleHQgZGVjb3JhdGlvblxuICAgKiB2YXIgdGV4dERlY29yYXRpb24gPSB0ZXh0LnRleHREZWNvcmF0aW9uKCk7XG4gICAqXG4gICAqIC8vIGNlbnRlciB0ZXh0XG4gICAqIHRleHQudGV4dERlY29yYXRpb24oJ3VuZGVybGluZScpO1xuICAgKi9cblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVGV4dFBhdGgpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8qKlxuICAgICAqIFJlZ3VsYXJQb2x5Z29uIGNvbnN0cnVjdG9yLiZuYnNwOyBFeGFtcGxlcyBpbmNsdWRlIHRyaWFuZ2xlcywgc3F1YXJlcywgcGVudGFnb25zLCBoZXhhZ29ucywgZXRjLlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBhdWdtZW50cyBLb252YS5TaGFwZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNpZGVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5yYWRpdXNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsXSBmaWxsIGNvbG9yXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW2NvbmZpZy5maWxsUGF0dGVybkltYWdlXSBmaWxsIHBhdHRlcm4gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5ZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRZXSBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlXSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuUm90YXRpb25dXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFBhdHRlcm5SZXBlYXRdIGNhbiBiZSBcInJlcGVhdFwiLCBcInJlcGVhdC14XCIsIFwicmVwZWF0LXlcIiwgb3IgXCJuby1yZXBlYXRcIi4gIFRoZSBkZWZhdWx0IGlzIFwibm8tcmVwZWF0XCJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFldXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFldIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UmFkaXVzXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmZpbGxFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGZpbGwuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbFByaW9yaXR5XSBjYW4gYmUgY29sb3IsIGxpbmVhci1ncmFkaWVudCwgcmFkaWFsLWdyYWlkZW50LCBvciBwYXR0ZXJuLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgY29sb3IuICBUaGUgZmlsbFByaW9yaXR5IHByb3BlcnR5IG1ha2VzIGl0IHJlYWxseSBlYXN5IHRvIHRvZ2dsZSBiZXR3ZWVuIGRpZmZlcmVudCBmaWxsIHR5cGVzLiAgRm9yIGV4YW1wbGUsIGlmIHlvdSB3YW50IHRvIHRvZ2dsZSBiZXR3ZWVuIGEgZmlsbCBjb2xvciBzdHlsZSBhbmQgYSBmaWxsIHBhdHRlcm4gc3R5bGUsIHNpbXBseSBzZXQgdGhlIGZpbGwgcHJvcGVydHkgYW5kIHRoZSBmaWxsUGF0dGVybiBwcm9wZXJ0aWVzLCBhbmQgdGhlbiB1c2Ugc2V0RmlsbFByaW9yaXR5KCdjb2xvcicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCBhIGNvbG9yIGZpbGwsIG9yIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ3BhdHRlcm4nKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggdGhlIHBhdHRlcm4gZmlsbCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc3Ryb2tlXSBzdHJva2UgY29sb3JcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zdHJva2VXaWR0aF0gc3Ryb2tlIHdpZHRoXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUhpdEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2UgaGl0IHJlZ2lvbi4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcucGVyZmVjdERyYXdFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdXNpbmcgYnVmZmVyIGNhbnZhcy4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93Rm9yU3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHNoYXNvdyBmb3Igc3Ryb2tlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VTY2FsZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzdHJva2Ugc2NhbGUuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc3Ryb2tlLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVKb2luXSBjYW4gYmUgbWl0ZXIsIHJvdW5kLCBvciBiZXZlbC4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIG1pdGVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUNhcF0gY2FuIGJlIGJ1dHQsIHJvdW5kLCBvciBzcWFyZS4gIFRoZSBkZWZhdWx0XG4gICAgICogIGlzIGJ1dHRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zaGFkb3dDb2xvcl1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dCbHVyXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNoYWRvd09mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T3BhY2l0eV0gc2hhZG93IG9wYWNpdHkuICBDYW4gYmUgYW55IHJlYWwgbnVtYmVyXG4gICAgICogIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHNoYWRvdy4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmRhc2hdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRhc2hFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIGRhc2hBcnJheS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGhleGFnb24gPSBuZXcgS29udmEuUmVndWxhclBvbHlnb24oe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgc2lkZXM6IDYsXG4gICAgICogICByYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5SZWd1bGFyUG9seWdvbiA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19faW5pdChjb25maWcpO1xuICB9O1xuXG4gIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IHRydWUsXG4gICAgX19faW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAvLyBjYWxsIHN1cGVyIGNvbnN0cnVjdG9yXG4gICAgICBLb252YS5TaGFwZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdSZWd1bGFyUG9seWdvbic7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHNpZGVzID0gdGhpcy5hdHRycy5zaWRlcywgcmFkaXVzID0gdGhpcy5hdHRycy5yYWRpdXMsIG4sIHgsIHk7XG5cbiAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICBjb250ZXh0Lm1vdmVUbygwLCAwIC0gcmFkaXVzKTtcblxuICAgICAgZm9yIChuID0gMTsgbiA8IHNpZGVzOyBuKyspIHtcbiAgICAgICAgeCA9IHJhZGl1cyAqIE1hdGguc2luKG4gKiAyICogTWF0aC5QSSAvIHNpZGVzKTtcbiAgICAgICAgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIDIgKiBNYXRoLlBJIC8gc2lkZXMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLmdldEhlaWdodCgpXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJhZGl1cygpICogMjtcbiAgICB9LFxuICAgIC8vIGltcGxlbWVudHMgU2hhcGUucHJvdG90eXBlLnNldFdpZHRoKClcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIEtvbnZhLk5vZGUucHJvdG90eXBlLnNldFdpZHRoLmNhbGwodGhpcywgd2lkdGgpO1xuICAgICAgaWYgKHRoaXMucmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldFJhZGl1cyh3aWR0aCAvIDIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuc2V0SGVpZ2h0KClcbiAgICBzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgS29udmEuTm9kZS5wcm90b3R5cGUuc2V0SGVpZ2h0LmNhbGwodGhpcywgaGVpZ2h0KTtcbiAgICAgIGlmICh0aGlzLnJhZGl1cygpICE9PSBoZWlnaHQgLyAyKSB7XG4gICAgICAgIHRoaXMuc2V0UmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuUmVndWxhclBvbHlnb24sIEtvbnZhLlNoYXBlKTtcblxuICAvLyBhZGQgZ2V0dGVycyBzZXR0ZXJzXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAncmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IHJhZGl1c1xuICAgICAqIEBuYW1lIHNldFJhZGl1c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCByYWRpdXNcbiAgICAgKiBAbmFtZSBnZXRSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlJlZ3VsYXJQb2x5Z29uLCAnc2lkZXMnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgbnVtYmVyIG9mIHNpZGVzXG4gICAgICogQG5hbWUgc2V0U2lkZXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlJlZ3VsYXJQb2x5Z29uLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7aW50fSBzaWRlc1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBudW1iZXIgb2Ygc2lkZXNcbiAgICAgKiBAbmFtZSBnZXRTaWRlc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuUmVndWxhclBvbHlnb24ucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlJlZ3VsYXJQb2x5Z29uKTtcbn0pKCk7XG5cbihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICAgKiBTdGFyIGNvbnN0cnVjdG9yXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQG1lbWJlcm9mIEtvbnZhXG4gICAgICogQGF1Z21lbnRzIEtvbnZhLlNoYXBlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gY29uZmlnLm51bVBvaW50c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLm91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuZmlsbF0gZmlsbCBjb2xvclxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IFtjb25maWcuZmlsbFBhdHRlcm5JbWFnZV0gZmlsbCBwYXR0ZXJuIGltYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5YXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuT2Zmc2V0WV0gXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZV0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblNjYWxlWV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblJvdGF0aW9uXVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQYXR0ZXJuUmVwZWF0XSBjYW4gYmUgXCJyZXBlYXRcIiwgXCJyZXBlYXQteFwiLCBcInJlcGVhdC15XCIsIG9yIFwibm8tcmVwZWF0XCIuICBUaGUgZGVmYXVsdCBpcyBcIm5vLXJlcGVhdFwiXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsTGluZWFyR3JhZGllbnRFbmRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRZXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudFN0YXJ0UG9pbnRZXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WF0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUG9pbnRZXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFJhZGl1c11cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRDb2xvclN0b3BzXSBhcnJheSBvZiBjb2xvciBzdG9wc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5maWxsRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBmaWxsLiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxQcmlvcml0eV0gY2FuIGJlIGNvbG9yLCBsaW5lYXItZ3JhZGllbnQsIHJhZGlhbC1ncmFpZGVudCwgb3IgcGF0dGVybi4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGNvbG9yLiAgVGhlIGZpbGxQcmlvcml0eSBwcm9wZXJ0eSBtYWtlcyBpdCByZWFsbHkgZWFzeSB0byB0b2dnbGUgYmV0d2VlbiBkaWZmZXJlbnQgZmlsbCB0eXBlcy4gIEZvciBleGFtcGxlLCBpZiB5b3Ugd2FudCB0byB0b2dnbGUgYmV0d2VlbiBhIGZpbGwgY29sb3Igc3R5bGUgYW5kIGEgZmlsbCBwYXR0ZXJuIHN0eWxlLCBzaW1wbHkgc2V0IHRoZSBmaWxsIHByb3BlcnR5IGFuZCB0aGUgZmlsbFBhdHRlcm4gcHJvcGVydGllcywgYW5kIHRoZW4gdXNlIHNldEZpbGxQcmlvcml0eSgnY29sb3InKSB0byByZW5kZXIgdGhlIHNoYXBlIHdpdGggYSBjb2xvciBmaWxsLCBvciB1c2Ugc2V0RmlsbFByaW9yaXR5KCdwYXR0ZXJuJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIHRoZSBwYXR0ZXJuIGZpbGwgY29uZmlndXJhdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnN0cm9rZV0gc3Ryb2tlIGNvbG9yXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc3Ryb2tlV2lkdGhdIHN0cm9rZSB3aWR0aFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VIaXRFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIGhpdCByZWdpb24uICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnBlcmZlY3REcmF3RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHVzaW5nIGJ1ZmZlciBjYW52YXMuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0ZvclN0cm9rZUVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyBzaGFzb3cgZm9yIHN0cm9rZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlU2NhbGVFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc3Ryb2tlIHNjYWxlLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgdGhlIHN0cm9rZS4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lSm9pbl0gY2FuIGJlIG1pdGVyLCByb3VuZCwgb3IgYmV2ZWwuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBtaXRlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmxpbmVDYXBdIGNhbiBiZSBidXR0LCByb3VuZCwgb3Igc3FhcmUuICBUaGUgZGVmYXVsdFxuICAgICAqICBpcyBidXR0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuc2hhZG93Q29sb3JdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93Qmx1cl1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5zaGFkb3dPZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPZmZzZXRZXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09wYWNpdHldIHNoYWRvdyBvcGFjaXR5LiAgQ2FuIGJlIGFueSByZWFsIG51bWJlclxuICAgICAqICBiZXR3ZWVuIDAgYW5kIDFcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc2hhZG93RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzaGFkb3cuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2NvbmZpZy5kYXNoXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5kYXNoRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBkYXNoQXJyYXkuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcueF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy55XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLndpZHRoXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmhlaWdodF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcudmlzaWJsZV1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcubGlzdGVuaW5nXSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBsaXN0ZW5pbmcgZm9yIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmlkXSB1bmlxdWUgaWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5uYW1lXSBub24tdW5pcXVlIG5hbWVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vcGFjaXR5XSBkZXRlcm1pbmVzIG5vZGUgb3BhY2l0eS4gIENhbiBiZSBhbnkgbnVtYmVyIGJldHdlZW4gMCBhbmQgMVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLnNjYWxlXSBzZXQgc2NhbGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVhdIHNldCBzY2FsZSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2NhbGVZXSBzZXQgc2NhbGUgeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnJvdGF0aW9uXSByb3RhdGlvbiBpbiBkZWdyZWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcub2Zmc2V0XSBvZmZzZXQgZnJvbSBjZW50ZXIgcG9pbnQgYW5kIHJvdGF0aW9uIHBvaW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WF0gc2V0IG9mZnNldCB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcub2Zmc2V0WV0gc2V0IG9mZnNldCB5XG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLmRyYWdnYWJsZV0gbWFrZXMgdGhlIG5vZGUgZHJhZ2dhYmxlLiAgV2hlbiBzdGFnZXMgYXJlIGRyYWdnYWJsZSwgeW91IGNhbiBkcmFnIGFuZCBkcm9wXG4gICAgICogIHRoZSBlbnRpcmUgc3RhZ2UgYnkgZHJhZ2dpbmcgYW55IHBvcnRpb24gb2YgdGhlIHN0YWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZHJhZ0Rpc3RhbmNlXVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb25maWcuZHJhZ0JvdW5kRnVuY11cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBzdGFyID0gbmV3IEtvbnZhLlN0YXIoe1xuICAgICAqICAgeDogMTAwLFxuICAgICAqICAgeTogMjAwLFxuICAgICAqICAgbnVtUG9pbnRzOiA1LFxuICAgICAqICAgaW5uZXJSYWRpdXM6IDcwLFxuICAgICAqICAgb3V0ZXJSYWRpdXM6IDcwLFxuICAgICAqICAgZmlsbDogJ3JlZCcsXG4gICAgICogICBzdHJva2U6ICdibGFjaycsXG4gICAgICogICBzdHJva2VXaWR0aDogNFxuICAgICAqIH0pO1xuICAgICAqL1xuICBLb252YS5TdGFyID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuU3Rhci5wcm90b3R5cGUgPSB7XG4gICAgX2NlbnRyb2lkOiB0cnVlLFxuICAgIF9fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuU2hhcGUuY2FsbCh0aGlzLCBjb25maWcpO1xuICAgICAgdGhpcy5jbGFzc05hbWUgPSAnU3Rhcic7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIGlubmVyUmFkaXVzID0gdGhpcy5pbm5lclJhZGl1cygpLFxuICAgICAgICBvdXRlclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMoKSxcbiAgICAgICAgbnVtUG9pbnRzID0gdGhpcy5udW1Qb2ludHMoKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIDAgLSBvdXRlclJhZGl1cyk7XG5cbiAgICAgIGZvciAodmFyIG4gPSAxOyBuIDwgbnVtUG9pbnRzICogMjsgbisrKSB7XG4gICAgICAgIHZhciByYWRpdXMgPSBuICUgMiA9PT0gMCA/IG91dGVyUmFkaXVzIDogaW5uZXJSYWRpdXM7XG4gICAgICAgIHZhciB4ID0gcmFkaXVzICogTWF0aC5zaW4obiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICB2YXIgeSA9IC0xICogcmFkaXVzICogTWF0aC5jb3MobiAqIE1hdGguUEkgLyBudW1Qb2ludHMpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0V2lkdGgoKVxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE91dGVyUmFkaXVzKCkgKiAyO1xuICAgIH0sXG4gICAgLy8gaW1wbGVtZW50cyBTaGFwZS5wcm90b3R5cGUuZ2V0SGVpZ2h0KClcbiAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRXaWR0aCgpXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRXaWR0aC5jYWxsKHRoaXMsIHdpZHRoKTtcbiAgICAgIGlmICh0aGlzLm91dGVyUmFkaXVzKCkgIT09IHdpZHRoIC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKHdpZHRoIC8gMik7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBpbXBsZW1lbnRzIFNoYXBlLnByb3RvdHlwZS5zZXRIZWlnaHQoKVxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICBLb252YS5Ob2RlLnByb3RvdHlwZS5zZXRIZWlnaHQuY2FsbCh0aGlzLCBoZWlnaHQpO1xuICAgICAgaWYgKHRoaXMub3V0ZXJSYWRpdXMoKSAhPT0gaGVpZ2h0IC8gMikge1xuICAgICAgICB0aGlzLnNldE91dGVyUmFkaXVzKGhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgS29udmEuVXRpbC5leHRlbmQoS29udmEuU3RhciwgS29udmEuU2hhcGUpO1xuXG4gIC8vIGFkZCBnZXR0ZXJzIHNldHRlcnNcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ251bVBvaW50cycsIDUpO1xuXG4gIC8qKlxuICAgICAqIHNldCBudW1iZXIgb2YgcG9pbnRzXG4gICAgICogQG5hbWUgc2V0TnVtUG9pbnRzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7SW50ZWdlcn0gcG9pbnRzXG4gICAgICovXG5cbiAgLyoqXG4gICAgICogZ2V0IG51bWJlciBvZiBwb2ludHNcbiAgICAgKiBAbmFtZSBnZXROdW1Qb2ludHNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ2lubmVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGlubmVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldElubmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgaW5uZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0SW5uZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuU3RhciwgJ291dGVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IG91dGVyIHJhZGl1c1xuICAgICAqIEBuYW1lIHNldE91dGVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5TdGFyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgb3V0ZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0T3V0ZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlN0YXIucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlN0YXIpO1xufSkoKTtcblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG4gIC8vIGNvbnN0YW50c1xuICB2YXIgQVRUUl9DSEFOR0VfTElTVCA9IFtcbiAgICAnZm9udEZhbWlseScsXG4gICAgJ2ZvbnRTaXplJyxcbiAgICAnZm9udFN0eWxlJyxcbiAgICAncGFkZGluZycsXG4gICAgJ2xpbmVIZWlnaHQnLFxuICAgICd0ZXh0JyxcbiAgICAnd2lkdGgnXG4gIF0sXG4gICAgQ0hBTkdFX0tPTlZBID0gJ0NoYW5nZS5rb252YScsXG4gICAgTk9ORSA9ICdub25lJyxcbiAgICBVUCA9ICd1cCcsXG4gICAgUklHSFQgPSAncmlnaHQnLFxuICAgIERPV04gPSAnZG93bicsXG4gICAgTEVGVCA9ICdsZWZ0JyxcbiAgICBMQUJFTCA9ICdMYWJlbCcsXG4gICAgLy8gY2FjaGVkIHZhcmlhYmxlc1xuICAgIGF0dHJDaGFuZ2VMaXN0TGVuID0gQVRUUl9DSEFOR0VfTElTVC5sZW5ndGg7XG5cbiAgLyoqXG4gICAgICogTGFiZWwgY29uc3RydWN0b3IuJm5ic3A7IExhYmVscyBhcmUgZ3JvdXBzIHRoYXQgY29udGFpbiBhIFRleHQgYW5kIFRhZyBzaGFwZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgICAqIEBleGFtcGxlXG4gICAgICogLy8gY3JlYXRlIGxhYmVsXG4gICAgICogdmFyIGxhYmVsID0gbmV3IEtvbnZhLkxhYmVsKHtcbiAgICAgKiAgIHg6IDEwMCxcbiAgICAgKiAgIHk6IDEwMCxcbiAgICAgKiAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gYWRkIGEgdGFnIHRvIHRoZSBsYWJlbFxuICAgICAqIGxhYmVsLmFkZChuZXcgS29udmEuVGFnKHtcbiAgICAgKiAgIGZpbGw6ICcjYmJiJyxcbiAgICAgKiAgIHN0cm9rZTogJyMzMzMnLFxuICAgICAqICAgc2hhZG93Q29sb3I6ICdibGFjaycsXG4gICAgICogICBzaGFkb3dCbHVyOiAxMCxcbiAgICAgKiAgIHNoYWRvd09mZnNldDogWzEwLCAxMF0sXG4gICAgICogICBzaGFkb3dPcGFjaXR5OiAwLjIsXG4gICAgICogICBsaW5lSm9pbjogJ3JvdW5kJyxcbiAgICAgKiAgIHBvaW50ZXJEaXJlY3Rpb246ICd1cCcsXG4gICAgICogICBwb2ludGVyV2lkdGg6IDIwLFxuICAgICAqICAgcG9pbnRlckhlaWdodDogMjAsXG4gICAgICogICBjb3JuZXJSYWRpdXM6IDVcbiAgICAgKiB9KSk7XG4gICAgICpcbiAgICAgKiAvLyBhZGQgdGV4dCB0byB0aGUgbGFiZWxcbiAgICAgKiBsYWJlbC5hZGQobmV3IEtvbnZhLlRleHQoe1xuICAgICAqICAgdGV4dDogJ0hlbGxvIFdvcmxkIScsXG4gICAgICogICBmb250U2l6ZTogNTAsXG4gICAgICogICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICogICBwYWRkaW5nOiAxMCxcbiAgICAgKiAgIGZpbGw6ICdncmVlbidcbiAgICAgKiAgfSkpO1xuICAgICAqL1xuICBLb252YS5MYWJlbCA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5MYWJlbC5wcm90b3R5cGUgPSB7XG4gICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICBLb252YS5Hcm91cC5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9IExBQkVMO1xuXG4gICAgICB0aGlzLm9uKCdhZGQua29udmEnLCBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdGhhdC5fYWRkTGlzdGVuZXJzKGV2dC5jaGlsZCk7XG4gICAgICAgIHRoYXQuX3N5bmMoKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgICAqIGdldCBUZXh0IHNoYXBlIGZvciB0aGUgbGFiZWwuICBZb3UgbmVlZCB0byBhY2Nlc3MgdGhlIFRleHQgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSB0ZXh0IHByb3BlcnRpZXNcbiAgICAgICAgICogQG5hbWUgZ2V0VGV4dFxuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5kKCdUZXh0JylbMF07XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAgICogZ2V0IFRhZyBzaGFwZSBmb3IgdGhlIGxhYmVsLiAgWW91IG5lZWQgdG8gYWNjZXNzIHRoZSBUYWcgc2hhcGUgaW4gb3JkZXIgdG8gdXBkYXRlXG4gICAgICAgICAqIHRoZSBwb2ludGVyIHByb3BlcnRpZXMgYW5kIHRoZSBjb3JuZXIgcmFkaXVzXG4gICAgICAgICAqIEBuYW1lIGdldFRhZ1xuICAgICAgICAgKiBAbWV0aG9kXG4gICAgICAgICAqIEBtZW1iZXJvZiBLb252YS5MYWJlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgZ2V0VGFnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoJ1RhZycpWzBdO1xuICAgIH0sXG4gICAgX2FkZExpc3RlbmVyczogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLCBuO1xuICAgICAgdmFyIGZ1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5fc3luYygpO1xuICAgICAgfTtcblxuICAgICAgLy8gdXBkYXRlIHRleHQgZGF0YSBmb3IgY2VydGFpbiBhdHRyIGNoYW5nZXNcbiAgICAgIGZvciAobiA9IDA7IG4gPCBhdHRyQ2hhbmdlTGlzdExlbjsgbisrKSB7XG4gICAgICAgIHRleHQub24oQVRUUl9DSEFOR0VfTElTVFtuXSArIENIQU5HRV9LT05WQSwgZnVuYyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0V2lkdGgoKTtcbiAgICB9LFxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUZXh0KCkuZ2V0SGVpZ2h0KCk7XG4gICAgfSxcbiAgICBfc3luYzogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0VGV4dCgpLFxuICAgICAgICB0YWcgPSB0aGlzLmdldFRhZygpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBwb2ludGVyRGlyZWN0aW9uLFxuICAgICAgICBwb2ludGVyV2lkdGgsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHBvaW50ZXJIZWlnaHQ7XG5cbiAgICAgIGlmICh0ZXh0ICYmIHRhZykge1xuICAgICAgICB3aWR0aCA9IHRleHQuZ2V0V2lkdGgoKTtcbiAgICAgICAgaGVpZ2h0ID0gdGV4dC5nZXRIZWlnaHQoKTtcbiAgICAgICAgcG9pbnRlckRpcmVjdGlvbiA9IHRhZy5nZXRQb2ludGVyRGlyZWN0aW9uKCk7XG4gICAgICAgIHBvaW50ZXJXaWR0aCA9IHRhZy5nZXRQb2ludGVyV2lkdGgoKTtcbiAgICAgICAgcG9pbnRlckhlaWdodCA9IHRhZy5nZXRQb2ludGVySGVpZ2h0KCk7XG4gICAgICAgIHggPSAwO1xuICAgICAgICB5ID0gMDtcblxuICAgICAgICBzd2l0Y2ggKHBvaW50ZXJEaXJlY3Rpb24pIHtcbiAgICAgICAgICBjYXNlIFVQOlxuICAgICAgICAgICAgeCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgIHkgPSAtMSAqIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFJJR0hUOlxuICAgICAgICAgICAgeCA9IHdpZHRoICsgcG9pbnRlcldpZHRoO1xuICAgICAgICAgICAgeSA9IGhlaWdodCAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIERPV046XG4gICAgICAgICAgICB4ID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgeSA9IGhlaWdodCArIHBvaW50ZXJIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIExFRlQ6XG4gICAgICAgICAgICB4ID0gLTEgKiBwb2ludGVyV2lkdGg7XG4gICAgICAgICAgICB5ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFnLnNldEF0dHJzKHtcbiAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgeTogLTEgKiB5LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9KTtcblxuICAgICAgICB0ZXh0LnNldEF0dHJzKHtcbiAgICAgICAgICB4OiAtMSAqIHgsXG4gICAgICAgICAgeTogLTEgKiB5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5MYWJlbCwgS29udmEuR3JvdXApO1xuXG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5MYWJlbCk7XG5cbiAgLyoqXG4gICAgICogVGFnIGNvbnN0cnVjdG9yLiZuYnNwOyBBIFRhZyBjYW4gYmUgY29uZmlndXJlZFxuICAgICAqICB0byBoYXZlIGEgcG9pbnRlciBlbGVtZW50IHRoYXQgcG9pbnRzIHVwLCByaWdodCwgZG93biwgb3IgbGVmdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBtZW1iZXJvZiBLb252YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5wb2ludGVyRGlyZWN0aW9uXSBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lOyB0aGUgZGVmYXVsdFxuICAgICAqICBpcyBub25lLiAgV2hlbiBhIHBvaW50ZXIgaXMgcHJlc2VudCwgdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBsYWJlbCBpcyByZWxhdGl2ZSB0byB0aGUgdGlwIG9mIHRoZSBwb2ludGVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnBvaW50ZXJXaWR0aF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wb2ludGVySGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmNvcm5lclJhZGl1c11cbiAgICAgKi9cbiAgS29udmEuVGFnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpcy5fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgS29udmEuVGFnLnByb3RvdHlwZSA9IHtcbiAgICBfX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIEtvbnZhLlNoYXBlLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RhZyc7XG4gICAgICB0aGlzLnNjZW5lRnVuYyh0aGlzLl9zY2VuZUZ1bmMpO1xuICAgIH0sXG4gICAgX3NjZW5lRnVuYzogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpLFxuICAgICAgICBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpLFxuICAgICAgICBwb2ludGVyRGlyZWN0aW9uID0gdGhpcy5nZXRQb2ludGVyRGlyZWN0aW9uKCksXG4gICAgICAgIHBvaW50ZXJXaWR0aCA9IHRoaXMuZ2V0UG9pbnRlcldpZHRoKCksXG4gICAgICAgIHBvaW50ZXJIZWlnaHQgPSB0aGlzLmdldFBvaW50ZXJIZWlnaHQoKSxcbiAgICAgICAgY29ybmVyUmFkaXVzID0gTWF0aC5taW4odGhpcy5nZXRDb3JuZXJSYWRpdXMoKSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcblxuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvaW50ZXJEaXJlY3Rpb24gPT09IFVQKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCAtIHBvaW50ZXJXaWR0aCkgLyAyLCAwKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGggLyAyLCAtMSAqIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggKyBwb2ludGVyV2lkdGgpIC8gMiwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29ybmVyUmFkaXVzKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoIC0gY29ybmVyUmFkaXVzLCAwKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJICogMyAvIDIsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gUklHSFQpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIChoZWlnaHQgLSBwb2ludGVySGVpZ2h0KSAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCArIHBvaW50ZXJXaWR0aCwgaGVpZ2h0IC8gMik7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHdpZHRoLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8od2lkdGgsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCwgaGVpZ2h0IC0gY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgd2lkdGggLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgaGVpZ2h0IC0gY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICAwLFxuICAgICAgICAgIE1hdGguUEkgLyAyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludGVyRGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKCh3aWR0aCArIHBvaW50ZXJXaWR0aCkgLyAyLCBoZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh3aWR0aCAvIDIsIGhlaWdodCArIHBvaW50ZXJIZWlnaHQpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygod2lkdGggLSBwb2ludGVyV2lkdGgpIC8gMiwgaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb3JuZXJSYWRpdXMpIHtcbiAgICAgICAgY29udGV4dC5saW5lVG8oMCwgaGVpZ2h0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKGNvcm5lclJhZGl1cywgaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5hcmMoXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGhlaWdodCAtIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgTWF0aC5QSSAvIDIsXG4gICAgICAgICAgTWF0aC5QSSxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAocG9pbnRlckRpcmVjdGlvbiA9PT0gTEVGVCkge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0ICsgcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oLTEgKiBwb2ludGVyV2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCAoaGVpZ2h0IC0gcG9pbnRlckhlaWdodCkgLyAyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvcm5lclJhZGl1cykge1xuICAgICAgICBjb250ZXh0LmxpbmVUbygwLCBjb3JuZXJSYWRpdXMpO1xuICAgICAgICBjb250ZXh0LmFyYyhcbiAgICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICAgIGNvcm5lclJhZGl1cyxcbiAgICAgICAgICBNYXRoLlBJLFxuICAgICAgICAgIE1hdGguUEkgKiAzIC8gMixcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgY29udGV4dC5maWxsU3Ryb2tlU2hhcGUodGhpcyk7XG4gICAgfSxcbiAgICBnZXRTZWxmUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBwb2ludGVyV2lkdGggPSB0aGlzLmdldFBvaW50ZXJXaWR0aCgpLFxuICAgICAgICBwb2ludGVySGVpZ2h0ID0gdGhpcy5nZXRQb2ludGVySGVpZ2h0KCksXG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMucG9pbnRlckRpcmVjdGlvbigpLFxuICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKSxcbiAgICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gVVApIHtcbiAgICAgICAgeSAtPSBwb2ludGVySGVpZ2h0O1xuICAgICAgICBoZWlnaHQgKz0gcG9pbnRlckhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBET1dOKSB7XG4gICAgICAgIGhlaWdodCArPSBwb2ludGVySGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IExFRlQpIHtcbiAgICAgICAgLy8gQVJHSCEhISBJIGhhdmUgbm8gaWRlYSB3aHkgc2hvdWxkIEkgdXNlZCBtYWdpYyAxLjUhISEhISEhISFcbiAgICAgICAgeCAtPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICAgIHdpZHRoICs9IHBvaW50ZXJXaWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSBSSUdIVCkge1xuICAgICAgICB3aWR0aCArPSBwb2ludGVyV2lkdGggKiAxLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UYWcsIEtvbnZhLlNoYXBlKTtcbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAncG9pbnRlckRpcmVjdGlvbicsIE5PTkUpO1xuXG4gIC8qKlxuICAgICAqIHNldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9pbnRlckRpcmVjdGlvbiBjYW4gYmUgdXAsIHJpZ2h0LCBkb3duLCBsZWZ0LCBvciBub25lLiAgVGhlXG4gICAgICogIGRlZmF1bHQgaXMgbm9uZVxuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBwb2ludGVyIERpcmVjdGlvblxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJEaXJlY3Rpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKi9cblxuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UYWcsICdwb2ludGVyV2lkdGgnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIHNldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb2ludGVyV2lkdGhcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciB3aWR0aFxuICAgICAqIEBuYW1lIGdldFBvaW50ZXJXaWR0aFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVGFnLnByb3RvdHlwZVxuICAgICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlRhZywgJ3BvaW50ZXJIZWlnaHQnLCAwKTtcblxuICAvKipcbiAgICAgKiBzZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBzZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHBvaW50ZXJIZWlnaHRcbiAgICAgKi9cblxuICAvKipcbiAgICAgKiBnZXQgcG9pbnRlciBoZWlnaHRcbiAgICAgKiBAbmFtZSBnZXRQb2ludGVySGVpZ2h0XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVGFnLCAnY29ybmVyUmFkaXVzJywgMCk7XG5cbiAgLyoqXG4gICAgICogc2V0IGNvcm5lciByYWRpdXNcbiAgICAgKiBAbmFtZSBzZXRDb3JuZXJSYWRpdXNcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRhZy5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29ybmVyIHJhZGl1c1xuICAgICAqL1xuXG4gIC8qKlxuICAgICAqIGdldCBjb3JuZXIgcmFkaXVzXG4gICAgICogQG5hbWUgZ2V0Q29ybmVyUmFkaXVzXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UYWcucHJvdG90eXBlXG4gICAgICovXG5cbiAgS29udmEuQ29sbGVjdGlvbi5tYXBNZXRob2RzKEtvbnZhLlRhZyk7XG59KSgpO1xuXG4oZnVuY3Rpb24oS29udmEpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogQXJyb3cgY29uc3RydWN0b3JcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAYXVnbWVudHMgS29udmEuU2hhcGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWcucG9pbnRzIEZsYXQgYXJyYXkgb2YgcG9pbnRzIGNvb3JkaW5hdGVzLiBZb3Ugc2hvdWxkIGRlZmluZSB0aGVtIGFzIFt4MSwgeTEsIHgyLCB5MiwgeDMsIHkzXS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcudGVuc2lvbl0gSGlnaGVyIHZhbHVlcyB3aWxsIHJlc3VsdCBpbiBhIG1vcmUgY3VydnkgbGluZS4gIEEgdmFsdWUgb2YgMCB3aWxsIHJlc3VsdCBpbiBubyBpbnRlcnBvbGF0aW9uLlxuICAgKiAgIFRoZSBkZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy5wb2ludGVyTGVuZ3RoIEFycm93IHBvaW50ZXIgbGVuZ3RoLiBEZWZhdWx0IHZhbHVlIGlzIDEwLlxuICAgKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnBvaW50ZXJXaWR0aCBBcnJvdyBwb2ludGVyIHdpZHRoLiBEZWZhdWx0IHZhbHVlIGlzIDEwLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbmZpZy5wb2ludGVyQXRCZWdpbm5pbmcgRG8gd2UgbmVlZCB0byBkcmF3IHBvaW50ZXIgb24gYm90aCBzaWRlcz8uIERlZmF1bHQgZmFsc2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLmZpbGxdIGZpbGwgY29sb3JcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbY29uZmlnLmZpbGxQYXR0ZXJuSW1hZ2VdIGZpbGwgcGF0dGVybiBpbWFnZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxQYXR0ZXJuWF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVyblldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5PZmZzZXRYXSBcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUGF0dGVybk9mZnNldFldIFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxQYXR0ZXJuU2NhbGVdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5TY2FsZVldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFBhdHRlcm5Sb3RhdGlvbl1cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUGF0dGVyblJlcGVhdF0gY2FuIGJlIFwicmVwZWF0XCIsIFwicmVwZWF0LXhcIiwgXCJyZXBlYXQteVwiLCBvciBcIm5vLXJlcGVhdFwiLiAgVGhlIGRlZmF1bHQgaXMgXCJuby1yZXBlYXRcIlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudFN0YXJ0UG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50U3RhcnRQb2ludFldXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRdIG9iamVjdCB3aXRoIHggYW5kIHkgY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbExpbmVhckdyYWRpZW50RW5kUG9pbnRYXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudEVuZFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLmZpbGxMaW5lYXJHcmFkaWVudENvbG9yU3RvcHNdIGFycmF5IG9mIGNvbG9yIHN0b3BzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WF1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRTdGFydFBvaW50WV1cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludF0gb2JqZWN0IHdpdGggeCBhbmQgeSBjb21wb25lbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5maWxsUmFkaWFsR3JhZGllbnRFbmRQb2ludFhdIFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLmZpbGxSYWRpYWxHcmFkaWVudEVuZFBvaW50WV0gXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50U3RhcnRSYWRpdXNdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50RW5kUmFkaXVzXVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZmlsbFJhZGlhbEdyYWRpZW50Q29sb3JTdG9wc10gYXJyYXkgb2YgY29sb3Igc3RvcHNcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZmlsbEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZmlsbC4gIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5maWxsUHJpb3JpdHldIGNhbiBiZSBjb2xvciwgbGluZWFyLWdyYWRpZW50LCByYWRpYWwtZ3JhaWRlbnQsIG9yIHBhdHRlcm4uICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBjb2xvci4gIFRoZSBmaWxsUHJpb3JpdHkgcHJvcGVydHkgbWFrZXMgaXQgcmVhbGx5IGVhc3kgdG8gdG9nZ2xlIGJldHdlZW4gZGlmZmVyZW50IGZpbGwgdHlwZXMuICBGb3IgZXhhbXBsZSwgaWYgeW91IHdhbnQgdG8gdG9nZ2xlIGJldHdlZW4gYSBmaWxsIGNvbG9yIHN0eWxlIGFuZCBhIGZpbGwgcGF0dGVybiBzdHlsZSwgc2ltcGx5IHNldCB0aGUgZmlsbCBwcm9wZXJ0eSBhbmQgdGhlIGZpbGxQYXR0ZXJuIHByb3BlcnRpZXMsIGFuZCB0aGVuIHVzZSBzZXRGaWxsUHJpb3JpdHkoJ2NvbG9yJykgdG8gcmVuZGVyIHRoZSBzaGFwZSB3aXRoIGEgY29sb3IgZmlsbCwgb3IgdXNlIHNldEZpbGxQcmlvcml0eSgncGF0dGVybicpIHRvIHJlbmRlciB0aGUgc2hhcGUgd2l0aCB0aGUgcGF0dGVybiBmaWxsIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5zdHJva2VdIHN0cm9rZSBjb2xvclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnN0cm9rZVdpZHRoXSBzdHJva2Ugd2lkdGhcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlSGl0RW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBoaXQgcmVnaW9uLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5wZXJmZWN0RHJhd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB1c2luZyBidWZmZXIgY2FudmFzLiAgVGhlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5zaGFkb3dGb3JTdHJva2VFbmFibGVkXSBmbGFnIHdoaWNoIGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhc293IGZvciBzdHJva2UuICBUaGUgZGVmYXVsdCBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnN0cm9rZVNjYWxlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHN0cm9rZSBzY2FsZS4gIFRoZSBkZWZhdWx0IGlzIHRydWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuc3Ryb2tlRW5hYmxlZF0gZmxhZyB3aGljaCBlbmFibGVzIG9yIGRpc2FibGVzIHRoZSBzdHJva2UuICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcubGluZUpvaW5dIGNhbiBiZSBtaXRlciwgcm91bmQsIG9yIGJldmVsLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgbWl0ZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbmZpZy5saW5lQ2FwXSBjYW4gYmUgYnV0dCwgcm91bmQsIG9yIHNxYXJlLiAgVGhlIGRlZmF1bHRcbiAgICAgKiAgaXMgYnV0dFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLnNoYWRvd0NvbG9yXVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd0JsdXJdXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2hhZG93T2Zmc2V0XSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNoYWRvd09mZnNldFhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuc2hhZG93T2Zmc2V0WV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zaGFkb3dPcGFjaXR5XSBzaGFkb3cgb3BhY2l0eS4gIENhbiBiZSBhbnkgcmVhbCBudW1iZXJcbiAgICAgKiAgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnNoYWRvd0VuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgc2hhZG93LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZGFzaF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZGFzaEVuYWJsZWRdIGZsYWcgd2hpY2ggZW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgZGFzaEFycmF5LiAgVGhlIGRlZmF1bHQgdmFsdWUgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy54XVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnldXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcud2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcuaGVpZ2h0XVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy52aXNpYmxlXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5saXN0ZW5pbmddIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIGxpc3RlbmluZyBmb3IgZXZlbnRzXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb25maWcuaWRdIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbY29uZmlnLm5hbWVdIG5vbi11bmlxdWUgbmFtZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLm9wYWNpdHldIGRldGVybWluZXMgbm9kZSBvcGFjaXR5LiAgQ2FuIGJlIGFueSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWcuc2NhbGVdIHNldCBzY2FsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uZmlnLnNjYWxlWF0gc2V0IHNjYWxlIHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5zY2FsZVldIHNldCBzY2FsZSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRpb25dIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZy5vZmZzZXRdIG9mZnNldCBmcm9tIGNlbnRlciBwb2ludCBhbmQgcm90YXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRYXSBzZXQgb2Zmc2V0IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5vZmZzZXRZXSBzZXQgb2Zmc2V0IHlcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb25maWcuZHJhZ2dhYmxlXSBtYWtlcyB0aGUgbm9kZSBkcmFnZ2FibGUuICBXaGVuIHN0YWdlcyBhcmUgZHJhZ2dhYmxlLCB5b3UgY2FuIGRyYWcgYW5kIGRyb3BcbiAgICAgKiAgdGhlIGVudGlyZSBzdGFnZSBieSBkcmFnZ2luZyBhbnkgcG9ydGlvbiBvZiB0aGUgc3RhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5kcmFnRGlzdGFuY2VdXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbmZpZy5kcmFnQm91bmRGdW5jXVxuICAgKiBAZXhhbXBsZVxuICAgKiB2YXIgbGluZSA9IG5ldyBLb252YS5MaW5lKHtcbiAgICogICBwb2ludHM6IFs3MywgNzAsIDM0MCwgMjMsIDQ1MCwgNjAsIDUwMCwgMjBdLFxuICAgKiAgIHN0cm9rZTogJ3JlZCcsXG4gICAqICAgdGVuc2lvbjogMSxcbiAgICogICBwb2ludGVyTGVuZ3RoIDogMTAsXG4gICAqICAgcG9pbnRlcldpZHRoIDogMTJcbiAgICogfSk7XG4gICAqL1xuICBLb252YS5BcnJvdyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuX19fX2luaXQoY29uZmlnKTtcbiAgfTtcblxuICBLb252YS5BcnJvdy5wcm90b3R5cGUgPSB7XG4gICAgX19fX2luaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgLy8gY2FsbCBzdXBlciBjb25zdHJ1Y3RvclxuICAgICAgS29udmEuTGluZS5jYWxsKHRoaXMsIGNvbmZpZyk7XG4gICAgICB0aGlzLmNsYXNzTmFtZSA9ICdBcnJvdyc7XG4gICAgfSxcbiAgICBfc2NlbmVGdW5jOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIEtvbnZhLkxpbmUucHJvdG90eXBlLl9zY2VuZUZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBQSTIgPSBNYXRoLlBJICogMjtcbiAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cygpO1xuXG4gICAgICB2YXIgdHAgPSBwb2ludHM7XG4gICAgICB2YXIgZnJvbVRlbnNpb24gPSB0aGlzLmdldFRlbnNpb24oKSAhPT0gMCAmJiBwb2ludHMubGVuZ3RoID4gNDtcbiAgICAgIGlmIChmcm9tVGVuc2lvbikge1xuICAgICAgICB0cCA9IHRoaXMuZ2V0VGVuc2lvblBvaW50cygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICAgIHZhciBkeCwgZHk7XG4gICAgICBpZiAoZnJvbVRlbnNpb24pIHtcbiAgICAgICAgZHggPSBwb2ludHNbbiAtIDJdIC0gdHBbbiAtIDJdO1xuICAgICAgICBkeSA9IHBvaW50c1tuIC0gMV0gLSB0cFtuIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHBvaW50c1tuIC0gMl0gLSBwb2ludHNbbiAtIDRdO1xuICAgICAgICBkeSA9IHBvaW50c1tuIC0gMV0gLSBwb2ludHNbbiAtIDNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFkaWFucyA9IChNYXRoLmF0YW4yKGR5LCBkeCkgKyBQSTIpICUgUEkyO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRlckxlbmd0aCgpO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy5wb2ludGVyV2lkdGgoKTtcblxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUocG9pbnRzW24gLSAyXSwgcG9pbnRzW24gLSAxXSk7XG4gICAgICBjdHgucm90YXRlKHJhZGlhbnMpO1xuICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgd2lkdGggLyAyKTtcbiAgICAgIGN0eC5saW5lVG8oLWxlbmd0aCwgLXdpZHRoIC8gMik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICBpZiAodGhpcy5wb2ludGVyQXRCZWdpbm5pbmcoKSkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgaWYgKGZyb21UZW5zaW9uKSB7XG4gICAgICAgICAgZHggPSB0cFswXSAtIHBvaW50c1swXTtcbiAgICAgICAgICBkeSA9IHRwWzFdIC0gcG9pbnRzWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGR4ID0gcG9pbnRzWzJdIC0gcG9pbnRzWzBdO1xuICAgICAgICAgIGR5ID0gcG9pbnRzWzNdIC0gcG9pbnRzWzFdO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJvdGF0ZSgoTWF0aC5hdGFuMigtZHksIC1keCkgKyBQSTIpICUgUEkyKTtcbiAgICAgICAgY3R4Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgY3R4LmxpbmVUbygtbGVuZ3RoLCB3aWR0aCAvIDIpO1xuICAgICAgICBjdHgubGluZVRvKC1sZW5ndGgsIC13aWR0aCAvIDIpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhlcmUgaXMgYSB0cmlja3kgcGFydFxuICAgICAgLy8gd2UgbmVlZCB0byBkaXNhYmxlIGRhc2ggZm9yIGFycm93IHBvaW50ZXJzXG4gICAgICB2YXIgaXNEYXNoRW5hYmxlZCA9IHRoaXMuZGFzaEVuYWJsZWQoKTtcbiAgICAgIGlmIChpc0Rhc2hFbmFibGVkKSB7XG4gICAgICAgIC8vIG1hbnVhbGx5IGRpc2FibGUgZGFzaCBmb3IgaGVhZFxuICAgICAgICAvLyBpdCBpcyBiZXR0ZXIgbm90IHRvIHVzZSBzZXR0ZXIgaGVyZSxcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIHRyaWdnZXIgYXR0ciBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy5hdHRycy5kYXNoRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgICAgfVxuXG4gICAgICBjdHguZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xuXG4gICAgICAvLyByZXN0b3JlIG9sZCB2YWx1ZVxuICAgICAgaWYgKGlzRGFzaEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5hdHRycy5kYXNoRW5hYmxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEtvbnZhLlV0aWwuZXh0ZW5kKEtvbnZhLkFycm93LCBLb252YS5MaW5lKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgcG9pbnRlckxlbmd0aFxuICAgKiBAbmFtZSBwb2ludGVyTGVuZ3RoXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gTGVuZ3RoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXG4gICAqICAgVGhlIGRlZmF1bHQgaXMgMTAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZW5zaW9uXG4gICAqIHZhciBwb2ludGVyTGVuZ3RoID0gbGluZS5wb2ludGVyTGVuZ3RoKCk7XG4gICAqXG4gICAqIC8vIHNldCB0ZW5zaW9uXG4gICAqIGxpbmUucG9pbnRlckxlbmd0aCgxNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlckxlbmd0aCcsIDEwKTtcbiAgLyoqXG4gICAqIGdldC9zZXQgcG9pbnRlcldpZHRoXG4gICAqIEBuYW1lIHBvaW50ZXJXaWR0aFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5BcnJvdy5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFdpZHRoIG9mIHBvaW50ZXIgb2YgYXJyb3cuXG4gICAqICAgVGhlIGRlZmF1bHQgaXMgMTAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZW5zaW9uXG4gICAqIHZhciBwb2ludGVyV2lkdGggPSBsaW5lLnBvaW50ZXJXaWR0aCgpO1xuICAgKlxuICAgKiAvLyBzZXQgdGVuc2lvblxuICAgKiBsaW5lLnBvaW50ZXJXaWR0aCgxNSk7XG4gICAqL1xuXG4gIEtvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLkFycm93LCAncG9pbnRlcldpZHRoJywgMTApO1xuICAvKipcbiAgICogZ2V0L3NldCBwb2ludGVyQXRCZWdpbm5pbmdcbiAgICogQG5hbWUgcG9pbnRlckF0QmVnaW5uaW5nXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLkFycm93LnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge051bWJlcn0gU2hvdWxkIHBvaW50ZXIgZGlzcGxheWVkIGF0IGJlZ2lubmluZyBvZiBhcnJvdy5cbiAgICogICBUaGUgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldCB0ZW5zaW9uXG4gICAqIHZhciBwb2ludGVyQXRCZWdpbm5pbmcgPSBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZygpO1xuICAgKlxuICAgKiAvLyBzZXQgdGVuc2lvblxuICAgKiBsaW5lLnBvaW50ZXJBdEJlZ2lubmluZyh0cnVlKTtcbiAgICovXG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuQXJyb3csICdwb2ludGVyQXRCZWdpbm5pbmcnLCBmYWxzZSk7XG4gIEtvbnZhLkNvbGxlY3Rpb24ubWFwTWV0aG9kcyhLb252YS5BcnJvdyk7XG59KShLb252YSk7XG5cbihmdW5jdGlvbihLb252YSkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFUVFJfQ0hBTkdFX0xJU1QgPSBbXG4gICAgJ3Jlc2l6ZUVuYWJsZWRDaGFuZ2UnLFxuICAgICdyb3RhdGVIYW5kbGVyT2Zmc2V0Q2hhbmdlJ1xuICBdLmpvaW4oJyAnKTtcblxuICB2YXIgTk9ERV9SRUNUID0gJ25vZGVSZWN0JztcblxuICB2YXIgVFJBTlNGT1JNX0NIQU5HRV9TVFIgPSBbXG4gICAgJ3hDaGFuZ2UucmVzaXplcicsXG4gICAgJ3lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3dpZHRoQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdoZWlnaHRDaGFuZ2UucmVzaXplcicsXG4gICAgJ3NjYWxlWENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2NhbGVZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdza2V3WENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2tld1lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3JvdGF0aW9uQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRYQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICd0cmFuc2Zvcm1zRW5hYmxlZENoYW5nZS5yZXNpemVyJ1xuICBdLmpvaW4oJyAnKTtcblxuICB2YXIgUkVEUkFXX0NIQU5HRV9TVFIgPSBbXG4gICAgJ3dpZHRoQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdoZWlnaHRDaGFuZ2UucmVzaXplcicsXG4gICAgJ3NjYWxlWENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2NhbGVZQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdza2V3WENoYW5nZS5yZXNpemVyJyxcbiAgICAnc2tld1lDaGFuZ2UucmVzaXplcicsXG4gICAgJ3JvdGF0aW9uQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRYQ2hhbmdlLnJlc2l6ZXInLFxuICAgICdvZmZzZXRZQ2hhbmdlLnJlc2l6ZXInXG4gIF0uam9pbignICcpO1xuXG4gIHZhciBBTkdMRVMgPSB7XG4gICAgJ3RvcC1sZWZ0JzogLTQ1LFxuICAgICd0b3AtY2VudGVyJzogMCxcbiAgICAndG9wLXJpZ2h0JzogNDUsXG4gICAgJ21pZGRsZS1yaWdodCc6IC05MCxcbiAgICAnbWlkZGxlLWxlZnQnOiA5MCxcbiAgICAnYm90dG9tLWxlZnQnOiAtMTM1LFxuICAgICdib3R0b20tY2VudGVyJzogMTgwLFxuICAgICdib3R0b20tcmlnaHQnOiAxMzVcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRDdXJzb3IoYW5jaG9yTmFtZSwgcmFkKSB7XG4gICAgaWYgKGFuY2hvck5hbWUgPT09ICdyb3RhdGVyJykge1xuICAgICAgcmV0dXJuICdjcm9zc2hhaXInO1xuICAgIH1cblxuICAgIHJhZCArPSBLb252YS5VdGlsLl9kZWdUb1JhZChBTkdMRVNbYW5jaG9yTmFtZV0gfHwgMCk7XG4gICAgdmFyIGFuZ2xlID0gKEtvbnZhLlV0aWwuX3JhZFRvRGVnKHJhZCkgJSAzNjAgKyAzNjApICUgMzYwO1xuXG4gICAgaWYgKFxuICAgICAgS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgMzE1ICsgMjIuNSwgMzYwKSB8fFxuICAgICAgS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgMCwgMjIuNSlcbiAgICApIHtcbiAgICAgIC8vIFRPUFxuICAgICAgcmV0dXJuICducy1yZXNpemUnO1xuICAgIH0gZWxzZSBpZiAoS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgNDUgLSAyMi41LCA0NSArIDIyLjUpKSB7XG4gICAgICAvLyBUT1AgLSBSSUdIVFxuICAgICAgcmV0dXJuICduZXN3LXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCA5MCAtIDIyLjUsIDkwICsgMjIuNSkpIHtcbiAgICAgIC8vIFJJR0hUXG4gICAgICByZXR1cm4gJ2V3LXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAxMzUgLSAyMi41LCAxMzUgKyAyMi41KSkge1xuICAgICAgLy8gQk9UVE9NIC0gUklHSFRcbiAgICAgIHJldHVybiAnbndzZS1yZXNpemUnO1xuICAgIH0gZWxzZSBpZiAoS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgMTgwIC0gMjIuNSwgMTgwICsgMjIuNSkpIHtcbiAgICAgIC8vIEJPVFRPTVxuICAgICAgcmV0dXJuICducy1yZXNpemUnO1xuICAgIH0gZWxzZSBpZiAoS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgMjI1IC0gMjIuNSwgMjI1ICsgMjIuNSkpIHtcbiAgICAgIC8vIEJPVFRPTSAtIExFRlRcbiAgICAgIHJldHVybiAnbmVzdy1yZXNpemUnO1xuICAgIH0gZWxzZSBpZiAoS29udmEuVXRpbC5faW5SYW5nZShhbmdsZSwgMjcwIC0gMjIuNSwgMjcwICsgMjIuNSkpIHtcbiAgICAgIC8vIFJJR0hUXG4gICAgICByZXR1cm4gJ2V3LXJlc2l6ZSc7XG4gICAgfSBlbHNlIGlmIChLb252YS5VdGlsLl9pblJhbmdlKGFuZ2xlLCAzMTUgLSAyMi41LCAzMTUgKyAyMi41KSkge1xuICAgICAgLy8gQk9UVE9NIC0gUklHSFRcbiAgICAgIHJldHVybiAnbndzZS1yZXNpemUnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3cgY2FuIHdlIGNhbiB0aGVyZT9cbiAgICAgIC8vIFRPRE86IHRocm93IGVycm9yXG4gICAgICBLb252YS5VdGlsLmVycm9yKFxuICAgICAgICAnVHJhbnNmb3JtZXIgaGFzIHVua25vd24gYW5nbGUgZm9yIGN1cnNvciBkZXRlY3Rpb246ICcgKyBhbmdsZVxuICAgICAgKTtcbiAgICAgIHJldHVybiAncG9pbnRlcic7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybWVyIGNvbnN0cnVjdG9yLiAgVHJhbnNmb3JtZXIgaXMgYSBzcGVjaWFsIHR5cGUgb2YgZ3JvdXAgdGhhdCBhbGxvdyB5b3UgdHJhbnNmb3JtIEtvbnZhXG4gICAqIHByaW1pdGl2ZXMgYW5kIHNoYXBlcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBtZW1iZXJvZiBLb252YVxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5yZXNpemVFbmFibGVkXSBEZWZhdWx0IGlzIHRydWVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29uZmlnLnJvdGF0ZUVuYWJsZWRdIERlZmF1bHQgaXMgdHJ1ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbY29uZmlnLnJvdGF0aW9uU25hcHNdIEFycmF5IG9mIGFuZ2xlcyBmb3Igcm90YXRpb24gc25hcHMuIERlZmF1bHQgaXMgW11cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcucm90YXRlSGFuZGxlck9mZnNldF0gRGVmYXVsdCBpcyA1MFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmZpZy5wYWRkaW5nXSBEZWZhdWx0IGlzIDBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25maWcubGluZUVuYWJsZWRdIFNob3VsZCB3ZSBkcmF3IGJvcmRlcj8gRGVmYXVsdCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbmZpZy5rZWVwUmF0aW9dIFNob3VsZCB3ZSBrZWVwIHJhdGlvIHdoZW4gd2UgYXJlIG1vdmluZyBlZGdlcz8gRGVmYXVsdCBpcyB0cnVlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtjb25maWcuZW5hYmxlZEhhbmRsZXJzXSBBcnJheSBvZiBuYW1lcyBvZiBlbmFibGVkIGhhbmRsZXNcbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHRyYW5zZm9ybWVyID0gbmV3IEtvbnZhLlRyYW5zZm9ybWVyKHtcbiAgICogICBub2RlOiByZWN0YW5nbGUsXG4gICAqICAgcm90YXRlSGFuZGxlck9mZnNldDogNjAsXG4gICAqICAgZW5hYmxlZEhhbmRsZXJzOiBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXVxuICAgKiB9KTtcbiAgICogbGF5ZXIuYWRkKHRyYW5zZm9ybWVyKTtcbiAgICovXG5cbiAgS29udmEuVHJhbnNmb3JtZXIgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzLl9fX19pbml0KGNvbmZpZyk7XG4gIH07XG5cbiAgdmFyIFJFU0laRVJTX05BTUVTID0gW1xuICAgICd0b3AtbGVmdCcsXG4gICAgJ3RvcC1jZW50ZXInLFxuICAgICd0b3AtcmlnaHQnLFxuICAgICdtaWRkbGUtcmlnaHQnLFxuICAgICdtaWRkbGUtbGVmdCcsXG4gICAgJ2JvdHRvbS1sZWZ0JyxcbiAgICAnYm90dG9tLWNlbnRlcicsXG4gICAgJ2JvdHRvbS1yaWdodCdcbiAgXTtcblxuICB2YXIgd2FybmluZ1Nob3dlZCA9IGZhbHNlO1xuXG4gIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IHtcbiAgICBfY2VudHJvaWQ6IGZhbHNlLFxuICAgIF9fX19pbml0OiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgIC8vIGNhbGwgc3VwZXIgY29uc3RydWN0b3JcbiAgICAgIEtvbnZhLkdyb3VwLmNhbGwodGhpcywgY29uZmlnKTtcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJ1RyYW5zZm9ybWVyJztcbiAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRzKCk7XG5cbiAgICAgIC8vIGJpbmRpbmdzXG4gICAgICB0aGlzLl9oYW5kbGVNb3VzZU1vdmUgPSB0aGlzLl9oYW5kbGVNb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX2hhbmRsZU1vdXNlVXAgPSB0aGlzLl9oYW5kbGVNb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLnVwZGF0ZSA9IHRoaXMudXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgICAgIC8vIHVwZGF0ZSB0cmFuc2Zvcm1lciBkYXRhIGZvciBjZXJ0YWluIGF0dHIgY2hhbmdlc1xuICAgICAgdGhpcy5vbihBVFRSX0NIQU5HRV9MSVNULCB0aGlzLnVwZGF0ZSk7XG5cbiAgICAgIGlmICghd2FybmluZ1Nob3dlZCkge1xuICAgICAgICBLb252YS5VdGlsLndhcm4oXG4gICAgICAgICAgJ0tvbnZhLlRyYW5zZm9ybWVyIGlzIGN1cnJlbnRseSBleHBlcmltZW50YWwgYW5kIG1heSBoYXZlIGJ1Z3MuIFBsZWFzZSByZXBvcnQgYW55IGlzc3VlcyB0byBHaXRIdWIgcmVwby4nXG4gICAgICAgICk7XG4gICAgICAgIHdhcm5pbmdTaG93ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5nZXROb2RlKCkpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXR0YWNoVG86IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHRoaXMuc2V0Tm9kZShub2RlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYXR0YWNoIHRyYW5zZm9ybWVyIHRvIGEgS29udmEuTm9kZS4gVHJhbnNmb3JtZXIgd2lsbCBhZGFwdCBpdCBpdHMgc2l6ZSBhbmQgbGlzdGVkIGV2ZW50c1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0tvbnZhLlRyYW5zZm9ybWVyfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogdHJhbnNmb3JtZXIuYXR0YWNoVG8oc2hhcGUpO1xuICAgICAqL1xuICAgIHNldE5vZGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmICh0aGlzLl9ub2RlKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICAgIHRoaXMuX2NsZWFyQ2FjaGUoTk9ERV9SRUNUKTtcblxuICAgICAgbm9kZS5vbihUUkFOU0ZPUk1fQ0hBTkdFX1NUUiwgdGhpcy5fcmVzZXRUcmFuc2Zvcm1DYWNoZS5iaW5kKHRoaXMpKTtcbiAgICAgIG5vZGUub24oXG4gICAgICAgIFJFRFJBV19DSEFOR0VfU1RSLFxuICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zZm9ybWluZykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKVxuICAgICAgKTtcblxuICAgICAgLy8gVE9ETzogd2h5IGRvIHdlIG5lZWQgdGhpcz9cbiAgICAgIHZhciBlbGVtZW50c0NyZWF0ZWQgPSAhIXRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0Jyk7XG4gICAgICBpZiAoZWxlbWVudHNDcmVhdGVkKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZGV0YWNoIHRyYW5zZm9ybWVyIGZyb20gYSBhdHRhY2hlZCBub2RlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7S29udmEuVHJhbnNmb3JtZXJ9XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cmFuc2Zvcm1lci5kZXRhY2goKTtcbiAgICAgKi9cbiAgICBkZXRhY2g6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuZ2V0Tm9kZSgpKSB7XG4gICAgICAgIHRoaXMuZ2V0Tm9kZSgpLm9mZignLnJlc2l6ZXInKTtcbiAgICAgICAgdGhpcy5fbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtQ2FjaGUoKTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0VHJhbnNmb3JtQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZShOT0RFX1JFQ1QpO1xuICAgICAgdGhpcy5fY2xlYXJDYWNoZSgndHJhbnNmb3JtJyk7XG4gICAgICB0aGlzLl9jbGVhclNlbGZBbmREZXNjZW5kYW50Q2FjaGUoJ2Fic29sdXRlVHJhbnNmb3JtJyk7XG4gICAgfSxcblxuICAgIF9nZXROb2RlUmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2FjaGUoTk9ERV9SRUNULCB0aGlzLl9fZ2V0Tm9kZVJlY3QpO1xuICAgIH0sXG5cbiAgICBfX2dldE5vZGVSZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiAtTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgeTogLU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICByb3RhdGlvbjogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdmFyIHJlY3QgPSBub2RlLmdldENsaWVudFJlY3QoeyBza2lwVHJhbnNmb3JtOiB0cnVlIH0pO1xuICAgICAgdmFyIHJvdGF0aW9uID0gS29udmEuZ2V0QW5nbGUobm9kZS5yb3RhdGlvbigpKTtcblxuICAgICAgdmFyIGR4ID0gcmVjdC54ICogbm9kZS5zY2FsZVgoKSAtIG5vZGUub2Zmc2V0WCgpICogbm9kZS5zY2FsZVgoKTtcbiAgICAgIHZhciBkeSA9IHJlY3QueSAqIG5vZGUuc2NhbGVZKCkgLSBub2RlLm9mZnNldFkoKSAqIG5vZGUuc2NhbGVZKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IG5vZGUueCgpICsgZHggKiBNYXRoLmNvcyhyb3RhdGlvbikgKyBkeSAqIE1hdGguc2luKC1yb3RhdGlvbiksXG4gICAgICAgIHk6IG5vZGUueSgpICsgZHkgKiBNYXRoLmNvcyhyb3RhdGlvbikgKyBkeCAqIE1hdGguc2luKHJvdGF0aW9uKSxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKiBub2RlLnNjYWxlWCgpLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICogbm9kZS5zY2FsZVkoKSxcbiAgICAgICAgcm90YXRpb246IG5vZGUucm90YXRpb24oKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Tm9kZVJlY3QoKS54O1xuICAgIH0sXG5cbiAgICBnZXRZOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlUmVjdCgpLnk7XG4gICAgfSxcblxuICAgIGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlUmVjdCgpLnJvdGF0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Tm9kZVJlY3QoKS53aWR0aDtcbiAgICB9LFxuXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXROb2RlUmVjdCgpLmhlaWdodDtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUVsZW1lbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZUJhY2soKTtcblxuICAgICAgUkVTSVpFUlNfTkFNRVMuZm9yRWFjaChcbiAgICAgICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHRoaXMuX2NyZWF0ZUFuY2hvcihuYW1lKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuXG4gICAgICB0aGlzLl9jcmVhdGVBbmNob3IoJ3JvdGF0ZXInKTtcbiAgICB9LFxuXG4gICAgX2NyZWF0ZUFuY2hvcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGFuY2hvciA9IG5ldyBLb252YS5SZWN0KHtcbiAgICAgICAgc3Ryb2tlOiAncmdiKDAsIDE2MSwgMjU1KScsXG4gICAgICAgIGZpbGw6ICd3aGl0ZScsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB3aWR0aDogMTAsXG4gICAgICAgIGhlaWdodDogMTAsXG4gICAgICAgIG9mZnNldFg6IDUsXG4gICAgICAgIG9mZnNldFk6IDUsXG4gICAgICAgIGRyYWdEaXN0YW5jZTogMFxuICAgICAgfSk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBhbmNob3Iub24oJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLl9oYW5kbGVNb3VzZURvd24oZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gYWRkIGhvdmVyIHN0eWxpbmdcbiAgICAgIGFuY2hvci5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgIHZhciB0ciA9IHRoaXMuZ2V0UGFyZW50KCk7XG5cbiAgICAgICAgLy8gVE9ETzogSSBndWVzcyB0aGVyZSBhcmUgc29tZSB3YXlzIHRvIHNpbXBsaWZ5IHRoYXQgY2FsY3VsYXRpb25zXG4gICAgICAgIC8vIHRoZSBiYXNpYyBpZGVhIGlzIHRvIGZpbmQgXCJhbmdsZVwiIG9mIGhhbmRsZXJcbiAgICAgICAgdmFyIHJhZCA9IEtvbnZhLmdldEFuZ2xlKHRyLnJvdGF0aW9uKCkpO1xuXG4gICAgICAgIC8vIHZhciBjZHggPSB0ci5nZXRXaWR0aCgpIC8gMjtcbiAgICAgICAgLy8gdmFyIGNkeSA9IHRyLmdldEhlaWdodCgpIC8gMjtcblxuICAgICAgICAvLyB2YXIgcGFyZW50UG9zID0gdHIuZ2V0QWJzb2x1dGVQb3NpdGlvbih0ci5nZXRQYXJlbnQoKSk7XG4gICAgICAgIC8vIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIC8vICAgeDogcGFyZW50UG9zLnggKyAoY2R4ICogTWF0aC5jb3MocmFkKSArIGNkeSAqIE1hdGguc2luKC1yYWQpKSxcbiAgICAgICAgLy8gICB5OiBwYXJlbnRQb3MueSArIChjZHkgKiBNYXRoLmNvcyhyYWQpICsgY2R4ICogTWF0aC5zaW4ocmFkKSlcbiAgICAgICAgLy8gfTtcblxuICAgICAgICAvLyB2YXIgcG9zID0gdGhpcy5nZXRBYnNvbHV0ZVBvc2l0aW9uKHRyLmdldFBhcmVudCgpKTtcblxuICAgICAgICAvLyB2YXIgZHggPSAtcG9zLnggKyBjZW50ZXIueDtcbiAgICAgICAgLy8gdmFyIGR5ID0gLXBvcy55ICsgY2VudGVyLnk7XG5cbiAgICAgICAgLy8gdmFyIGFuZ2xlID0gLU1hdGguYXRhbjIoLWR5LCBkeCkgLSBNYXRoLlBJIC8gMjtcblxuICAgICAgICB2YXIgY3Vyc29yID0gZ2V0Q3Vyc29yKG5hbWUsIHJhZCk7XG4gICAgICAgIGFuY2hvci5nZXRTdGFnZSgpLmNvbnRlbnQuc3R5bGUuY3Vyc29yID0gY3Vyc29yO1xuICAgICAgICBsYXllci5iYXRjaERyYXcoKTtcbiAgICAgIH0pO1xuICAgICAgYW5jaG9yLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLmdldExheWVyKCk7XG4gICAgICAgIGlmICghbGF5ZXIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYW5jaG9yLmdldFN0YWdlKCkuY29udGVudC5zdHlsZS5jdXJzb3IgPSAnJztcbiAgICAgICAgbGF5ZXIuYmF0Y2hEcmF3KCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWRkKGFuY2hvcik7XG4gICAgfSxcblxuICAgIF9jcmVhdGVCYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiYWNrID0gbmV3IEtvbnZhLlNoYXBlKHtcbiAgICAgICAgc3Ryb2tlOiAncmdiKDAsIDE2MSwgMjU1KScsXG4gICAgICAgIG5hbWU6ICdiYWNrJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbGlzdGVuaW5nOiBmYWxzZSxcbiAgICAgICAgc2NlbmVGdW5jOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICB2YXIgdHIgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICAgIHZhciBwYWRkaW5nID0gdHIuZ2V0UGFkZGluZygpO1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgucmVjdChcbiAgICAgICAgICAgIC1wYWRkaW5nLFxuICAgICAgICAgICAgLXBhZGRpbmcsXG4gICAgICAgICAgICB0aGlzLndpZHRoKCkgKyBwYWRkaW5nICogMixcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0KCkgKyBwYWRkaW5nICogMlxuICAgICAgICAgICk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh0aGlzLndpZHRoKCkgLyAyLCAtcGFkZGluZyk7XG4gICAgICAgICAgaWYgKHRyLnJvdGF0ZUVuYWJsZWQoKSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhcbiAgICAgICAgICAgICAgdGhpcy53aWR0aCgpIC8gMixcbiAgICAgICAgICAgICAgLXRyLnJvdGF0ZUhhbmRsZXJPZmZzZXQoKSAqIEtvbnZhLlV0aWwuX3NpZ24odGhpcy5oZWlnaHQoKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFkZChiYWNrKTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgdGhpcy5tb3ZpbmdSZXNpemVyID0gZS50YXJnZXQubmFtZSgpO1xuXG4gICAgICAvLyB2YXIgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICAgICAgdmFyIGF0dHJzID0gdGhpcy5fZ2V0Tm9kZVJlY3QoKTtcbiAgICAgIHZhciB3aWR0aCA9IGF0dHJzLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcbiAgICAgIHZhciBoeXBvdGVudXNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHdpZHRoLCAyKSArIE1hdGgucG93KGhlaWdodCwgMikpO1xuICAgICAgdGhpcy5zaW4gPSBoZWlnaHQgLyBoeXBvdGVudXNlO1xuICAgICAgdGhpcy5jb3MgPSB3aWR0aCAvIGh5cG90ZW51c2U7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXAsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5faGFuZGxlTW91c2VVcCwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMuX3RyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuZmlyZSgndHJhbnNmb3Jtc3RhcnQnKTtcbiAgICAgIHRoaXMuZ2V0Tm9kZSgpLmZpcmUoJ3RyYW5zZm9ybXN0YXJ0Jyk7XG4gICAgfSxcblxuICAgIF9oYW5kbGVNb3VzZU1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciB4LCB5LCBuZXdIeXBvdGVudXNlO1xuICAgICAgdmFyIHJlc2l6ZXJOb2RlID0gdGhpcy5maW5kT25lKCcuJyArIHRoaXMubW92aW5nUmVzaXplcik7XG4gICAgICB2YXIgc3RhZ2UgPSByZXNpemVyTm9kZS5nZXRTdGFnZSgpO1xuXG4gICAgICB2YXIgYm94ID0gc3RhZ2UuZ2V0Q29udGVudCgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHplcm9Qb2ludCA9IHtcbiAgICAgICAgeDogYm94LmxlZnQsXG4gICAgICAgIHk6IGJveC50b3BcbiAgICAgIH07XG4gICAgICB2YXIgcG9pbnRlclBvcyA9IHtcbiAgICAgICAgbGVmdDogZS5jbGllbnRYICE9PSB1bmRlZmluZWQgPyBlLmNsaWVudFggOiBlLnRvdWNoZXNbMF0uY2xpZW50WCxcbiAgICAgICAgdG9wOiBlLmNsaWVudFggIT09IHVuZGVmaW5lZCA/IGUuY2xpZW50WSA6IGUudG91Y2hlc1swXS5jbGllbnRZXG4gICAgICB9O1xuICAgICAgdmFyIG5ld0Fic1BvcyA9IHtcbiAgICAgICAgeDogcG9pbnRlclBvcy5sZWZ0IC0gemVyb1BvaW50LngsXG4gICAgICAgIHk6IHBvaW50ZXJQb3MudG9wIC0gemVyb1BvaW50LnlcbiAgICAgIH07XG5cbiAgICAgIHJlc2l6ZXJOb2RlLnNldEFic29sdXRlUG9zaXRpb24obmV3QWJzUG9zKTtcblxuICAgICAgdmFyIGtlZXBQcm9wb3J0aW9uID0gdGhpcy5rZWVwUmF0aW8oKSB8fCBlLnNoaWZ0S2V5O1xuXG4gICAgICBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAndG9wLWxlZnQnKSB7XG4gICAgICAgIGlmIChrZWVwUHJvcG9ydGlvbikge1xuICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KCkgLSByZXNpemVyTm9kZS54KCksIDIpICtcbiAgICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueSgpIC0gcmVzaXplck5vZGUueSgpLCAyKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB4ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuY29zO1xuICAgICAgICAgIHkgPSBuZXdIeXBvdGVudXNlICogdGhpcy5zaW47XG5cbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngodGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpIC0geCk7XG4gICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkoKSAtIHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ3RvcC1jZW50ZXInKSB7XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueShyZXNpemVyTm9kZS55KCkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1vdmluZ1Jlc2l6ZXIgPT09ICd0b3AtcmlnaHQnKSB7XG4gICAgICAgIGlmIChrZWVwUHJvcG9ydGlvbikge1xuICAgICAgICAgIG5ld0h5cG90ZW51c2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLngoKSAtIHJlc2l6ZXJOb2RlLngoKSwgMikgK1xuICAgICAgICAgICAgICBNYXRoLnBvdyh0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLnkoKSAtIHJlc2l6ZXJOb2RlLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLXJpZ2h0JykueCh4KTtcbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtcmlnaHQnKS55KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1sZWZ0JykueSgpIC0geSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvcyA9IHJlc2l6ZXJOb2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS55KHBvcy55KTtcbiAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueChwb3MueCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ21pZGRsZS1sZWZ0Jykge1xuICAgICAgICB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngocmVzaXplck5vZGUueCgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAnbWlkZGxlLXJpZ2h0Jykge1xuICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KHJlc2l6ZXJOb2RlLngoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ2JvdHRvbS1sZWZ0Jykge1xuICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcudG9wLXJpZ2h0JykueCgpIC0gcmVzaXplck5vZGUueCgpLCAyKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnkoKSAtIHJlc2l6ZXJOb2RlLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLWxlZnQnKS54KHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLngoKSAtIHgpO1xuICAgICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1sZWZ0JykueSh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvcyA9IHJlc2l6ZXJOb2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS54KHBvcy54KTtcbiAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueShwb3MueSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ2JvdHRvbS1jZW50ZXInKSB7XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkocmVzaXplck5vZGUueSgpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAnYm90dG9tLXJpZ2h0Jykge1xuICAgICAgICBpZiAoa2VlcFByb3BvcnRpb24pIHtcbiAgICAgICAgICBuZXdIeXBvdGVudXNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3codGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCgpLCAyKSArXG4gICAgICAgICAgICAgIE1hdGgucG93KHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkoKSwgMilcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgeCA9IG5ld0h5cG90ZW51c2UgKiB0aGlzLmNvcztcbiAgICAgICAgICB5ID0gbmV3SHlwb3RlbnVzZSAqIHRoaXMuc2luO1xuXG4gICAgICAgICAgdGhpcy5maW5kT25lKCcuYm90dG9tLXJpZ2h0JykueCh4KTtcbiAgICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS55KHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubW92aW5nUmVzaXplciA9PT0gJ3JvdGF0ZXInKSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXRQYWRkaW5nKCk7XG4gICAgICAgIHZhciBhdHRycyA9IHRoaXMuX2dldE5vZGVSZWN0KCk7XG4gICAgICAgIHggPSByZXNpemVyTm9kZS54KCkgLSBhdHRycy53aWR0aCAvIDI7XG4gICAgICAgIHkgPSAtcmVzaXplck5vZGUueSgpICsgYXR0cnMuaGVpZ2h0IC8gMjtcblxuICAgICAgICB2YXIgZEFscGhhID0gTWF0aC5hdGFuMigteSwgeCkgKyBNYXRoLlBJIC8gMjtcblxuICAgICAgICBpZiAoYXR0cnMuaGVpZ2h0IDwgMCkge1xuICAgICAgICAgIGRBbHBoYSAtPSBNYXRoLlBJO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdCA9IEtvbnZhLmdldEFuZ2xlKHRoaXMucm90YXRpb24oKSk7XG5cbiAgICAgICAgdmFyIG5ld1JvdGF0aW9uID1cbiAgICAgICAgICBLb252YS5VdGlsLl9yYWRUb0RlZyhyb3QpICsgS29udmEuVXRpbC5fcmFkVG9EZWcoZEFscGhhKTtcblxuICAgICAgICB2YXIgYWxwaGEgPSBLb252YS5nZXRBbmdsZSh0aGlzLmdldE5vZGUoKS5yb3RhdGlvbigpKTtcbiAgICAgICAgdmFyIG5ld0FscGhhID0gS29udmEuVXRpbC5fZGVnVG9SYWQobmV3Um90YXRpb24pO1xuXG4gICAgICAgIHZhciBzbmFwcyA9IHRoaXMucm90YXRpb25TbmFwcygpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMC4xO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNuYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gS29udmEuZ2V0QW5nbGUoc25hcHNbaV0pO1xuXG4gICAgICAgICAgdmFyIGRpZiA9XG4gICAgICAgICAgICBNYXRoLmFicyhhbmdsZSAtIEtvbnZhLlV0aWwuX2RlZ1RvUmFkKG5ld1JvdGF0aW9uKSkgJSAoTWF0aC5QSSAqIDIpO1xuXG4gICAgICAgICAgaWYgKGRpZiA8IG9mZnNldCkge1xuICAgICAgICAgICAgbmV3Um90YXRpb24gPSBLb252YS5VdGlsLl9yYWRUb0RlZyhhbmdsZSk7XG4gICAgICAgICAgICBuZXdBbHBoYSA9IEtvbnZhLlV0aWwuX2RlZ1RvUmFkKG5ld1JvdGF0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHggPSBwYWRkaW5nO1xuICAgICAgICB2YXIgZHkgPSBwYWRkaW5nO1xuXG4gICAgICAgIHRoaXMuX2ZpdE5vZGVJbnRvKHtcbiAgICAgICAgICByb3RhdGlvbjogS29udmEuYW5nbGVEZWdcbiAgICAgICAgICAgID8gbmV3Um90YXRpb25cbiAgICAgICAgICAgIDogS29udmEuVXRpbC5fZGVnVG9SYWQobmV3Um90YXRpb24pLFxuICAgICAgICAgIHg6XG4gICAgICAgICAgICBhdHRycy54ICtcbiAgICAgICAgICAgIChhdHRycy53aWR0aCAvIDIgKyBwYWRkaW5nKSAqXG4gICAgICAgICAgICAgIChNYXRoLmNvcyhhbHBoYSkgLSBNYXRoLmNvcyhuZXdBbHBoYSkpICtcbiAgICAgICAgICAgIChhdHRycy5oZWlnaHQgLyAyICsgcGFkZGluZykgKlxuICAgICAgICAgICAgICAoTWF0aC5zaW4oLWFscGhhKSAtIE1hdGguc2luKC1uZXdBbHBoYSkpIC1cbiAgICAgICAgICAgIChkeCAqIE1hdGguY29zKHJvdCkgKyBkeSAqIE1hdGguc2luKC1yb3QpKSxcbiAgICAgICAgICB5OlxuICAgICAgICAgICAgYXR0cnMueSArXG4gICAgICAgICAgICAoYXR0cnMuaGVpZ2h0IC8gMiArIHBhZGRpbmcpICpcbiAgICAgICAgICAgICAgKE1hdGguY29zKGFscGhhKSAtIE1hdGguY29zKG5ld0FscGhhKSkgK1xuICAgICAgICAgICAgKGF0dHJzLndpZHRoIC8gMiArIHBhZGRpbmcpICpcbiAgICAgICAgICAgICAgKE1hdGguc2luKGFscGhhKSAtIE1hdGguc2luKG5ld0FscGhhKSkgLVxuICAgICAgICAgICAgKGR5ICogTWF0aC5jb3Mocm90KSArIGR4ICogTWF0aC5zaW4ocm90KSksXG4gICAgICAgICAgd2lkdGg6IGF0dHJzLndpZHRoICsgcGFkZGluZyAqIDIsXG4gICAgICAgICAgaGVpZ2h0OiBhdHRycy5oZWlnaHQgKyBwYWRkaW5nICogMlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1dyb25nIHBvc2l0aW9uIGFyZ3VtZW50IG9mIHNlbGVjdGlvbiByZXNpemVyOiAnLFxuICAgICAgICAgICAgdGhpcy5tb3ZpbmdSZXNpemVyXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tb3ZpbmdSZXNpemVyID09PSAncm90YXRlcicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWJzUG9zID0gdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS5nZXRBYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICB0aGlzLmdldFBhcmVudCgpXG4gICAgICApO1xuXG4gICAgICB4ID0gYWJzUG9zLng7XG4gICAgICB5ID0gYWJzUG9zLnk7XG4gICAgICB2YXIgd2lkdGggPVxuICAgICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tcmlnaHQnKS54KCkgLSB0aGlzLmZpbmRPbmUoJy50b3AtbGVmdCcpLngoKTtcblxuICAgICAgdmFyIGhlaWdodCA9XG4gICAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnkoKSAtIHRoaXMuZmluZE9uZSgnLnRvcC1sZWZ0JykueSgpO1xuXG4gICAgICB0aGlzLl9maXROb2RlSW50byh7XG4gICAgICAgIHg6IHggKyB0aGlzLm9mZnNldFgoKSxcbiAgICAgICAgeTogeSArIHRoaXMub2Zmc2V0WSgpLFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgX2hhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRzKCk7XG4gICAgfSxcblxuICAgIF9yZW1vdmVFdmVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybWluZykge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlVXAsIHRydWUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVNb3VzZVVwLCB0cnVlKTtcbiAgICAgICAgdGhpcy5maXJlKCd0cmFuc2Zvcm1lbmQnKTtcbiAgICAgICAgdGhpcy5nZXROb2RlKCkuZmlyZSgndHJhbnNmb3JtZW5kJyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9maXROb2RlSW50bzogZnVuY3Rpb24obmV3QXR0cnMpIHtcbiAgICAgIC8vIHdhcmluZyEgaW4gdGhpcyBhdHRycyBwYWRkaW5nIG1heSBiZSBpbmNsdWRlZFxuICAgICAgdmFyIGJvdW5kQm94RnVuYyA9IHRoaXMuZ2V0Qm91bmRCb3hGdW5jKCk7XG4gICAgICBpZiAoYm91bmRCb3hGdW5jKSB7XG4gICAgICAgIHZhciBvbGRBdHRycyA9IHRoaXMuX2dldE5vZGVSZWN0KCk7XG4gICAgICAgIG5ld0F0dHJzID0gYm91bmRCb3hGdW5jLmNhbGwodGhpcywgb2xkQXR0cnMsIG5ld0F0dHJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldHRpbmdzID0gdHJ1ZTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gICAgICBpZiAobmV3QXR0cnMucm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmdldE5vZGUoKS5yb3RhdGlvbihuZXdBdHRycy5yb3RhdGlvbik7XG4gICAgICB9XG4gICAgICB2YXIgcHVyZSA9IG5vZGUuZ2V0Q2xpZW50UmVjdCh7IHNraXBUcmFuc2Zvcm06IHRydWUgfSk7XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0UGFkZGluZygpO1xuICAgICAgdmFyIHNjYWxlWCA9IChuZXdBdHRycy53aWR0aCAtIHBhZGRpbmcgKiAyKSAvIHB1cmUud2lkdGg7XG4gICAgICB2YXIgc2NhbGVZID0gKG5ld0F0dHJzLmhlaWdodCAtIHBhZGRpbmcgKiAyKSAvIHB1cmUuaGVpZ2h0O1xuXG4gICAgICB2YXIgcm90YXRpb24gPSBLb252YS5nZXRBbmdsZShub2RlLmdldFJvdGF0aW9uKCkpO1xuICAgICAgdmFyIGR4ID0gcHVyZS54ICogc2NhbGVYIC0gcGFkZGluZyAtIG5vZGUub2Zmc2V0WCgpICogc2NhbGVYO1xuICAgICAgdmFyIGR5ID0gcHVyZS55ICogc2NhbGVZIC0gcGFkZGluZyAtIG5vZGUub2Zmc2V0WSgpICogc2NhbGVZO1xuXG4gICAgICB0aGlzLmdldE5vZGUoKS5zZXRBdHRycyh7XG4gICAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgeDogbmV3QXR0cnMueCAtIChkeCAqIE1hdGguY29zKHJvdGF0aW9uKSArIGR5ICogTWF0aC5zaW4oLXJvdGF0aW9uKSksXG4gICAgICAgIHk6IG5ld0F0dHJzLnkgLSAoZHkgKiBNYXRoLmNvcyhyb3RhdGlvbikgKyBkeCAqIE1hdGguc2luKHJvdGF0aW9uKSlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0dGluZ3MgPSBmYWxzZTtcblxuICAgICAgdGhpcy5maXJlKCd0cmFuc2Zvcm0nKTtcbiAgICAgIHRoaXMuZ2V0Tm9kZSgpLmZpcmUoJ3RyYW5zZm9ybScpO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMuZ2V0TGF5ZXIoKS5iYXRjaERyYXcoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGZvcmNlIHVwZGF0ZSBvZiBLb252YS5UcmFuc2Zvcm1lci5cbiAgICAgKiBVc2UgaXQgd2hlbiB5b3UgdXBkYXRlZCBhdHRhY2hlZCBLb252YS5Hcm91cCBhbmQgbm93IHlvdSBuZWVkIHRvIHJlc2V0IHRyYW5zZm9ybWVyIHNpemVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3Jlc2V0VHJhbnNmb3JtQ2FjaGUoKTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSxcbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF0dHJzID0gdGhpcy5fZ2V0Tm9kZVJlY3QoKTtcbiAgICAgIHZhciB3aWR0aCA9IGF0dHJzLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGF0dHJzLmhlaWdodDtcblxuICAgICAgdmFyIGVuYWJsZWRIYW5kbGVycyA9IHRoaXMuZW5hYmxlZEhhbmRsZXJzKCk7XG4gICAgICB2YXIgcmVzaXplRW5hYmxlZCA9IHRoaXMucmVzaXplRW5hYmxlZCgpO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldFBhZGRpbmcoKTtcblxuICAgICAgdGhpcy5maW5kT25lKCcudG9wLWxlZnQnKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IC1wYWRkaW5nLFxuICAgICAgICB5OiAtcGFkZGluZyxcbiAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkSGFuZGxlcnMuaW5kZXhPZigndG9wLWxlZnQnKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1jZW50ZXInKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IHdpZHRoIC8gMixcbiAgICAgICAgeTogLXBhZGRpbmcsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEhhbmRsZXJzLmluZGV4T2YoJ3RvcC1jZW50ZXInKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLnRvcC1yaWdodCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogd2lkdGggKyBwYWRkaW5nLFxuICAgICAgICB5OiAtcGFkZGluZyxcbiAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkSGFuZGxlcnMuaW5kZXhPZigndG9wLXJpZ2h0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5taWRkbGUtbGVmdCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogLXBhZGRpbmcsXG4gICAgICAgIHk6IGhlaWdodCAvIDIsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEhhbmRsZXJzLmluZGV4T2YoJ21pZGRsZS1sZWZ0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5taWRkbGUtcmlnaHQnKS5zZXRBdHRycyh7XG4gICAgICAgIHg6IHdpZHRoICsgcGFkZGluZyxcbiAgICAgICAgeTogaGVpZ2h0IC8gMixcbiAgICAgICAgdmlzaWJsZTogcmVzaXplRW5hYmxlZCAmJiBlbmFibGVkSGFuZGxlcnMuaW5kZXhPZignbWlkZGxlLXJpZ2h0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tbGVmdCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogLXBhZGRpbmcsXG4gICAgICAgIHk6IGhlaWdodCArIHBhZGRpbmcsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEhhbmRsZXJzLmluZGV4T2YoJ2JvdHRvbS1sZWZ0JykgPj0gMFxuICAgICAgfSk7XG4gICAgICB0aGlzLmZpbmRPbmUoJy5ib3R0b20tY2VudGVyJykuc2V0QXR0cnMoe1xuICAgICAgICB4OiB3aWR0aCAvIDIsXG4gICAgICAgIHk6IGhlaWdodCArIHBhZGRpbmcsXG4gICAgICAgIHZpc2libGU6IHJlc2l6ZUVuYWJsZWQgJiYgZW5hYmxlZEhhbmRsZXJzLmluZGV4T2YoJ2JvdHRvbS1jZW50ZXInKSA+PSAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluZE9uZSgnLmJvdHRvbS1yaWdodCcpLnNldEF0dHJzKHtcbiAgICAgICAgeDogd2lkdGggKyBwYWRkaW5nLFxuICAgICAgICB5OiBoZWlnaHQgKyBwYWRkaW5nLFxuICAgICAgICB2aXNpYmxlOiByZXNpemVFbmFibGVkICYmIGVuYWJsZWRIYW5kbGVycy5pbmRleE9mKCdib3R0b20tcmlnaHQnKSA+PSAwXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5maW5kT25lKCcucm90YXRlcicpLnNldEF0dHJzKHtcbiAgICAgICAgeDogd2lkdGggLyAyLFxuICAgICAgICB5OiAtdGhpcy5yb3RhdGVIYW5kbGVyT2Zmc2V0KCkgKiBLb252YS5VdGlsLl9zaWduKGhlaWdodCksXG4gICAgICAgIHZpc2libGU6IHRoaXMucm90YXRlRW5hYmxlZCgpXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5maW5kT25lKCcuYmFjaycpLnNldEF0dHJzKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgdmlzaWJsZTogdGhpcy5saW5lRW5hYmxlZCgpXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGRldGVybWluZSBpZiB0cmFuc2Zvcm1lciBpcyBpbiBhY3RpdmUgdHJhbnNmb3JtXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RyYW5zZm9ybWluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtaW5nO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU3RvcCBhY3RpdmUgdHJhbnNmb3JtIGFjdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgc3RvcFRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fdHJhbnNmb3JtaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50cygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBLb252YS5Hcm91cC5wcm90b3R5cGUuZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgIHRoaXMuX3JlbW92ZUV2ZW50cygpO1xuICAgIH0sXG4gICAgLy8gZG8gbm90IHdvcmsgYXMgYSBjb250YWluZXJcbiAgICAvLyB3ZSB3aWxsIHJlY3JlYXRlIGlubmVyIG5vZGVzIG1hbnVhbGx5XG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEtvbnZhLk5vZGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgfVxuICB9O1xuICBLb252YS5VdGlsLmV4dGVuZChLb252YS5UcmFuc2Zvcm1lciwgS29udmEuR3JvdXApO1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlUmVzaXplcnModmFsKSB7XG4gICAgaWYgKCEodmFsIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBLb252YS5VdGlsLndhcm4oJ2VuYWJsZWRIYW5kbGVycyB2YWx1ZSBzaG91bGQgYmUgYW4gYXJyYXknKTtcbiAgICB9XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YWwuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmIChSRVNJWkVSU19OQU1FUy5pbmRleE9mKG5hbWUpID09PSAtMSkge1xuICAgICAgICAgIEtvbnZhLlV0aWwud2FybihcbiAgICAgICAgICAgICdVbmtub3duIHJlc2l6ZXIgbmFtZTogJyArXG4gICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAnLiBBdmFpbGFibGUgbmFtZXMgYXJlOiAnICtcbiAgICAgICAgICAgICAgUkVTSVpFUlNfTkFNRVMuam9pbignLCAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZW5hYmxlZCBoYW5kbGVyc1xuICAgKiBAbmFtZSBlbmFibGVkSGFuZGxlcnNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0IGxpc3Qgb2YgaGFuZGxlcnNcbiAgICogdmFyIGVuYWJsZWRIYW5kbGVycyA9IHNoYXBlLmVuYWJsZWRIYW5kbGVycygpO1xuICAgKlxuICAgKiAvLyBzZXQgaGFuZGxlcnNcbiAgICogc2hhcGUuZW5hYmxlZEhhbmRsZXJzKFsndG9wLWxlZnQnLCAndG9wLWNlbnRlcicsICd0b3AtcmlnaHQnLCAnbWlkZGxlLXJpZ2h0JywgJ21pZGRsZS1sZWZ0JywgJ2JvdHRvbS1sZWZ0JywgJ2JvdHRvbS1jZW50ZXInLCAnYm90dG9tLXJpZ2h0J10pO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoXG4gICAgS29udmEuVHJhbnNmb3JtZXIsXG4gICAgJ2VuYWJsZWRIYW5kbGVycycsXG4gICAgUkVTSVpFUlNfTkFNRVMsXG4gICAgdmFsaWRhdGVSZXNpemVyc1xuICApO1xuXG4gIC8qKlxuICAgKiBnZXQvc2V0IHJlc2l6ZSBhYmlsaXR5LiBJZiBmYWxzZSBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgaGlkZSByZXNpemluZyBoYW5kbGVyc1xuICAgKiBAbmFtZSByZXNpemVFbmFibGVkXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldFxuICAgKiB2YXIgcmVzaXplRW5hYmxlZCA9IHNoYXBlLnJlc2l6ZUVuYWJsZWQoKTtcbiAgICpcbiAgICogLy8gc2V0XG4gICAqIHNoYXBlLnJlc2l6ZUVuYWJsZWQoZmFsc2UpO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVHJhbnNmb3JtZXIsICdyZXNpemVFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgYWJpbGl0eSB0byByb3RhdGUuXG4gICAqIEBuYW1lIHJvdGF0ZUVuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciByb3RhdGVFbmFibGVkID0gc2hhcGUucm90YXRlRW5hYmxlZCgpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogc2hhcGUucm90YXRlRW5hYmxlZChmYWxzZSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ3JvdGF0ZUVuYWJsZWQnLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCByb3RhdGlvbiBzbmFwcyBhbmdsZXMuXG4gICAqIEBuYW1lIHJvdGF0aW9uU25hcHNcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciByb3RhdGlvblNuYXBzID0gc2hhcGUucm90YXRpb25TbmFwcygpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogc2hhcGUucm90YXRpb25TbmFwcyhbMCwgOTAsIDE4MCwgMjcwXSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ3JvdGF0aW9uU25hcHMnLCBbXSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgZGlzdGFuY2UgZm9yIHJvdGF0aW9uIGhhbmRsZXJcbiAgICogQG5hbWUgcm90YXRlSGFuZGxlck9mZnNldFxuICAgKiBAbWV0aG9kXG4gICAqIEBtZW1iZXJvZiBLb252YS5UcmFuc2Zvcm1lci5wcm90b3R5cGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICogQHJldHVybnMge0FycmF5fVxuICAgKiBAZXhhbXBsZVxuICAgKiAvLyBnZXRcbiAgICogdmFyIHJvdGF0ZUhhbmRsZXJPZmZzZXQgPSBzaGFwZS5yb3RhdGVIYW5kbGVyT2Zmc2V0KCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiBzaGFwZS5yb3RhdGVIYW5kbGVyT2Zmc2V0KDEwMCk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ3JvdGF0ZUhhbmRsZXJPZmZzZXQnLCA1MCk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgdmlzaWJpbGl0eSBvZiBib3JkZXJcbiAgICogQG5hbWUgbGluZUVuYWJsZWRcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBsaW5lRW5hYmxlZCA9IHNoYXBlLmxpbmVFbmFibGVkKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiBzaGFwZS5saW5lRW5hYmxlZChmYWxzZSk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ2xpbmVFbmFibGVkJywgdHJ1ZSk7XG5cbiAgLyoqXG4gICAqIGdldC9zZXQgc2hvdWxkIHdlIGtlZXAgcmF0aW9uIG9mIHJlc2l6ZT9cbiAgICogQG5hbWUga2VlcFJhdGlvXG4gICAqIEBtZXRob2RcbiAgICogQG1lbWJlcm9mIEtvbnZhLlRyYW5zZm9ybWVyLnByb3RvdHlwZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAqIEBleGFtcGxlXG4gICAqIC8vIGdldFxuICAgKiB2YXIga2VlcFJhdGlvID0gc2hhcGUua2VlcFJhdGlvKCk7XG4gICAqXG4gICAqIC8vIHNldFxuICAgKiBzaGFwZS5rZWVwUmF0aW8oZmFsc2UpO1xuICAgKi9cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVHJhbnNmb3JtZXIsICdrZWVwUmF0aW8nLCB0cnVlKTtcblxuICAvKipcbiAgICogZ2V0L3NldCBwYWRkaW5nXG4gICAqIEBuYW1lIHBhZGRpbmdcbiAgICogQG1ldGhvZFxuICAgKiBAbWVtYmVyb2YgS29udmEuVHJhbnNmb3JtZXIucHJvdG90eXBlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICogQGV4YW1wbGVcbiAgICogLy8gZ2V0XG4gICAqIHZhciBwYWRkaW5nID0gc2hhcGUucGFkZGluZygpO1xuICAgKlxuICAgKiAvLyBzZXRcbiAgICogc2hhcGUucGFkZGluZygxMCk7XG4gICAqL1xuICBLb252YS5GYWN0b3J5LmFkZEdldHRlclNldHRlcihLb252YS5UcmFuc2Zvcm1lciwgJ3BhZGRpbmcnLCAwKTtcblxuICBLb252YS5GYWN0b3J5LmFkZE92ZXJsb2FkZWRHZXR0ZXJTZXR0ZXIoS29udmEuVHJhbnNmb3JtZXIsICdub2RlJyk7XG5cbiAgS29udmEuRmFjdG9yeS5hZGRHZXR0ZXJTZXR0ZXIoS29udmEuVHJhbnNmb3JtZXIsICdib3VuZEJveEZ1bmMnKTtcblxuICBLb252YS5Db2xsZWN0aW9uLm1hcE1ldGhvZHMoS29udmEuVHJhbnNmb3JtZXIpO1xufSkoS29udmEpO1xuIiwiY2xhc3MgRWRnZSB7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBlZGdlIHRvIHNvdXJjZSBhbmQgdGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIHtTc2VxQ2xhc3N9IHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtTc2VxQ2xhc3N9IHRhcmdldFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIHRhcmdldCl7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5wYWdlID0gaW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5wYWdlX21pbiA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IFwiIzAwMFwiO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGVkZ2UgaXMgZHJhd24gb24gdGhlIGdpdmVuIHBhZ2UuIE92ZXJyaWRkZW4gaW4gc3ViY2xhc3Nlcy5cclxuICAgICAqIEBwYXJhbSBwYWdlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqIEBwYWNrYWdlXHJcbiAgICAgKi9cclxuICAgIF9kcmF3T25QYWdlUShwYWdlKXtcclxuICAgICAgICByZXR1cm4gcGFnZSA8PSB0aGlzLnBhZ2UgJiYgdGhpcy5wYWdlX21pbiA8PSBwYWdlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRWRnZSA9IEVkZ2U7XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBzdHJ1Y3RsaW5lIGNsYXNzIGlzIGp1c3QgYSByZW5hbWVkIHZlcnNpb24gb2YgRWRnZS4gU28gZmFyIG5vIG1ldGhvZHMgaGVyZS4uLlxyXG4gKi9cclxuY2xhc3MgU3RydWN0bGluZSBleHRlbmRzIEVkZ2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQpe1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0KTtcclxuICAgICAgICBzb3VyY2UuX2FkZFN0cnVjdGxpbmUodGhpcyk7XHJcbiAgICAgICAgdGFyZ2V0Ll9hZGRTdHJ1Y3RsaW5lKHRoaXMpO1xyXG4gICAgfVxyXG5cclxufVxyXG5leHBvcnRzLlN0cnVjdGxpbmUgPSBTdHJ1Y3RsaW5lO1xyXG5cclxuLyoqXHJcbiAqIE9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGEgdmFuaWxsYSBlZGdlIGFuZCBhbiBFeHRlbnNpb24gaXMgdGhhdCBFeHRlbnNpb25zIGFyZSBvbmx5IGRyYXduIG9uIHRoZSBFaW5mdHkgcGFnZS5cclxuICovXHJcbmNsYXNzIEV4dGVuc2lvbiBleHRlbmRzIEVkZ2Uge1xyXG4gICAgX2RyYXdPblBhZ2VRKHBhZ2Upe1xyXG4gICAgICAgIHJldHVybiBwYWdlID09PSBpbmZpbml0eTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkV4dGVuc2lvbiA9IEV4dGVuc2lvbjtcclxuXHJcblxyXG4vKipcclxuICogRGlmZmVyZW50aWFscyBhcmUgYSBiaXQgbW9yZSBjb21wbGljYXRlZC5cclxuICovXHJcbmNsYXNzIERpZmZlcmVudGlhbCBleHRlbmRzIEVkZ2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCB0YXJnZXQsIHBhZ2Upe1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSwgdGFyZ2V0KTtcclxuICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBcIiMwMEZcIjtcclxuICAgICAgICBzb3VyY2UuX2FkZE91dGdvaW5nRGlmZmVyZW50aWFsKHRoaXMpO1xyXG4gICAgICAgIHRhcmdldC5fYWRkSW5jb21pbmdEaWZmZXJlbnRpYWwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VfbmFtZSA9IHRoaXMuc291cmNlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXRfbmFtZSA9IHRoaXMudGFyZ2V0LnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBkaWZmZXJlbnRpYWwgb24gXCJwYWdlIDBcIiBvciBvbiB0aGUgcGFnZSBjb3JyZXNwb25kaW5nIHRvIHRoZSBkaWZmZXJlbnRpYWwuXHJcbiAgICAgKiBAcGFyYW0gcGFnZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAcGFja2FnZVxyXG4gICAgICovXHJcbiAgICBfZHJhd09uUGFnZVEocGFnZSl7XHJcbiAgICAgICAgcmV0dXJuIHBhZ2UgPT09IDAgfHwgdGhpcy5wYWdlID09PSBwYWdlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgc291cmNlIG9mIGRpZmZlcmVudGlhbCBkaXNhcHBlYXJzIGFmdGVyIHRoZSBwYWdlIHRoZSBkaWZmZXJlbnRpYWwgb2NjdXJzIG9uLiBJbnN0ZWFkLCBmcm9tIG5vdyBvblxyXG4gICAgICogZGlzcGxheSB0aGUgc291cmNlIHVzaW5nIGBub2RlYC5cclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBTcGVjaWZpZXMgYW55IGNoYW5nZXMgaW4gdGhlIGRpc3BsYXkgb2Ygc291cmNlIHRoYXQgb2NjdXIgYWZ0ZXIgdGhpcyBwYWdlLlxyXG4gICAgICogQHJldHVybnMge0RpZmZlcmVudGlhbH0gQ2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIHNldEtlcm5lbChub2RlKXtcclxuICAgICAgICB0aGlzLnNvdXJjZS5yZXBsYWNlKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3lub255bSBmb3Igc2V0S2VybmVsLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcmV0dXJucyB7RGlmZmVyZW50aWFsfSBDaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgcmVwbGFjZVNvdXJjZShub2RlKXtcclxuICAgICAgICB0aGlzLnNldEtlcm5lbChub2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRhcmdldCBvZiBkaWZmZXJlbnRpYWwgZGlzYXBwZWFycyBhZnRlciB0aGUgcGFnZSB0aGUgZGlmZmVyZW50aWFsIG9jY3VycyBvbi4gSW5zdGVhZCwgZnJvbSBub3cgb25cclxuICAgICAqIGRpc3BsYXkgdGhlIHRhcmdldCB1c2luZyBgbm9kZWAuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgU3BlY2lmaWVzIGFueSBjaGFuZ2VzIGluIHRoZSBkaXNwbGF5IG9mIHRhcmdldCB0aGF0IG9jY3VyIGFmdGVyIHRoaXMgcGFnZS5cclxuICAgICAqIEByZXR1cm5zIHtEaWZmZXJlbnRpYWx9IENoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBzZXRDb2tlcm5lbChub2RlKXtcclxuICAgICAgICB0aGlzLnRhcmdldC5yZXBsYWNlKG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3lub255bSBmb3Igc2V0Q29rZXJuZWwuXHJcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcclxuICAgICAqIEByZXR1cm5zIHtEaWZmZXJlbnRpYWx9IENoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICByZXBsYWNlVGFyZ2V0KG5vZGUpe1xyXG4gICAgICAgIHRoaXMuc2V0Q29rZXJuZWwobm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbmFtZSBvZiB0aGUgdGFyZ2V0IGZvciB1c2UgaW4gZGV0ZXJtaW5pbmcgdGhlIG5hbWUgb2YgdGhlIGRpZmZlcmVudGlhbC4gQnkgZGVmYXVsdCB0aGUgdGFyZ2V0X25hbWVcclxuICAgICAqIGlzIHRoZSBuYW1lIG9mIHRoZSB0YXJnZXQgY2xhc3MsIGJ1dCBwYXJ0aWN1bGFybHkgaWYgdGhlcmUgaXMgYSBjb2tlcm5lbCBpdCBzaG91bGQgcG90ZW50aWFsbHkgYmUgc29tZXRoaW5nIGVsc2VcclxuICAgICAqIGZvciBpbnN0YW5jZSwgaWYgdGhlIGRpZmZlcmVudGlhbCBpcyBtdWx0aXBsaWNhdGlvbiBieSBwLCB0aGUgdGFyZ2V0IGNsYXNzIG1pZ2h0IGJlIG5hbWVkIGB4YCBidXQgdGhlIHRhcmdldFxyXG4gICAgICogc2hvdWxkIGJlIGBweGAuXHJcbiAgICAgKiBAcGFyYW0gbmFtZVxyXG4gICAgICogQHJldHVybnMge0RpZmZlcmVudGlhbH0gY2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIHNldFRhcmdldE5hbWUobmFtZSl7XHJcbiAgICAgICAgdGhpcy50YXJnZXRfbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJIGRvbid0IGtub3cgaWYgdGhpcyBpcyB1c2VmdWwsIGp1c3QgaW5jbHVkZWQgZm9yIHN5bW1ldHJ5IHdpdGggc2V0VGFyZ2V0TmFtZS5cclxuICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgKiBAcmV0dXJucyB7RGlmZmVyZW50aWFsfSBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgc2V0U291cmNlTmFtZShuYW1lKXtcclxuICAgICAgICB0aGlzLnNvdXJjZV9uYW1lID0gbmFtZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcblxyXG4vLyAgICBoaXRNZXNzYWdlKCl7XHJcbi8vICAgICAgICByZXR1cm4gXCJoaXQgb24gcGFnZSAlZCBieSBjbGFzcyAlclwiICUgKHRoaXMucGFnZSwgdGhpcy5zb3VyY2UpO1xyXG4vLyAgICB9XHJcbi8vXHJcbi8vICAgIHN1cHBvcnRlZE1lc3NhZ2UoKXtcclxuLy8gICAgICAgIHJldHVybiBcInN1cHBvcnRlZCBhIGRpZmZlcmVudGlhbCBvbiBwYWdlICVkIGhpdHRpbmcgY2xhc3MgJXJcIiAlICh0aGlzLnBhZ2UsIHRoaXMudGFyZ2V0KTtcclxuLy8gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIG5hbWUgb2YgdGhpcyBkaWZmZXJudGlhbCB0byB0aGUgZXh0cmFfaW5mbyBmb3IgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IGNsYXNzIChzbyB0aGF0IGl0IGdldHMgZGlzcGxheWVkXHJcbiAgICAgKiBpbiBhIHRvb2x0aXApLiBNYXliZSB3ZSBzaG91bGQgZG8gdGhpcyBieSBkZWZhdWx0P1xyXG4gICAgICogQHJldHVybnMge0RpZmZlcmVudGlhbH0gY2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIGFkZEluZm9Ub1NvdXJjZUFuZFRhcmdldCgpe1xyXG4gICAgICAgIHRoaXMuc291cmNlLmFkZEV4dHJhSW5mbyh0aGlzKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5hZGRFeHRyYUluZm8odGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBpZiB3ZSB1c2UgXCJyZXBsYWNlXCIgb24gdGhlIHNvdXJjZSBjbGFzcyAob3IgcmVwbGFjZVNvdXJjZSwgc2V0S2VybmVsKSwgYW55IHN0cnVjdGxpbmVzIHdpbGwgY29udGludWUgdG8gYmUgZHJhd24uXHJcbiAgICAgKiBJZiB0aGF0J3MgaW5hcHByb3ByaWF0ZSwgY2FsbCB0aGlzIHRvIGtpbGwgdGhlIHN0cnVjdGxpbmVzIGNvbm5lY3RpbmcgdG8gdGhlIHNvdXJjZSBhZnRlciB0aGlzIHBhZ2UuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlmZmVyZW50aWFsfSBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgc2V0U291cmNlU3RydWN0bGluZVBhZ2VzKCl7XHJcbiAgICAgICAgdGhpcy5zb3VyY2Uuc2V0U3RydWN0bGluZVBhZ2VzKHRoaXMucGFnZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgaWYgd2UgdXNlIFwicmVwbGFjZVwiIG9uIHRoZSB0YXJnZXQgY2xhc3MgKG9yIHJlcGxhY2VUYXJnZXQsIHNldENva2VybmVsKSwgYW55IHN0cnVjdGxpbmVzIHdpbGwgY29udGludWUgdG8gYmUgZHJhd24uXHJcbiAgICAgKiBJZiB0aGF0J3MgaW5hcHByb3ByaWF0ZSwgY2FsbCB0aGlzIHRvIGtpbGwgdGhlIHN0cnVjdGxpbmVzIGNvbm5lY3RpbmcgdG8gdGhlIHRhcmdldCBhZnRlciB0aGlzIHBhZ2UuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlmZmVyZW50aWFsfSBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgc2V0VGFyZ2V0U3RydWN0bGluZVBhZ2VzKCl7XHJcbiAgICAgICAgdGhpcy50YXJnZXQuc2V0U3RydWN0bGluZVBhZ2VzKHRoaXMucGFnZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEb2VzIGJvdGggc2V0U291cmNlU3RydWN0bGluZVBhZ2VzIGFuZCBzZXRUYXJnZXRTdHJ1Y3RsaW5lUGFnZXNcclxuICAgICAqIEByZXR1cm5zIHtEaWZmZXJlbnRpYWx9IGNoYWluYWJsZVxyXG4gICAgICovXHJcbiAgICBzZXRTdHJ1Y3RsaW5lUGFnZXMoKXtcclxuICAgICAgICB0aGlzLnNvdXJjZS5zZXRTdHJ1Y3RsaW5lUGFnZXModGhpcy5wYWdlKTtcclxuICAgICAgICB0aGlzLnRhcmdldC5zZXRTdHJ1Y3RsaW5lUGFnZXModGhpcy5wYWdlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICB0b1N0cmluZygpe1xyXG4gICAgICAgIHJldHVybiBgXFxcXChkX3ske3RoaXMucGFnZX19KCR7dGhpcy5zb3VyY2VfbmFtZX0pID0gJHt0aGlzLnRhcmdldF9uYW1lfVxcXFwpYDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkRpZmZlcmVudGlhbCA9IERpZmZlcmVudGlhbDsiLCJleHBvcnRzLmNpcmNsZSA9IHtcclxuICAgIGRyYXcgOiBmdW5jdGlvbihjb250ZXh0KSB7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmFyYygwLCAwLCB0aGlzLnNpemUoKSwgMCwgMiAqIE1hdGguUEksIGZhbHNlKTtcclxuICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0cm9rZVNoYXBlKHRoaXMpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0cy5zcXVhcmUgPSB7XHJcbiAgICBkcmF3IDogZnVuY3Rpb24oY29udGV4dCkge1xyXG4gICAgICAgIGxldCBzaXplID0gdGhpcy5zaXplKCk7XHJcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LnJlY3QoLXNpemUsIC1zaXplLCAyKnNpemUsIDIqc2l6ZSk7XHJcbiAgICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHJva2VTaGFwZSh0aGlzKTtcclxuICAgIH1cclxufSIsIlwidXNlIHN0cmljdFwiO1xyXG5sZXQgU2hhcGVzID0gcmVxdWlyZShcIi4vU2hhcGUuanNcIik7XHJcbmxldCBTc2VxQ2xhc3NqcyA9IHJlcXVpcmUoXCIuL1NzZXFDbGFzcy5qc1wiKTtcclxubGV0IFNzZXFDbGFzcyA9IFNzZXFDbGFzc2pzLlNzZXFDbGFzcztcclxubGV0IE5vZGUgPSBTc2VxQ2xhc3Nqcy5Ob2RlO1xyXG5sZXQgRWRnZXMgPSByZXF1aXJlKFwiLi9FZGdlcy5qc1wiKTtcclxubGV0IEVkZ2UgPSBFZGdlcy5FZGdlO1xyXG5sZXQgU3RydWN0bGluZSA9IEVkZ2VzLlN0cnVjdGxpbmU7XHJcbmxldCBFeHRlbnNpb24gPSBFZGdlcy5FeHRlbnNpb247XHJcbmxldCBEaWZmZXJlbnRpYWwgPSBFZGdlcy5EaWZmZXJlbnRpYWw7XHJcblxyXG5jb25zdCBTdHJpbmdpZnlpbmdNYXAgPSByZXF1aXJlKFwiLi9TdHJpbmdpZnlpbmdNYXAuanNcIik7XHJcblxyXG4vKipcclxuICogTWFwIG1ldGhvZCBnZXQgd2l0aCBkZWZhdWx0LlxyXG4gKiBAcGFyYW0ga2V5XHJcbiAqIEBwYXJhbSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Kn1cclxuICovXHJcbk1hcC5wcm90b3R5cGUuZ2V0T3JFbHNlID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gIHJldHVybiB0aGlzLmhhcyhrZXkpID8gdGhpcy5nZXQoa2V5KSA6IHZhbHVlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gZW50cnkgdG8gYSBtYXAga2V5cyA9PT4gbGlzdHMuXHJcbiAqIElmIHRoZSBjdXJyZW50IGtleSBpc24ndCBwcmVzZW50IGluIHRoZSBtYXAsIGFkZCBhbiBlbXB0eSBsaXN0IGZpcnN0LlxyXG4gKiBAcGFyYW0gZGljdGlvbmFyeSBUaGUgZGljdGlvbmFyeSBvZiBsaXN0cyB0byBhZGQgdGhlIGVudHJ5IHRvXHJcbiAqIEBwYXJhbSBrZXlcclxuICogQHBhcmFtIHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRUb0RpY3Rpb25hcnlPZkxpc3RzKGRpY3Rpb25hcnksIGtleSx2YWx1ZSl7XHJcbiAgICBpZighZGljdGlvbmFyeS5oYXMoa2V5KSl7XHJcbiAgICAgICAgZGljdGlvbmFyeS5zZXQoa2V5LCBbXSk7XHJcbiAgICB9XHJcbiAgICBkaWN0aW9uYXJ5LmdldChrZXkpLnB1c2godmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogTWFrZSBhIHN0cmluZyBmcm9tIGEgbGlzdCBvZiB2YXJpYWJsZSBuYW1lcyBhbmQgYSBsaXN0IG9mIGV4cG9uZW50cy5cclxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHZhcnMgVGhlIGxpc3Qgb2YgdmFyaWFibGUgbmFtZXNcclxuICogQHBhcmFtIHtBcnJheXxpbnR9IGV4cG9uZW50c1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbmFtZSBvZiB0aGUgbW9ub21pYWxcclxuICovXHJcbmZ1bmN0aW9uIG1vbm9taWFsU3RyaW5nKHZhcnMsIGV4cG9uZW50cyl7XHJcbiAgICBsZXQgb3V0ID0gW107XHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgaWYoZXhwb25lbnRzW2ldID09PSAwKXtcclxuICAgICAgICAgICAgb3V0W2ldID0gXCJcIjtcclxuICAgICAgICB9IGVsc2UgaWYoZXhwb25lbnRzW2ldPT09MSl7XHJcbiAgICAgICAgICAgIG91dFtpXSA9IHZhcnNbaV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgb3V0W2ldID0gYCR7dmFyc1tpXX1eeyR7ZXhwb25lbnRzW2ldfX1gO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxldCBvdXRTdHIgPSBvdXQuZmlsdGVyKHMgPT4gIHMgIT09IFwiXCIpLmpvaW4oXCIgXCIpO1xyXG4gICAgaWYoIG91dFN0ciA9PT0gXCJcIiApe1xyXG4gICAgICAgIG91dFN0ciA9IFwiMVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dFN0cjtcclxufVxyXG5cclxuXHJcbmNsYXNzIFNzZXEge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYWtlIGEgc3BlY3RyYWwgc2VxdWVuY2Ugb2JqZWN0LlxyXG4gICAgICogS2V5IHByb3BlcnRpZXM6XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcigpe1xyXG4gICAgICAgIHRoaXMudG90YWxfY2xhc3NlcyA9IDA7XHJcbiAgICAgICAgdGhpcy5jbGFzc2VzX2J5X2RlZ3JlZSA9IG5ldyBTdHJpbmdpZnlpbmdNYXAoKTtcclxuICAgICAgICB0aGlzLm51bV9jbGFzc2VzX2J5X2RlZ3JlZSA9IG5ldyBTdHJpbmdpZnlpbmdNYXAoKTtcclxuICAgICAgICB0aGlzLmNsYXNzZXNfYnlfc3RlbSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmNsYXNzZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0cnVjdGxpbmVzID0gW107XHJcbiAgICAgICAgdGhpcy5kaWZmZXJlbnRpYWxzID0gW107XHJcbiAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheV9jbGFzc2VzID0gW107ICAgICAgICBcclxuICAgICAgICB0aGlzLmRpc3BsYXlfc3RydWN0bGluZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlfZGlmZmVyZW50aWFscyA9IFtdO1xyXG4gICAgICAgIHRoaXMueHNoaWZ0ID0gMDtcclxuICAgICAgICB0aGlzLnlzaGlmdCA9IDA7ICAgICAgICBcclxuICAgICAgICB0aGlzLm9mZnNldF9zaXplID0gMTA7XHJcbiAgICAgICAgdGhpcy5wYWdlX2xpc3QgPSBbMCxpbmZpbml0eV07XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0X25vZGUgPSBuZXcgTm9kZSgpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdF9ub2RlLmZpbGwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdF9ub2RlLnN0cm9rZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0X25vZGUuc2hhcGUgPSBTaGFwZXMuY2lyY2xlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdF9ub2RlLnNpemUgPSA2O1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbiA9IGZ1bmN0aW9uKHNzY2xhc3Mpe1xyXG4gICAgICAgICAgICByZXR1cm4gW3NzY2xhc3MuZGVncmVlLngsIHNzY2xhc3MuZGVncmVlLnldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzZXRfc2hpZnQoeCwgeSl7XHJcbiAgICAgICAgdGhpcy54c2hpZnQgPSB4O1xyXG4gICAgICAgIHRoaXMueXNoaWZ0ID0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgfVxyXG5cclxuICAgYWRkX3RvX3NoaWZ0KHgsIHkpe1xyXG4gICAgICAgIHRoaXMueHNoaWZ0ICs9IHg7XHJcbiAgICAgICAgdGhpcy55c2hpZnQgKz0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGNsYXNzIGluIHBvc2l0aW9uICh4LHkpIGFuZCByZXR1cm4gdGhlIGNsYXNzLiBVc2VzIHNzZXEuZGVmYXVsdF9ub2RlIGZvciBkaXNwbGF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IFRoZSB4IHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHJldHVybnMge1NzZXFDbGFzc30gVGhlIG5ldyBjbGFzc1xyXG4gICAgICovXHJcbiAgICBhZGRDbGFzcyh4LCB5KXtcclxuICAgICAgICBsZXQgZGVncmVlO1xyXG4gICAgICAgIGlmKHkgPT09IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgIGRlZ3JlZSA9IHg7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IHggKyB0aGlzLnhzaGlmdDtcclxuICAgICAgICAgICAgeSA9IHkgKyB0aGlzLnlzaGlmdDtcclxuICAgICAgICAgICAgZGVncmVlID0ge3g6IHgsIHk6IHl9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYyA9IG5ldyBTc2VxQ2xhc3ModGhpcywgZGVncmVlKTtcclxuICAgICAgICBsZXQgaWR4ICA9IHRoaXMubnVtX2NsYXNzZXNfYnlfZGVncmVlLmdldE9yRWxzZShjLnByb2plY3Rpb24sIDApO1xyXG4gICAgICAgIHRoaXMubnVtX2NsYXNzZXNfYnlfZGVncmVlLnNldChjLnByb2plY3Rpb24sIGlkeCArIDEpO1xyXG4gICAgICAgIGMuaWR4ID0gaWR4O1xyXG4gICAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKGMpO1xyXG4gICAgICAgIGFkZFRvRGljdGlvbmFyeU9mTGlzdHModGhpcy5jbGFzc2VzX2J5X2RlZ3JlZSwgZGVncmVlLCBjKTtcclxuICAgICAgICBhZGRUb0RpY3Rpb25hcnlPZkxpc3RzKHRoaXMuY2xhc3Nlc19ieV9zdGVtLCBjLnggLCBjKTtcclxuICAgICAgICB0aGlzLnRvdGFsX2NsYXNzZXMgKys7XHJcbiAgICAgICAgcmV0dXJuIGM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBhbiBpbnRlcm5hbCBtZXRob2QgdXNlZCBieSBkaXNwbGF5IHRvIGNhbGN1bGF0ZSB0aGUgc2V0IG9mIGZlYXR1cmVzIHRvIGJlIGRpc3BsYXllZCBvbiB0aGUgY3VycmVudCBwYWdlLlxyXG4gICAgICogQHBhcmFtIHBhZ2VcclxuICAgICAqIEBwYXJhbSB4bWluXHJcbiAgICAgKiBAcGFyYW0geG1heFxyXG4gICAgICogQHBhcmFtIHltaW5cclxuICAgICAqIEBwYXJhbSB5bWF4XHJcbiAgICAgKiBAcGFja2FnZVxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlRHJhd25FbGVtZW50cyhwYWdlLCB4bWluLCB4bWF4LCB5bWluLCB5bWF4KXtcclxuICAgICAgICB0aGlzLmRpc3BsYXlfY2xhc3NlcyA9IHRoaXMuY2xhc3Nlcy5maWx0ZXIoYyA9PiB7Yy5pbl9yYW5nZSA9IGMuX2luUmFuZ2VRKHhtaW4sIHhtYXgsIHltaW4sIHltYXgpOyByZXR1cm4gYy5pbl9yYW5nZSAmJiBjLl9kcmF3T25QYWdlUShwYWdlKTt9KTtcclxuICAgICAgICB0aGlzLmRpc3BsYXlfZWRnZXMgPSB0aGlzLmVkZ2VzLmZpbHRlcihlID0+IFxyXG4gICAgICAgICAgICAgZS5fZHJhd09uUGFnZVEocGFnZSlcclxuICAgICAgICAgICYmIGUuc291cmNlLl9kcmF3T25QYWdlUShwYWdlKSAmJiBlLnRhcmdldC5fZHJhd09uUGFnZVEocGFnZSlcclxuICAgICAgICAgICYmICggZS5zb3VyY2UuaW5fcmFuZ2UgfHwgZS50YXJnZXQuaW5fcmFuZ2UgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuZGlzcGxheV9lZGdlcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBlID0gdGhpcy5kaXNwbGF5X2VkZ2VzW2ldO1xyXG4gICAgICAgICAgICBpZighZS5zb3VyY2UuaW5fcmFuZ2Upe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5X2NsYXNzZXMucHVzaChlLnNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoIWUudGFyZ2V0LmluX3JhbmdlKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheV9jbGFzc2VzLnB1c2goZS50YXJnZXQpO1xyXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXHJcbiAgICAgICAgfSAgICAgIFxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgcmVjYWxjdWxhdGVkIGJ5IF9jYWxjdWxhdGVEcmF3bkVsZW1lbnRzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fFNzZXFDbGFzc30gVGhlIGxpc3Qgb2YgY2xhc3NlcyBjdXJyZW50bHkgYmVpbmcgZGlzcGxheWVkLlxyXG4gICAgICovXHJcbiAgICBnZXRDbGFzc2VzVG9EaXNwbGF5KCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheV9jbGFzc2VzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdldHMgcmVjYWxjdWxhdGVkIGJ5IF9jYWxjdWxhdGVEcmF3bkVsZW1lbnRzLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fEVkZ2V9IFRoZSBsaXN0IG9mIGVkZ2VzIGN1cnJlbnRseSBiZWluZyBkaXNwbGF5ZWQuXHJcbiAgICAgKi9cclxuICAgIGdldEVkZ2VzVG9EaXNwbGF5KCl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheV9lZGdlcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdHJ1Y3RsaW5lIGZyb20gc291cmNlIHRvIHRhcmdldC5cclxuICAgICAqIEBwYXJhbSBzb3VyY2VcclxuICAgICAqIEBwYXJhbSB0YXJnZXRcclxuICAgICAqIEByZXR1cm5zIHtTdHJ1Y3RsaW5lfSB0aGUgc3RydWN0bGluZSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgYWRkU3RydWN0bGluZShzb3VyY2UsIHRhcmdldCl7XHJcbi8vICAgICAgICBpZihzb3VyY2UgPT0gdW5kZWZpbmVkKXtcclxuLy8gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmxhc3RfY2xhc3Nlc1swXVxyXG4vLyAgICAgICAgICAgIHRhcmdldCA9IHRoaXMubGFzdF9jbGFzc2VzWzFdXHJcbi8vICAgICAgICB9IGVsc2UgaWYodGFyZ2V0ID09IHVuZGVmaW5lZCl7XHJcbi8vICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5sYXN0X2NsYXNzZXNbMF1cclxuLy8gICAgICAgIH1cclxuICAgICAgICBpZighc291cmNlIHx8ICF0YXJnZXQpe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHN0cnVjdCA9IG5ldyBTdHJ1Y3RsaW5lKHNvdXJjZSx0YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuc3RydWN0bGluZXMucHVzaChzdHJ1Y3QpO1xyXG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChzdHJ1Y3QpO1xyXG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgZGlmZmVyZW50aWFsLlxyXG4gICAgICogQHBhcmFtIHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHRhcmdldFxyXG4gICAgICogQHBhcmFtIHBhZ2VcclxuICAgICAqIEByZXR1cm5zIHtEaWZmZXJlbnRpYWx9XHJcbiAgICAgKi9cclxuICAgYWRkRGlmZmVyZW50aWFsKHNvdXJjZSwgdGFyZ2V0LCBwYWdlKXtcclxuICAgICAgICBpZihwYWdlIDw9IDApe1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vIHBhZ2UgPD0gMCBkaWZmZXJlbnRpYWxzIGFsbG93ZWQuXCIpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYoIXNvdXJjZSB8fCAhdGFyZ2V0KXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfSAgICAgICAgXHJcbiAgICAgICAgbGV0IGRpZmZlcmVudGlhbCA9IG5ldyBEaWZmZXJlbnRpYWwoc291cmNlLCB0YXJnZXQsIHBhZ2UpO1xyXG4gICAgICAgIHRoaXMuZGlmZmVyZW50aWFscy5wdXNoKGRpZmZlcmVudGlhbCk7XHJcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGRpZmZlcmVudGlhbCk7XHJcbiAgICAgICAgdGhpcy5hZGRQYWdlVG9QYWdlTGlzdChwYWdlKTtcclxuICAgICAgICByZXR1cm4gZGlmZmVyZW50aWFsO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBleHRlbnNpb24uXHJcbiAgICAgKiBAcGFyYW0gc291cmNlXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0XHJcbiAgICAgKiBAcmV0dXJucyB7RXh0ZW5zaW9ufVxyXG4gICAgICovXHJcbiAgIGFkZEV4dGVuc2lvbihzb3VyY2UsIHRhcmdldCl7XHJcbiAgICAgICAgaWYoIXNvdXJjZSB8fCAhdGFyZ2V0KXtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBleHQgPSBuZXcgRXh0ZW5zaW9uKHNvdXJjZSwgdGFyZ2V0KTtcclxuICAgICAgICB0aGlzLmVkZ2VzLnB1c2goZXh0KTtcclxuICAgICAgICByZXR1cm4gZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGRpc3BsYXkgcHVycG9zZXMsIGEgU3NlcSBvYmplY3QgbWFpbnRhaW5zIGEgbGlzdCBvZiBwYWdlcyBvbiB3aGljaCBzb21ldGhpbmcgY2hhbmdlcyBpbiB0aGUgc3BlY3RyYWwgc2VxdWVuY2UuXHJcbiAgICAgKiBDdXJyZW50bHkgdGhpcyBsaXN0IGFsd2F5cyBjb250YWlucyAwLCBpbmZpbml0eSwgYW5kIHRoZSBzZXQgb2YgcGFnZXMgb24gd2hpY2ggZGlmZmVyZW50aWFscyBsaXZlLlxyXG4gICAgICogQHBhcmFtIHBhZ2VcclxuICAgICAqIEByZXR1cm5zIHtTc2VxfSBjaGFpbmFibGVcclxuICAgICAqL1xyXG4gICBhZGRQYWdlVG9QYWdlTGlzdChwYWdlKXtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5wYWdlX2xpc3QubGVuZ3RoOyBpKyspe1xyXG4gICAgICAgICAgICBpZih0aGlzLnBhZ2VfbGlzdFtpXSA+IHBhZ2Upe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlX2xpc3Quc3BsaWNlKGksIDAsIHBhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKHRoaXMucGFnZV9saXN0W2ldID49IHBhZ2Upe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdmFyX2RlZ3JlZV9kaWN0IC0tIE9iamVjdCB3aXRoIGJpZGVncmVlcyBvZiB0aGUgZ2VuZXJhdG9ycywgb2YgdGhlIGZvcm0gYFwidmFyX25hbWVcIiA6IFtzdGVtLCBmaWx0cmF0aW9uXWBcclxuICAgICAqIEBwYXJhbSB2YXJfc3BlY19saXN0IC0tIExpc3Qgb2YgcmFuZ2Ugc3BlY2lmaWNhdGlvbnMuIEVhY2ggcmFuZ2Ugc3BlY2lmaWNhdGlvbiBpcyBhIGxpc3Qgb2YgdGhlIGZvcm1cclxuICAgICAqICBgW1widmFyX25hbWVcIiwgbWluLCBtYXgsIHN0ZXBdYCB3aGVyZSBgbWluYCBkZWZhdWx0cyB0byAwIGFuZCBgc3RlcGAgZGVmYXVsdHMgdG8gMS5cclxuICAgICAqIEBwYXJhbSBjb25kXHJcbiAgICAgKiBAcmV0dXJucyB7bW9ub21pYWxfYmFzaXN9IEEgbW9ub21pYWxfYmFzaXMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHNldCBvZiBjbGFzc2VzIHNvIGdlbmVyYXRlZC5cclxuICAgICAqL1xyXG4gICBhZGRQb2x5bm9taWFsQ2xhc3Nlcyh2YXJfZGVncmVlX2RpY3QsdmFyX3NwZWNfbGlzdCwgY29uZCl7XHJcbiAgICAgICAgbGV0IHZhcl9uYW1lX2xpc3QgPSBbXTtcclxuICAgICAgICBsZXQgc3RlbV9saXN0ID0gW107XHJcbiAgICAgICAgbGV0IGZpbHRyYXRpb25fbGlzdCA9IFtdO1xyXG4gICAgICAgIGxldCByYW5nZV9saXN0ID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yKGxldCBpPTA7IGk8dmFyX3NwZWNfbGlzdC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCB2YXJfc3BlYyA9IHZhcl9zcGVjX2xpc3RbaV07XHJcbiAgICAgICAgICAgIGxldCB2YXJfbmFtZSA9IHZhcl9zcGVjWzBdO1xyXG4gICAgICAgICAgICBpZighdmFyX2RlZ3JlZV9kaWN0Lmhhc093blByb3BlcnR5KHZhcl9uYW1lKSl7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBcIk5vIGJpZGVncmVlIHNwZWNpZmllZCBmb3IgdmFyaWFibGUgJ1wiICsgdmFyX25hbWUgKyBcIicuXCJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXJfbmFtZV9saXN0LnB1c2godmFyX25hbWUpO1xyXG4gICAgICAgICAgICBzdGVtX2xpc3QucHVzaCh2YXJfZGVncmVlX2RpY3RbdmFyX25hbWVdWzBdKTtcclxuICAgICAgICAgICAgZmlsdHJhdGlvbl9saXN0LnB1c2godmFyX2RlZ3JlZV9kaWN0W3Zhcl9uYW1lXVsxXSk7XHJcbiAgICAgICAgICAgIHJhbmdlX2xpc3QucHVzaChyYW5nZSguLi52YXJfc3BlYy5zbGljZSgxKSkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNsYXNzX2RpY3QgPSBuZXcgbW9ub21pYWxfYmFzaXModGhpcywgdmFyX25hbWVfbGlzdCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIGxldCBsID0gcHJvZHVjdCguLi5yYW5nZV9saXN0KTtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBtb25vbWlhbF9leHBvbmVudHMgPSBsW2ldO1xyXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBkb3QgcHJvZHVjdCBoZXJlLi4uXHJcbiAgICAgICAgICAgIGxldCBzdGVtID0gZG90X3Byb2R1Y3QobW9ub21pYWxfZXhwb25lbnRzLCBzdGVtX2xpc3QpO1xyXG4gICAgICAgICAgICBsZXQgZmlsdHJhdGlvbiA9IGRvdF9wcm9kdWN0KG1vbm9taWFsX2V4cG9uZW50cywgZmlsdHJhdGlvbl9saXN0KTtcclxuICAgICAgICAgICAgaWYodGhpcy54UmFuZ2Upe1xyXG4gICAgICAgICAgICAgICAgaWYoc3RlbSA8IHRoaXMueFJhbmdlWzBdIC0xMCB8fCBzdGVtID4gdGhpcy54UmFuZ2VbMV0gKyAxMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoY29uZCAmJiBjb25kKCkpe1xyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0aGlzLnlSYW5nZSAmJiB0aGlzLm1heF9kaWZmZXJlbnRpYWxfbGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIGlmKGZpbHRyYXRpb24gPiB0aGlzLnlSYW5nZVsxXSArIHRoaXMubWF4X2RpZmZlcmVudGlhbF9sZW5ndGggfHwgZmlsdHJhdGlvbiA8IHRoaXMueVJhbmdlWzBdKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgbmFtZSA9IG1vbm9taWFsU3RyaW5nKHZhcl9uYW1lX2xpc3QsbW9ub21pYWxfZXhwb25lbnRzKTtcclxuICAgICAgICAgICAgY2xhc3NfZGljdC5fYWRkX2NsYXNzKG1vbm9taWFsX2V4cG9uZW50cywgbmFtZSwgdGhpcy5hZGRDbGFzcyhzdGVtLGZpbHRyYXRpb24pLnNldE5hbWUobmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NfZGljdDsgXHJcbiAgIH1cclxuICAgIFxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIE1ha2UgYW4gYXJyYXkgYmFzZWQgb24gdGhlIGdpdmVuIHN0YXJ0LCBzdG9wLCBzdGVwXHJcbiAqIEBwYXJhbSBzdGFydFxyXG4gKiBAcGFyYW0gc3RvcFxyXG4gKiBAcGFyYW0gc3RlcFxyXG4gKiBAcmV0dXJucyB7QXJyYXl8aW50fVxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZ2Uoc3RhcnQsIHN0b3AsIHN0ZXAgPSAxKXtcclxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpe1xyXG4gICAgICAgIHN0YXJ0ID0gMTtcclxuICAgICAgICBzdG9wID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIHN0ZXAgPSAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0ICsgc3RlcCkvc3RlcCkpLmZpbGwoc3RhcnQpLm1hcCgoeCwgeSkgPT4geCArIHkgKiBzdGVwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcHJvZHVjdCgpIHtcclxuICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gbWFrZXMgYXJyYXkgZnJvbSBhcmd1bWVudHNcclxuICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gdGwgKGFjY3VtdWxhdG9yLCB2YWx1ZSkge1xyXG4gICAgICBjb25zdCB0bXAgPSBbXTtcclxuICAgICAgYWNjdW11bGF0b3IuZm9yRWFjaChmdW5jdGlvbiAoYTApIHtcclxuICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoYTEpIHtcclxuICAgICAgICB0bXAucHVzaChhMC5jb25jYXQoYTEpKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB0bXA7XHJcbiAgfSwgW1tdXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWN0b3JzIG9mIHRoZSBzYW1lIGxlbmd0aFxyXG4gKiBAcGFyYW0ge0FycmF5fGludH0ga1xyXG4gKiBAcGFyYW0ge0FycmF5fGludH0gbFxyXG4gKiBAcmV0dXJucyB7aW50fSB0aGUgZG90IHByb2R1Y3Qgb2YgayBhbmQgbC5cclxuICovXHJcbmZ1bmN0aW9uIGRvdF9wcm9kdWN0KGssbCl7XHJcbiAgICBsZXQgcyA9IDA7XHJcbiAgICBmb3IobGV0IGk9MDsgaTxrLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBzICs9IGtbaV0gKiBsW2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGQgdHdvIHZlY3RvcnMgb2YgdGhlIHNhbWUgbGVuZ3RoLlxyXG4gKiBAcGFyYW0ge0FycmF5fGludH0ga1xyXG4gKiBAcGFyYW0ge0FycmF5fGludH0gbFxyXG4gKiBAcmV0dXJucyB7QXJyYXl8aW50fSBUaGUgc3VtIGsgKyBsLlxyXG4gKi9cclxuZnVuY3Rpb24gdmVjdG9yU3VtKGssbCl7XHJcbiAgICBsZXQgb3V0ID0gW107XHJcbiAgICBmb3IobGV0IGk9MDsgaTxrLmxlbmd0aDsgaSsrKXtcclxuICAgICAgICBvdXQucHVzaChrW2ldK2xbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dDtcclxufVxyXG5cclxuXHJcbmNsYXNzIG1vbm9taWFsX2Jhc2lzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RydWN0IGEgbW9ub21pYWxfYmFzaXMuXHJcbiAgICAgKiBAcGFyYW0gc3NlcSBQYXJlbnQgc3BlY3RyYWwgc2VxdWVuY2UuXHJcbiAgICAgKiBAcGFyYW0gdmFyaWFibGVfbGlzdCBUaGUgbGlzdCBvZiB2YXJpYWJsZSBuYW1lcyBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSByZWZlcnJlZCB0byBieSB2ZWN0b3JzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioc3NlcSwgdmFyaWFibGVfbGlzdCl7XHJcbiAgICAgICAgdGhpcy5zc2VxID0gc3NlcTtcclxuICAgICAgICB0aGlzLl90dXBsZXNfdG9fY2xhc3NlcyA9IG5ldyBTdHJpbmdpZnlpbmdNYXAoKTtcclxuICAgICAgICB0aGlzLl9zdHJpbmdzX3RvX2NsYXNzZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdHVwbGVzX3RvX3N0cmluZ3MgPSBuZXcgU3RyaW5naWZ5aW5nTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fc3RyaW5nc190b190dXBsZXMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMudmFyaWFibGVfbGlzdCA9IHZhcmlhYmxlX2xpc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBjbGFzcyB0byB0aGUgYmFzaXMuXHJcbiAgICAgKiBAcGFyYW0gdHVwbGUgVGhlIHZlY3RvciBvZiBwb3dlcnMgb2YgZWFjaCB2YXJpYWJsZSBpbiB0aGUgbW9ub21pYWxcclxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBjbGFzcy5cclxuICAgICAqIEBwYXJhbSB0aGVfY2xhc3MgVGhlIGNsYXNzXHJcbiAgICAgKiBAcGFja2FnZVxyXG4gICAgICovXHJcbiAgICBfYWRkX2NsYXNzKHR1cGxlLCBuYW1lLCB0aGVfY2xhc3Mpe1xyXG4gICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICAgICAgdGhpcy5fdHVwbGVzX3RvX2NsYXNzZXMuc2V0KHR1cGxlLCB0aGVfY2xhc3MpO1xyXG4gICAgICAgIHRoaXMuX3N0cmluZ3NfdG9fY2xhc3Nlcy5zZXQobmFtZSwgdGhlX2NsYXNzKTtcclxuICAgICAgICB0aGlzLl90dXBsZXNfdG9fc3RyaW5ncy5zZXQodHVwbGUsIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3N0cmluZ3NfdG9fdHVwbGVzLnNldChuYW1lLCB0dXBsZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0IGFuIG9iamVjdCBvZiB0aGUgZm9ybSB7Li4uLCB2YXJpYWJsZV9uYW1lIDogcG93ZXIsIC4uLn0gdG8gYSB2ZWN0b3IuXHJcbiAgICAgKiBAcGFyYW0gbWFwXHJcbiAgICAgKiBAcmV0dXJucyB7Kn1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9tb25vbWlhbF9tYXBfdG9fdmVjdChtYXApe1xyXG4gICAgICAgIC8vIFdlIGp1c3QgbWFwIG92ZXIgdGhlIHZhcmlhYmxlX2xpc3QgYXMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLiBDaGVjayBpZiBwcm9wZXJ0eSBpcyBwcmVzZW50LCBlbHNlIHJldHVybiB6ZXJvLlxyXG4gICAgICAgIHJldHVybiB0aGlzLnZhcmlhYmxlX2xpc3QubWFwKHYgPT4ge1xyXG4gICAgICAgICAgICBpZihtYXAuaGFzT3duUHJvcGVydHkodikpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcFt2XTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgYXJndW1lbnQgaXMgYWxyZWFkeSBhbiBhcnJheSwgZG8gbm90aGluZy4gSWYgaXQncyBhIG1hcCwgYXBwbHkgX21vbm9taWFsX21hcF90b192ZWN0IHRvIGl0LiBJZiBpdCdzIGFcclxuICAgICAqIHN0cmluZyBsb29rIGl0IHVwIGluIF9zdHJpbmdzX3RvX2NsYXNzZXMuXHJcbiAgICAgKiBAcGFyYW0gdmVjdFxyXG4gICAgICogQHJldHVybnMge0FycmF5fGludH0gVGhlIG9mZnNldCB2ZWN0b3JcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9lbnN1cmVfdmVjdCh2ZWN0KXtcclxuICAgICAgICBpZighIEFycmF5LmlzQXJyYXkodmVjdCkpe1xyXG4gICAgICAgICAgICBpZih0eXBlb2YodmVjdCkgPT09IFwic3RyaW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMuX3N0cmluZ3NfdG9fY2xhc3Nlcy5oYXModmVjdCkpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IFwiSW52YWxpZCB2YXJpYWJsZSBuYW1lXCI7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZlY3QgPSB0aGlzLl9zdHJpbmdzX3RvX3R1cGxlcy5nZXQodmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2ZWN0ID0gdGhpcy5fbW9ub21pYWxfbWFwX3RvX3ZlY3QodmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlY3Q7XHJcbiAgICB9XHJcblxyXG4gICAgLypcclxuICAgICAqIEFkZCBzdHJ1Y3RsaW5lcyB0byBldmVyeSBtb25vbWlhbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBvZmZzZXQgdmVjdG9yLlxyXG4gICAgICogRm9yIGluc3RhbmNlLCBpZiB0aGVyZSBpcyBhIGdlbmVyYXRvciBjYWxsZWRcclxuICAgICAqL1xyXG4gICAgYWRkU3RydWN0bGluZShvZmZzZXRfdmVjdG9yLCBjYWxsYmFjayl7XHJcbiAgICAgICAgb2Zmc2V0X3ZlY3RvciA9IHRoaXMuX2Vuc3VyZV92ZWN0KG9mZnNldF92ZWN0b3IpO1xyXG4gICAgICAgIGZvcihsZXQgayBvZiB0aGlzKXtcclxuICAgICAgICAgICAgbGV0IGMxID0ga1sxXTtcclxuICAgICAgICAgICAgbGV0IGMyID0gdGhpcy5nZXQodmVjdG9yU3VtKGtbMF0sb2Zmc2V0X3ZlY3RvcikpO1xyXG4gICAgICAgICAgICBpZihjMiAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGxldCBzbGluZSA9IHRoaXMuc3NlcS5hZGRTdHJ1Y3RsaW5lKGMxLCBjMik7XHJcbiAgICAgICAgICAgICAgICBpZihjYWxsYmFjayl7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc2xpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZCBkaWZmZXJlbnRpYWxzIHRvIG1vbm9taWFscy5cclxuICAgICAqIEBwYXJhbSBwYWdlIFRoZSBwYWdlIG9mIHRoZSBkaWZmZXJlbnRpYWxcclxuICAgICAqIEBwYXJhbSB0YXJnZXRfdmVjdCBUaGUgZGlmZmVyZW50aWFsIGlzIGVmZmVjdGl2ZWx5IG9mIHRoZSBmb3JtIGQoeCkgPSByKnggd2hlcmUgciBpcyBzcGVjaWZpZWQgYnkgdGFyZ2V0X3ZlY3QuXHJcbiAgICAgKiAgICAgICAgVGhpcyBjYW4gZWl0aGVyIGJlIG9mIHRoZSBmb3JtIGBbZmlyc3RfdmFyX3Bvd2VyLCAuLi4sIGxhc3RfdmFyX3Bvd2VyXWAgb3Igb2YgdGhlIGZvcm0gYHsgXCJ2YXJfbmFtZVwiIDogdmFyX3Bvd2VyIH1gXHJcbiAgICAgKiBAcGFyYW0gY29uZCBBIGNvbmRpdGlvbmFsIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcGxhY2UgYSBkaWZmZXJlbnRpYWwgY29taW5nIG9mZiBvZiB0aGlzIHBhcnRpY3VsYXIgc291cmNlLlxyXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEEgY2FsbGJhY2sgY2FsbGVkIG9uIGVhY2ggcmVzdWx0aW5nIGRpZmZlcmVudGlhbC5cclxuICAgICAqIEByZXR1cm5zIHttb25vbWlhbF9iYXNpc30gQ2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIGFkZERpZmZlcmVudGlhbChwYWdlLCB0YXJnZXRfdmVjdCwgY29uZCwgY2FsbGJhY2spe1xyXG4gICAgICAgIHRhcmdldF92ZWN0ID0gdGhpcy5fZW5zdXJlX3ZlY3QodGFyZ2V0X3ZlY3QpO1xyXG4gICAgICAgIGZvcihsZXQga2V5X3ZhbHVlIG9mIHRoaXMpe1xyXG4gICAgICAgICAgICBsZXQgayA9IGtleV92YWx1ZVswXTsgICBcclxuICAgICAgICAgICAgbGV0IGMxID0ga2V5X3ZhbHVlWzFdOyAgXHJcbiAgICAgICAgICAgIGxldCBjMiA9IHRoaXMuZ2V0KHZlY3RvclN1bShrLCB0YXJnZXRfdmVjdCkpO1xyXG4gICAgICAgICAgICBpZihjb25kKGspKXtcclxuICAgICAgICAgICAgICAgIGlmKGMyKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZCA9IHRoaXMuc3NlcS5hZGREaWZmZXJlbnRpYWwoYzEsIGMyLCBwYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjayAhPT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZCxrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKGMxLmdldFBhZ2UoKSA+IHBhZ2Upe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjMS5zZXRQYWdlKHBhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGVzZSBhcmUgaW1tdXRhYmxlIG1hcCBtZXRob2RzLlxyXG5cclxuICAgIGhhcyhrZXkpe1xyXG4gICAgICAgIGlmKHRoaXMuX3N0cmluZ3NfdG9fY2xhc3Nlcy5oYXMoa2V5KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAga2V5ID0gdGhpcy5fZW5zdXJlX3ZlY3Qoa2V5KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHVwbGVzX3RvX2NsYXNzZXMuaGFzKGtleSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGdldChrZXksIGRlZmF1bHRfdmFsdWUpe1xyXG4gICAgICAgIGlmKHRoaXMuX3N0cmluZ3NfdG9fY2xhc3Nlcy5oYXMoa2V5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RyaW5nc190b19jbGFzc2VzLmdldChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBrZXkgPSB0aGlzLl9lbnN1cmVfdmVjdChrZXkpO1xyXG4gICAgICAgIGlmKHRoaXMuX3R1cGxlc190b19jbGFzc2VzLmhhcyhrZXkpKXtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3R1cGxlc190b19jbGFzc2VzLmdldChrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdF92YWx1ZTtcclxuICAgIH1cclxufVxyXG5cclxuICAgIFxyXG5tb25vbWlhbF9iYXNpcy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKigpe1xyXG4gICAgZm9yKGxldCBrIG9mIHRoaXMuX3R1cGxlc190b19jbGFzc2VzKXtcclxuICAgICAgICB5aWVsZCBrO1xyXG4gICAgfVxyXG59O1xyXG5cclxuZXhwb3J0cy5Tc2VxID0gU3NlcTtcclxud2luZG93LlNzZXFOb2RlID0gTm9kZTtcclxuXHJcbiIsIi8qKlxyXG4gKiBUaGUgTm9kZSBjbGFzcyBjb250cm9scyB0aGUgZGlzcGxheSBvZiBTc2VxQ2xhc3Mncy5cclxuICogVGhlIGJlaGF2aW9yIG9mIGEgTm9kZSdzIGZpZWxkcyBpcyBjb250cm9sbGVkIGJ5IHRoZSBtZXRob2QgS29udmEuU2hhcGUucHJvdG90eXBlLnNldE5vZGUgZGVmaW5lZCBpbiBkaXNwbGF5LmpzLlxyXG4gKiBUaGUgZmllbGRzIGFyZTpcclxuICogICAgY29sb3IgLS0gdGhlIGNvbG9yIHRvIGRyYXcgd2l0aC4gRGVmYXVsdCBibGFjay5cclxuICogICAgZmlsbCAtLSBlaXRoZXIgYSBib29sZWFuIG9yIGEgY29sb3IuIFwidHJ1ZVwiIG1lYW5zIGZpbGwgaXQsIGFuZCB1c2UgdGhlIGNvbG9yIGZpZWxkIHRvIGRlY2lkZSB3aGF0IGNvbG9yLlxyXG4gKiAgICAgICAgICAgIFNwZWNpZnlpbmcgYSBjb2xvciBvdmVycmlkZXMgdGhlIHZhbHVlIG9mIHRoZSBjb2xvciBrZXkuXHJcbiAqICAgIHN0cm9rZSAtLSBzaW1pbGFyIHRvIGZpbGwgZXhjZXB0IGZvciB0aGUgc3Ryb2tlLlxyXG4gKiAgICBzaGFwZSAtLSBhbiBvYmplY3Qgd2l0aCBhIGtleSBcImRyYXdcIiB3aXRoIHZhbHVlIGEgZHJhd2luZyBmdW5jdGlvbi4gT3B0aW9uYWxseSBhIHNlY29uZCBrZXkgXCJoaXRSZWdpb25cIiB3aGljaFxyXG4gKiAgICAgICAgICAgICBkZXRlcm1pbmVzIHdoYXQgcmVnaW9uIHRoZSBzaGFwZSBsaWVzIG92ZXIuXHJcbiAqICAgIHNpemUgIC0tIHRoaXMga2V5IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNjYWxpbmcgb2YgdGhlIG5vZGUuIEl0IGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgZHJhdyBmdW5jdGlvbiB0b1xyXG4gKiAgICAgICAgICAgICBjb25zaWRlciB0aGUgdmFsdWUgb2YgdGhpcyBrZXkgd2hlbiBkcmF3aW5nIHRoZSBzaGFwZS5cclxuICovXHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29weSgpe1xyXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBOb2RlKCksIHRoaXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldFNoYXBlKHNoYXBlKXtcclxuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gey4uLk5vZGV9IG5vZGVzIC0tIGEgbGlzdCBvZiBub2RlcyB0byBtZXJnZS4gTWVyZ2VzIHRoZW0gaW50byBhIG5ldyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyB7Tm9kZX0gLS0gYSBuZXcgbm9kZSBmb3JtZWQgYnkgbWVyZ2luZyB0aGUgbGlzdCBvZiBub2RlcyBwYXNzZWQgYXMgYXJndW1lbnRzLiBMYXRlciBhcmd1bWVudHMgaGF2ZVxyXG4gICAgICogICAgcHJpb3JpdHkgb3ZlciBlYXJsaWVyIG9uZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtZXJnZSguLi5ub2Rlcyl7XHJcbiAgICAgICAgbGV0IHJvb3QgPSBuZXcgU3NlcU5vZGUoKTtcclxuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApXHJcbiAgICAgICAgICAgIGZvciAoIHZhciBrZXkgaW4gbm9kZXNbaV0gKVxyXG4gICAgICAgICAgICAgICAgcm9vdFtrZXldID0gbm9kZXNbaV1ba2V5XTtcclxuICAgICAgICByZXR1cm4gcm9vdDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogIEEgU3NlcUNsYXNzIHJlcHJlc2VudHMgYSBwYXJ0aWN1bGFyIHN1Ymdyb3VwIG9mIHNvbWUgYmlkZWdyZWUgaW4gdGhlIEUyIHBhZ2Ugb2YgdGhlIHNwZWN0cmFsIHNlcXVlbmNlLCBhbmQgc2hvdWxkXHJcbiAqICBjb250YWluIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZmF0ZSBvZiB0aGF0IHN1Ymdyb3VwIC0tIHdoYXQgZGlmZmVyZW50aWFscyBkb2VzIGl0IHN1cHBvcnQsIHdoYXQgc3VicXVvdGllbnRzXHJcbiAqICBsaXZlIHRvIGVhY2ggcGFnZSwgd2hhdCBkaWZmZXJlbnRpYWxzLCBzdHJ1Y3R1cmUgbGluZXMsIGFuZCBleHRlbnNpb25zIG9jY3VyLlxyXG4gKlxyXG4gKiAgQSBjbGFzcyBjb250YWlucyB0aGUgZm9sbG93aW5nIGZpZWxkczpcclxuICogICAgZGVncmVlICAtLSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtdWx0aWRlZ3JlZSB0aGUgY2xhc3MgbGl2ZXMgaW5cclxuICogICAgbmFtZSAgICAtLSB0aGUgbmFtZSBvZiB0aGlzIGNsYXNzIChhIHN0cmluZylcclxuICogICAgZXh0cmFfaW5mbyAtLSBleHRyYSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGNsYXNzIChhIHN0cmluZylcclxuICogICAgZWRnZXMsIHN0cnVjdGxpbmVzLCBldGMgLS0gbGlzdHMgb2YgZWRnZXMgaW5jaWRlbnQgdG8gdGhpcyBjbGFzc1xyXG4gKiAgICBwYWdlX2xpc3QgLS0gYSBsaXN0IG9mIHBhZ2VzIG9uIHdoaWNoIHRoZSBjbGFzcyBzdXBwb3J0cyBvciByZWNlaXZlcyBhIGRpZmZlcmVudGlhbFxyXG4gKiAgICBub2RlX2xpc3QgLS0gYSBsaXN0IG9mIG5vZGVzIHRoYXQgY29udHJvbCB0aGUgZGlzcGxheSBvZiB0aGUgY2xhc3MgaW4gZWFjaCByYW5nZVxyXG4gKlxyXG4gKiAgVGhlIHBhZ2VfbGlzdCBhbmQgbm9kZV9saXN0IHNob3VsZCBiZSB0aGUgc2FtZSBsZW5ndGguIEhlcmUncyBhbiBleGFtcGxlIHRvIGV4cGxhaW4gcGFnZV9saXN0IGFuZCBub2RlX2xpc3Q6XHJcbiAqICBzdXBwb3NlIHRoZSBjbGFzcyByZXByZXNlbnRzIGEgZ3JvdXAgdGhhdFxyXG4gKiAgc3RhcnRzIG91dCBiZWluZyBaIG9uIHRoZSBFMiBwYWdlLCBzYXkgb24gcGFnZSA1IGl0IHN1cHBvcnRzIGEgZGlmZmVyZW50aWFsIHdpdGgga2VybmVsIHBaIGFuZCBvbiBwYWdlIDkgaXQncyBoaXQgYnlcclxuICogIGEgZGlmZmVyZW50aWFsIHdpdGggY29rZXJuZWwgcFovcF4yWi4gVGhlbjpcclxuICogICAgIGBwYWdlX2xpc3QgPSBbNSwgOSwgaW5maW5pdHldYCBhbmRcclxuICogICAgIGBub2RlX2xpc3QgPSBbIFpub2RlLCBwWm5vZGUsIFptcG5vZGVdYCxcclxuICogIHdoZXJlIG1heWJlIFpub2RlIGlzIGEgZmlsbGVkIGJsYWNrIHNxdWFyZSwgcFpub2RlIGlzIGFuIHVuZmlsbGVkIGJsYWNrIHNxdWFyZSAoanVzdCB0aGUgYm9yZGVyKSBhbmQgWm1wbm9kZSBpcyBhXHJcbiAqICBmaWxsZWQgYmxhY2sgY2lyY2xlLiBUaGlzIG1lYW5zIHRoYXQgb24gcGFnZSByYW5nZSBbMCw1XSB0aGUgY2xhc3MgaXMgZGlzcGxheWVkIHVzaW5nIFpub2RlLCBvbiBwYWdlIHJhbmdlIFs2LDldXHJcbiAqICBpdCdzIGRpc3BsYXllZCB1c2luZyBwWm5vZGUsIGFuZCBvbiBbMTAsIGluZmluaXR5XSBpdCdzIGRpc3BsYXllZCB1c2luZyBabXBub2RlLlxyXG4gKlxyXG4gKiAgSWYgaW5zdGVhZCB0aGUgZDkgd2VyZSBzdXJqZWN0aXZlLCB0aGVuIHRoZSBjbGFzcyBzaG91bGRuJ3QgYmUgZGlzcGxheWVkIGF0IGFsbCBhZnRlciBwYWdlIDkuIFRoaXMgd291bGQgYmVcclxuICogIHJlcHJlc2VudGVkIGFzIGBwYWdlX2xpc3QgPSBbNSwgOV1gIGFuZCBgbm9kZV9saXN0ID0gWyBabm9kZSwgcFpub2RlIF1gLlxyXG4gKi9cclxuY2xhc3MgU3NlcUNsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHNzZXEgVGhlIHBhcmVudCBzcGVjdHJhbCBzZXF1ZW5jZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNzZXEsIGRlZ3JlZSl7XHJcbiAgICAgICAgdGhpcy5zc2VxID0gc3NlcTtcclxuICAgICAgICB0aGlzLmRlZ3JlZSA9IGRlZ3JlZTtcclxuICAgICAgICB0aGlzLnByb2plY3Rpb24gPSBzc2VxLnByb2plY3Rpb24odGhpcyk7XHJcbiAgICAgICAgdGhpcy54ID0gdGhpcy5wcm9qZWN0aW9uWzBdO1xyXG4gICAgICAgIHRoaXMueSA9IHRoaXMucHJvamVjdGlvblsxXTtcclxuXHJcbiAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RydWN0bGluZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm91dGdvaW5nX2RpZmZlcmVudGlhbHMgPSBbXTtcclxuICAgICAgICB0aGlzLmluY29taW5nX2RpZmZlcmVudGlhbHMgPSBbXTtcclxuICAgICAgICB0aGlzLm5hbWUgPSBcIlwiO1xyXG4gICAgICAgIHRoaXMuZXh0cmFfaW5mbyA9IFwiXCI7XHJcbiAgICAgICAgdGhpcy5wYWdlX2xpc3QgPSBbaW5maW5pdHldO1xyXG4gICAgICAgIHRoaXMubm9kZV9saXN0ID0gW3NzZXEuZGVmYXVsdF9ub2RlLmNvcHkoKV07XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuXHJcblxyXG4gICAgICAgIC8vIGludGVybmFsIGZpZWxkcyBvbmx5LlxyXG4gICAgICAgIHRoaXMuX2xhc3RfcGFnZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdF9wYWdlX2lkeCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBzdHJ1Y3RsaW5lIHRvIHRoaXMgY2xhc3MuIENhbGxlZCBieSBTdHJ1Y3RsaW5lIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHBhcmFtIHNsIFRoZVxyXG4gICAgICogQHBhY2thZ2VcclxuICAgICAqL1xyXG4gICAgX2FkZFN0cnVjdGxpbmUoc2wpe1xyXG4gICAgICAgIHRoaXMuc3RydWN0bGluZXMucHVzaChzbCk7XHJcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKHNsKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIHtpbnR9IFRoZSBwYWdlIHRoaXMgY2xhc3MgZGllcyBvbiAob3IgaW5maW5pdHkgaWYgaXQgbGl2ZXMgZm9yZXZlcikuXHJcbiAgICAgKi9cclxuICAgIGdldFBhZ2UoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYWdlX2xpc3RbdGhpcy5wYWdlX2xpc3QubGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcblxyXG4gICAgc2V0UGFnZShwYWdlKXtcclxuICAgICAgICB0aGlzLnBhZ2VfbGlzdFt0aGlzLnBhZ2VfbGlzdC5sZW5ndGggLSAxXSA9IHBhZ2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0TmFtZShuYW1lKXtcclxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBnZXRzIHRoZSBpbmRleCBvZiBhIHNwZWNpZmllZCBwYWdlIGluIHRoZSBwYWdlIGxpc3QuIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IGlmIHRoZSBwYWdlIGxpc3QgaXMgb2YgdGhlXHJcbiAgICAgKiBmb3JtIFs1LCA5LCBpbmZpbml0eV0sIHRoaXMgZGl2aWRlcyB0aGUgcGFnZXMgaW50byB0aHJlZSBpbnRlcnZhbHMsIFswLDVdLCBbNiw5XSwgYW5kIFsxMCwgaW5maW5pdHldLlxyXG4gICAgICogSWYgcGFnZSBpcyBpbiB0aGUgcmFuZ2UgZnJvbSAwIHRvIDUsIHRoZSBwYWdlSW5kZXggaXMgemVybywgaWYgaXQgaXMgaW4gdGhlIHJhbmdlIDYgdG8gOSwgdGhlIGluZGV4IGlzIDEsXHJcbiAgICAgKiBhbmQgaW4gdGhlIHJhbmdlIDEwIHRvIGluZmluaXR5LCBpdCBpcyAyLlxyXG4gICAgICpcclxuICAgICAqIElmIHRoZSBwYWdlX2xpc3QgZG9lcyBub3QgZW5kIGluIGluZmluaXR5IGFuZCBwYWdlIGlzIGxhcmdlciB0aGFuIHRoZSBsYXJnZXN0IGVudHJ5IGluIHBhZ2VfbGlzdCB0aGVuIHRoaXMgdGhyb3dzXHJcbiAgICAgKiBhbiBlcnJvci5cclxuICAgICAqIEBwYXJhbSB7aW50fSBwYWdlXHJcbiAgICAgKiBAcmV0dXJucyB7aW50fSB0aGUgaW5kZXhcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9nZXRQYWdlSW5kZXgocGFnZSl7XHJcbiAgICAgICAgaWYoIHBhZ2UgPT09IHVuZGVmaW5lZCApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFnZV9saXN0Lmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmKCBwYWdlID09PSB0aGlzLl9sYXN0X3BhZ2UgKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXN0X3BhZ2VfaWR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcGFnZV9pZHg7XHJcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGFnZV9saXN0Lmxlbmd0aDsgaSsrKXtcclxuICAgICAgICAgICAgaWYodGhpcy5wYWdlX2xpc3RbaV0gPj0gcGFnZSl7XHJcbiAgICAgICAgICAgICAgICBwYWdlX2lkeCA9IGk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZihwYWdlX2lkeCA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgdGhyb3cgXCJQYWdlIHRvbyBsYXJnZS5cIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdF9wYWdlID0gcGFnZTtcclxuICAgICAgICB0aGlzLl9sYXN0X3BhZ2VfaWR4ID0gcGFnZV9pZHg7XHJcbiAgICAgICAgcmV0dXJuIHBhZ2VfaWR4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBub2RlIHRoYXQgY29udHJvbHMgdGhlIGRpc3BsYXkgb2YgdGhlIGNsYXNzIG9uIHRoZSBnaXZlbiBwYWdlLlxyXG4gICAgICogQHBhcmFtIHBhZ2VcclxuICAgICAqIEByZXR1cm5zIHtOb2RlfSBUaGUgbm9kZSB0aGF0IGNvbnRyb2xzIHRoZSBkaXNwbGF5IG9mIHRoaXMgY2xhc3Mgb24gcGFnZSBgcGFnZWAuXHJcbiAgICAgKi9cclxuICAgIGdldE5vZGUocGFnZSl7XHJcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fZ2V0UGFnZUluZGV4KHBhZ2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVfbGlzdFtpZHhdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbm9kZSB0aGF0IGNvbnRyb2xzIHRoZSBkaXNwbGF5IG9uIHRoZSBnaXZlbiBwYWdlLlxyXG4gICAgICogUHJvcGVydGllcyB0aGF0IGFyZSBtaXNzaW5nIGZyb20gdGhlIGdpdmVuIG5vZGUgYXJlIGxlZnQgdW5jaGFuZ2VkLlxyXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlXHJcbiAgICAgKiBAcGFyYW0ge2ludH0gcGFnZVxyXG4gICAgICogQHJldHVybnMge1NzZXFDbGFzc30gQ2hhaW5hYmxlXHJcbiAgICAgKi9cclxuICAgIHNldE5vZGUobm9kZSwgcGFnZSl7XHJcbiAgICAgICAgaWYobm9kZSA9PT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgbm9kZSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9nZXRQYWdlSW5kZXgocGFnZSk7XHJcbiAgICAgICAgdGhpcy5ub2RlX2xpc3RbaWR4XSA9IE5vZGUubWVyZ2UodGhpcy5ub2RlX2xpc3RbaWR4XSwgbm9kZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyBhIHBhZ2UgdG8gdGhlIGxpc3Qgb2YgcGFnZXMgYW5kIHNldHMgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSB0byBiZSB0aGUgcHJldmlvdXMgbm9kZS5cclxuICAgICAqIEBwYXJhbSB7aW50fSBwYWdlIFRoZSBwYWdlIHRvIGFwcGVuZC4gUmVhbGx5IHNob3VsZCBhbHdheXMgYmUgaW5maW5pdHkuLi5cclxuICAgICAqIEByZXR1cm5zIHtTc2VxQ2xhc3N9IENoYWluYWJsZVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2FwcGVuZFBhZ2UocGFnZSl7XHJcbiAgICAgICAgdGhpcy5wYWdlX2xpc3QucHVzaChwYWdlKTtcclxuICAgICAgICB0aGlzLm5vZGVfbGlzdC5wdXNoKHRoaXMubm9kZV9saXN0W3RoaXMubm9kZV9saXN0Lmxlbmd0aCAtIDFdLmNvcHkoKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXBsYWNlIGEgXCJkZWFkXCIgY2xhc3MuXHJcbiAgICAgKiBAcGFyYW0gbm9kZSBDb250cm9sIHRoZSB3YXkgdGhlIGRpc3BsYXkgb2YgdGhlIFwicmVwbGFjZWRcIiBjbGFzcyBjaGFuZ2VzLiBJZiB0aGUgbm9kZSBpcyB1bmRlZmluZWQsIG5vIGNoYW5nZVxyXG4gICAgICogICBpbiBhcHBlYXJhbmNlIHdpbGwgb2NjdXIuXHJcbiAgICAgKiBAcmV0dXJucyB7U3NlcUNsYXNzfVxyXG4gICAgICovXHJcbiAgICByZXBsYWNlKG5vZGUpe1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZFBhZ2UoaW5maW5pdHkpO1xyXG4gICAgICAgIHRoaXMuc2V0Tm9kZShub2RlKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBzdHJpbmcgdG8gZXh0cmFfaW5mbyAoaW4gcHJhY3RpY2UsIHRoaXMgY29udHJvbHMgdGhlIHRvb2x0aXAgZm9yIHRoZSBjbGFzcykuXHJcbiAgICAgKiBAcGFyYW0gc3RyXHJcbiAgICAgKiBAcmV0dXJucyB7U3NlcUNsYXNzfSBDaGFpbmFibGVcclxuICAgICAqL1xyXG4gICAgYWRkRXh0cmFJbmZvKHN0cil7XHJcbiAgICAgICAgdGhpcy5leHRyYV9pbmZvICs9IFwiXFxuXCIgKyBzdHI7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBtdWx0aXBsZSBjbGFzc2VzIGFyZSBpbiB0aGUgc2FtZSAoeCx5KSBsb2NhdGlvbiwgd2Ugb2Zmc2V0IHRoZWlyIHBvc2l0aW9uIGEgYml0IHRvIGF2b2lkIGNsYXNoZXMuXHJcbiAgICAgKiBHZXRzIGNhbGxlZCBieSBkaXNwbGF5IGNvZGUuXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgeCBvZmZzZXRcclxuICAgICAqIEBwYWNrYWdlXHJcbiAgICAgKi9cclxuICAgIF9nZXRYT2Zmc2V0KCl7XHJcbiAgICAgICAgbGV0IHRvdGFsX2NsYXNzZXMgPSB0aGlzLnNzZXEubnVtX2NsYXNzZXNfYnlfZGVncmVlLmdldCh0aGlzLnByb2plY3Rpb24pO1xyXG4gICAgICAgIGxldCBpZHggPSB0aGlzLmlkeDtcclxuICAgICAgICByZXR1cm4gKGlkeCAtICh0b3RhbF9jbGFzc2VzIC0gMSkvMikqdGhpcy5zc2VxLm9mZnNldF9zaXplO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgbXVsdGlwbGUgY2xhc3NlcyBhcmUgaW4gdGhlIHNhbWUgKHgseSkgbG9jYXRpb24sIHdlIG9mZnNldCB0aGVpciBwb3NpdGlvbiBhIGJpdCB0byBhdm9pZCBjbGFzaGVzLlxyXG4gICAgICogR2V0cyBjYWxsZWQgYnkgZGlzcGxheSBjb2RlLlxyXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHkgb2Zmc2V0XHJcbiAgICAgKiBAcGFja2FnZVxyXG4gICAgICovXHJcbiAgICBfZ2V0WU9mZnNldCgpe1xyXG4gICAgICAgIGxldCB0b3RhbF9jbGFzc2VzID0gdGhpcy5zc2VxLm51bV9jbGFzc2VzX2J5X2RlZ3JlZS5nZXQodGhpcy5wcm9qZWN0aW9uKTtcclxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5pZHg7XHJcbiAgICAgICAgcmV0dXJuIC0oaWR4IC0gKHRvdGFsX2NsYXNzZXMgLSAxKS8yKSp0aGlzLnNzZXEub2Zmc2V0X3NpemU7XHJcbiAgICB9XHJcblxyXG4gICAgdG9TdHJpbmcoKXtcclxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBvdXRnb2luZyBkaWZmZXJlbnRpYWwuIENhbGxlZCBieSB0aGUgZGlmZmVyZW50aWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHBhcmFtIGRpZmZlcmVudGlhbFxyXG4gICAgICogQHBhY2thZ2VcclxuICAgICAqL1xyXG4gICAgX2FkZE91dGdvaW5nRGlmZmVyZW50aWFsKGRpZmZlcmVudGlhbCl7XHJcbiAgICAgICAgaWYodGhpcy5nZXRQYWdlKCkgPCBkaWZmZXJlbnRpYWwucGFnZSl7XHJcbiAgICAgICAgICAgIC8vdGhpcy5oYW5kbGVEb3VibGVkRGlmZmVyZW50aWFsKFwic3VwcG9ydGluZyBhbm90aGVyXCIgKyBkaWZmZXJlbnRpYWwuc3VwcG9ydGVkTWVzc2FnZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQYWdlKGRpZmZlcmVudGlhbC5wYWdlKTtcclxuICAgICAgICB0aGlzLm91dGdvaW5nX2RpZmZlcmVudGlhbHMucHVzaChkaWZmZXJlbnRpYWwpO1xyXG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChkaWZmZXJlbnRpYWwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBpbmNvbWluZyBkaWZmZXJlbnRpYWwuIENhbGxlZCBieSB0aGUgZGlmZmVyZW50aWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgICogQHBhcmFtIGRpZmZlcmVudGlhbFxyXG4gICAgICogQHBhY2thZ2VcclxuICAgICAqL1xyXG4gICAgX2FkZEluY29taW5nRGlmZmVyZW50aWFsKGRpZmZlcmVudGlhbCl7XHJcbiAgICAgICAgaWYodGhpcy5nZXRQYWdlKCkgPCBkaWZmZXJlbnRpYWwucGFnZSl7XHJcbiAgICAgICAgICAgIC8vdGhpcy5oYW5kbGVEb3VibGVkRGlmZmVyZW50aWFsKFwicmVjZWl2aW5nIGFub3RoZXJcIiArIGRpZmZlcmVudGlhbC5oaXRNZXNzYWdlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNldFBhZ2UoZGlmZmVyZW50aWFsLnBhZ2UpO1xyXG4gICAgICAgIHRoaXMuaW5jb21pbmdfZGlmZmVyZW50aWFscy5wdXNoKGRpZmZlcmVudGlhbCk7XHJcbiAgICAgICAgdGhpcy5lZGdlcy5wdXNoKGRpZmZlcmVudGlhbCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBwYWdlIG9mIGV2ZXJ5IHN0cnVjdGxpbmUgaW5jaWRlbnQgdG8gdGhpcyBlZGdlLiBTdHJ1Y3RsaW5lcyBhcmUgbm90IGRpc3BsYXllZCBvbiBwYWdlcyBsYXRlciB0aGFuIHRoZWlyXHJcbiAgICAgKiBwYWdlLlxyXG4gICAgICogQHBhcmFtIHBhZ2VcclxuICAgICAqIEByZXR1cm5zIHtTc2VxQ2xhc3N9XHJcbiAgICAgKi9cclxuICAgIHNldFN0cnVjdGxpbmVQYWdlcyhwYWdlKXtcclxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5zdHJ1Y3RsaW5lcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgICAgIGxldCBzbCA9IHRoaXMuc3RydWN0bGluZXNbaV07XHJcbiAgICAgICAgICAgIGlmKHNsLnBhZ2UgPiBwYWdlKXtcclxuICAgICAgICAgICAgICAgIHNsLnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgY2xhc3MgaXMgZHJhd24gb24gdGhlIGdpdmVuIHBhZ2UuXHJcbiAgICAgKiBAcGFyYW0gcGFnZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKiBAcGFja2FnZVxyXG4gICAgICovXHJcbiAgICBfZHJhd09uUGFnZVEocGFnZSl7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZV9saXN0W3RoaXMucGFnZV9saXN0Lmxlbmd0aCAtMV0gPj0gcGFnZSAmJiB0aGlzLnZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdpdGhlciB0aGUgY2xhc3MgaXMgaW4gdGhlIGdpdmVuIHJhbmdlLlxyXG4gICAgICogQHBhcmFtIHhtaW5cclxuICAgICAqIEBwYXJhbSB4bWF4XHJcbiAgICAgKiBAcGFyYW0geW1pblxyXG4gICAgICogQHBhcmFtIHltYXhcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAgICogQHBhY2thZ2VcclxuICAgICAqL1xyXG4gICAgX2luUmFuZ2VRKHhtaW4sIHhtYXgsIHltaW4sIHltYXgpe1xyXG4gICAgICAgIHJldHVybiB4bWluIDw9IHRoaXMueCAmJiB0aGlzLnggPD0geG1heFxyXG4gICAgICAgICAgICAmJiB5bWluIDw9IHRoaXMueSAmJiB0aGlzLnkgPD0geW1heDtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydHMuTm9kZSA9IE5vZGU7XHJcbmV4cG9ydHMuU3NlcUNsYXNzID0gU3NlcUNsYXNzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gc3RkQ2F0VG9TdHJpbmcoeCl7XG4gICAgaWYoeC5jYXRUb1N0cmluZyAhPT0gdW5kZWZpbmVkKXtcbiAgICAgICAgcmV0dXJuIHguY2F0VG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4geC50b1N0cmluZygpO1xuICAgIH1cbn1cblxudmFyIFN0cmluZ2lmeWluZ01hcCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RyaW5naWZ5aW5nTWFwKGNhdFRvU3RyaW5nKSB7XG4gICAgICAgIGlmKGNhdFRvU3RyaW5nID09PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgY2F0VG9TdHJpbmcgPSBzdGRDYXRUb1N0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2F0VG9TdHJpbmcgPSBjYXRUb1N0cmluZztcbiAgICAgICAgdGhpcy5tID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtleXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFN0cmluZ2lmeWluZ01hcC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgdGhpcy5rZXlzLnNldCh0aGlzLmNhdFRvU3RyaW5nKGspLGspO1xuICAgICAgICBsZXQgcyA9IHRoaXMubS5zZXQodGhpcy5jYXRUb1N0cmluZyhrKSwgdik7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH07XG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gdGhpcy5tLmdldCh0aGlzLmNhdFRvU3RyaW5nKGspKTtcbiAgICB9O1xuICAgIFN0cmluZ2lmeWluZ01hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdGhpcy5rZXlzLmRlbGV0ZSh0aGlzLmNhdFRvU3RyaW5nKGspKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubS5kZWxldGUodGhpcy5jYXRUb1N0cmluZyhrKSk7XG4gICAgfTtcbiAgICBTdHJpbmdpZnlpbmdNYXAucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm0uaGFzKHRoaXMuY2F0VG9TdHJpbmcoaykpO1xuICAgIH07ICAgIFxuXG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZS5nZXRPckVsc2UgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KSA/IHRoaXMuZ2V0KGtleSkgOiB2YWx1ZTtcbiAgICB9XG4gICAgXG4gICAgU3RyaW5naWZ5aW5nTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qKCl7XG4gICAgICAgIGZvcihsZXQgayBvZiB0aGlzLm0pe1xuICAgICAgICAgICAgeWllbGQgW3RoaXMua2V5cy5nZXQoa1swXSksa1sxXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0cmluZ2lmeWluZ01hcC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubS5zaXplO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gU3RyaW5naWZ5aW5nTWFwO1xufSgpKTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ2lmeWluZ01hcDtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5cclxuXHJcbmxldCBkMyA9IHJlcXVpcmUoXCJkM1wiKTtcclxubGV0IE1vdXNldHJhcCA9IHJlcXVpcmUoXCJtb3VzZXRyYXBcIik7XHJcbmxldCBLb252YSA9IHJlcXVpcmUoXCJrb252YVwiKTtcclxuLy8gcHJldmVudCBzY3JvbGxiYXJzXHJcbmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nOyAgLy8gZmlyZWZveCwgY2hyb21lXHJcbi8vIG5vaW5zcGVjdGlvbiBKU1ZhbGlkYXRlVHlwZXNcclxuZG9jdW1lbnQuYm9keS5zY3JvbGwgPSBcIm5vXCI7IC8vIGllIG9ubHlcclxuXHJcbktvbnZhLkZhY3RvcnkuYWRkR2V0dGVyU2V0dGVyKEtvbnZhLlNoYXBlLCAnc2l6ZScpO1xyXG5Lb252YS5TaGFwZS5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XHJcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xyXG4gICAgdGhpcy5zZXRBdHRycyhub2RlKTtcclxuICAgIHRoaXMuc2NlbmVGdW5jKG5vZGUuc2hhcGUuZHJhdyk7XHJcbiAgICBpZiAobm9kZS5zaGFwZS5oaXRSZWdpb24pIHtcclxuICAgICAgICB0aGlzLmhpdEZ1bmMobm9kZS5zaGFwZS5oaXRSZWdpb24pO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zZXRGaWxsRW5hYmxlZChub2RlLmZpbGwpO1xyXG4gICAgdGhpcy5zZXRTdHJva2VFbmFibGVkKG5vZGUuc3Ryb2tlKTtcclxuICAgIGlmICgobm9kZS5maWxsICE9PSB0cnVlICYmIG5vZGUuZmlsbCkgfHwgbm9kZS5jb2xvcikge1xyXG4gICAgICAgIHRoaXMuZmlsbCgobm9kZS5maWxsICE9PSB0cnVlICYmIG5vZGUuZmlsbCkgfHwgbm9kZS5jb2xvcik7XHJcbiAgICB9XHJcbiAgICBpZiAoKG5vZGUuc3Ryb2tlICE9PSB0cnVlICYmIG5vZGUuc3Ryb2tlKSB8fCBub2RlLmNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5zdHJva2UoKG5vZGUuc3Ryb2tlICE9PSB0cnVlICYmIG5vZGUuc3Ryb2tlKSB8fCBub2RlLmNvbG9yKTtcclxuICAgIH1cclxuXHJcbn1cclxuXHJcblxyXG5cclxuY2xhc3MgRGlzcGxheSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzcykge1xyXG4gICAgICAgIHRoaXMuc3NlcSA9IHNzO1xyXG4gICAgICAgIHNzLmRpc3AgPSB0aGlzO1xyXG4gICAgICAgIC8vIEdsb2JhbCBjb25zdGFudHMgZm9yIGdyaWQgYW5kIHNldHVwXHJcbiAgICAgICAgdGhpcy5ncmlkQ29sb3IgPSBcIiM1NTVcIjtcclxuICAgICAgICB0aGlzLmdyaWRTdHJva2VXaWR0aCA9IDAuNTtcclxuICAgICAgICB0aGlzLmJveFNpemUgPSA1MDtcclxuICAgICAgICB0aGlzLlpPT01fQkFTRSA9IDEuMTtcclxuICAgICAgICBjb25zdCBib3VuZGluZ1JlY3RhbmdsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpblwiKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IGJvdW5kaW5nUmVjdGFuZ2xlLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IGJvdW5kaW5nUmVjdGFuZ2xlLmhlaWdodDtcclxuXHJcbiAgICAgICAgdGhpcy5vbGRfc2NhbGVzX21heGVkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuZG9tYWluT2Zmc2V0ID0gMSAvIDI7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzc2VxIG9iamVjdCBjb250YWlucyB0aGUgbGlzdCBvZiB2YWxpZCBwYWdlcy4gQWx3YXlzIGluY2x1ZGVzIGF0IGxlYXN0IDAgYW5kIGluZmluaXR5LlxyXG4gICAgICAgIHRoaXMucGFnZV9pZHggPSAwO1xyXG4gICAgICAgIHRoaXMucGFnZSA9IDA7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBsZWZ0IC8gcmlnaHQgbW91c2UgYnV0dG9ucyB0byBjaGFuZ2UgcGFnZS5cclxuICAgICAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRMb2NhbFN5bWJvbHNcclxuICAgICAgICBNb3VzZXRyYXAuYmluZCgnbGVmdCcsIChlLCBuKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2VfaWR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlX2lkeC0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYWdlID0gdGhpcy5zc2VxLnBhZ2VfbGlzdFt0aGlzLnBhZ2VfaWR4XTtcclxuICAgICAgICAgICAgICAgIC8vcGFnZU51bVRleHQudGV4dChwYWdlKTtcclxuICAgICAgICAgICAgICAgIC8vd2luZG93LnBhZ2UgPSBwYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3QWxsKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFnZS5nZXRQb2ludGVyUG9zaXRpb24oKSAmJiB0aGlzLnN0YWdlLmdldEludGVyc2VjdGlvbih0aGlzLnN0YWdlLmdldFBvaW50ZXJQb3NpdGlvbigpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VvdmVyKHRoaXMuc3RhZ2UuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXHJcbiAgICAgICAgTW91c2V0cmFwLmJpbmQoJ3JpZ2h0JywgKGUsIG4pID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGFnZV9pZHggPCB0aGlzLnNzZXEucGFnZV9saXN0Lmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZV9pZHgrKztcclxuICAgICAgICAgICAgICAgIHRoaXMucGFnZSA9IHRoaXMuc3NlcS5wYWdlX2xpc3RbdGhpcy5wYWdlX2lkeF07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYWdlX2lkeCA9PT0gdGhpcy5zc2VxLnBhZ2VfbGlzdC5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9wYWdlTnVtVGV4dC50ZXh0KFwi4oieXCIpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3BhZ2VOdW1UZXh0LnRleHQocGFnZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL3dpbmRvdy5wYWdlID0gcGFnZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0FsbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIERyYXdpbmcgZWxlbWVudHNcclxuICAgICAgICB0aGlzLmJvZHkgPSBkMy5zZWxlY3QoXCJib2R5XCIpO1xyXG4gICAgICAgIGxldCBib2R5ID0gdGhpcy5ib2R5O1xyXG5cclxuICAgICAgICB0aGlzLnRvb2x0aXBfZGl2ID0gYm9keS5hcHBlbmQoXCJkaXZcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJpZFwiLCBcInRvb2x0aXBfZGl2XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ0b29sdGlwXCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XHJcblxyXG4gICAgICAgIHRoaXMudG9vbHRpcF9kaXZfZHVtbXkgPSBib2R5LmFwcGVuZChcImRpdlwiKVxyXG4gICAgICAgICAgICAuYXR0cihcImlkXCIsIFwidG9vbHRpcF9kaXZfZHVtbXlcIilcclxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInRvb2x0aXBcIilcclxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcclxuXHJcbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBLb252YS5TdGFnZSh7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lcjogJ21haW4nLFxyXG4gICAgICAgICAgICB3aWR0aDogY2FudmFzV2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogY2FudmFzSGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGV0IHN0YWdlID0gdGhpcy5zdGFnZTtcclxuXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHN0YWdlLndpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzdGFnZS5oZWlnaHQoKTtcclxuXHJcbiAgICAgICAgLy93aW5kb3cuc3RhZ2UgPSBzdGFnZTtcclxuXHJcbiAgICAgICAgLy8gTGF5ZXJzIGZyb20gYmFjayB0byBmcm9udC5cclxuICAgICAgICB0aGlzLmdyaWRMYXllciA9IG5ldyBLb252YS5MYXllcigpO1xyXG4gICAgICAgIHRoaXMuZWRnZUxheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XHJcbiAgICAgICAgdGhpcy5jbGFzc0xheWVyID0gbmV3IEtvbnZhLkxheWVyKCk7XHJcbiAgICAgICAgLy8gRm9yIGF4ZXMgbGFiZWxzLlxyXG4gICAgICAgIHRoaXMubWFyZ2luID0gbmV3IEtvbnZhLkxheWVyKCk7XHJcbiAgICAgICAgLy8gVGhpcyBqdXN0IGNvbnRhaW5zIGEgd2hpdGUgc3F1YXJlIGluIHRoZSBib3R0b20gcmlnaHQgY29ybmVyIHRvIHByZXZlbnQgYXhlcyBsYWJlbHNcclxuICAgICAgICAvLyBmcm9tIHNob3dpbmcgdXAgZG93biB0aGVyZS4gVGhlIHpvb20gZXZlbnQgaGFuZGxlciBpcyBhdHRhY2hlZCB0byB0aGUgc3VwZXJtYXJnaW4uXHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbiA9IG5ldyBLb252YS5MYXllcigpO1xyXG5cclxuICAgICAgICBzdGFnZS5hZGQodGhpcy5ncmlkTGF5ZXIpO1xyXG4gICAgICAgIHN0YWdlLmFkZCh0aGlzLmVkZ2VMYXllcik7XHJcbiAgICAgICAgc3RhZ2UuYWRkKHRoaXMuY2xhc3NMYXllcik7XHJcbiAgICAgICAgc3RhZ2UuYWRkKHRoaXMubWFyZ2luKTtcclxuICAgICAgICBzdGFnZS5hZGQodGhpcy5zdXBlcm1hcmdpbik7XHJcblxyXG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjYW52YXNcIiksXHJcbiAgICAgICAgICAgIChjLCBpZHgpID0+IGMuc2V0QXR0cmlidXRlKFwiaWRcIiwgW1wiZ3JpZExheWVyXCIsIFwiZWRnZUxheWVyXCIsIFwiY2xhc3NMYXllclwiLCBcIm1hcmdpbkxheWVyXCIsIFwic3VwZXJtYXJnaW5MYXllclwiXVtpZHhdKSk7XHJcblxyXG4gICAgICAgIHRoaXMuZ3JpZExheWVyQ29udGV4dCA9IGQzLnNlbGVjdChcIiNncmlkTGF5ZXJcIikubm9kZSgpLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICB0aGlzLmVkZ2VMYXllckNvbnRleHQgPSBkMy5zZWxlY3QoXCIjZWRnZUxheWVyXCIpLm5vZGUoKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgdGhpcy5jbGFzc0xheWVyQ29udGV4dCA9IGQzLnNlbGVjdChcIiNjbGFzc0xheWVyXCIpLm5vZGUoKS5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICAgICAgdGhpcy5tYXJnaW5MYXllckNvbnRleHQgPSBkMy5zZWxlY3QoXCIjbWFyZ2luTGF5ZXJcIikubm9kZSgpLmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICB0aGlzLnN1cGVybWFyZ2luTGF5ZXJDb250ZXh0ID0gZDMuc2VsZWN0KFwiI3N1cGVybWFyZ2luTGF5ZXJcIikubm9kZSgpLmdldENvbnRleHQoXCIyZFwiKTtcclxuXHJcbiAgICAgICAgdGhpcy54TWFyZ2luU2l6ZSA9IHRoaXMuYm94U2l6ZSAvIDIgKyAzMDtcclxuICAgICAgICB0aGlzLnlNYXJnaW5TaXplID0gdGhpcy5ib3hTaXplO1xyXG5cclxuICAgICAgICB0aGlzLmNsaXBYID0gdGhpcy54TWFyZ2luU2l6ZTtcclxuICAgICAgICB0aGlzLmNsaXBZID0gLXRoaXMuYm94U2l6ZTtcclxuICAgICAgICB0aGlzLmNsaXBXaWR0aCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5jbGlwSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLSB0aGlzLnlNYXJnaW5TaXplO1xyXG5cclxuICAgICAgICB0aGlzLmdyaWRMYXllckNvbnRleHQucmVjdCh0aGlzLmNsaXBYLCB0aGlzLmNsaXBZLCB0aGlzLmNsaXBXaWR0aCAtIHRoaXMuY2xpcFgsIHRoaXMuY2xpcEhlaWdodCAtIHRoaXMuY2xpcFkpO1xyXG4gICAgICAgIHRoaXMuZ3JpZExheWVyQ29udGV4dC5jbGlwKCk7XHJcbiAgICAgICAgdGhpcy5ncmlkTGF5ZXJDb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5ncmlkQ29sb3I7XHJcblxyXG4gICAgICAgIHRoaXMuZWRnZUxheWVyQ29udGV4dC5yZWN0KHRoaXMuY2xpcFgsIHRoaXMuY2xpcFksIHRoaXMuY2xpcFdpZHRoIC0gdGhpcy5jbGlwWCwgdGhpcy5jbGlwSGVpZ2h0IC0gdGhpcy5jbGlwWSk7XHJcbiAgICAgICAgdGhpcy5lZGdlTGF5ZXJDb250ZXh0LmNsaXAoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jbGFzc0xheWVyQ29udGV4dC5yZWN0KHRoaXMuY2xpcFgsIHRoaXMuY2xpcFksIHRoaXMuY2xpcFdpZHRoIC0gdGhpcy5jbGlwWCwgdGhpcy5jbGlwSGVpZ2h0IC0gdGhpcy5jbGlwWSk7XHJcbiAgICAgICAgdGhpcy5jbGFzc0xheWVyQ29udGV4dC5jbGlwKCk7XHJcbiAgICAgICAgdGhpcy5oaXRDdHggPSB0aGlzLmNsYXNzTGF5ZXIuZ2V0SGl0Q2FudmFzKCkuY29udGV4dDtcclxuXHJcbiAgICAgICAgdGhpcy5tYXJnaW5MYXllckNvbnRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcclxuICAgICAgICB0aGlzLm1hcmdpbkxheWVyQ29udGV4dC5mb250ID0gXCIxNXB4IEFyaWFsXCI7XHJcblxyXG4gICAgICAgIHRoaXMuc3VwZXJtYXJnaW5MYXllckNvbnRleHQuZmlsbFN0eWxlID0gXCIjRkZGXCI7XHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbkxheWVyQ29udGV4dC5yZWN0KDAsIHRoaXMuY2xpcEhlaWdodCwgdGhpcy54TWFyZ2luU2l6ZSAtIDUsIHRoaXMuYm94U2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbkxheWVyQ29udGV4dC5maWxsKCk7XHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbkxheWVyQ29udGV4dC5maWxsU3R5bGUgPSBcIiMwMDBcIjtcclxuXHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbkxheWVyQ29udGV4dC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLnN1cGVybWFyZ2luTGF5ZXJDb250ZXh0Lm1vdmVUbyh0aGlzLnhNYXJnaW5TaXplLCAwKTtcclxuICAgICAgICB0aGlzLnN1cGVybWFyZ2luTGF5ZXJDb250ZXh0LmxpbmVUbyh0aGlzLnhNYXJnaW5TaXplLCB0aGlzLmNsaXBIZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc3VwZXJtYXJnaW5MYXllckNvbnRleHQubGluZVRvKHRoaXMud2lkdGgsIHRoaXMuY2xpcEhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5zdXBlcm1hcmdpbkxheWVyQ29udGV4dC5zdHJva2UoKTtcclxuXHJcbiAgICAgICAgLy93aW5kb3cuY29udGV4dCA9IHRoaXMuY2xhc3NMYXllckNvbnRleHQ7XHJcblxyXG4gICAgICAgIHRoaXMueFNjYWxlSW5pdCA9IGQzLnNjYWxlTGluZWFyKCkucmFuZ2UoW3RoaXMueE1hcmdpblNpemUsIHRoaXMud2lkdGhdKTtcclxuICAgICAgICB0aGlzLnlTY2FsZUluaXQgPSBkMy5zY2FsZUxpbmVhcigpLnJhbmdlKFt0aGlzLmhlaWdodCAtIHRoaXMueU1hcmdpblNpemUsIDBdKTtcclxuXHJcbiAgICAgICAgdGhpcy54U2NhbGVJbml0LmRvbWFpbihbdGhpcy5zc2VxLmluaXRpYWx4UmFuZ2VbMF0gLSB0aGlzLmRvbWFpbk9mZnNldCwgdGhpcy5zc2VxLmluaXRpYWx4UmFuZ2VbMV0gKyB0aGlzLmRvbWFpbk9mZnNldF0pO1xyXG4gICAgICAgIHRoaXMueVNjYWxlSW5pdC5kb21haW4oW3RoaXMuc3NlcS5pbml0aWFseVJhbmdlWzBdIC0gdGhpcy5kb21haW5PZmZzZXQsIHRoaXMuc3NlcS5pbml0aWFseVJhbmdlWzFdICsgdGhpcy5kb21haW5PZmZzZXRdKTtcclxuXHJcbiAgICAgICAgdGhpcy56b29tRG9tRWxlbWVudCA9IGQzLnNlbGVjdChcIiNzdXBlcm1hcmdpbkxheWVyXCIpO1xyXG5cclxuICAgICAgICB0aGlzLmRyYXdBbGwgPSB0aGlzLmRyYXdBbGwuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRyYXdHcmlkID0gdGhpcy5kcmF3R3JpZC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZHJhd1RpY2tzID0gdGhpcy5kcmF3VGlja3MuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmRyYXcgPSB0aGlzLmRyYXcuYmluZCh0aGlzKTtcclxuXHJcblxyXG4gICAgICAgIHRoaXMuem9vbSA9IGQzLnpvb20oKS5zY2FsZUV4dGVudChbMCwgNF0pO1xyXG4gICAgICAgIHRoaXMuem9vbS5vbihcInpvb21cIiwgKCkgPT4gdGhpcy5kcmF3QWxsKCkpO1xyXG4gICAgICAgIHRoaXMuem9vbURvbUVsZW1lbnQuY2FsbCh0aGlzLnpvb20pLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHJcblxyXG4gICAgICAgIC8vd2luZG93LnNzZXEgPSBzc2VxO1xyXG4gICAgICAgIHRoaXMuYWRkQ2xhc3NlcygpO1xyXG4gICAgICAgIHRoaXMuZHJhd0FsbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdBbGwoKSB7XHJcbiAgICAgICAgbGV0IHpvb21Eb21FbGVtZW50ID0gdGhpcy56b29tRG9tRWxlbWVudDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGQzLnpvb21UcmFuc2Zvcm0oem9vbURvbUVsZW1lbnQubm9kZSgpKTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy50cmFuc2Zvcm0uaztcclxuICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgIGxldCB4U2NhbGUgPSB0aGlzLnhTY2FsZTtcclxuICAgICAgICBsZXQgeVNjYWxlID0gdGhpcy55U2NhbGU7XHJcbiAgICAgICAgbGV0IHNzZXEgPSB0aGlzLnNzZXE7XHJcblxyXG4gICAgICAgIHhTY2FsZSA9IHRoaXMudHJhbnNmb3JtLnJlc2NhbGVYKHRoaXMueFNjYWxlSW5pdCk7XHJcbiAgICAgICAgaWYgKCFzc2VxLmZpeFkpIHtcclxuICAgICAgICAgICAgeVNjYWxlID0gdGhpcy50cmFuc2Zvcm0ucmVzY2FsZVkodGhpcy55U2NhbGVJbml0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5U2NhbGUgPSB0aGlzLnlTY2FsZUluaXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBXZSBoYXZlIHRvIGNhbGwgem9vbS50cmFuc2xhdGVCeSB3aGVuIHRoZSB1c2VyIGhpdHMgdGhlIGJvdW5kYXJ5IG9mIHRoZSBwYW4gcmVnaW9uXHJcbiAgICAgICAgLy8gdG8gYWRqdXN0IHRoZSB6b29tIHRyYW5zZm9ybS4gSG93ZXZlciwgdGhpcyBjYXVzZXMgdGhlIHpvb20gaGFuZGxlciAodGhpcyBmdW5jdGlvbikgdG8gYmUgY2FsbGVkIGEgc2Vjb25kIHRpbWUsXHJcbiAgICAgICAgLy8gd2hpY2ggaXMgbGVzcyBpbnR1aXRpdmUgcHJvZ3JhbSBmbG93IHRoYW4ganVzdCBjb250aW51aW5nIG9uIGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxyXG4gICAgICAgIC8vIEluIG9yZGVyIHRvIHByZXZlbnQgdGhpcywgdGVtcG9yYXJpbHkgdW5zZXQgdGhlIHpvb20gaGFuZGxlci5cclxuICAgICAgICB0aGlzLnpvb20ub24oXCJ6b29tXCIsIG51bGwpO1xyXG4gICAgICAgIGlmICghdGhpcy5vbGRfc2NhbGVzX21heGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChzc2VxLnhSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHhNaW5PZmZzZXQgPSBzY2FsZSA+IDEgPyAxMCAqIHNjYWxlIDogMTA7XHJcbiAgICAgICAgICAgICAgICBsZXQgeE1heE9mZnNldCA9IHhNaW5PZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoeFNjYWxlKHNzZXEueFJhbmdlWzBdKSA+IHRoaXMueE1hcmdpblNpemUgKyB4TWluT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21Eb21FbGVtZW50LCAodGhpcy54TWFyZ2luU2l6ZSArIHhNaW5PZmZzZXQgLSB4U2NhbGUoc3NlcS54UmFuZ2VbMF0pIC0gMC4xKSAvIHNjYWxlLCAwKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeFNjYWxlKHNzZXEueFJhbmdlWzFdKSA8IHRoaXMud2lkdGggLSB4TWF4T2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21Eb21FbGVtZW50LCAodGhpcy53aWR0aCAtIHhNYXhPZmZzZXQgLSB4U2NhbGUoc3NlcS54UmFuZ2VbMV0pICsgMC4xKSAvIHNjYWxlLCAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCFzc2VxLmZpeFkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzc2VxLnlSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5TWluT2Zmc2V0ID0gc2NhbGUgPiAxID8gMTAgKiBzY2FsZSA6IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB5TWF4T2Zmc2V0ID0geU1pbk9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoeVNjYWxlKHNzZXEueVJhbmdlWzBdKSA8IHRoaXMuY2xpcEhlaWdodCAtIHlNaW5PZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21Eb21FbGVtZW50LCAwLCAodGhpcy5jbGlwSGVpZ2h0IC0geU1pbk9mZnNldCAtIHlTY2FsZShzc2VxLnlSYW5nZVswXSkgLSAwLjEpIC8gc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoeVNjYWxlKHNzZXEueVJhbmdlWzFdKSA+IHlNYXhPZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zbGF0ZUJ5KHpvb21Eb21FbGVtZW50LCAwLCAoeU1heE9mZnNldCAtIHlTY2FsZShzc2VxLnlSYW5nZVsxXSkgKyAwLjEpIC8gc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBkMy56b29tVHJhbnNmb3JtKHpvb21Eb21FbGVtZW50Lm5vZGUoKSk7XHJcbiAgICAgICAgeFNjYWxlID0gdGhpcy50cmFuc2Zvcm0ucmVzY2FsZVgodGhpcy54U2NhbGVJbml0KTtcclxuXHJcbiAgICAgICAgaWYgKCFzc2VxLmZpeFkpIHtcclxuICAgICAgICAgICAgeVNjYWxlID0gdGhpcy50cmFuc2Zvcm0ucmVzY2FsZVkodGhpcy55U2NhbGVJbml0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB4bWluID0gTWF0aC5jZWlsKHhTY2FsZS5pbnZlcnQodGhpcy54TWFyZ2luU2l6ZSkpO1xyXG4gICAgICAgIGxldCB4bWF4ID0gTWF0aC5mbG9vcih4U2NhbGUuaW52ZXJ0KHRoaXMud2lkdGgpKTtcclxuICAgICAgICBsZXQgeW1pbiA9IE1hdGguY2VpbCh5U2NhbGUuaW52ZXJ0KHRoaXMuaGVpZ2h0IC0gdGhpcy55TWFyZ2luU2l6ZSkpO1xyXG4gICAgICAgIGxldCB5bWF4ID0gTWF0aC5mbG9vcih5U2NhbGUuaW52ZXJ0KDApKTtcclxuXHJcblxyXG4gICAgICAgIGxldCB4U2NhbGVNYXhlZCA9IGZhbHNlLCB5U2NhbGVNYXhlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICBpZiAoc3NlcS54UmFuZ2UgJiYgKHhtYXggLSB4bWluKSA+IHNzZXEueFJhbmdlWzFdIC0gc3NlcS54UmFuZ2VbMF0pIHtcclxuICAgICAgICAgICAgeFNjYWxlTWF4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB4U2NhbGUuZG9tYWluKFtzc2VxLnhSYW5nZVswXSAtIHRoaXMuZG9tYWluT2Zmc2V0LCBzc2VxLnhSYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoc3NlcS55UmFuZ2UgJiYgKHltYXggLSB5bWluKSA+IHNzZXEueVJhbmdlWzFdIC0gc3NlcS55UmFuZ2VbMF0pIHtcclxuICAgICAgICAgICAgeVNjYWxlTWF4ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB5U2NhbGUuZG9tYWluKFtzc2VxLnlSYW5nZVswXSAtIHRoaXMuZG9tYWluT2Zmc2V0LCBzc2VxLnlSYW5nZVsxXSArIHRoaXMuZG9tYWluT2Zmc2V0XSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoeFNjYWxlTWF4ZWQgJiYgeVNjYWxlTWF4ZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm9sZF9zY2FsZXNfbWF4ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub2xkX3NjYWxlc19tYXhlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb21fbWF4X3RyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tLnRyYW5zZm9ybSh6b29tRG9tRWxlbWVudCwgdGhpcy56b29tX21heF90cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub2xkX3NjYWxlc19tYXhlZCkge1xyXG4gICAgICAgICAgICAgICAgLy96b29tLnRyYW5zZm9ybSh6b29tRG9tRWxlbWVudCwgcHJlX3pvb21fbWF4X3RyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9sZF9zY2FsZXNfbWF4ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJlX3pvb21fbWF4X3RyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IGQzLnpvb21UcmFuc2Zvcm0oem9vbURvbUVsZW1lbnQubm9kZSgpKTtcclxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy50cmFuc2Zvcm0uaztcclxuICAgICAgICB0aGlzLnhtaW4gPSBNYXRoLmNlaWwoeFNjYWxlLmludmVydCh0aGlzLnhNYXJnaW5TaXplKSk7XHJcbiAgICAgICAgdGhpcy54bWF4ID0gTWF0aC5mbG9vcih4U2NhbGUuaW52ZXJ0KHRoaXMud2lkdGgpKTtcclxuICAgICAgICB0aGlzLnltaW4gPSBNYXRoLmNlaWwoeVNjYWxlLmludmVydCh0aGlzLmhlaWdodCAtIHRoaXMueU1hcmdpblNpemUpKTtcclxuICAgICAgICB0aGlzLnltYXggPSBNYXRoLmZsb29yKHlTY2FsZS5pbnZlcnQoMCkpO1xyXG4gICAgICAgIHRoaXMuem9vbS5vbihcInpvb21cIiwgdGhpcy5kcmF3QWxsKTtcclxuICAgICAgICB0aGlzLnhTY2FsZSA9IHhTY2FsZTtcclxuICAgICAgICB0aGlzLnlTY2FsZSA9IHlTY2FsZTtcclxuXHJcbiAgICAgICAgLy8gd2luZG93LnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgICAgICAvLyB3aW5kb3cueFNjYWxlID0geFNjYWxlO1xyXG5cclxuICAgICAgICB0aGlzLnhab29tID0gTWF0aC5sb2coc2NhbGUpIC8gTWF0aC5sb2codGhpcy5aT09NX0JBU0UpO1xyXG4gICAgICAgIHRoaXMueVpvb20gPSB0aGlzLnhab29tO1xyXG5cclxuICAgICAgICB0aGlzLnhUaWNrcyA9IHRoaXMueFNjYWxlLnRpY2tzKDE1KTtcclxuICAgICAgICB0aGlzLnlUaWNrcyA9IHRoaXMueVNjYWxlLnRpY2tzKCk7XHJcblxyXG4gICAgICAgIHRoaXMueFRpY2tTdGVwID0gTWF0aC5jZWlsKHRoaXMueFRpY2tzWzFdIC0gdGhpcy54VGlja3NbMF0pO1xyXG4gICAgICAgIHRoaXMueVRpY2tTdGVwID0gTWF0aC5jZWlsKHRoaXMueVRpY2tzWzFdIC0gdGhpcy55VGlja3NbMF0pO1xyXG5cclxuICAgICAgICB0aGlzLnhHcmlkU3RlcCA9IChNYXRoLmZsb29yKHRoaXMueFRpY2tTdGVwIC8gNSkgPT09IDApID8gMSA6IE1hdGguZmxvb3IodGhpcy54VGlja1N0ZXAgLyA1KTtcclxuICAgICAgICB0aGlzLnlHcmlkU3RlcCA9IChNYXRoLmZsb29yKHRoaXMueVRpY2tTdGVwIC8gNSkgPT09IDApID8gMSA6IE1hdGguZmxvb3IodGhpcy55VGlja1N0ZXAgLyA1KTtcclxuXHJcbiAgICAgICAgdGhpcy5kcmF3R3JpZCgpO1xyXG4gICAgICAgIHRoaXMuZHJhd1RpY2tzKCk7XHJcbiAgICAgICAgdGhpcy5kcmF3KCk7XHJcblxyXG5cclxuICAgICAgICBpZiAoZDMuZXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIEtvbnZhcyBzdGFnZSB0cmFja3MgdGhlIHBvaW50ZXIgcG9zaXRpb24gdXNpbmcgX3NldFBvaW50ZXJQb3NpdGlvbi5cclxuICAgICAgICAgICAgLy8gZDMgem9vbSBkb2Vzbid0IGFsbG93IHRoZSBldmVudHMgaXQgaGFuZGxlcyB0byBidWJibGUsIHNvIEtvbnZhcyBmYWlscyB0byB0cmFjayBwb2ludGVyIHBvc2l0aW9uLlxyXG4gICAgICAgICAgICAvLyBXZSBoYXZlIHRvIG1hbnVhbGx5IHRlbGwgS29udmFzIHRvIHVwZGF0ZSB0aGUgcG9pbnRlciBwb3NpdGlvbiB1c2luZyB0aGUgZXZlbnQuXHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuX3NldFBvaW50ZXJQb3NpdGlvbihkMy5ldmVudC5zb3VyY2VFdmVudCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHRvb2x0aXAgYmVpbmcgZGlzcGxheWVkIGFuZCB0aGUgem9vbSBldmVudCBoYXMgbW9kaWZpZWQgdGhlIGNhbnZhcyBzbyB0aGF0IHRoZSBjdXJzb3IgaXMgbm9cclxuICAgICAgICAvLyBsb25nZXIgb3ZlciB0aGVcclxuICAgICAgICBpZiAodGhpcy5zdGFnZS5nZXRQb2ludGVyUG9zaXRpb24oKSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuc3RhZ2UuZ2V0SW50ZXJzZWN0aW9uKHRoaXMuc3RhZ2UuZ2V0UG9pbnRlclBvc2l0aW9uKCkpID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VvdXQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd0dyaWQoKSB7XHJcbiAgICAgICAgbGV0IGNvbnRleHQgPSB0aGlzLmdyaWRMYXllckNvbnRleHQ7XHJcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG5cclxuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IE1hdGguZmxvb3IodGhpcy54bWluIC8gdGhpcy54R3JpZFN0ZXApICogdGhpcy54R3JpZFN0ZXA7IGNvbCA8PSB0aGlzLnhtYXg7IGNvbCArPSB0aGlzLnhHcmlkU3RlcCkge1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyh0aGlzLnhTY2FsZShjb2wpLCAwKTtcclxuICAgICAgICAgICAgY29udGV4dC5saW5lVG8odGhpcy54U2NhbGUoY29sKSwgdGhpcy5jbGlwSGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmlkTGF5ZXJDb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuZ3JpZFN0cm9rZVdpZHRoO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcblxyXG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgZm9yIChsZXQgcm93ID0gTWF0aC5mbG9vcih0aGlzLnltaW4gLyB0aGlzLnlHcmlkU3RlcCkgKiB0aGlzLnlHcmlkU3RlcDsgcm93IDw9IHRoaXMueW1heDsgcm93ICs9IHRoaXMueUdyaWRTdGVwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQubW92ZVRvKC10aGlzLmJveFNpemUsIHRoaXMueVNjYWxlKHJvdykpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh0aGlzLndpZHRoICsgdGhpcy5ib3hTaXplLCB0aGlzLnlTY2FsZShyb3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmlkTGF5ZXJDb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuZ3JpZFN0cm9rZVdpZHRoO1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXdUaWNrcygpIHtcclxuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMubWFyZ2luTGF5ZXJDb250ZXh0O1xyXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IE1hdGguZmxvb3IodGhpcy54VGlja3NbMF0pOyBpIDw9IHRoaXMueFRpY2tzW3RoaXMueFRpY2tzLmxlbmd0aCAtIDFdOyBpICs9IHRoaXMueFRpY2tTdGVwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoaSwgdGhpcy54U2NhbGUoaSksIHRoaXMuY2xpcEhlaWdodCArIDIwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gXCJyaWdodFwiO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKHRoaXMueVRpY2tzWzBdKTsgaSA8PSB0aGlzLnlUaWNrc1t0aGlzLnlUaWNrcy5sZW5ndGggLSAxXTsgaSArPSB0aGlzLnlUaWNrU3RlcCkge1xyXG4gICAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KGksIHRoaXMueE1hcmdpblNpemUgLSAxMCwgdGhpcy55U2NhbGUoaSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgZ2V0UG9zaXRpb25Db2xvcktleSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIFwiI1wiICsgS29udmEuVXRpbC5fcmdiVG9IZXgoLi4udGhpcy5oaXRDdHguZ2V0SW1hZ2VEYXRhKHgsIHksIDEsIDEpLmRhdGEpO1xyXG4gICAgfVxyXG5cclxuICAgIGZpbmRCb3VuZGFyeVRvd2FyZHMoc2hhcGUsIHgsIHkpIHtcclxuICAgICAgICBjb25zdCBjb2xvcktleSA9IHNoYXBlLmNvbG9yS2V5O1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0X2Rpc3RhbmNlID0gODtcclxuICAgICAgICBsZXQgeDAgPSBzaGFwZS54KCk7XHJcbiAgICAgICAgbGV0IHkwID0gc2hhcGUueSgpO1xyXG4gICAgICAgIGxldCBkeCA9IHggLSB4MDtcclxuICAgICAgICBsZXQgZHkgPSB5IC0geTA7XHJcbiAgICAgICAgbGV0IGxlbmd0aCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XHJcblxyXG4gICAgICAgIGlmIChsZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHt4OiB4MCwgeTogeTB9O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZHggPSBkeCAvIGxlbmd0aCAqIHN0YXJ0X2Rpc3RhbmNlO1xyXG4gICAgICAgIGR5ID0gZHkgLyBsZW5ndGggKiBzdGFydF9kaXN0YW5jZTtcclxuICAgICAgICBsZW5ndGggPSBzdGFydF9kaXN0YW5jZTtcclxuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMC41KSB7XHJcbiAgICAgICAgICAgIGxlbmd0aCAvPSAyO1xyXG4gICAgICAgICAgICBkeCAvPSAyO1xyXG4gICAgICAgICAgICBkeSAvPSAyO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQb3NpdGlvbkNvbG9yS2V5KHgwICsgZHgsIHkwICsgZHkpID09PSBjb2xvcktleSkge1xyXG4gICAgICAgICAgICAgICAgeDAgKz0gZHg7XHJcbiAgICAgICAgICAgICAgICB5MCArPSBkeTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge3g6IHgwLCB5OiB5MH07XHJcbiAgICB9XHJcblxyXG4gICAgYWRkQ2xhc3NlcygpIHtcclxuICAgICAgICBsZXQgY2xhc3NlcyA9IHRoaXMuc3NlcS5jbGFzc2VzO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgYyA9IGNsYXNzZXNbaV07XHJcbiAgICAgICAgICAgIGMuY2FudmFzX3NoYXBlID0gbmV3IEtvbnZhLlNoYXBlKCk7XHJcbiAgICAgICAgICAgIGMuY2FudmFzX3NoYXBlLnNzZXFfY2xhc3MgPSBjO1xyXG4gICAgICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIGMuY2FudmFzX3NoYXBlLm9uKCdtb3VzZW92ZXInLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VvdmVyKGV2ZW50LmN1cnJlbnRUYXJnZXQpKTtcclxuICAgICAgICAgICAgYy5jYW52YXNfc2hhcGUub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGVNb3VzZW91dCh0aGlzKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc0xheWVyLmFkZChjLmNhbnZhc19zaGFwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHNldFVwRWRnZShlZGdlKSB7XHJcbiAgICAgICAgbGV0IHNvdXJjZV9zaGFwZSA9IGVkZ2Uuc291cmNlLmNhbnZhc19zaGFwZTtcclxuICAgICAgICBsZXQgdGFyZ2V0X3NoYXBlID0gZWRnZS50YXJnZXQuY2FudmFzX3NoYXBlO1xyXG5cclxuICAgICAgICBzb3VyY2Vfc2hhcGUuc2hvdygpO1xyXG4gICAgICAgIHNvdXJjZV9zaGFwZS5kcmF3KCk7XHJcbiAgICAgICAgdGFyZ2V0X3NoYXBlLnNob3coKTtcclxuICAgICAgICB0YXJnZXRfc2hhcGUuZHJhdygpO1xyXG5cclxuXHJcbiAgICAgICAgbGV0IHNvdXJjZVB0ID0gdGhpcy5maW5kQm91bmRhcnlUb3dhcmRzKHNvdXJjZV9zaGFwZSwgdGFyZ2V0X3NoYXBlLngoKSwgdGFyZ2V0X3NoYXBlLnkoKSk7XHJcbiAgICAgICAgbGV0IHRhcmdldFB0ID0gdGhpcy5maW5kQm91bmRhcnlUb3dhcmRzKHRhcmdldF9zaGFwZSwgc291cmNlX3NoYXBlLngoKSwgc291cmNlX3NoYXBlLnkoKSk7XHJcbiAgICAgICAgZWRnZS5zb3VyY2VPZmZzZXQgPSB7eDogKHNvdXJjZVB0LnggLSBzb3VyY2Vfc2hhcGUueCgpKSwgeTogKHNvdXJjZVB0LnkgLSBzb3VyY2Vfc2hhcGUueSgpKX07XHJcbiAgICAgICAgZWRnZS50YXJnZXRPZmZzZXQgPSB7eDogKHRhcmdldFB0LnggLSBzb3VyY2Vfc2hhcGUueCgpKSwgeTogKHRhcmdldFB0LnkgLSBzb3VyY2Vfc2hhcGUueSgpKX07XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgLy8gd2luZG93LmxheWVyID0gY2xhc3NMYXllcjtcclxuICAgICAgICBsZXQgY29udGV4dCA9IHRoaXMuY2xhc3NMYXllckNvbnRleHQ7XHJcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuc3NlcS5fY2FsY3VsYXRlRHJhd25FbGVtZW50cyh0aGlzLnBhZ2UsIHRoaXMueG1pbiwgdGhpcy54bWF4LCB0aGlzLnltaW4sIHRoaXMueW1heCk7XHJcblxyXG5cclxuICAgICAgICBsZXQgY2xhc3NlcyA9IHRoaXMuc3NlcS5nZXRDbGFzc2VzVG9EaXNwbGF5KCk7XHJcbiAgICAgICAgdGhpcy5jbGFzc0xheWVyLnJlbW92ZUNoaWxkcmVuKCk7XHJcblxyXG4gICAgICAgIGxldCBzY2FsZV9zaXplO1xyXG4gICAgICAgIGlmICh0aGlzLnNjYWxlIDwgMSAvIDIpIHtcclxuICAgICAgICAgICAgc2NhbGVfc2l6ZSA9IDEgLyAyO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY2FsZSA+IDIpIHtcclxuICAgICAgICAgICAgc2NhbGVfc2l6ZSA9IDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc2NhbGVfc2l6ZSA9IHRoaXMuc2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGMgPSBjbGFzc2VzW2ldO1xyXG4gICAgICAgICAgICBsZXQgcyA9IGMuY2FudmFzX3NoYXBlO1xyXG4gICAgICAgICAgICBpZiAoIXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMuc2V0UG9zaXRpb24oe3g6IHRoaXMueFNjYWxlKGMueCkgKyBjLl9nZXRYT2Zmc2V0KCksIHk6IHRoaXMueVNjYWxlKGMueSkgKyBjLl9nZXRZT2Zmc2V0KCl9KTtcclxuICAgICAgICAgICAgcy5zZXROb2RlKGMuZ2V0Tm9kZSh0aGlzLnBhZ2UpKTtcclxuICAgICAgICAgICAgcy5zaXplKHMuc2l6ZSgpICogc2NhbGVfc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NMYXllci5hZGQocyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmNsYXNzTGF5ZXIuZHJhdygpO1xyXG5cclxuICAgICAgICBjb250ZXh0ID0gdGhpcy5lZGdlTGF5ZXJDb250ZXh0O1xyXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuXHJcbiAgICAgICAgbGV0IGVkZ2VzID0gdGhpcy5zc2VxLmdldEVkZ2VzVG9EaXNwbGF5KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZSA9IGVkZ2VzW2ldO1xyXG4gICAgICAgICAgICBsZXQgc291cmNlX3NoYXBlID0gZS5zb3VyY2UuY2FudmFzX3NoYXBlO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0X3NoYXBlID0gZS50YXJnZXQuY2FudmFzX3NoYXBlO1xyXG4gICAgICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAoIWUuc291cmNlT2Zmc2V0IHx8IChlLnNvdXJjZU9mZnNldC54ID09PSAwICYmIGUuc291cmNlT2Zmc2V0LnkgPT09IDApKSB7XHJcbiAgICAgICAgICAgICAgICBlLnNvdXJjZU9mZnNldCA9IHt4OiAwLCB5OiAwfTtcclxuICAgICAgICAgICAgICAgIGUudGFyZ2V0T2Zmc2V0ID0ge3g6IDAsIHk6IDB9O1xyXG4gICAgICAgICAgICAgICAgLy9zZXRUaW1lb3V0KHNldFVwRWRnZShlKSwwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBlLmNvbG9yO1xyXG4gICAgICAgICAgICBjb250ZXh0Lm1vdmVUbyhzb3VyY2Vfc2hhcGUueCgpICsgZS5zb3VyY2VPZmZzZXQueCwgc291cmNlX3NoYXBlLnkoKSArIGUuc291cmNlT2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmxpbmVUbyh0YXJnZXRfc2hhcGUueCgpICsgZS50YXJnZXRPZmZzZXQueCwgdGFyZ2V0X3NoYXBlLnkoKSArIGUudGFyZ2V0T2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG5cclxuICAgIGhhbmRsZU1vdXNlb3ZlcihzaGFwZSkge1xyXG4gICAgICAgIGxldCBjID0gc2hhcGUuc3NlcV9jbGFzcztcclxuICAgICAgICBsZXQgZGlzcCA9IGMuc3NlcS5kaXNwO1xyXG4gICAgICAgIGlmIChjLnRvb2x0aXBfaHRtbCkge1xyXG4gICAgICAgICAgICBkaXNwLnRvb2x0aXBfZGl2X2R1bW15Lmh0bWwoYy50b29sdGlwX2h0bWwpO1xyXG4gICAgICAgICAgICBkaXNwLnNldHVwVG9vbHRpcERpdihzaGFwZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IGV4dHJhX2luZm9faHRtbCA9IGMuZXh0cmFfaW5mby5yZXBsYWNlKFwiXFxuXCIsIFwiXFxuPGhyPlxcblwiKTtcclxuICAgICAgICAgICAgaWYgKE1hdGhKYXggJiYgTWF0aEpheC5IdWIpIHtcclxuICAgICAgICAgICAgICAgIGRpc3AudG9vbHRpcF9kaXZfZHVtbXkuaHRtbChgXFxcXCgke2MubmFtZX1cXFxcKSAtLSAoJHtjLnh9LCAke2MueX0pYCArIGV4dHJhX2luZm9faHRtbCk7XHJcbiAgICAgICAgICAgICAgICBNYXRoSmF4Lkh1Yi5RdWV1ZShbXCJUeXBlc2V0XCIsIE1hdGhKYXguSHViLCBcInRvb2x0aXBfZGl2X2R1bW15XCJdKTtcclxuICAgICAgICAgICAgICAgIE1hdGhKYXguSHViLlF1ZXVlKCgpID0+IGRpc3Auc2V0dXBUb29sdGlwRGl2KHNoYXBlKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwLnRvb2x0aXBfZGl2X2R1bW15Lmh0bWwoYFxcXFwoJHtjLm5hbWV9XFxcXCkgLS0gKCR7Yy54fSwgJHtjLnl9KWAgKyBleHRyYV9pbmZvX2h0bWwpO1xyXG4gICAgICAgICAgICAgICAgZGlzcC5zZXR1cFRvb2x0aXBEaXYodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2V0dXBUb29sdGlwRGl2KHNoYXBlKSB7XHJcbiAgICAgICAgbGV0IHJlY3QgPSB0aGlzLnRvb2x0aXBfZGl2Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBsZXQgdG9vbHRpcF93aWR0aCA9IHJlY3Qud2lkdGg7XHJcbiAgICAgICAgbGV0IHRvb2x0aXBfaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XHJcbiAgICAgICAgc2hhcGUuc3NlcV9jbGFzcy50b29sdGlwX2h0bWwgPSB0aGlzLnRvb2x0aXBfZGl2X2R1bW15Lmh0bWwoKTtcclxuICAgICAgICB0aGlzLnRvb2x0aXBfZGl2Lmh0bWwodGhpcy50b29sdGlwX2Rpdl9kdW1teS5odG1sKCkpO1xyXG4gICAgICAgIHRoaXMudG9vbHRpcF9kaXYuc3R5bGUoXCJsZWZ0XCIsIChzaGFwZS54KCkgKyAyNSkgKyBcInB4XCIpXHJcbiAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAoc2hhcGUueSgpIC0gdG9vbHRpcF9oZWlnaHQpICsgXCJweFwiKVxyXG4gICAgICAgICAgICAuc3R5bGUoXCJyaWdodFwiLCBudWxsKS5zdHlsZShcImJvdHRvbVwiLCBudWxsKTtcclxuICAgICAgICBsZXQgYm91bmRpbmdfcmVjdCA9IHRoaXMudG9vbHRpcF9kaXYubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIGlmIChib3VuZGluZ19yZWN0LnJpZ2h0ID4gdGhpcy53aWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBfZGl2LnN0eWxlKFwibGVmdFwiLCBudWxsKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwicmlnaHRcIiwgKHRoaXMud2lkdGggLSBzaGFwZS54KCkgKyAxMCkgKyBcInB4XCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3VuZGluZ19yZWN0LnRvcCA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy50b29sdGlwX2Rpdi5zdHlsZShcInRvcFwiLCAoc2hhcGUueSgpICsgMTApICsgXCJweFwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50b29sdGlwX2Rpdi50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcclxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAuOSk7XHJcbiAgICB9XHJcblxyXG4gICAgaGFuZGxlTW91c2VvdXQoKSB7XHJcbiAgICAgICAgdGhpcy50b29sdGlwX2Rpdi50cmFuc2l0aW9uKClcclxuICAgICAgICAgICAgLmR1cmF0aW9uKDUwMClcclxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0cy5EaXNwbGF5ID0gRGlzcGxheTsiLCIvLyBUaGlzIE1hdGhKYXggZmlsZSBjb21lcyBmcm9tIHRoZSBNYXRoSmF4LXNpbmdsZS1maWxlIGdpdCBhcmNoaXZlIGZvbGRlciBkaXN0L1RlWFNWR1RlWFxyXG4vLyBJdCBpc24ndCBkZXNpZ25lZCB0byB3b3JrIHdpdGggbm9kZSAvIGJyb3dzZXJpZnkgLS0gaXQganVzdCBpbnN0YWxscyBpdHNlbGYgYXMgYSBnbG9iYWwgdmFyaWFibGUuXHJcbi8vIGJlY2F1c2Ugb2YgdGhpcywgcmVxdWlyZSBqdXN0IFwicmV0dXJuc1wiIGFuIGVtcHR5IG9iamVjdCwgc28gdGhlcmUncyBubyB1c2UgaW4gc2F2aW5nIHRoZSBvdXRwdXQuXHJcbi8vcmVxdWlyZShcIi4vbWF0aGpheC5taW4uanNcIik7XHJcblxyXG53aW5kb3cuaW5maW5pdHkgPSAxMDAwMDtcclxuXHJcbndpbmRvdy5tb2QgPSBmdW5jdGlvbihuLGQpe1xyXG4gICAgcmV0dXJuIChuICUgZCArIGQpJWQ7XHJcbn1cclxuXHJcblxyXG53aW5kb3cuU2hhcGVzID0gcmVxdWlyZShcIi4vU2hhcGUuanNcIik7XHJcbndpbmRvdy5EaXNwbGF5ID0gcmVxdWlyZShcIi4vZGlzcGxheS5qc1wiKS5EaXNwbGF5O1xyXG5cclxuXHJcbndpbmRvdy5Tc2VxID0gcmVxdWlyZShcIi4vU3NlcS5qc1wiKS5Tc2VxO1xyXG53aW5kb3cuZDMgPSByZXF1aXJlKFwiZDNcIik7XHJcbi8vcmVxdWlyZShcIi4uL2V4YW1wbGVzL0tPLmpzXCIpO1xyXG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWFycmF5LyBWZXJzaW9uIDEuMi4xLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBhc2NlbmRpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogYSA+PSBiID8gMCA6IE5hTjtcbn07XG5cbnZhciBiaXNlY3RvciA9IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgaWYgKGNvbXBhcmUubGVuZ3RoID09PSAxKSBjb21wYXJlID0gYXNjZW5kaW5nQ29tcGFyYXRvcihjb21wYXJlKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBmdW5jdGlvbihhLCB4LCBsbywgaGkpIHtcbiAgICAgIGlmIChsbyA9PSBudWxsKSBsbyA9IDA7XG4gICAgICBpZiAoaGkgPT0gbnVsbCkgaGkgPSBhLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICAgIHZhciBtaWQgPSBsbyArIGhpID4+PiAxO1xuICAgICAgICBpZiAoY29tcGFyZShhW21pZF0sIHgpIDwgMCkgbG8gPSBtaWQgKyAxO1xuICAgICAgICBlbHNlIGhpID0gbWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvO1xuICAgIH0sXG4gICAgcmlnaHQ6IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSkge1xuICAgICAgaWYgKGxvID09IG51bGwpIGxvID0gMDtcbiAgICAgIGlmIChoaSA9PSBudWxsKSBoaSA9IGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICAgICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgICAgIGlmIChjb21wYXJlKGFbbWlkXSwgeCkgPiAwKSBoaSA9IG1pZDtcbiAgICAgICAgZWxzZSBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG87XG4gICAgfVxuICB9O1xufTtcblxuZnVuY3Rpb24gYXNjZW5kaW5nQ29tcGFyYXRvcihmKSB7XG4gIHJldHVybiBmdW5jdGlvbihkLCB4KSB7XG4gICAgcmV0dXJuIGFzY2VuZGluZyhmKGQpLCB4KTtcbiAgfTtcbn1cblxudmFyIGFzY2VuZGluZ0Jpc2VjdCA9IGJpc2VjdG9yKGFzY2VuZGluZyk7XG52YXIgYmlzZWN0UmlnaHQgPSBhc2NlbmRpbmdCaXNlY3QucmlnaHQ7XG52YXIgYmlzZWN0TGVmdCA9IGFzY2VuZGluZ0Jpc2VjdC5sZWZ0O1xuXG52YXIgcGFpcnMgPSBmdW5jdGlvbihhcnJheSwgZikge1xuICBpZiAoZiA9PSBudWxsKSBmID0gcGFpcjtcbiAgdmFyIGkgPSAwLCBuID0gYXJyYXkubGVuZ3RoIC0gMSwgcCA9IGFycmF5WzBdLCBwYWlycyA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBwYWlyc1tpXSA9IGYocCwgcCA9IGFycmF5WysraV0pO1xuICByZXR1cm4gcGFpcnM7XG59O1xuXG5mdW5jdGlvbiBwYWlyKGEsIGIpIHtcbiAgcmV0dXJuIFthLCBiXTtcbn1cblxudmFyIGNyb3NzID0gZnVuY3Rpb24odmFsdWVzMCwgdmFsdWVzMSwgcmVkdWNlKSB7XG4gIHZhciBuMCA9IHZhbHVlczAubGVuZ3RoLFxuICAgICAgbjEgPSB2YWx1ZXMxLmxlbmd0aCxcbiAgICAgIHZhbHVlcyA9IG5ldyBBcnJheShuMCAqIG4xKSxcbiAgICAgIGkwLFxuICAgICAgaTEsXG4gICAgICBpLFxuICAgICAgdmFsdWUwO1xuXG4gIGlmIChyZWR1Y2UgPT0gbnVsbCkgcmVkdWNlID0gcGFpcjtcblxuICBmb3IgKGkwID0gaSA9IDA7IGkwIDwgbjA7ICsraTApIHtcbiAgICBmb3IgKHZhbHVlMCA9IHZhbHVlczBbaTBdLCBpMSA9IDA7IGkxIDwgbjE7ICsraTEsICsraSkge1xuICAgICAgdmFsdWVzW2ldID0gcmVkdWNlKHZhbHVlMCwgdmFsdWVzMVtpMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufTtcblxudmFyIG51bWJlciA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPT09IG51bGwgPyBOYU4gOiAreDtcbn07XG5cbnZhciB2YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gMCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG1lYW4gPSAwLFxuICAgICAgdmFsdWUsXG4gICAgICBkZWx0YSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKCFpc05hTih2YWx1ZSA9IG51bWJlcih2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkpKSB7XG4gICAgICAgIGRlbHRhID0gdmFsdWUgLSBtZWFuO1xuICAgICAgICBtZWFuICs9IGRlbHRhIC8gKyttO1xuICAgICAgICBzdW0gKz0gZGVsdGEgKiAodmFsdWUgLSBtZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobSA+IDEpIHJldHVybiBzdW0gLyAobSAtIDEpO1xufTtcblxudmFyIGRldmlhdGlvbiA9IGZ1bmN0aW9uKGFycmF5LCBmKSB7XG4gIHZhciB2ID0gdmFyaWFuY2UoYXJyYXksIGYpO1xuICByZXR1cm4gdiA/IE1hdGguc3FydCh2KSA6IHY7XG59O1xuXG52YXIgZXh0ZW50ID0gZnVuY3Rpb24odmFsdWVzLCB2YWx1ZW9mKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgbWluLFxuICAgICAgbWF4O1xuXG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtaW4gPSBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobWluID4gdmFsdWUpIG1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKG1heCA8IHZhbHVlKSBtYXggPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBGaW5kIHRoZSBmaXJzdCBjb21wYXJhYmxlIHZhbHVlLlxuICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IG1heCA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG1pbiA+IHZhbHVlKSBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChtYXggPCB2YWx1ZSkgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttaW4sIG1heF07XG59O1xuXG52YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGU7XG5cbnZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xudmFyIG1hcCA9IGFycmF5Lm1hcDtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgaWRlbnRpdHkgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiB4O1xufTtcblxudmFyIHJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgc3RhcnQgPSArc3RhcnQsIHN0b3AgPSArc3RvcCwgc3RlcCA9IChuID0gYXJndW1lbnRzLmxlbmd0aCkgPCAyID8gKHN0b3AgPSBzdGFydCwgc3RhcnQgPSAwLCAxKSA6IG4gPCAzID8gMSA6ICtzdGVwO1xuXG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCkpIHwgMCxcbiAgICAgIHJhbmdlID0gbmV3IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgcmFuZ2VbaV0gPSBzdGFydCArIGkgKiBzdGVwO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlO1xufTtcblxudmFyIGUxMCA9IE1hdGguc3FydCg1MCk7XG52YXIgZTUgPSBNYXRoLnNxcnQoMTApO1xudmFyIGUyID0gTWF0aC5zcXJ0KDIpO1xuXG52YXIgdGlja3MgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgY291bnQpIHtcbiAgdmFyIHJldmVyc2UsXG4gICAgICBpID0gLTEsXG4gICAgICBuLFxuICAgICAgdGlja3MsXG4gICAgICBzdGVwO1xuXG4gIHN0b3AgPSArc3RvcCwgc3RhcnQgPSArc3RhcnQsIGNvdW50ID0gK2NvdW50O1xuICBpZiAoc3RhcnQgPT09IHN0b3AgJiYgY291bnQgPiAwKSByZXR1cm4gW3N0YXJ0XTtcbiAgaWYgKHJldmVyc2UgPSBzdG9wIDwgc3RhcnQpIG4gPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gbjtcbiAgaWYgKChzdGVwID0gdGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpKSA9PT0gMCB8fCAhaXNGaW5pdGUoc3RlcCkpIHJldHVybiBbXTtcblxuICBpZiAoc3RlcCA+IDApIHtcbiAgICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAvIHN0ZXApO1xuICAgIHN0b3AgPSBNYXRoLmZsb29yKHN0b3AgLyBzdGVwKTtcbiAgICB0aWNrcyA9IG5ldyBBcnJheShuID0gTWF0aC5jZWlsKHN0b3AgLSBzdGFydCArIDEpKTtcbiAgICB3aGlsZSAoKytpIDwgbikgdGlja3NbaV0gPSAoc3RhcnQgKyBpKSAqIHN0ZXA7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0ICogc3RlcCk7XG4gICAgc3RvcCA9IE1hdGguY2VpbChzdG9wICogc3RlcCk7XG4gICAgdGlja3MgPSBuZXcgQXJyYXkobiA9IE1hdGguY2VpbChzdGFydCAtIHN0b3AgKyAxKSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHRpY2tzW2ldID0gKHN0YXJ0IC0gaSkgLyBzdGVwO1xuICB9XG5cbiAgaWYgKHJldmVyc2UpIHRpY2tzLnJldmVyc2UoKTtcblxuICByZXR1cm4gdGlja3M7XG59O1xuXG5mdW5jdGlvbiB0aWNrSW5jcmVtZW50KHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICB2YXIgc3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoMCwgY291bnQpLFxuICAgICAgcG93ZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXApIC8gTWF0aC5MTjEwKSxcbiAgICAgIGVycm9yID0gc3RlcCAvIE1hdGgucG93KDEwLCBwb3dlcik7XG4gIHJldHVybiBwb3dlciA+PSAwXG4gICAgICA/IChlcnJvciA+PSBlMTAgPyAxMCA6IGVycm9yID49IGU1ID8gNSA6IGVycm9yID49IGUyID8gMiA6IDEpICogTWF0aC5wb3coMTAsIHBvd2VyKVxuICAgICAgOiAtTWF0aC5wb3coMTAsIC1wb3dlcikgLyAoZXJyb3IgPj0gZTEwID8gMTAgOiBlcnJvciA+PSBlNSA/IDUgOiBlcnJvciA+PSBlMiA/IDIgOiAxKTtcbn1cblxuZnVuY3Rpb24gdGlja1N0ZXAoc3RhcnQsIHN0b3AsIGNvdW50KSB7XG4gIHZhciBzdGVwMCA9IE1hdGguYWJzKHN0b3AgLSBzdGFydCkgLyBNYXRoLm1heCgwLCBjb3VudCksXG4gICAgICBzdGVwMSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKE1hdGgubG9nKHN0ZXAwKSAvIE1hdGguTE4xMCkpLFxuICAgICAgZXJyb3IgPSBzdGVwMCAvIHN0ZXAxO1xuICBpZiAoZXJyb3IgPj0gZTEwKSBzdGVwMSAqPSAxMDtcbiAgZWxzZSBpZiAoZXJyb3IgPj0gZTUpIHN0ZXAxICo9IDU7XG4gIGVsc2UgaWYgKGVycm9yID49IGUyKSBzdGVwMSAqPSAyO1xuICByZXR1cm4gc3RvcCA8IHN0YXJ0ID8gLXN0ZXAxIDogc3RlcDE7XG59XG5cbnZhciBzdHVyZ2VzID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoTWF0aC5sb2codmFsdWVzLmxlbmd0aCkgLyBNYXRoLkxOMikgKyAxO1xufTtcblxudmFyIGhpc3RvZ3JhbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdmFsdWUgPSBpZGVudGl0eSxcbiAgICAgIGRvbWFpbiA9IGV4dGVudCxcbiAgICAgIHRocmVzaG9sZCA9IHN0dXJnZXM7XG5cbiAgZnVuY3Rpb24gaGlzdG9ncmFtKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgICB4LFxuICAgICAgICB2YWx1ZXMgPSBuZXcgQXJyYXkobik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YWx1ZXNbaV0gPSB2YWx1ZShkYXRhW2ldLCBpLCBkYXRhKTtcbiAgICB9XG5cbiAgICB2YXIgeHogPSBkb21haW4odmFsdWVzKSxcbiAgICAgICAgeDAgPSB4elswXSxcbiAgICAgICAgeDEgPSB4elsxXSxcbiAgICAgICAgdHogPSB0aHJlc2hvbGQodmFsdWVzLCB4MCwgeDEpO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgb2YgdGhyZXNob2xkcyBpbnRvIHVuaWZvcm0gdGhyZXNob2xkcy5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodHopKSB7XG4gICAgICB0eiA9IHRpY2tTdGVwKHgwLCB4MSwgdHopO1xuICAgICAgdHogPSByYW5nZShNYXRoLmNlaWwoeDAgLyB0eikgKiB0eiwgTWF0aC5mbG9vcih4MSAvIHR6KSAqIHR6LCB0eik7IC8vIGV4Y2x1c2l2ZVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSBhbnkgdGhyZXNob2xkcyBvdXRzaWRlIHRoZSBkb21haW4uXG4gICAgdmFyIG0gPSB0ei5sZW5ndGg7XG4gICAgd2hpbGUgKHR6WzBdIDw9IHgwKSB0ei5zaGlmdCgpLCAtLW07XG4gICAgd2hpbGUgKHR6W20gLSAxXSA+IHgxKSB0ei5wb3AoKSwgLS1tO1xuXG4gICAgdmFyIGJpbnMgPSBuZXcgQXJyYXkobSArIDEpLFxuICAgICAgICBiaW47XG5cbiAgICAvLyBJbml0aWFsaXplIGJpbnMuXG4gICAgZm9yIChpID0gMDsgaSA8PSBtOyArK2kpIHtcbiAgICAgIGJpbiA9IGJpbnNbaV0gPSBbXTtcbiAgICAgIGJpbi54MCA9IGkgPiAwID8gdHpbaSAtIDFdIDogeDA7XG4gICAgICBiaW4ueDEgPSBpIDwgbSA/IHR6W2ldIDogeDE7XG4gICAgfVxuXG4gICAgLy8gQXNzaWduIGRhdGEgdG8gYmlucyBieSB2YWx1ZSwgaWdub3JpbmcgYW55IG91dHNpZGUgdGhlIGRvbWFpbi5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4ID0gdmFsdWVzW2ldO1xuICAgICAgaWYgKHgwIDw9IHggJiYgeCA8PSB4MSkge1xuICAgICAgICBiaW5zW2Jpc2VjdFJpZ2h0KHR6LCB4LCAwLCBtKV0ucHVzaChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmlucztcbiAgfVxuXG4gIGhpc3RvZ3JhbS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGhpc3RvZ3JhbSkgOiB2YWx1ZTtcbiAgfTtcblxuICBoaXN0b2dyYW0uZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoW19bMF0sIF9bMV1dKSwgaGlzdG9ncmFtKSA6IGRvbWFpbjtcbiAgfTtcblxuICBoaXN0b2dyYW0udGhyZXNob2xkcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aHJlc2hvbGQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IEFycmF5LmlzQXJyYXkoXykgPyBjb25zdGFudChzbGljZS5jYWxsKF8pKSA6IGNvbnN0YW50KF8pLCBoaXN0b2dyYW0pIDogdGhyZXNob2xkO1xuICB9O1xuXG4gIHJldHVybiBoaXN0b2dyYW07XG59O1xuXG52YXIgcXVhbnRpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIHAsIHZhbHVlb2YpIHtcbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkgdmFsdWVvZiA9IG51bWJlcjtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIGlmICgocCA9ICtwKSA8PSAwIHx8IG4gPCAyKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzWzBdLCAwLCB2YWx1ZXMpO1xuICBpZiAocCA+PSAxKSByZXR1cm4gK3ZhbHVlb2YodmFsdWVzW24gLSAxXSwgbiAtIDEsIHZhbHVlcyk7XG4gIHZhciBuLFxuICAgICAgaSA9IChuIC0gMSkgKiBwLFxuICAgICAgaTAgPSBNYXRoLmZsb29yKGkpLFxuICAgICAgdmFsdWUwID0gK3ZhbHVlb2YodmFsdWVzW2kwXSwgaTAsIHZhbHVlcyksXG4gICAgICB2YWx1ZTEgPSArdmFsdWVvZih2YWx1ZXNbaTAgKyAxXSwgaTAgKyAxLCB2YWx1ZXMpO1xuICByZXR1cm4gdmFsdWUwICsgKHZhbHVlMSAtIHZhbHVlMCkgKiAoaSAtIGkwKTtcbn07XG5cbnZhciBmcmVlZG1hbkRpYWNvbmlzID0gZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICB2YWx1ZXMgPSBtYXAuY2FsbCh2YWx1ZXMsIG51bWJlcikuc29ydChhc2NlbmRpbmcpO1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDIgKiAocXVhbnRpbGUodmFsdWVzLCAwLjc1KSAtIHF1YW50aWxlKHZhbHVlcywgMC4yNSkpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufTtcblxudmFyIHNjb3R0ID0gZnVuY3Rpb24odmFsdWVzLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKDMuNSAqIGRldmlhdGlvbih2YWx1ZXMpICogTWF0aC5wb3codmFsdWVzLmxlbmd0aCwgLTEgLyAzKSkpO1xufTtcblxudmFyIG1heCA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1heDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlc1tpXSkgIT0gbnVsbCAmJiB2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgbWF4ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gRmluZCB0aGUgZmlyc3QgY29tcGFyYWJsZSB2YWx1ZS5cbiAgICAgIGlmICgodmFsdWUgPSB2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgIT0gbnVsbCAmJiB2YWx1ZSA+PSB2YWx1ZSkge1xuICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgd2hpbGUgKCsraSA8IG4pIHsgLy8gQ29tcGFyZSB0aGUgcmVtYWluaW5nIHZhbHVlcy5cbiAgICAgICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXg7XG59O1xuXG52YXIgbWVhbiA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBtID0gbixcbiAgICAgIGkgPSAtMSxcbiAgICAgIHZhbHVlLFxuICAgICAgc3VtID0gMDtcblxuICBpZiAodmFsdWVvZiA9PSBudWxsKSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVzW2ldKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSkpIHN1bSArPSB2YWx1ZTtcbiAgICAgIGVsc2UgLS1tO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtKSByZXR1cm4gc3VtIC8gbTtcbn07XG5cbnZhciBtZWRpYW4gPSBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBudW1iZXJzID0gW107XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAoIWlzTmFOKHZhbHVlID0gbnVtYmVyKHZhbHVlc1tpXSkpKSB7XG4gICAgICAgIG51bWJlcnMucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICghaXNOYU4odmFsdWUgPSBudW1iZXIodmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpKSkge1xuICAgICAgICBudW1iZXJzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWFudGlsZShudW1iZXJzLnNvcnQoYXNjZW5kaW5nKSwgMC41KTtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbiA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBtLFxuICAgICAgaSA9IC0xLFxuICAgICAgaiA9IDAsXG4gICAgICBtZXJnZWQsXG4gICAgICBhcnJheTtcblxuICB3aGlsZSAoKytpIDwgbikgaiArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICBtZXJnZWQgPSBuZXcgQXJyYXkoaik7XG5cbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgYXJyYXkgPSBhcnJheXNbbl07XG4gICAgbSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIG1lcmdlZFstLWpdID0gYXJyYXlbbV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1lcmdlZDtcbn07XG5cbnZhciBtaW4gPSBmdW5jdGlvbih2YWx1ZXMsIHZhbHVlb2YpIHtcbiAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgaSA9IC0xLFxuICAgICAgdmFsdWUsXG4gICAgICBtaW47XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVzW2ldKSAhPSBudWxsICYmIHZhbHVlID49IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICB3aGlsZSAoKytpIDwgbikgeyAvLyBDb21wYXJlIHRoZSByZW1haW5pbmcgdmFsdWVzLlxuICAgICAgICAgIGlmICgodmFsdWUgPSB2YWx1ZXNbaV0pICE9IG51bGwgJiYgbWluID4gdmFsdWUpIHtcbiAgICAgICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsc2Uge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIEZpbmQgdGhlIGZpcnN0IGNvbXBhcmFibGUgdmFsdWUuXG4gICAgICBpZiAoKHZhbHVlID0gdmFsdWVvZih2YWx1ZXNbaV0sIGksIHZhbHVlcykpICE9IG51bGwgJiYgdmFsdWUgPj0gdmFsdWUpIHtcbiAgICAgICAgbWluID0gdmFsdWU7XG4gICAgICAgIHdoaWxlICgrK2kgPCBuKSB7IC8vIENvbXBhcmUgdGhlIHJlbWFpbmluZyB2YWx1ZXMuXG4gICAgICAgICAgaWYgKCh2YWx1ZSA9IHZhbHVlb2YodmFsdWVzW2ldLCBpLCB2YWx1ZXMpKSAhPSBudWxsICYmIG1pbiA+IHZhbHVlKSB7XG4gICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWluO1xufTtcblxudmFyIHBlcm11dGUgPSBmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICB2YXIgaSA9IGluZGV4ZXMubGVuZ3RoLCBwZXJtdXRlcyA9IG5ldyBBcnJheShpKTtcbiAgd2hpbGUgKGktLSkgcGVybXV0ZXNbaV0gPSBhcnJheVtpbmRleGVzW2ldXTtcbiAgcmV0dXJuIHBlcm11dGVzO1xufTtcblxudmFyIHNjYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGNvbXBhcmUpIHtcbiAgaWYgKCEobiA9IHZhbHVlcy5sZW5ndGgpKSByZXR1cm47XG4gIHZhciBuLFxuICAgICAgaSA9IDAsXG4gICAgICBqID0gMCxcbiAgICAgIHhpLFxuICAgICAgeGogPSB2YWx1ZXNbal07XG5cbiAgaWYgKGNvbXBhcmUgPT0gbnVsbCkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGlmIChjb21wYXJlKHhpID0gdmFsdWVzW2ldLCB4aikgPCAwIHx8IGNvbXBhcmUoeGosIHhqKSAhPT0gMCkge1xuICAgICAgeGogPSB4aSwgaiA9IGk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbXBhcmUoeGosIHhqKSA9PT0gMCkgcmV0dXJuIGo7XG59O1xuXG52YXIgc2h1ZmZsZSA9IGZ1bmN0aW9uKGFycmF5LCBpMCwgaTEpIHtcbiAgdmFyIG0gPSAoaTEgPT0gbnVsbCA/IGFycmF5Lmxlbmd0aCA6IGkxKSAtIChpMCA9IGkwID09IG51bGwgPyAwIDogK2kwKSxcbiAgICAgIHQsXG4gICAgICBpO1xuXG4gIHdoaWxlIChtKSB7XG4gICAgaSA9IE1hdGgucmFuZG9tKCkgKiBtLS0gfCAwO1xuICAgIHQgPSBhcnJheVttICsgaTBdO1xuICAgIGFycmF5W20gKyBpMF0gPSBhcnJheVtpICsgaTBdO1xuICAgIGFycmF5W2kgKyBpMF0gPSB0O1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxudmFyIHN1bSA9IGZ1bmN0aW9uKHZhbHVlcywgdmFsdWVvZikge1xuICB2YXIgbiA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN1bSA9IDA7XG5cbiAgaWYgKHZhbHVlb2YgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBpZiAodmFsdWUgPSArdmFsdWVzW2ldKSBzdW0gKz0gdmFsdWU7IC8vIE5vdGU6IHplcm8gYW5kIG51bGwgYXJlIGVxdWl2YWxlbnQuXG4gICAgfVxuICB9XG5cbiAgZWxzZSB7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZSA9ICt2YWx1ZW9mKHZhbHVlc1tpXSwgaSwgdmFsdWVzKSkgc3VtICs9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdW07XG59O1xuXG52YXIgdHJhbnNwb3NlID0gZnVuY3Rpb24obWF0cml4KSB7XG4gIGlmICghKG4gPSBtYXRyaXgubGVuZ3RoKSkgcmV0dXJuIFtdO1xuICBmb3IgKHZhciBpID0gLTEsIG0gPSBtaW4obWF0cml4LCBsZW5ndGgpLCB0cmFuc3Bvc2UgPSBuZXcgQXJyYXkobSk7ICsraSA8IG07KSB7XG4gICAgZm9yICh2YXIgaiA9IC0xLCBuLCByb3cgPSB0cmFuc3Bvc2VbaV0gPSBuZXcgQXJyYXkobik7ICsraiA8IG47KSB7XG4gICAgICByb3dbal0gPSBtYXRyaXhbal1baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0cmFuc3Bvc2U7XG59O1xuXG5mdW5jdGlvbiBsZW5ndGgoZCkge1xuICByZXR1cm4gZC5sZW5ndGg7XG59XG5cbnZhciB6aXAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRyYW5zcG9zZShhcmd1bWVudHMpO1xufTtcblxuZXhwb3J0cy5iaXNlY3QgPSBiaXNlY3RSaWdodDtcbmV4cG9ydHMuYmlzZWN0UmlnaHQgPSBiaXNlY3RSaWdodDtcbmV4cG9ydHMuYmlzZWN0TGVmdCA9IGJpc2VjdExlZnQ7XG5leHBvcnRzLmFzY2VuZGluZyA9IGFzY2VuZGluZztcbmV4cG9ydHMuYmlzZWN0b3IgPSBiaXNlY3RvcjtcbmV4cG9ydHMuY3Jvc3MgPSBjcm9zcztcbmV4cG9ydHMuZGVzY2VuZGluZyA9IGRlc2NlbmRpbmc7XG5leHBvcnRzLmRldmlhdGlvbiA9IGRldmlhdGlvbjtcbmV4cG9ydHMuZXh0ZW50ID0gZXh0ZW50O1xuZXhwb3J0cy5oaXN0b2dyYW0gPSBoaXN0b2dyYW07XG5leHBvcnRzLnRocmVzaG9sZEZyZWVkbWFuRGlhY29uaXMgPSBmcmVlZG1hbkRpYWNvbmlzO1xuZXhwb3J0cy50aHJlc2hvbGRTY290dCA9IHNjb3R0O1xuZXhwb3J0cy50aHJlc2hvbGRTdHVyZ2VzID0gc3R1cmdlcztcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5tZWFuID0gbWVhbjtcbmV4cG9ydHMubWVkaWFuID0gbWVkaWFuO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLnBhaXJzID0gcGFpcnM7XG5leHBvcnRzLnBlcm11dGUgPSBwZXJtdXRlO1xuZXhwb3J0cy5xdWFudGlsZSA9IHF1YW50aWxlO1xuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuZXhwb3J0cy5zY2FuID0gc2NhbjtcbmV4cG9ydHMuc2h1ZmZsZSA9IHNodWZmbGU7XG5leHBvcnRzLnN1bSA9IHN1bTtcbmV4cG9ydHMudGlja3MgPSB0aWNrcztcbmV4cG9ydHMudGlja0luY3JlbWVudCA9IHRpY2tJbmNyZW1lbnQ7XG5leHBvcnRzLnRpY2tTdGVwID0gdGlja1N0ZXA7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZTtcbmV4cG9ydHMudmFyaWFuY2UgPSB2YXJpYW5jZTtcbmV4cG9ydHMuemlwID0gemlwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1heGlzLyBWZXJzaW9uIDEuMC44LiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn07XG5cbnZhciB0b3AgPSAxO1xudmFyIHJpZ2h0ID0gMjtcbnZhciBib3R0b20gPSAzO1xudmFyIGxlZnQgPSA0O1xudmFyIGVwc2lsb24gPSAxZS02O1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVYKHgpIHtcbiAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgKHggKyAwLjUpICsgXCIsMClcIjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlWSh5KSB7XG4gIHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgKHkgKyAwLjUpICsgXCIpXCI7XG59XG5cbmZ1bmN0aW9uIG51bWJlcihzY2FsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiArc2NhbGUoZCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNlbnRlcihzY2FsZSkge1xuICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgc2NhbGUuYmFuZHdpZHRoKCkgLSAxKSAvIDI7IC8vIEFkanVzdCBmb3IgMC41cHggb2Zmc2V0LlxuICBpZiAoc2NhbGUucm91bmQoKSkgb2Zmc2V0ID0gTWF0aC5yb3VuZChvZmZzZXQpO1xuICByZXR1cm4gZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiArc2NhbGUoZCkgKyBvZmZzZXQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVudGVyaW5nKCkge1xuICByZXR1cm4gIXRoaXMuX19heGlzO1xufVxuXG5mdW5jdGlvbiBheGlzKG9yaWVudCwgc2NhbGUpIHtcbiAgdmFyIHRpY2tBcmd1bWVudHMgPSBbXSxcbiAgICAgIHRpY2tWYWx1ZXMgPSBudWxsLFxuICAgICAgdGlja0Zvcm1hdCA9IG51bGwsXG4gICAgICB0aWNrU2l6ZUlubmVyID0gNixcbiAgICAgIHRpY2tTaXplT3V0ZXIgPSA2LFxuICAgICAgdGlja1BhZGRpbmcgPSAzLFxuICAgICAgayA9IG9yaWVudCA9PT0gdG9wIHx8IG9yaWVudCA9PT0gbGVmdCA/IC0xIDogMSxcbiAgICAgIHggPSBvcmllbnQgPT09IGxlZnQgfHwgb3JpZW50ID09PSByaWdodCA/IFwieFwiIDogXCJ5XCIsXG4gICAgICB0cmFuc2Zvcm0gPSBvcmllbnQgPT09IHRvcCB8fCBvcmllbnQgPT09IGJvdHRvbSA/IHRyYW5zbGF0ZVggOiB0cmFuc2xhdGVZO1xuXG4gIGZ1bmN0aW9uIGF4aXMoY29udGV4dCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aWNrVmFsdWVzID09IG51bGwgPyAoc2NhbGUudGlja3MgPyBzY2FsZS50aWNrcy5hcHBseShzY2FsZSwgdGlja0FyZ3VtZW50cykgOiBzY2FsZS5kb21haW4oKSkgOiB0aWNrVmFsdWVzLFxuICAgICAgICBmb3JtYXQgPSB0aWNrRm9ybWF0ID09IG51bGwgPyAoc2NhbGUudGlja0Zvcm1hdCA/IHNjYWxlLnRpY2tGb3JtYXQuYXBwbHkoc2NhbGUsIHRpY2tBcmd1bWVudHMpIDogaWRlbnRpdHkpIDogdGlja0Zvcm1hdCxcbiAgICAgICAgc3BhY2luZyA9IE1hdGgubWF4KHRpY2tTaXplSW5uZXIsIDApICsgdGlja1BhZGRpbmcsXG4gICAgICAgIHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICAgICAgcmFuZ2UwID0gK3JhbmdlWzBdICsgMC41LFxuICAgICAgICByYW5nZTEgPSArcmFuZ2VbcmFuZ2UubGVuZ3RoIC0gMV0gKyAwLjUsXG4gICAgICAgIHBvc2l0aW9uID0gKHNjYWxlLmJhbmR3aWR0aCA/IGNlbnRlciA6IG51bWJlcikoc2NhbGUuY29weSgpKSxcbiAgICAgICAgc2VsZWN0aW9uID0gY29udGV4dC5zZWxlY3Rpb24gPyBjb250ZXh0LnNlbGVjdGlvbigpIDogY29udGV4dCxcbiAgICAgICAgcGF0aCA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIuZG9tYWluXCIpLmRhdGEoW251bGxdKSxcbiAgICAgICAgdGljayA9IHNlbGVjdGlvbi5zZWxlY3RBbGwoXCIudGlja1wiKS5kYXRhKHZhbHVlcywgc2NhbGUpLm9yZGVyKCksXG4gICAgICAgIHRpY2tFeGl0ID0gdGljay5leGl0KCksXG4gICAgICAgIHRpY2tFbnRlciA9IHRpY2suZW50ZXIoKS5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIiksXG4gICAgICAgIGxpbmUgPSB0aWNrLnNlbGVjdChcImxpbmVcIiksXG4gICAgICAgIHRleHQgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XG5cbiAgICBwYXRoID0gcGF0aC5tZXJnZShwYXRoLmVudGVyKCkuaW5zZXJ0KFwicGF0aFwiLCBcIi50aWNrXCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb21haW5cIilcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCIjMDAwXCIpKTtcblxuICAgIHRpY2sgPSB0aWNrLm1lcmdlKHRpY2tFbnRlcik7XG5cbiAgICBsaW5lID0gbGluZS5tZXJnZSh0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKVxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcIiMwMDBcIilcbiAgICAgICAgLmF0dHIoeCArIFwiMlwiLCBrICogdGlja1NpemVJbm5lcikpO1xuXG4gICAgdGV4dCA9IHRleHQubWVyZ2UodGlja0VudGVyLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzAwMFwiKVxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLmF0dHIoXCJkeVwiLCBvcmllbnQgPT09IHRvcCA/IFwiMGVtXCIgOiBvcmllbnQgPT09IGJvdHRvbSA/IFwiMC43MWVtXCIgOiBcIjAuMzJlbVwiKSk7XG5cbiAgICBpZiAoY29udGV4dCAhPT0gc2VsZWN0aW9uKSB7XG4gICAgICBwYXRoID0gcGF0aC50cmFuc2l0aW9uKGNvbnRleHQpO1xuICAgICAgdGljayA9IHRpY2sudHJhbnNpdGlvbihjb250ZXh0KTtcbiAgICAgIGxpbmUgPSBsaW5lLnRyYW5zaXRpb24oY29udGV4dCk7XG4gICAgICB0ZXh0ID0gdGV4dC50cmFuc2l0aW9uKGNvbnRleHQpO1xuXG4gICAgICB0aWNrRXhpdCA9IHRpY2tFeGl0LnRyYW5zaXRpb24oY29udGV4dClcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBpc0Zpbml0ZShkID0gcG9zaXRpb24oZCkpID8gdHJhbnNmb3JtKGQpIDogdGhpcy5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7IH0pO1xuXG4gICAgICB0aWNrRW50ZXJcbiAgICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgZXBzaWxvbilcbiAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHZhciBwID0gdGhpcy5wYXJlbnROb2RlLl9fYXhpczsgcmV0dXJuIHRyYW5zZm9ybShwICYmIGlzRmluaXRlKHAgPSBwKGQpKSA/IHAgOiBwb3NpdGlvbihkKSk7IH0pO1xuICAgIH1cblxuICAgIHRpY2tFeGl0LnJlbW92ZSgpO1xuXG4gICAgcGF0aFxuICAgICAgICAuYXR0cihcImRcIiwgb3JpZW50ID09PSBsZWZ0IHx8IG9yaWVudCA9PSByaWdodFxuICAgICAgICAgICAgPyBcIk1cIiArIGsgKiB0aWNrU2l6ZU91dGVyICsgXCIsXCIgKyByYW5nZTAgKyBcIkgwLjVWXCIgKyByYW5nZTEgKyBcIkhcIiArIGsgKiB0aWNrU2l6ZU91dGVyXG4gICAgICAgICAgICA6IFwiTVwiICsgcmFuZ2UwICsgXCIsXCIgKyBrICogdGlja1NpemVPdXRlciArIFwiVjAuNUhcIiArIHJhbmdlMSArIFwiVlwiICsgayAqIHRpY2tTaXplT3V0ZXIpO1xuXG4gICAgdGlja1xuICAgICAgICAuYXR0cihcIm9wYWNpdHlcIiwgMSlcbiAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNmb3JtKHBvc2l0aW9uKGQpKTsgfSk7XG5cbiAgICBsaW5lXG4gICAgICAgIC5hdHRyKHggKyBcIjJcIiwgayAqIHRpY2tTaXplSW5uZXIpO1xuXG4gICAgdGV4dFxuICAgICAgICAuYXR0cih4LCBrICogc3BhY2luZylcbiAgICAgICAgLnRleHQoZm9ybWF0KTtcblxuICAgIHNlbGVjdGlvbi5maWx0ZXIoZW50ZXJpbmcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJmb250LXNpemVcIiwgMTApXG4gICAgICAgIC5hdHRyKFwiZm9udC1mYW1pbHlcIiwgXCJzYW5zLXNlcmlmXCIpXG4gICAgICAgIC5hdHRyKFwidGV4dC1hbmNob3JcIiwgb3JpZW50ID09PSByaWdodCA/IFwic3RhcnRcIiA6IG9yaWVudCA9PT0gbGVmdCA/IFwiZW5kXCIgOiBcIm1pZGRsZVwiKTtcblxuICAgIHNlbGVjdGlvblxuICAgICAgICAuZWFjaChmdW5jdGlvbigpIHsgdGhpcy5fX2F4aXMgPSBwb3NpdGlvbjsgfSk7XG4gIH1cblxuICBheGlzLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNjYWxlID0gXywgYXhpcykgOiBzY2FsZTtcbiAgfTtcblxuICBheGlzLnRpY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRpY2tBcmd1bWVudHMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksIGF4aXM7XG4gIH07XG5cbiAgYXhpcy50aWNrQXJndW1lbnRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tBcmd1bWVudHMgPSBfID09IG51bGwgPyBbXSA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja0FyZ3VtZW50cy5zbGljZSgpO1xuICB9O1xuXG4gIGF4aXMudGlja1ZhbHVlcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrVmFsdWVzID0gXyA9PSBudWxsID8gbnVsbCA6IHNsaWNlLmNhbGwoXyksIGF4aXMpIDogdGlja1ZhbHVlcyAmJiB0aWNrVmFsdWVzLnNsaWNlKCk7XG4gIH07XG5cbiAgYXhpcy50aWNrRm9ybWF0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tGb3JtYXQgPSBfLCBheGlzKSA6IHRpY2tGb3JtYXQ7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZUlubmVyID0gdGlja1NpemVPdXRlciA9ICtfLCBheGlzKSA6IHRpY2tTaXplSW5uZXI7XG4gIH07XG5cbiAgYXhpcy50aWNrU2l6ZUlubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tTaXplSW5uZXIgPSArXywgYXhpcykgOiB0aWNrU2l6ZUlubmVyO1xuICB9O1xuXG4gIGF4aXMudGlja1NpemVPdXRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWNrU2l6ZU91dGVyID0gK18sIGF4aXMpIDogdGlja1NpemVPdXRlcjtcbiAgfTtcblxuICBheGlzLnRpY2tQYWRkaW5nID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRpY2tQYWRkaW5nID0gK18sIGF4aXMpIDogdGlja1BhZGRpbmc7XG4gIH07XG5cbiAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIGF4aXNUb3Aoc2NhbGUpIHtcbiAgcmV0dXJuIGF4aXModG9wLCBzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNSaWdodChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhyaWdodCwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzQm90dG9tKHNjYWxlKSB7XG4gIHJldHVybiBheGlzKGJvdHRvbSwgc2NhbGUpO1xufVxuXG5mdW5jdGlvbiBheGlzTGVmdChzY2FsZSkge1xuICByZXR1cm4gYXhpcyhsZWZ0LCBzY2FsZSk7XG59XG5cbmV4cG9ydHMuYXhpc1RvcCA9IGF4aXNUb3A7XG5leHBvcnRzLmF4aXNSaWdodCA9IGF4aXNSaWdodDtcbmV4cG9ydHMuYXhpc0JvdHRvbSA9IGF4aXNCb3R0b207XG5leHBvcnRzLmF4aXNMZWZ0ID0gYXhpc0xlZnQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWJydXNoLyBWZXJzaW9uIDEuMC40LiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLWRyYWcnKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLXRyYW5zaXRpb24nKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRpc3BhdGNoJywgJ2QzLWRyYWcnLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtc2VsZWN0aW9uJywgJ2QzLXRyYW5zaXRpb24nXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0Rpc3BhdGNoLGQzRHJhZyxkM0ludGVycG9sYXRlLGQzU2VsZWN0aW9uLGQzVHJhbnNpdGlvbikgeyAndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxudmFyIEJydXNoRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQsIHR5cGUsIHNlbGVjdGlvbikge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy5zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59O1xuXG5mdW5jdGlvbiBub3Byb3BhZ2F0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn1cblxudmFyIG5vZXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59O1xuXG52YXIgTU9ERV9EUkFHID0ge25hbWU6IFwiZHJhZ1wifTtcbnZhciBNT0RFX1NQQUNFID0ge25hbWU6IFwic3BhY2VcIn07XG52YXIgTU9ERV9IQU5ETEUgPSB7bmFtZTogXCJoYW5kbGVcIn07XG52YXIgTU9ERV9DRU5URVIgPSB7bmFtZTogXCJjZW50ZXJcIn07XG5cbnZhciBYID0ge1xuICBuYW1lOiBcInhcIixcbiAgaGFuZGxlczogW1wiZVwiLCBcIndcIl0ubWFwKHR5cGUpLFxuICBpbnB1dDogZnVuY3Rpb24oeCwgZSkgeyByZXR1cm4geCAmJiBbW3hbMF0sIGVbMF1bMV1dLCBbeFsxXSwgZVsxXVsxXV1dOyB9LFxuICBvdXRwdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eSAmJiBbeHlbMF1bMF0sIHh5WzFdWzBdXTsgfVxufTtcblxudmFyIFkgPSB7XG4gIG5hbWU6IFwieVwiLFxuICBoYW5kbGVzOiBbXCJuXCIsIFwic1wiXS5tYXAodHlwZSksXG4gIGlucHV0OiBmdW5jdGlvbih5LCBlKSB7IHJldHVybiB5ICYmIFtbZVswXVswXSwgeVswXV0sIFtlWzFdWzBdLCB5WzFdXV07IH0sXG4gIG91dHB1dDogZnVuY3Rpb24oeHkpIHsgcmV0dXJuIHh5ICYmIFt4eVswXVsxXSwgeHlbMV1bMV1dOyB9XG59O1xuXG52YXIgWFkgPSB7XG4gIG5hbWU6IFwieHlcIixcbiAgaGFuZGxlczogW1wiblwiLCBcImVcIiwgXCJzXCIsIFwid1wiLCBcIm53XCIsIFwibmVcIiwgXCJzZVwiLCBcInN3XCJdLm1hcCh0eXBlKSxcbiAgaW5wdXQ6IGZ1bmN0aW9uKHh5KSB7IHJldHVybiB4eTsgfSxcbiAgb3V0cHV0OiBmdW5jdGlvbih4eSkgeyByZXR1cm4geHk7IH1cbn07XG5cbnZhciBjdXJzb3JzID0ge1xuICBvdmVybGF5OiBcImNyb3NzaGFpclwiLFxuICBzZWxlY3Rpb246IFwibW92ZVwiLFxuICBuOiBcIm5zLXJlc2l6ZVwiLFxuICBlOiBcImV3LXJlc2l6ZVwiLFxuICBzOiBcIm5zLXJlc2l6ZVwiLFxuICB3OiBcImV3LXJlc2l6ZVwiLFxuICBudzogXCJud3NlLXJlc2l6ZVwiLFxuICBuZTogXCJuZXN3LXJlc2l6ZVwiLFxuICBzZTogXCJud3NlLXJlc2l6ZVwiLFxuICBzdzogXCJuZXN3LXJlc2l6ZVwiXG59O1xuXG52YXIgZmxpcFggPSB7XG4gIGU6IFwid1wiLFxuICB3OiBcImVcIixcbiAgbnc6IFwibmVcIixcbiAgbmU6IFwibndcIixcbiAgc2U6IFwic3dcIixcbiAgc3c6IFwic2VcIlxufTtcblxudmFyIGZsaXBZID0ge1xuICBuOiBcInNcIixcbiAgczogXCJuXCIsXG4gIG53OiBcInN3XCIsXG4gIG5lOiBcInNlXCIsXG4gIHNlOiBcIm5lXCIsXG4gIHN3OiBcIm53XCJcbn07XG5cbnZhciBzaWduc1ggPSB7XG4gIG92ZXJsYXk6ICsxLFxuICBzZWxlY3Rpb246ICsxLFxuICBuOiBudWxsLFxuICBlOiArMSxcbiAgczogbnVsbCxcbiAgdzogLTEsXG4gIG53OiAtMSxcbiAgbmU6ICsxLFxuICBzZTogKzEsXG4gIHN3OiAtMVxufTtcblxudmFyIHNpZ25zWSA9IHtcbiAgb3ZlcmxheTogKzEsXG4gIHNlbGVjdGlvbjogKzEsXG4gIG46IC0xLFxuICBlOiBudWxsLFxuICBzOiArMSxcbiAgdzogbnVsbCxcbiAgbnc6IC0xLFxuICBuZTogLTEsXG4gIHNlOiArMSxcbiAgc3c6ICsxXG59O1xuXG5mdW5jdGlvbiB0eXBlKHQpIHtcbiAgcmV0dXJuIHt0eXBlOiB0fTtcbn1cblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIHN2ZyA9IHRoaXMub3duZXJTVkdFbGVtZW50IHx8IHRoaXM7XG4gIHJldHVybiBbWzAsIDBdLCBbc3ZnLndpZHRoLmJhc2VWYWwudmFsdWUsIHN2Zy5oZWlnaHQuYmFzZVZhbC52YWx1ZV1dO1xufVxuXG4vLyBMaWtlIGQzLmxvY2FsLCBidXQgd2l0aCB0aGUgbmFtZSDigJxfX2JydXNo4oCdIHJhdGhlciB0aGFuIGF1dG8tZ2VuZXJhdGVkLlxuZnVuY3Rpb24gbG9jYWwobm9kZSkge1xuICB3aGlsZSAoIW5vZGUuX19icnVzaCkgaWYgKCEobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkpIHJldHVybjtcbiAgcmV0dXJuIG5vZGUuX19icnVzaDtcbn1cblxuZnVuY3Rpb24gZW1wdHkoZXh0ZW50KSB7XG4gIHJldHVybiBleHRlbnRbMF1bMF0gPT09IGV4dGVudFsxXVswXVxuICAgICAgfHwgZXh0ZW50WzBdWzFdID09PSBleHRlbnRbMV1bMV07XG59XG5cbmZ1bmN0aW9uIGJydXNoU2VsZWN0aW9uKG5vZGUpIHtcbiAgdmFyIHN0YXRlID0gbm9kZS5fX2JydXNoO1xuICByZXR1cm4gc3RhdGUgPyBzdGF0ZS5kaW0ub3V0cHV0KHN0YXRlLnNlbGVjdGlvbikgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBicnVzaFgoKSB7XG4gIHJldHVybiBicnVzaCQxKFgpO1xufVxuXG5mdW5jdGlvbiBicnVzaFkoKSB7XG4gIHJldHVybiBicnVzaCQxKFkpO1xufVxuXG52YXIgYnJ1c2ggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGJydXNoJDEoWFkpO1xufTtcblxuZnVuY3Rpb24gYnJ1c2gkMShkaW0pIHtcbiAgdmFyIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBmaWx0ZXIgPSBkZWZhdWx0RmlsdGVyLFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChicnVzaCwgXCJzdGFydFwiLCBcImJydXNoXCIsIFwiZW5kXCIpLFxuICAgICAgaGFuZGxlU2l6ZSA9IDYsXG4gICAgICB0b3VjaGVuZGluZztcblxuICBmdW5jdGlvbiBicnVzaChncm91cCkge1xuICAgIHZhciBvdmVybGF5ID0gZ3JvdXBcbiAgICAgICAgLnByb3BlcnR5KFwiX19icnVzaFwiLCBpbml0aWFsaXplKVxuICAgICAgLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpXG4gICAgICAuZGF0YShbdHlwZShcIm92ZXJsYXlcIildKTtcblxuICAgIG92ZXJsYXkuZW50ZXIoKS5hcHBlbmQoXCJyZWN0XCIpXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJvdmVybGF5XCIpXG4gICAgICAgIC5hdHRyKFwicG9pbnRlci1ldmVudHNcIiwgXCJhbGxcIilcbiAgICAgICAgLmF0dHIoXCJjdXJzb3JcIiwgY3Vyc29ycy5vdmVybGF5KVxuICAgICAgLm1lcmdlKG92ZXJsYXkpXG4gICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBleHRlbnQgPSBsb2NhbCh0aGlzKS5leHRlbnQ7XG4gICAgICAgICAgZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpXG4gICAgICAgICAgICAgIC5hdHRyKFwieFwiLCBleHRlbnRbMF1bMF0pXG4gICAgICAgICAgICAgIC5hdHRyKFwieVwiLCBleHRlbnRbMF1bMV0pXG4gICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV0pO1xuICAgICAgICB9KTtcblxuICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb25cIilcbiAgICAgIC5kYXRhKFt0eXBlKFwic2VsZWN0aW9uXCIpXSlcbiAgICAgIC5lbnRlcigpLmFwcGVuZChcInJlY3RcIilcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdGlvblwiKVxuICAgICAgICAuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzLnNlbGVjdGlvbilcbiAgICAgICAgLmF0dHIoXCJmaWxsXCIsIFwiIzc3N1wiKVxuICAgICAgICAuYXR0cihcImZpbGwtb3BhY2l0eVwiLCAwLjMpXG4gICAgICAgIC5hdHRyKFwic3Ryb2tlXCIsIFwiI2ZmZlwiKVxuICAgICAgICAuYXR0cihcInNoYXBlLXJlbmRlcmluZ1wiLCBcImNyaXNwRWRnZXNcIik7XG5cbiAgICB2YXIgaGFuZGxlID0gZ3JvdXAuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKVxuICAgICAgLmRhdGEoZGltLmhhbmRsZXMsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZTsgfSk7XG5cbiAgICBoYW5kbGUuZXhpdCgpLnJlbW92ZSgpO1xuXG4gICAgaGFuZGxlLmVudGVyKCkuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIFwiaGFuZGxlIGhhbmRsZS0tXCIgKyBkLnR5cGU7IH0pXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGN1cnNvcnNbZC50eXBlXTsgfSk7XG5cbiAgICBncm91cFxuICAgICAgICAuZWFjaChyZWRyYXcpXG4gICAgICAgIC5hdHRyKFwiZmlsbFwiLCBcIm5vbmVcIilcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcImFsbFwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi5icnVzaCB0b3VjaHN0YXJ0LmJydXNoXCIsIHN0YXJ0ZWQpO1xuICB9XG5cbiAgYnJ1c2gubW92ZSA9IGZ1bmN0aW9uKGdyb3VwLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoZ3JvdXAuc2VsZWN0aW9uKSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5vbihcInN0YXJ0LmJydXNoXCIsIGZ1bmN0aW9uKCkgeyBlbWl0dGVyKHRoaXMsIGFyZ3VtZW50cykuYmVmb3Jlc3RhcnQoKS5zdGFydCgpOyB9KVxuICAgICAgICAgIC5vbihcImludGVycnVwdC5icnVzaCBlbmQuYnJ1c2hcIiwgZnVuY3Rpb24oKSB7IGVtaXR0ZXIodGhpcywgYXJndW1lbnRzKS5lbmQoKTsgfSlcbiAgICAgICAgICAudHdlZW4oXCJicnVzaFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHRoYXQuX19icnVzaCxcbiAgICAgICAgICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbjAgPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMSA9IGRpbS5pbnB1dCh0eXBlb2Ygc2VsZWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHNlbGVjdGlvbiwgc3RhdGUuZXh0ZW50KSxcbiAgICAgICAgICAgICAgICBpID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZShzZWxlY3Rpb24wLCBzZWxlY3Rpb24xKTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdHdlZW4odCkge1xuICAgICAgICAgICAgICBzdGF0ZS5zZWxlY3Rpb24gPSB0ID09PSAxICYmIGVtcHR5KHNlbGVjdGlvbjEpID8gbnVsbCA6IGkodCk7XG4gICAgICAgICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICAgICAgICBlbWl0LmJydXNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24wICYmIHNlbGVjdGlvbjEgPyB0d2VlbiA6IHR3ZWVuKDEpO1xuICAgICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cFxuICAgICAgICAgIC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgc3RhdGUgPSB0aGF0Ll9fYnJ1c2gsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uMSA9IGRpbS5pbnB1dCh0eXBlb2Ygc2VsZWN0aW9uID09PSBcImZ1bmN0aW9uXCIgPyBzZWxlY3Rpb24uYXBwbHkodGhhdCwgYXJncykgOiBzZWxlY3Rpb24sIHN0YXRlLmV4dGVudCksXG4gICAgICAgICAgICAgICAgZW1pdCA9IGVtaXR0ZXIodGhhdCwgYXJncykuYmVmb3Jlc3RhcnQoKTtcblxuICAgICAgICAgICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGF0KTtcbiAgICAgICAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjEgPT0gbnVsbCB8fCBlbXB0eShzZWxlY3Rpb24xKSA/IG51bGwgOiBzZWxlY3Rpb24xO1xuICAgICAgICAgICAgcmVkcmF3LmNhbGwodGhhdCk7XG4gICAgICAgICAgICBlbWl0LnN0YXJ0KCkuYnJ1c2goKS5lbmQoKTtcbiAgICAgICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVkcmF3KCkge1xuICAgIHZhciBncm91cCA9IGQzU2VsZWN0aW9uLnNlbGVjdCh0aGlzKSxcbiAgICAgICAgc2VsZWN0aW9uID0gbG9jYWwodGhpcykuc2VsZWN0aW9uO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLnNlbGVjdGlvblwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInhcIiwgc2VsZWN0aW9uWzBdWzBdKVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBzZWxlY3Rpb25bMF1bMV0pXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBzZWxlY3Rpb25bMV1bMF0gLSBzZWxlY3Rpb25bMF1bMF0pXG4gICAgICAgICAgLmF0dHIoXCJoZWlnaHRcIiwgc2VsZWN0aW9uWzFdWzFdIC0gc2VsZWN0aW9uWzBdWzFdKTtcblxuICAgICAgZ3JvdXAuc2VsZWN0QWxsKFwiLmhhbmRsZVwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcbiAgICAgICAgICAuYXR0cihcInhcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZC50eXBlW2QudHlwZS5sZW5ndGggLSAxXSA9PT0gXCJlXCIgPyBzZWxlY3Rpb25bMV1bMF0gLSBoYW5kbGVTaXplIC8gMiA6IHNlbGVjdGlvblswXVswXSAtIGhhbmRsZVNpemUgLyAyOyB9KVxuICAgICAgICAgIC5hdHRyKFwieVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkLnR5cGVbMF0gPT09IFwic1wiID8gc2VsZWN0aW9uWzFdWzFdIC0gaGFuZGxlU2l6ZSAvIDIgOiBzZWxlY3Rpb25bMF1bMV0gLSBoYW5kbGVTaXplIC8gMjsgfSlcbiAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZSA9PT0gXCJuXCIgfHwgZC50eXBlID09PSBcInNcIiA/IHNlbGVjdGlvblsxXVswXSAtIHNlbGVjdGlvblswXVswXSArIGhhbmRsZVNpemUgOiBoYW5kbGVTaXplOyB9KVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQudHlwZSA9PT0gXCJlXCIgfHwgZC50eXBlID09PSBcIndcIiA/IHNlbGVjdGlvblsxXVsxXSAtIHNlbGVjdGlvblswXVsxXSArIGhhbmRsZVNpemUgOiBoYW5kbGVTaXplOyB9KTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIGdyb3VwLnNlbGVjdEFsbChcIi5zZWxlY3Rpb24sLmhhbmRsZVwiKVxuICAgICAgICAgIC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIG51bGwpXG4gICAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBudWxsKVxuICAgICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXR0ZXIodGhhdCwgYXJncykge1xuICAgIHJldHVybiB0aGF0Ll9fYnJ1c2guZW1pdHRlciB8fCBuZXcgRW1pdHRlcih0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEVtaXR0ZXIodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLnN0YXRlID0gdGhhdC5fX2JydXNoO1xuICAgIHRoaXMuYWN0aXZlID0gMDtcbiAgfVxuXG4gIEVtaXR0ZXIucHJvdG90eXBlID0ge1xuICAgIGJlZm9yZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgrK3RoaXMuYWN0aXZlID09PSAxKSB0aGlzLnN0YXRlLmVtaXR0ZXIgPSB0aGlzLCB0aGlzLnN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnRpbmcpIHRoaXMuc3RhcnRpbmcgPSBmYWxzZSwgdGhpcy5lbWl0KFwic3RhcnRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGJydXNoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdChcImJydXNoXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIGRlbGV0ZSB0aGlzLnN0YXRlLmVtaXR0ZXIsIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IEJydXNoRXZlbnQoYnJ1c2gsIHR5cGUsIGRpbS5vdXRwdXQodGhpcy5zdGF0ZS5zZWxlY3Rpb24pKSwgbGlzdGVuZXJzLmFwcGx5LCBsaXN0ZW5lcnMsIFt0eXBlLCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBzdGFydGVkKCkge1xuICAgIGlmIChkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzKSB7IGlmIChkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPCBkM1NlbGVjdGlvbi5ldmVudC50b3VjaGVzLmxlbmd0aCkgcmV0dXJuIG5vZXZlbnQoKTsgfVxuICAgIGVsc2UgaWYgKHRvdWNoZW5kaW5nKSByZXR1cm47XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuXG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICB0eXBlID0gZDNTZWxlY3Rpb24uZXZlbnQudGFyZ2V0Ll9fZGF0YV9fLnR5cGUsXG4gICAgICAgIG1vZGUgPSAoZDNTZWxlY3Rpb24uZXZlbnQubWV0YUtleSA/IHR5cGUgPSBcIm92ZXJsYXlcIiA6IHR5cGUpID09PSBcInNlbGVjdGlvblwiID8gTU9ERV9EUkFHIDogKGQzU2VsZWN0aW9uLmV2ZW50LmFsdEtleSA/IE1PREVfQ0VOVEVSIDogTU9ERV9IQU5ETEUpLFxuICAgICAgICBzaWduWCA9IGRpbSA9PT0gWSA/IG51bGwgOiBzaWduc1hbdHlwZV0sXG4gICAgICAgIHNpZ25ZID0gZGltID09PSBYID8gbnVsbCA6IHNpZ25zWVt0eXBlXSxcbiAgICAgICAgc3RhdGUgPSBsb2NhbCh0aGF0KSxcbiAgICAgICAgZXh0ZW50ID0gc3RhdGUuZXh0ZW50LFxuICAgICAgICBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24sXG4gICAgICAgIFcgPSBleHRlbnRbMF1bMF0sIHcwLCB3MSxcbiAgICAgICAgTiA9IGV4dGVudFswXVsxXSwgbjAsIG4xLFxuICAgICAgICBFID0gZXh0ZW50WzFdWzBdLCBlMCwgZTEsXG4gICAgICAgIFMgPSBleHRlbnRbMV1bMV0sIHMwLCBzMSxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5LFxuICAgICAgICBtb3ZpbmcsXG4gICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblkgJiYgZDNTZWxlY3Rpb24uZXZlbnQuc2hpZnRLZXksXG4gICAgICAgIGxvY2tYLFxuICAgICAgICBsb2NrWSxcbiAgICAgICAgcG9pbnQwID0gZDNTZWxlY3Rpb24ubW91c2UodGhhdCksXG4gICAgICAgIHBvaW50ID0gcG9pbnQwLFxuICAgICAgICBlbWl0ID0gZW1pdHRlcih0aGF0LCBhcmd1bWVudHMpLmJlZm9yZXN0YXJ0KCk7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJvdmVybGF5XCIpIHtcbiAgICAgIHN0YXRlLnNlbGVjdGlvbiA9IHNlbGVjdGlvbiA9IFtcbiAgICAgICAgW3cwID0gZGltID09PSBZID8gVyA6IHBvaW50MFswXSwgbjAgPSBkaW0gPT09IFggPyBOIDogcG9pbnQwWzFdXSxcbiAgICAgICAgW2UwID0gZGltID09PSBZID8gRSA6IHcwLCBzMCA9IGRpbSA9PT0gWCA/IFMgOiBuMF1cbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHcwID0gc2VsZWN0aW9uWzBdWzBdO1xuICAgICAgbjAgPSBzZWxlY3Rpb25bMF1bMV07XG4gICAgICBlMCA9IHNlbGVjdGlvblsxXVswXTtcbiAgICAgIHMwID0gc2VsZWN0aW9uWzFdWzFdO1xuICAgIH1cblxuICAgIHcxID0gdzA7XG4gICAgbjEgPSBuMDtcbiAgICBlMSA9IGUwO1xuICAgIHMxID0gczA7XG5cbiAgICB2YXIgZ3JvdXAgPSBkM1NlbGVjdGlvbi5zZWxlY3QodGhhdClcbiAgICAgICAgLmF0dHIoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XG5cbiAgICB2YXIgb3ZlcmxheSA9IGdyb3VwLnNlbGVjdEFsbChcIi5vdmVybGF5XCIpXG4gICAgICAgIC5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZV0pO1xuXG4gICAgaWYgKGQzU2VsZWN0aW9uLmV2ZW50LnRvdWNoZXMpIHtcbiAgICAgIGdyb3VwXG4gICAgICAgICAgLm9uKFwidG91Y2htb3ZlLmJydXNoXCIsIG1vdmVkLCB0cnVlKVxuICAgICAgICAgIC5vbihcInRvdWNoZW5kLmJydXNoIHRvdWNoY2FuY2VsLmJydXNoXCIsIGVuZGVkLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZpZXcgPSBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldylcbiAgICAgICAgICAub24oXCJrZXlkb3duLmJydXNoXCIsIGtleWRvd25lZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJrZXl1cC5icnVzaFwiLCBrZXl1cHBlZCwgdHJ1ZSlcbiAgICAgICAgICAub24oXCJtb3VzZW1vdmUuYnJ1c2hcIiwgbW92ZWQsIHRydWUpXG4gICAgICAgICAgLm9uKFwibW91c2V1cC5icnVzaFwiLCBlbmRlZCwgdHJ1ZSk7XG5cbiAgICAgIGQzRHJhZy5kcmFnRGlzYWJsZShkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICB9XG5cbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGF0KTtcbiAgICByZWRyYXcuY2FsbCh0aGF0KTtcbiAgICBlbWl0LnN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiBtb3ZlZCgpIHtcbiAgICAgIHZhciBwb2ludDEgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGF0KTtcbiAgICAgIGlmIChzaGlmdGluZyAmJiAhbG9ja1ggJiYgIWxvY2tZKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhwb2ludDFbMF0gLSBwb2ludFswXSkgPiBNYXRoLmFicyhwb2ludDFbMV0gLSBwb2ludFsxXSkpIGxvY2tZID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBsb2NrWCA9IHRydWU7XG4gICAgICB9XG4gICAgICBwb2ludCA9IHBvaW50MTtcbiAgICAgIG1vdmluZyA9IHRydWU7XG4gICAgICBub2V2ZW50KCk7XG4gICAgICBtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW92ZSgpIHtcbiAgICAgIHZhciB0O1xuXG4gICAgICBkeCA9IHBvaW50WzBdIC0gcG9pbnQwWzBdO1xuICAgICAgZHkgPSBwb2ludFsxXSAtIHBvaW50MFsxXTtcblxuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgTU9ERV9TUEFDRTpcbiAgICAgICAgY2FzZSBNT0RFX0RSQUc6IHtcbiAgICAgICAgICBpZiAoc2lnblgpIGR4ID0gTWF0aC5tYXgoVyAtIHcwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAgKyBkeCwgZTEgPSBlMCArIGR4O1xuICAgICAgICAgIGlmIChzaWduWSkgZHkgPSBNYXRoLm1heChOIC0gbjAsIE1hdGgubWluKFMgLSBzMCwgZHkpKSwgbjEgPSBuMCArIGR5LCBzMSA9IHMwICsgZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNT0RFX0hBTkRMRToge1xuICAgICAgICAgIGlmIChzaWduWCA8IDApIGR4ID0gTWF0aC5tYXgoVyAtIHcwLCBNYXRoLm1pbihFIC0gdzAsIGR4KSksIHcxID0gdzAgKyBkeCwgZTEgPSBlMDtcbiAgICAgICAgICBlbHNlIGlmIChzaWduWCA+IDApIGR4ID0gTWF0aC5tYXgoVyAtIGUwLCBNYXRoLm1pbihFIC0gZTAsIGR4KSksIHcxID0gdzAsIGUxID0gZTAgKyBkeDtcbiAgICAgICAgICBpZiAoc2lnblkgPCAwKSBkeSA9IE1hdGgubWF4KE4gLSBuMCwgTWF0aC5taW4oUyAtIG4wLCBkeSkpLCBuMSA9IG4wICsgZHksIHMxID0gczA7XG4gICAgICAgICAgZWxzZSBpZiAoc2lnblkgPiAwKSBkeSA9IE1hdGgubWF4KE4gLSBzMCwgTWF0aC5taW4oUyAtIHMwLCBkeSkpLCBuMSA9IG4wLCBzMSA9IHMwICsgZHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNT0RFX0NFTlRFUjoge1xuICAgICAgICAgIGlmIChzaWduWCkgdzEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCB3MCAtIGR4ICogc2lnblgpKSwgZTEgPSBNYXRoLm1heChXLCBNYXRoLm1pbihFLCBlMCArIGR4ICogc2lnblgpKTtcbiAgICAgICAgICBpZiAoc2lnblkpIG4xID0gTWF0aC5tYXgoTiwgTWF0aC5taW4oUywgbjAgLSBkeSAqIHNpZ25ZKSksIHMxID0gTWF0aC5tYXgoTiwgTWF0aC5taW4oUywgczAgKyBkeSAqIHNpZ25ZKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGUxIDwgdzEpIHtcbiAgICAgICAgc2lnblggKj0gLTE7XG4gICAgICAgIHQgPSB3MCwgdzAgPSBlMCwgZTAgPSB0O1xuICAgICAgICB0ID0gdzEsIHcxID0gZTEsIGUxID0gdDtcbiAgICAgICAgaWYgKHR5cGUgaW4gZmxpcFgpIG92ZXJsYXkuYXR0cihcImN1cnNvclwiLCBjdXJzb3JzW3R5cGUgPSBmbGlwWFt0eXBlXV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoczEgPCBuMSkge1xuICAgICAgICBzaWduWSAqPSAtMTtcbiAgICAgICAgdCA9IG4wLCBuMCA9IHMwLCBzMCA9IHQ7XG4gICAgICAgIHQgPSBuMSwgbjEgPSBzMSwgczEgPSB0O1xuICAgICAgICBpZiAodHlwZSBpbiBmbGlwWSkgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZSA9IGZsaXBZW3R5cGVdXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24pIHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjsgLy8gTWF5IGJlIHNldCBieSBicnVzaC5tb3ZlIVxuICAgICAgaWYgKGxvY2tYKSB3MSA9IHNlbGVjdGlvblswXVswXSwgZTEgPSBzZWxlY3Rpb25bMV1bMF07XG4gICAgICBpZiAobG9ja1kpIG4xID0gc2VsZWN0aW9uWzBdWzFdLCBzMSA9IHNlbGVjdGlvblsxXVsxXTtcblxuICAgICAgaWYgKHNlbGVjdGlvblswXVswXSAhPT0gdzFcbiAgICAgICAgICB8fCBzZWxlY3Rpb25bMF1bMV0gIT09IG4xXG4gICAgICAgICAgfHwgc2VsZWN0aW9uWzFdWzBdICE9PSBlMVxuICAgICAgICAgIHx8IHNlbGVjdGlvblsxXVsxXSAhPT0gczEpIHtcbiAgICAgICAgc3RhdGUuc2VsZWN0aW9uID0gW1t3MSwgbjFdLCBbZTEsIHMxXV07XG4gICAgICAgIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgICBlbWl0LmJydXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kZWQoKSB7XG4gICAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcykge1xuICAgICAgICBpZiAoZDNTZWxlY3Rpb24uZXZlbnQudG91Y2hlcy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgaWYgKHRvdWNoZW5kaW5nKSBjbGVhclRpbWVvdXQodG91Y2hlbmRpbmcpO1xuICAgICAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgNTAwKTsgLy8gR2hvc3QgY2xpY2tzIGFyZSBkZWxheWVkIVxuICAgICAgICBncm91cC5vbihcInRvdWNobW92ZS5icnVzaCB0b3VjaGVuZC5icnVzaCB0b3VjaGNhbmNlbC5icnVzaFwiLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGQzRHJhZy5kcmFnRW5hYmxlKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcsIG1vdmluZyk7XG4gICAgICAgIHZpZXcub24oXCJrZXlkb3duLmJydXNoIGtleXVwLmJydXNoIG1vdXNlbW92ZS5icnVzaCBtb3VzZXVwLmJydXNoXCIsIG51bGwpO1xuICAgICAgfVxuICAgICAgZ3JvdXAuYXR0cihcInBvaW50ZXItZXZlbnRzXCIsIFwiYWxsXCIpO1xuICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMub3ZlcmxheSk7XG4gICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uKSBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247IC8vIE1heSBiZSBzZXQgYnkgYnJ1c2gubW92ZSAob24gc3RhcnQpIVxuICAgICAgaWYgKGVtcHR5KHNlbGVjdGlvbikpIHN0YXRlLnNlbGVjdGlvbiA9IG51bGwsIHJlZHJhdy5jYWxsKHRoYXQpO1xuICAgICAgZW1pdC5lbmQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlkb3duZWQoKSB7XG4gICAgICBzd2l0Y2ggKGQzU2VsZWN0aW9uLmV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgY2FzZSAxNjogeyAvLyBTSElGVFxuICAgICAgICAgIHNoaWZ0aW5nID0gc2lnblggJiYgc2lnblk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxODogeyAvLyBBTFRcbiAgICAgICAgICBpZiAobW9kZSA9PT0gTU9ERV9IQU5ETEUpIHtcbiAgICAgICAgICAgIGlmIChzaWduWCkgZTAgPSBlMSAtIGR4ICogc2lnblgsIHcwID0gdzEgKyBkeCAqIHNpZ25YO1xuICAgICAgICAgICAgaWYgKHNpZ25ZKSBzMCA9IHMxIC0gZHkgKiBzaWduWSwgbjAgPSBuMSArIGR5ICogc2lnblk7XG4gICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICBtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzI6IHsgLy8gU1BBQ0U7IHRha2VzIHByaW9yaXR5IG92ZXIgQUxUXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfSEFORExFIHx8IG1vZGUgPT09IE1PREVfQ0VOVEVSKSB7XG4gICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxIC0gZHg7IGVsc2UgaWYgKHNpZ25YID4gMCkgdzAgPSB3MSAtIGR4O1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMSAtIGR5OyBlbHNlIGlmIChzaWduWSA+IDApIG4wID0gbjEgLSBkeTtcbiAgICAgICAgICAgIG1vZGUgPSBNT0RFX1NQQUNFO1xuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnMuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIG1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9ldmVudCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwcGVkKCkge1xuICAgICAgc3dpdGNoIChkM1NlbGVjdGlvbi5ldmVudC5rZXlDb2RlKSB7XG4gICAgICAgIGNhc2UgMTY6IHsgLy8gU0hJRlRcbiAgICAgICAgICBpZiAoc2hpZnRpbmcpIHtcbiAgICAgICAgICAgIGxvY2tYID0gbG9ja1kgPSBzaGlmdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE4OiB7IC8vIEFMVFxuICAgICAgICAgIGlmIChtb2RlID09PSBNT0RFX0NFTlRFUikge1xuICAgICAgICAgICAgaWYgKHNpZ25YIDwgMCkgZTAgPSBlMTsgZWxzZSBpZiAoc2lnblggPiAwKSB3MCA9IHcxO1xuICAgICAgICAgICAgaWYgKHNpZ25ZIDwgMCkgczAgPSBzMTsgZWxzZSBpZiAoc2lnblkgPiAwKSBuMCA9IG4xO1xuICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7IC8vIFNQQUNFXG4gICAgICAgICAgaWYgKG1vZGUgPT09IE1PREVfU1BBQ0UpIHtcbiAgICAgICAgICAgIGlmIChkM1NlbGVjdGlvbi5ldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgaWYgKHNpZ25YKSBlMCA9IGUxIC0gZHggKiBzaWduWCwgdzAgPSB3MSArIGR4ICogc2lnblg7XG4gICAgICAgICAgICAgIGlmIChzaWduWSkgczAgPSBzMSAtIGR5ICogc2lnblksIG4wID0gbjEgKyBkeSAqIHNpZ25ZO1xuICAgICAgICAgICAgICBtb2RlID0gTU9ERV9DRU5URVI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoc2lnblggPCAwKSBlMCA9IGUxOyBlbHNlIGlmIChzaWduWCA+IDApIHcwID0gdzE7XG4gICAgICAgICAgICAgIGlmIChzaWduWSA8IDApIHMwID0gczE7IGVsc2UgaWYgKHNpZ25ZID4gMCkgbjAgPSBuMTtcbiAgICAgICAgICAgICAgbW9kZSA9IE1PREVfSEFORExFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcmxheS5hdHRyKFwiY3Vyc29yXCIsIGN1cnNvcnNbdHlwZV0pO1xuICAgICAgICAgICAgbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiByZXR1cm47XG4gICAgICB9XG4gICAgICBub2V2ZW50KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9fYnJ1c2ggfHwge3NlbGVjdGlvbjogbnVsbH07XG4gICAgc3RhdGUuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgc3RhdGUuZGltID0gZGltO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIGJydXNoLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgYnJ1c2gpIDogZXh0ZW50O1xuICB9O1xuXG4gIGJydXNoLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGJydXNoKSA6IGZpbHRlcjtcbiAgfTtcblxuICBicnVzaC5oYW5kbGVTaXplID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGhhbmRsZVNpemUgPSArXywgYnJ1c2gpIDogaGFuZGxlU2l6ZTtcbiAgfTtcblxuICBicnVzaC5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBicnVzaCA6IHZhbHVlO1xuICB9O1xuXG4gIHJldHVybiBicnVzaDtcbn1cblxuZXhwb3J0cy5icnVzaCA9IGJydXNoO1xuZXhwb3J0cy5icnVzaFggPSBicnVzaFg7XG5leHBvcnRzLmJydXNoWSA9IGJydXNoWTtcbmV4cG9ydHMuYnJ1c2hTZWxlY3Rpb24gPSBicnVzaFNlbGVjdGlvbjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY2hvcmQvIFZlcnNpb24gMS4wLjQuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtYXJyYXknKSwgcmVxdWlyZSgnZDMtcGF0aCcpKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtYXJyYXknLCAnZDMtcGF0aCddLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzQXJyYXksZDNQYXRoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG52YXIgdGF1ID0gcGkgKiAyO1xudmFyIG1heCA9IE1hdGgubWF4O1xuXG5mdW5jdGlvbiBjb21wYXJlVmFsdWUoY29tcGFyZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlKFxuICAgICAgYS5zb3VyY2UudmFsdWUgKyBhLnRhcmdldC52YWx1ZSxcbiAgICAgIGIuc291cmNlLnZhbHVlICsgYi50YXJnZXQudmFsdWVcbiAgICApO1xuICB9O1xufVxuXG52YXIgY2hvcmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhZEFuZ2xlID0gMCxcbiAgICAgIHNvcnRHcm91cHMgPSBudWxsLFxuICAgICAgc29ydFN1Ymdyb3VwcyA9IG51bGwsXG4gICAgICBzb3J0Q2hvcmRzID0gbnVsbDtcblxuICBmdW5jdGlvbiBjaG9yZChtYXRyaXgpIHtcbiAgICB2YXIgbiA9IG1hdHJpeC5sZW5ndGgsXG4gICAgICAgIGdyb3VwU3VtcyA9IFtdLFxuICAgICAgICBncm91cEluZGV4ID0gZDNBcnJheS5yYW5nZShuKSxcbiAgICAgICAgc3ViZ3JvdXBJbmRleCA9IFtdLFxuICAgICAgICBjaG9yZHMgPSBbXSxcbiAgICAgICAgZ3JvdXBzID0gY2hvcmRzLmdyb3VwcyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG4gKiBuKSxcbiAgICAgICAgayxcbiAgICAgICAgeCxcbiAgICAgICAgeDAsXG4gICAgICAgIGR4LFxuICAgICAgICBpLFxuICAgICAgICBqO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3VtLlxuICAgIGsgPSAwLCBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICB4ID0gMCwgaiA9IC0xOyB3aGlsZSAoKytqIDwgbikge1xuICAgICAgICB4ICs9IG1hdHJpeFtpXVtqXTtcbiAgICAgIH1cbiAgICAgIGdyb3VwU3Vtcy5wdXNoKHgpO1xuICAgICAgc3ViZ3JvdXBJbmRleC5wdXNoKGQzQXJyYXkucmFuZ2UobikpO1xuICAgICAgayArPSB4O1xuICAgIH1cblxuICAgIC8vIFNvcnQgZ3JvdXBz4oCmXG4gICAgaWYgKHNvcnRHcm91cHMpIGdyb3VwSW5kZXguc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gc29ydEdyb3Vwcyhncm91cFN1bXNbYV0sIGdyb3VwU3Vtc1tiXSk7XG4gICAgfSk7XG5cbiAgICAvLyBTb3J0IHN1Ymdyb3Vwc+KAplxuICAgIGlmIChzb3J0U3ViZ3JvdXBzKSBzdWJncm91cEluZGV4LmZvckVhY2goZnVuY3Rpb24oZCwgaSkge1xuICAgICAgZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHNvcnRTdWJncm91cHMobWF0cml4W2ldW2FdLCBtYXRyaXhbaV1bYl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDb252ZXJ0IHRoZSBzdW0gdG8gc2NhbGluZyBmYWN0b3IgZm9yIFswLCAycGldLlxuICAgIC8vIFRPRE8gQWxsb3cgc3RhcnQgYW5kIGVuZCBhbmdsZSB0byBiZSBzcGVjaWZpZWQ/XG4gICAgLy8gVE9ETyBBbGxvdyBwYWRkaW5nIHRvIGJlIHNwZWNpZmllZCBhcyBwZXJjZW50YWdlP1xuICAgIGsgPSBtYXgoMCwgdGF1IC0gcGFkQW5nbGUgKiBuKSAvIGs7XG4gICAgZHggPSBrID8gcGFkQW5nbGUgOiB0YXUgLyBuO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgc3RhcnQgYW5kIGVuZCBhbmdsZSBmb3IgZWFjaCBncm91cCBhbmQgc3ViZ3JvdXAuXG4gICAgLy8gTm90ZTogT3BlcmEgaGFzIGEgYnVnIHJlb3JkZXJpbmcgb2JqZWN0IGxpdGVyYWwgcHJvcGVydGllcyFcbiAgICB4ID0gMCwgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikge1xuICAgICAgeDAgPSB4LCBqID0gLTE7IHdoaWxlICgrK2ogPCBuKSB7XG4gICAgICAgIHZhciBkaSA9IGdyb3VwSW5kZXhbaV0sXG4gICAgICAgICAgICBkaiA9IHN1Ymdyb3VwSW5kZXhbZGldW2pdLFxuICAgICAgICAgICAgdiA9IG1hdHJpeFtkaV1bZGpdLFxuICAgICAgICAgICAgYTAgPSB4LFxuICAgICAgICAgICAgYTEgPSB4ICs9IHYgKiBrO1xuICAgICAgICBzdWJncm91cHNbZGogKiBuICsgZGldID0ge1xuICAgICAgICAgIGluZGV4OiBkaSxcbiAgICAgICAgICBzdWJpbmRleDogZGosXG4gICAgICAgICAgc3RhcnRBbmdsZTogYTAsXG4gICAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICAgIHZhbHVlOiB2XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBncm91cHNbZGldID0ge1xuICAgICAgICBpbmRleDogZGksXG4gICAgICAgIHN0YXJ0QW5nbGU6IHgwLFxuICAgICAgICBlbmRBbmdsZTogeCxcbiAgICAgICAgdmFsdWU6IGdyb3VwU3Vtc1tkaV1cbiAgICAgIH07XG4gICAgICB4ICs9IGR4O1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGNob3JkcyBmb3IgZWFjaCAobm9uLWVtcHR5KSBzdWJncm91cC1zdWJncm91cCBsaW5rLlxuICAgIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGogPSBpIC0gMTsgd2hpbGUgKCsraiA8IG4pIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHN1Ymdyb3Vwc1tqICogbiArIGldLFxuICAgICAgICAgICAgdGFyZ2V0ID0gc3ViZ3JvdXBzW2kgKiBuICsgal07XG4gICAgICAgIGlmIChzb3VyY2UudmFsdWUgfHwgdGFyZ2V0LnZhbHVlKSB7XG4gICAgICAgICAgY2hvcmRzLnB1c2goc291cmNlLnZhbHVlIDwgdGFyZ2V0LnZhbHVlXG4gICAgICAgICAgICAgID8ge3NvdXJjZTogdGFyZ2V0LCB0YXJnZXQ6IHNvdXJjZX1cbiAgICAgICAgICAgICAgOiB7c291cmNlOiBzb3VyY2UsIHRhcmdldDogdGFyZ2V0fSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydENob3JkcyA/IGNob3Jkcy5zb3J0KHNvcnRDaG9yZHMpIDogY2hvcmRzO1xuICB9XG5cbiAgY2hvcmQucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSBtYXgoMCwgXyksIGNob3JkKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIGNob3JkLnNvcnRHcm91cHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydEdyb3VwcyA9IF8sIGNob3JkKSA6IHNvcnRHcm91cHM7XG4gIH07XG5cbiAgY2hvcmQuc29ydFN1Ymdyb3VwcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0U3ViZ3JvdXBzID0gXywgY2hvcmQpIDogc29ydFN1Ymdyb3VwcztcbiAgfTtcblxuICBjaG9yZC5zb3J0Q2hvcmRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IHNvcnRDaG9yZHMgPSBudWxsIDogKHNvcnRDaG9yZHMgPSBjb21wYXJlVmFsdWUoXykpLl8gPSBfLCBjaG9yZCkgOiBzb3J0Q2hvcmRzICYmIHNvcnRDaG9yZHMuXztcbiAgfTtcblxuICByZXR1cm4gY2hvcmQ7XG59O1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdFNvdXJjZShkKSB7XG4gIHJldHVybiBkLnNvdXJjZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRhcmdldChkKSB7XG4gIHJldHVybiBkLnRhcmdldDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFJhZGl1cyhkKSB7XG4gIHJldHVybiBkLnJhZGl1cztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0RW5kQW5nbGUoZCkge1xuICByZXR1cm4gZC5lbmRBbmdsZTtcbn1cblxudmFyIHJpYmJvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc291cmNlID0gZGVmYXVsdFNvdXJjZSxcbiAgICAgIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsXG4gICAgICByYWRpdXMgPSBkZWZhdWx0UmFkaXVzLFxuICAgICAgc3RhcnRBbmdsZSA9IGRlZmF1bHRTdGFydEFuZ2xlLFxuICAgICAgZW5kQW5nbGUgPSBkZWZhdWx0RW5kQW5nbGUsXG4gICAgICBjb250ZXh0ID0gbnVsbDtcblxuICBmdW5jdGlvbiByaWJib24oKSB7XG4gICAgdmFyIGJ1ZmZlcixcbiAgICAgICAgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSxcbiAgICAgICAgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSxcbiAgICAgICAgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KSxcbiAgICAgICAgc3IgPSArcmFkaXVzLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLFxuICAgICAgICBzYTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpLFxuICAgICAgICBzYTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaSxcbiAgICAgICAgc3gwID0gc3IgKiBjb3Moc2EwKSxcbiAgICAgICAgc3kwID0gc3IgKiBzaW4oc2EwKSxcbiAgICAgICAgdHIgPSArcmFkaXVzLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gdCwgYXJndikpLFxuICAgICAgICB0YTAgPSBzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3YpIC0gaGFsZlBpLFxuICAgICAgICB0YTEgPSBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd2KSAtIGhhbGZQaTtcblxuICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCk7XG5cbiAgICBjb250ZXh0Lm1vdmVUbyhzeDAsIHN5MCk7XG4gICAgY29udGV4dC5hcmMoMCwgMCwgc3IsIHNhMCwgc2ExKTtcbiAgICBpZiAoc2EwICE9PSB0YTAgfHwgc2ExICE9PSB0YTEpIHsgLy8gVE9ETyBzciAhPT0gdHI/XG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMCwgMCwgdHIgKiBjb3ModGEwKSwgdHIgKiBzaW4odGEwKSk7XG4gICAgICBjb250ZXh0LmFyYygwLCAwLCB0ciwgdGEwLCB0YTEpO1xuICAgIH1cbiAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oMCwgMCwgc3gwLCBzeTApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHJpYmJvbi5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHJpYmJvbikgOiByYWRpdXM7XG4gIH07XG5cbiAgcmliYm9uLnN0YXJ0QW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RhcnRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCByaWJib24pIDogc3RhcnRBbmdsZTtcbiAgfTtcblxuICByaWJib24uZW5kQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZW5kQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcmliYm9uKSA6IGVuZEFuZ2xlO1xuICB9O1xuXG4gIHJpYmJvbi5zb3VyY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc291cmNlID0gXywgcmliYm9uKSA6IHNvdXJjZTtcbiAgfTtcblxuICByaWJib24udGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIHJpYmJvbikgOiB0YXJnZXQ7XG4gIH07XG5cbiAgcmliYm9uLmNvbnRleHQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXyksIHJpYmJvbikgOiBjb250ZXh0O1xuICB9O1xuXG4gIHJldHVybiByaWJib247XG59O1xuXG5leHBvcnRzLmNob3JkID0gY2hvcmQ7XG5leHBvcnRzLnJpYmJvbiA9IHJpYmJvbjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtY29sbGVjdGlvbi8gVmVyc2lvbiAxLjAuNC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZml4ID0gXCIkXCI7XG5cbmZ1bmN0aW9uIE1hcCgpIHt9XG5cbk1hcC5wcm90b3R5cGUgPSBtYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogTWFwLFxuICBoYXM6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAocHJlZml4ICsga2V5KSBpbiB0aGlzO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzW3ByZWZpeCArIGtleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHRoaXNbcHJlZml4ICsga2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBwcm9wZXJ0eSA9IHByZWZpeCArIGtleTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiBkZWxldGUgdGhpc1twcm9wZXJ0eV07XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgZGVsZXRlIHRoaXNbcHJvcGVydHldO1xuICB9LFxuICBrZXlzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBrZXlzLnB1c2gocHJvcGVydHkuc2xpY2UoMSkpO1xuICAgIHJldHVybiBrZXlzO1xuICB9LFxuICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgdmFsdWVzLnB1c2godGhpc1twcm9wZXJ0eV0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0sXG4gIGVudHJpZXM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIGVudHJpZXMucHVzaCh7a2V5OiBwcm9wZXJ0eS5zbGljZSgxKSwgdmFsdWU6IHRoaXNbcHJvcGVydHldfSk7XG4gICAgcmV0dXJuIGVudHJpZXM7XG4gIH0sXG4gIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzKSBpZiAocHJvcGVydHlbMF0gPT09IHByZWZpeCkgKytzaXplO1xuICAgIHJldHVybiBzaXplO1xuICB9LFxuICBlbXB0eTogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gdGhpcykgaWYgKHByb3BlcnR5WzBdID09PSBwcmVmaXgpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgZWFjaDogZnVuY3Rpb24oZikge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHRoaXMpIGlmIChwcm9wZXJ0eVswXSA9PT0gcHJlZml4KSBmKHRoaXNbcHJvcGVydHldLCBwcm9wZXJ0eS5zbGljZSgxKSwgdGhpcyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcChvYmplY3QsIGYpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXA7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkgeyBtYXAuc2V0KGtleSwgdmFsdWUpOyB9KTtcblxuICAvLyBJbmRleCBhcnJheSBieSBudW1lcmljIGluZGV4IG9yIHNwZWNpZmllZCBrZXkgZnVuY3Rpb24uXG4gIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgIHZhciBpID0gLTEsXG4gICAgICAgIG4gPSBvYmplY3QubGVuZ3RoLFxuICAgICAgICBvO1xuXG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIG1hcC5zZXQoaSwgb2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBtYXAuc2V0KGYobyA9IG9iamVjdFtpXSwgaSwgb2JqZWN0KSwgbyk7XG4gIH1cblxuICAvLyBDb252ZXJ0IG9iamVjdCB0byBtYXAuXG4gIGVsc2UgaWYgKG9iamVjdCkgZm9yICh2YXIga2V5IGluIG9iamVjdCkgbWFwLnNldChrZXksIG9iamVjdFtrZXldKTtcblxuICByZXR1cm4gbWFwO1xufVxuXG52YXIgbmVzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIga2V5cyA9IFtdLFxuICAgICAgc29ydEtleXMgPSBbXSxcbiAgICAgIHNvcnRWYWx1ZXMsXG4gICAgICByb2xsdXAsXG4gICAgICBuZXN0O1xuXG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpIHtcbiAgICBpZiAoZGVwdGggPj0ga2V5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChzb3J0VmFsdWVzICE9IG51bGwpIGFycmF5LnNvcnQoc29ydFZhbHVlcyk7XG4gICAgICByZXR1cm4gcm9sbHVwICE9IG51bGwgPyByb2xsdXAoYXJyYXkpIDogYXJyYXk7XG4gICAgfVxuXG4gICAgdmFyIGkgPSAtMSxcbiAgICAgICAgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgICAga2V5VmFsdWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB2YWx1ZXNCeUtleSA9IG1hcCgpLFxuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHJlc3VsdCA9IGNyZWF0ZVJlc3VsdCgpO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleS5nZXQoa2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyBcIlwiKSkge1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNCeUtleS5zZXQoa2V5VmFsdWUsIFt2YWx1ZV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbHVlc0J5S2V5LmVhY2goZnVuY3Rpb24odmFsdWVzLCBrZXkpIHtcbiAgICAgIHNldFJlc3VsdChyZXN1bHQsIGtleSwgYXBwbHkodmFsdWVzLCBkZXB0aCwgY3JlYXRlUmVzdWx0LCBzZXRSZXN1bHQpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBlbnRyaWVzKG1hcCQkMSwgZGVwdGgpIHtcbiAgICBpZiAoKytkZXB0aCA+IGtleXMubGVuZ3RoKSByZXR1cm4gbWFwJCQxO1xuICAgIHZhciBhcnJheSwgc29ydEtleSA9IHNvcnRLZXlzW2RlcHRoIC0gMV07XG4gICAgaWYgKHJvbGx1cCAhPSBudWxsICYmIGRlcHRoID49IGtleXMubGVuZ3RoKSBhcnJheSA9IG1hcCQkMS5lbnRyaWVzKCk7XG4gICAgZWxzZSBhcnJheSA9IFtdLCBtYXAkJDEuZWFjaChmdW5jdGlvbih2LCBrKSB7IGFycmF5LnB1c2goe2tleTogaywgdmFsdWVzOiBlbnRyaWVzKHYsIGRlcHRoKX0pOyB9KTtcbiAgICByZXR1cm4gc29ydEtleSAhPSBudWxsID8gYXJyYXkuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzb3J0S2V5KGEua2V5LCBiLmtleSk7IH0pIDogYXJyYXk7XG4gIH1cblxuICByZXR1cm4gbmVzdCA9IHtcbiAgICBvYmplY3Q6IGZ1bmN0aW9uKGFycmF5KSB7IHJldHVybiBhcHBseShhcnJheSwgMCwgY3JlYXRlT2JqZWN0LCBzZXRPYmplY3QpOyB9LFxuICAgIG1hcDogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGFwcGx5KGFycmF5LCAwLCBjcmVhdGVNYXAsIHNldE1hcCk7IH0sXG4gICAgZW50cmllczogZnVuY3Rpb24oYXJyYXkpIHsgcmV0dXJuIGVudHJpZXMoYXBwbHkoYXJyYXksIDAsIGNyZWF0ZU1hcCwgc2V0TWFwKSwgMCk7IH0sXG4gICAga2V5OiBmdW5jdGlvbihkKSB7IGtleXMucHVzaChkKTsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydEtleXM6IGZ1bmN0aW9uKG9yZGVyKSB7IHNvcnRLZXlzW2tleXMubGVuZ3RoIC0gMV0gPSBvcmRlcjsgcmV0dXJuIG5lc3Q7IH0sXG4gICAgc29ydFZhbHVlczogZnVuY3Rpb24ob3JkZXIpIHsgc29ydFZhbHVlcyA9IG9yZGVyOyByZXR1cm4gbmVzdDsgfSxcbiAgICByb2xsdXA6IGZ1bmN0aW9uKGYpIHsgcm9sbHVwID0gZjsgcmV0dXJuIG5lc3Q7IH1cbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdCgpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBzZXRPYmplY3Qob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcCgpIHtcbiAgcmV0dXJuIG1hcCgpO1xufVxuXG5mdW5jdGlvbiBzZXRNYXAobWFwJCQxLCBrZXksIHZhbHVlKSB7XG4gIG1hcCQkMS5zZXQoa2V5LCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIFNldCgpIHt9XG5cbnZhciBwcm90byA9IG1hcC5wcm90b3R5cGU7XG5cblNldC5wcm90b3R5cGUgPSBzZXQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU2V0LFxuICBoYXM6IHByb3RvLmhhcyxcbiAgYWRkOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhbHVlICs9IFwiXCI7XG4gICAgdGhpc1twcmVmaXggKyB2YWx1ZV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgcmVtb3ZlOiBwcm90by5yZW1vdmUsXG4gIGNsZWFyOiBwcm90by5jbGVhcixcbiAgdmFsdWVzOiBwcm90by5rZXlzLFxuICBzaXplOiBwcm90by5zaXplLFxuICBlbXB0eTogcHJvdG8uZW1wdHksXG4gIGVhY2g6IHByb3RvLmVhY2hcbn07XG5cbmZ1bmN0aW9uIHNldChvYmplY3QsIGYpIHtcbiAgdmFyIHNldCA9IG5ldyBTZXQ7XG5cbiAgLy8gQ29weSBjb25zdHJ1Y3Rvci5cbiAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFNldCkgb2JqZWN0LmVhY2goZnVuY3Rpb24odmFsdWUpIHsgc2V0LmFkZCh2YWx1ZSk7IH0pO1xuXG4gIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl04oCZcyBhbiBhcnJheS5cbiAgZWxzZSBpZiAob2JqZWN0KSB7XG4gICAgdmFyIGkgPSAtMSwgbiA9IG9iamVjdC5sZW5ndGg7XG4gICAgaWYgKGYgPT0gbnVsbCkgd2hpbGUgKCsraSA8IG4pIHNldC5hZGQob2JqZWN0W2ldKTtcbiAgICBlbHNlIHdoaWxlICgrK2kgPCBuKSBzZXQuYWRkKGYob2JqZWN0W2ldLCBpLCBvYmplY3QpKTtcbiAgfVxuXG4gIHJldHVybiBzZXQ7XG59XG5cbnZhciBrZXlzID0gZnVuY3Rpb24obWFwKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBtYXApIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn07XG5cbnZhciB2YWx1ZXMgPSBmdW5jdGlvbihtYXApIHtcbiAgdmFyIHZhbHVlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSB2YWx1ZXMucHVzaChtYXBba2V5XSk7XG4gIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgZW50cmllcyA9IGZ1bmN0aW9uKG1hcCkge1xuICB2YXIgZW50cmllcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gbWFwKSBlbnRyaWVzLnB1c2goe2tleToga2V5LCB2YWx1ZTogbWFwW2tleV19KTtcbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG5leHBvcnRzLm5lc3QgPSBuZXN0O1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLm1hcCA9IG1hcDtcbmV4cG9ydHMua2V5cyA9IGtleXM7XG5leHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcbmV4cG9ydHMuZW50cmllcyA9IGVudHJpZXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbG9yLyBWZXJzaW9uIDEuMi4wLiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBkZWZpbmUgPSBmdW5jdGlvbihjb25zdHJ1Y3RvciwgZmFjdG9yeSwgcHJvdG90eXBlKSB7XG4gIGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGZhY3RvcnkucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBwcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZChwYXJlbnQsIGRlZmluaXRpb24pIHtcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUocGFyZW50LnByb3RvdHlwZSk7XG4gIGZvciAodmFyIGtleSBpbiBkZWZpbml0aW9uKSBwcm90b3R5cGVba2V5XSA9IGRlZmluaXRpb25ba2V5XTtcbiAgcmV0dXJuIHByb3RvdHlwZTtcbn1cblxuZnVuY3Rpb24gQ29sb3IoKSB7fVxuXG52YXIgZGFya2VyID0gMC43O1xudmFyIGJyaWdodGVyID0gMSAvIGRhcmtlcjtcblxudmFyIHJlSSA9IFwiXFxcXHMqKFsrLV0/XFxcXGQrKVxcXFxzKlwiO1xudmFyIHJlTiA9IFwiXFxcXHMqKFsrLV0/XFxcXGQqXFxcXC4/XFxcXGQrKD86W2VFXVsrLV0/XFxcXGQrKT8pXFxcXHMqXCI7XG52YXIgcmVQID0gXCJcXFxccyooWystXT9cXFxcZCpcXFxcLj9cXFxcZCsoPzpbZUVdWystXT9cXFxcZCspPyklXFxcXHMqXCI7XG52YXIgcmVIZXgzID0gL14jKFswLTlhLWZdezN9KSQvO1xudmFyIHJlSGV4NiA9IC9eIyhbMC05YS1mXXs2fSkkLztcbnZhciByZVJnYkludGVnZXIgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVJLCByZUksIHJlSV0gKyBcIlxcXFwpJFwiKTtcbnZhciByZVJnYlBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXnJnYlxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUF0gKyBcIlxcXFwpJFwiKTtcbnZhciByZVJnYmFJbnRlZ2VyID0gbmV3IFJlZ0V4cChcIl5yZ2JhXFxcXChcIiArIFtyZUksIHJlSSwgcmVJLCByZU5dICsgXCJcXFxcKSRcIik7XG52YXIgcmVSZ2JhUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJecmdiYVxcXFwoXCIgKyBbcmVQLCByZVAsIHJlUCwgcmVOXSArIFwiXFxcXCkkXCIpO1xudmFyIHJlSHNsUGVyY2VudCA9IG5ldyBSZWdFeHAoXCJeaHNsXFxcXChcIiArIFtyZU4sIHJlUCwgcmVQXSArIFwiXFxcXCkkXCIpO1xudmFyIHJlSHNsYVBlcmNlbnQgPSBuZXcgUmVnRXhwKFwiXmhzbGFcXFxcKFwiICsgW3JlTiwgcmVQLCByZVAsIHJlTl0gKyBcIlxcXFwpJFwiKTtcblxudmFyIG5hbWVkID0ge1xuICBhbGljZWJsdWU6IDB4ZjBmOGZmLFxuICBhbnRpcXVld2hpdGU6IDB4ZmFlYmQ3LFxuICBhcXVhOiAweDAwZmZmZixcbiAgYXF1YW1hcmluZTogMHg3ZmZmZDQsXG4gIGF6dXJlOiAweGYwZmZmZixcbiAgYmVpZ2U6IDB4ZjVmNWRjLFxuICBiaXNxdWU6IDB4ZmZlNGM0LFxuICBibGFjazogMHgwMDAwMDAsXG4gIGJsYW5jaGVkYWxtb25kOiAweGZmZWJjZCxcbiAgYmx1ZTogMHgwMDAwZmYsXG4gIGJsdWV2aW9sZXQ6IDB4OGEyYmUyLFxuICBicm93bjogMHhhNTJhMmEsXG4gIGJ1cmx5d29vZDogMHhkZWI4ODcsXG4gIGNhZGV0Ymx1ZTogMHg1ZjllYTAsXG4gIGNoYXJ0cmV1c2U6IDB4N2ZmZjAwLFxuICBjaG9jb2xhdGU6IDB4ZDI2OTFlLFxuICBjb3JhbDogMHhmZjdmNTAsXG4gIGNvcm5mbG93ZXJibHVlOiAweDY0OTVlZCxcbiAgY29ybnNpbGs6IDB4ZmZmOGRjLFxuICBjcmltc29uOiAweGRjMTQzYyxcbiAgY3lhbjogMHgwMGZmZmYsXG4gIGRhcmtibHVlOiAweDAwMDA4YixcbiAgZGFya2N5YW46IDB4MDA4YjhiLFxuICBkYXJrZ29sZGVucm9kOiAweGI4ODYwYixcbiAgZGFya2dyYXk6IDB4YTlhOWE5LFxuICBkYXJrZ3JlZW46IDB4MDA2NDAwLFxuICBkYXJrZ3JleTogMHhhOWE5YTksXG4gIGRhcmtraGFraTogMHhiZGI3NmIsXG4gIGRhcmttYWdlbnRhOiAweDhiMDA4YixcbiAgZGFya29saXZlZ3JlZW46IDB4NTU2YjJmLFxuICBkYXJrb3JhbmdlOiAweGZmOGMwMCxcbiAgZGFya29yY2hpZDogMHg5OTMyY2MsXG4gIGRhcmtyZWQ6IDB4OGIwMDAwLFxuICBkYXJrc2FsbW9uOiAweGU5OTY3YSxcbiAgZGFya3NlYWdyZWVuOiAweDhmYmM4ZixcbiAgZGFya3NsYXRlYmx1ZTogMHg0ODNkOGIsXG4gIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmLFxuICBkYXJrc2xhdGVncmV5OiAweDJmNGY0ZixcbiAgZGFya3R1cnF1b2lzZTogMHgwMGNlZDEsXG4gIGRhcmt2aW9sZXQ6IDB4OTQwMGQzLFxuICBkZWVwcGluazogMHhmZjE0OTMsXG4gIGRlZXBza3libHVlOiAweDAwYmZmZixcbiAgZGltZ3JheTogMHg2OTY5NjksXG4gIGRpbWdyZXk6IDB4Njk2OTY5LFxuICBkb2RnZXJibHVlOiAweDFlOTBmZixcbiAgZmlyZWJyaWNrOiAweGIyMjIyMixcbiAgZmxvcmFsd2hpdGU6IDB4ZmZmYWYwLFxuICBmb3Jlc3RncmVlbjogMHgyMjhiMjIsXG4gIGZ1Y2hzaWE6IDB4ZmYwMGZmLFxuICBnYWluc2Jvcm86IDB4ZGNkY2RjLFxuICBnaG9zdHdoaXRlOiAweGY4ZjhmZixcbiAgZ29sZDogMHhmZmQ3MDAsXG4gIGdvbGRlbnJvZDogMHhkYWE1MjAsXG4gIGdyYXk6IDB4ODA4MDgwLFxuICBncmVlbjogMHgwMDgwMDAsXG4gIGdyZWVueWVsbG93OiAweGFkZmYyZixcbiAgZ3JleTogMHg4MDgwODAsXG4gIGhvbmV5ZGV3OiAweGYwZmZmMCxcbiAgaG90cGluazogMHhmZjY5YjQsXG4gIGluZGlhbnJlZDogMHhjZDVjNWMsXG4gIGluZGlnbzogMHg0YjAwODIsXG4gIGl2b3J5OiAweGZmZmZmMCxcbiAga2hha2k6IDB4ZjBlNjhjLFxuICBsYXZlbmRlcjogMHhlNmU2ZmEsXG4gIGxhdmVuZGVyYmx1c2g6IDB4ZmZmMGY1LFxuICBsYXduZ3JlZW46IDB4N2NmYzAwLFxuICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkLFxuICBsaWdodGJsdWU6IDB4YWRkOGU2LFxuICBsaWdodGNvcmFsOiAweGYwODA4MCxcbiAgbGlnaHRjeWFuOiAweGUwZmZmZixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IDB4ZmFmYWQyLFxuICBsaWdodGdyYXk6IDB4ZDNkM2QzLFxuICBsaWdodGdyZWVuOiAweDkwZWU5MCxcbiAgbGlnaHRncmV5OiAweGQzZDNkMyxcbiAgbGlnaHRwaW5rOiAweGZmYjZjMSxcbiAgbGlnaHRzYWxtb246IDB4ZmZhMDdhLFxuICBsaWdodHNlYWdyZWVuOiAweDIwYjJhYSxcbiAgbGlnaHRza3libHVlOiAweDg3Y2VmYSxcbiAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5LFxuICBsaWdodHNsYXRlZ3JleTogMHg3Nzg4OTksXG4gIGxpZ2h0c3RlZWxibHVlOiAweGIwYzRkZSxcbiAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwLFxuICBsaW1lOiAweDAwZmYwMCxcbiAgbGltZWdyZWVuOiAweDMyY2QzMixcbiAgbGluZW46IDB4ZmFmMGU2LFxuICBtYWdlbnRhOiAweGZmMDBmZixcbiAgbWFyb29uOiAweDgwMDAwMCxcbiAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWEsXG4gIG1lZGl1bWJsdWU6IDB4MDAwMGNkLFxuICBtZWRpdW1vcmNoaWQ6IDB4YmE1NWQzLFxuICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiLFxuICBtZWRpdW1zZWFncmVlbjogMHgzY2IzNzEsXG4gIG1lZGl1bXNsYXRlYmx1ZTogMHg3YjY4ZWUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YSxcbiAgbWVkaXVtdHVycXVvaXNlOiAweDQ4ZDFjYyxcbiAgbWVkaXVtdmlvbGV0cmVkOiAweGM3MTU4NSxcbiAgbWlkbmlnaHRibHVlOiAweDE5MTk3MCxcbiAgbWludGNyZWFtOiAweGY1ZmZmYSxcbiAgbWlzdHlyb3NlOiAweGZmZTRlMSxcbiAgbW9jY2FzaW46IDB4ZmZlNGI1LFxuICBuYXZham93aGl0ZTogMHhmZmRlYWQsXG4gIG5hdnk6IDB4MDAwMDgwLFxuICBvbGRsYWNlOiAweGZkZjVlNixcbiAgb2xpdmU6IDB4ODA4MDAwLFxuICBvbGl2ZWRyYWI6IDB4NmI4ZTIzLFxuICBvcmFuZ2U6IDB4ZmZhNTAwLFxuICBvcmFuZ2VyZWQ6IDB4ZmY0NTAwLFxuICBvcmNoaWQ6IDB4ZGE3MGQ2LFxuICBwYWxlZ29sZGVucm9kOiAweGVlZThhYSxcbiAgcGFsZWdyZWVuOiAweDk4ZmI5OCxcbiAgcGFsZXR1cnF1b2lzZTogMHhhZmVlZWUsXG4gIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzLFxuICBwYXBheWF3aGlwOiAweGZmZWZkNSxcbiAgcGVhY2hwdWZmOiAweGZmZGFiOSxcbiAgcGVydTogMHhjZDg1M2YsXG4gIHBpbms6IDB4ZmZjMGNiLFxuICBwbHVtOiAweGRkYTBkZCxcbiAgcG93ZGVyYmx1ZTogMHhiMGUwZTYsXG4gIHB1cnBsZTogMHg4MDAwODAsXG4gIHJlYmVjY2FwdXJwbGU6IDB4NjYzMzk5LFxuICByZWQ6IDB4ZmYwMDAwLFxuICByb3N5YnJvd246IDB4YmM4ZjhmLFxuICByb3lhbGJsdWU6IDB4NDE2OWUxLFxuICBzYWRkbGVicm93bjogMHg4YjQ1MTMsXG4gIHNhbG1vbjogMHhmYTgwNzIsXG4gIHNhbmR5YnJvd246IDB4ZjRhNDYwLFxuICBzZWFncmVlbjogMHgyZThiNTcsXG4gIHNlYXNoZWxsOiAweGZmZjVlZSxcbiAgc2llbm5hOiAweGEwNTIyZCxcbiAgc2lsdmVyOiAweGMwYzBjMCxcbiAgc2t5Ymx1ZTogMHg4N2NlZWIsXG4gIHNsYXRlYmx1ZTogMHg2YTVhY2QsXG4gIHNsYXRlZ3JheTogMHg3MDgwOTAsXG4gIHNsYXRlZ3JleTogMHg3MDgwOTAsXG4gIHNub3c6IDB4ZmZmYWZhLFxuICBzcHJpbmdncmVlbjogMHgwMGZmN2YsXG4gIHN0ZWVsYmx1ZTogMHg0NjgyYjQsXG4gIHRhbjogMHhkMmI0OGMsXG4gIHRlYWw6IDB4MDA4MDgwLFxuICB0aGlzdGxlOiAweGQ4YmZkOCxcbiAgdG9tYXRvOiAweGZmNjM0NyxcbiAgdHVycXVvaXNlOiAweDQwZTBkMCxcbiAgdmlvbGV0OiAweGVlODJlZSxcbiAgd2hlYXQ6IDB4ZjVkZWIzLFxuICB3aGl0ZTogMHhmZmZmZmYsXG4gIHdoaXRlc21va2U6IDB4ZjVmNWY1LFxuICB5ZWxsb3c6IDB4ZmZmZjAwLFxuICB5ZWxsb3dncmVlbjogMHg5YWNkMzJcbn07XG5cbmRlZmluZShDb2xvciwgY29sb3IsIHtcbiAgZGlzcGxheWFibGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJnYigpLmRpc3BsYXlhYmxlKCk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmdiKCkuaGV4KCk7XG4gIH0sXG4gIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZ2IoKSArIFwiXCI7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb2xvcihmb3JtYXQpIHtcbiAgdmFyIG07XG4gIGZvcm1hdCA9IChmb3JtYXQgKyBcIlwiKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChtID0gcmVIZXgzLmV4ZWMoZm9ybWF0KSkgPyAobSA9IHBhcnNlSW50KG1bMV0sIDE2KSwgbmV3IFJnYigobSA+PiA4ICYgMHhmKSB8IChtID4+IDQgJiAweDBmMCksIChtID4+IDQgJiAweGYpIHwgKG0gJiAweGYwKSwgKChtICYgMHhmKSA8PCA0KSB8IChtICYgMHhmKSwgMSkpIC8vICNmMDBcbiAgICAgIDogKG0gPSByZUhleDYuZXhlYyhmb3JtYXQpKSA/IHJnYm4ocGFyc2VJbnQobVsxXSwgMTYpKSAvLyAjZmYwMDAwXG4gICAgICA6IChtID0gcmVSZ2JJbnRlZ2VyLmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0sIG1bMl0sIG1bM10sIDEpIC8vIHJnYigyNTUsIDAsIDApXG4gICAgICA6IChtID0gcmVSZ2JQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBuZXcgUmdiKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIDEpIC8vIHJnYigxMDAlLCAwJSwgMCUpXG4gICAgICA6IChtID0gcmVSZ2JhSW50ZWdlci5leGVjKGZvcm1hdCkpID8gcmdiYShtWzFdLCBtWzJdLCBtWzNdLCBtWzRdKSAvLyByZ2JhKDI1NSwgMCwgMCwgMSlcbiAgICAgIDogKG0gPSByZVJnYmFQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyByZ2JhKG1bMV0gKiAyNTUgLyAxMDAsIG1bMl0gKiAyNTUgLyAxMDAsIG1bM10gKiAyNTUgLyAxMDAsIG1bNF0pIC8vIHJnYigxMDAlLCAwJSwgMCUsIDEpXG4gICAgICA6IChtID0gcmVIc2xQZXJjZW50LmV4ZWMoZm9ybWF0KSkgPyBoc2xhKG1bMV0sIG1bMl0gLyAxMDAsIG1bM10gLyAxMDAsIDEpIC8vIGhzbCgxMjAsIDUwJSwgNTAlKVxuICAgICAgOiAobSA9IHJlSHNsYVBlcmNlbnQuZXhlYyhmb3JtYXQpKSA/IGhzbGEobVsxXSwgbVsyXSAvIDEwMCwgbVszXSAvIDEwMCwgbVs0XSkgLy8gaHNsYSgxMjAsIDUwJSwgNTAlLCAxKVxuICAgICAgOiBuYW1lZC5oYXNPd25Qcm9wZXJ0eShmb3JtYXQpID8gcmdibihuYW1lZFtmb3JtYXRdKVxuICAgICAgOiBmb3JtYXQgPT09IFwidHJhbnNwYXJlbnRcIiA/IG5ldyBSZ2IoTmFOLCBOYU4sIE5hTiwgMClcbiAgICAgIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gcmdibihuKSB7XG4gIHJldHVybiBuZXcgUmdiKG4gPj4gMTYgJiAweGZmLCBuID4+IDggJiAweGZmLCBuICYgMHhmZiwgMSk7XG59XG5cbmZ1bmN0aW9uIHJnYmEociwgZywgYiwgYSkge1xuICBpZiAoYSA8PSAwKSByID0gZyA9IGIgPSBOYU47XG4gIHJldHVybiBuZXcgUmdiKHIsIGcsIGIsIGEpO1xufVxuXG5mdW5jdGlvbiByZ2JDb252ZXJ0KG8pIHtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIENvbG9yKSkgbyA9IGNvbG9yKG8pO1xuICBpZiAoIW8pIHJldHVybiBuZXcgUmdiO1xuICBvID0gby5yZ2IoKTtcbiAgcmV0dXJuIG5ldyBSZ2Ioby5yLCBvLmcsIG8uYiwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gcmdiKHIsIGcsIGIsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyByZ2JDb252ZXJ0KHIpIDogbmV3IFJnYihyLCBnLCBiLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIFJnYihyLCBnLCBiLCBvcGFjaXR5KSB7XG4gIHRoaXMuciA9ICtyO1xuICB0aGlzLmcgPSArZztcbiAgdGhpcy5iID0gK2I7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoUmdiLCByZ2IsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICBrID0gayA9PSBudWxsID8gZGFya2VyIDogTWF0aC5wb3coZGFya2VyLCBrKTtcbiAgICByZXR1cm4gbmV3IFJnYih0aGlzLnIgKiBrLCB0aGlzLmcgKiBrLCB0aGlzLmIgKiBrLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMuciAmJiB0aGlzLnIgPD0gMjU1KVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmcgJiYgdGhpcy5nIDw9IDI1NSlcbiAgICAgICAgJiYgKDAgPD0gdGhpcy5iICYmIHRoaXMuYiA8PSAyNTUpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH0sXG4gIGhleDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiI1wiICsgaGV4KHRoaXMucikgKyBoZXgodGhpcy5nKSArIGhleCh0aGlzLmIpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGEgPSB0aGlzLm9wYWNpdHk7IGEgPSBpc05hTihhKSA/IDEgOiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBhKSk7XG4gICAgcmV0dXJuIChhID09PSAxID8gXCJyZ2IoXCIgOiBcInJnYmEoXCIpXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMucikgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuZykgfHwgMCkpICsgXCIsIFwiXG4gICAgICAgICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuYikgfHwgMCkpXG4gICAgICAgICsgKGEgPT09IDEgPyBcIilcIiA6IFwiLCBcIiArIGEgKyBcIilcIik7XG4gIH1cbn0pKTtcblxuZnVuY3Rpb24gaGV4KHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHZhbHVlKSB8fCAwKSk7XG4gIHJldHVybiAodmFsdWUgPCAxNiA/IFwiMFwiIDogXCJcIikgKyB2YWx1ZS50b1N0cmluZygxNik7XG59XG5cbmZ1bmN0aW9uIGhzbGEoaCwgcywgbCwgYSkge1xuICBpZiAoYSA8PSAwKSBoID0gcyA9IGwgPSBOYU47XG4gIGVsc2UgaWYgKGwgPD0gMCB8fCBsID49IDEpIGggPSBzID0gTmFOO1xuICBlbHNlIGlmIChzIDw9IDApIGggPSBOYU47XG4gIHJldHVybiBuZXcgSHNsKGgsIHMsIGwsIGEpO1xufVxuXG5mdW5jdGlvbiBoc2xDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBuZXcgSHNsKG8uaCwgby5zLCBvLmwsIG8ub3BhY2l0eSk7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBDb2xvcikpIG8gPSBjb2xvcihvKTtcbiAgaWYgKCFvKSByZXR1cm4gbmV3IEhzbDtcbiAgaWYgKG8gaW5zdGFuY2VvZiBIc2wpIHJldHVybiBvO1xuICBvID0gby5yZ2IoKTtcbiAgdmFyIHIgPSBvLnIgLyAyNTUsXG4gICAgICBnID0gby5nIC8gMjU1LFxuICAgICAgYiA9IG8uYiAvIDI1NSxcbiAgICAgIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuICAgICAgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG4gICAgICBoID0gTmFOLFxuICAgICAgcyA9IG1heCAtIG1pbixcbiAgICAgIGwgPSAobWF4ICsgbWluKSAvIDI7XG4gIGlmIChzKSB7XG4gICAgaWYgKHIgPT09IG1heCkgaCA9IChnIC0gYikgLyBzICsgKGcgPCBiKSAqIDY7XG4gICAgZWxzZSBpZiAoZyA9PT0gbWF4KSBoID0gKGIgLSByKSAvIHMgKyAyO1xuICAgIGVsc2UgaCA9IChyIC0gZykgLyBzICsgNDtcbiAgICBzIC89IGwgPCAwLjUgPyBtYXggKyBtaW4gOiAyIC0gbWF4IC0gbWluO1xuICAgIGggKj0gNjA7XG4gIH0gZWxzZSB7XG4gICAgcyA9IGwgPiAwICYmIGwgPCAxID8gMCA6IGg7XG4gIH1cbiAgcmV0dXJuIG5ldyBIc2woaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaHNsKGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoc2xDb252ZXJ0KGgpIDogbmV3IEhzbChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhzbChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSHNsLCBoc2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEhzbCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBIc2wodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSB0aGlzLmggJSAzNjAgKyAodGhpcy5oIDwgMCkgKiAzNjAsXG4gICAgICAgIHMgPSBpc05hTihoKSB8fCBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyxcbiAgICAgICAgbCA9IHRoaXMubCxcbiAgICAgICAgbTIgPSBsICsgKGwgPCAwLjUgPyBsIDogMSAtIGwpICogcyxcbiAgICAgICAgbTEgPSAyICogbCAtIG0yO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgaHNsMnJnYihoID49IDI0MCA/IGggLSAyNDAgOiBoICsgMTIwLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoLCBtMSwgbTIpLFxuICAgICAgaHNsMnJnYihoIDwgMTIwID8gaCArIDI0MCA6IGggLSAxMjAsIG0xLCBtMiksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9LFxuICBkaXNwbGF5YWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwIDw9IHRoaXMucyAmJiB0aGlzLnMgPD0gMSB8fCBpc05hTih0aGlzLnMpKVxuICAgICAgICAmJiAoMCA8PSB0aGlzLmwgJiYgdGhpcy5sIDw9IDEpXG4gICAgICAgICYmICgwIDw9IHRoaXMub3BhY2l0eSAmJiB0aGlzLm9wYWNpdHkgPD0gMSk7XG4gIH1cbn0pKTtcblxuLyogRnJvbSBGdkQgMTMuMzcsIENTUyBDb2xvciBNb2R1bGUgTGV2ZWwgMyAqL1xuZnVuY3Rpb24gaHNsMnJnYihoLCBtMSwgbTIpIHtcbiAgcmV0dXJuIChoIDwgNjAgPyBtMSArIChtMiAtIG0xKSAqIGggLyA2MFxuICAgICAgOiBoIDwgMTgwID8gbTJcbiAgICAgIDogaCA8IDI0MCA/IG0xICsgKG0yIC0gbTEpICogKDI0MCAtIGgpIC8gNjBcbiAgICAgIDogbTEpICogMjU1O1xufVxuXG52YXIgZGVnMnJhZCA9IE1hdGguUEkgLyAxODA7XG52YXIgcmFkMmRlZyA9IDE4MCAvIE1hdGguUEk7XG5cbi8vIGh0dHBzOi8vYmV0YS5vYnNlcnZhYmxlaHEuY29tL0BtYm9zdG9jay9sYWItYW5kLXJnYlxudmFyIEsgPSAxODtcbnZhciBYbiA9IDAuOTY0MjI7XG52YXIgWW4gPSAxO1xudmFyIFpuID0gMC44MjUyMTtcbnZhciB0MCA9IDQgLyAyOTtcbnZhciB0MSA9IDYgLyAyOTtcbnZhciB0MiA9IDMgKiB0MSAqIHQxO1xudmFyIHQzID0gdDEgKiB0MSAqIHQxO1xuXG5mdW5jdGlvbiBsYWJDb252ZXJ0KG8pIHtcbiAgaWYgKG8gaW5zdGFuY2VvZiBMYWIpIHJldHVybiBuZXcgTGFiKG8ubCwgby5hLCBvLmIsIG8ub3BhY2l0eSk7XG4gIGlmIChvIGluc3RhbmNlb2YgSGNsKSB7XG4gICAgaWYgKGlzTmFOKG8uaCkpIHJldHVybiBuZXcgTGFiKG8ubCwgMCwgMCwgby5vcGFjaXR5KTtcbiAgICB2YXIgaCA9IG8uaCAqIGRlZzJyYWQ7XG4gICAgcmV0dXJuIG5ldyBMYWIoby5sLCBNYXRoLmNvcyhoKSAqIG8uYywgTWF0aC5zaW4oaCkgKiBvLmMsIG8ub3BhY2l0eSk7XG4gIH1cbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IHJnYjJscmdiKG8uciksXG4gICAgICBnID0gcmdiMmxyZ2Ioby5nKSxcbiAgICAgIGIgPSByZ2IybHJnYihvLmIpLFxuICAgICAgeSA9IHh5ejJsYWIoKDAuMjIyNTA0NSAqIHIgKyAwLjcxNjg3ODYgKiBnICsgMC4wNjA2MTY5ICogYikgLyBZbiksIHgsIHo7XG4gIGlmIChyID09PSBnICYmIGcgPT09IGIpIHggPSB6ID0geTsgZWxzZSB7XG4gICAgeCA9IHh5ejJsYWIoKDAuNDM2MDc0NyAqIHIgKyAwLjM4NTA2NDkgKiBnICsgMC4xNDMwODA0ICogYikgLyBYbik7XG4gICAgeiA9IHh5ejJsYWIoKDAuMDEzOTMyMiAqIHIgKyAwLjA5NzEwNDUgKiBnICsgMC43MTQxNzMzICogYikgLyBabik7XG4gIH1cbiAgcmV0dXJuIG5ldyBMYWIoMTE2ICogeSAtIDE2LCA1MDAgKiAoeCAtIHkpLCAyMDAgKiAoeSAtIHopLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBncmF5KGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIG5ldyBMYWIobCwgMCwgMCwgb3BhY2l0eSA9PSBudWxsID8gMSA6IG9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsYWIobCwgYSwgYiwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGxhYkNvbnZlcnQobCkgOiBuZXcgTGFiKGwsIGEsIGIsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gTGFiKGwsIGEsIGIsIG9wYWNpdHkpIHtcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMuYSA9ICthO1xuICB0aGlzLmIgPSArYjtcbiAgdGhpcy5vcGFjaXR5ID0gK29wYWNpdHk7XG59XG5cbmRlZmluZShMYWIsIGxhYiwgZXh0ZW5kKENvbG9yLCB7XG4gIGJyaWdodGVyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBMYWIodGhpcy5sICsgSyAqIChrID09IG51bGwgPyAxIDogayksIHRoaXMuYSwgdGhpcy5iLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICBkYXJrZXI6IGZ1bmN0aW9uKGspIHtcbiAgICByZXR1cm4gbmV3IExhYih0aGlzLmwgLSBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5hLCB0aGlzLmIsIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHkgPSAodGhpcy5sICsgMTYpIC8gMTE2LFxuICAgICAgICB4ID0gaXNOYU4odGhpcy5hKSA/IHkgOiB5ICsgdGhpcy5hIC8gNTAwLFxuICAgICAgICB6ID0gaXNOYU4odGhpcy5iKSA/IHkgOiB5IC0gdGhpcy5iIC8gMjAwO1xuICAgIHggPSBYbiAqIGxhYjJ4eXooeCk7XG4gICAgeSA9IFluICogbGFiMnh5eih5KTtcbiAgICB6ID0gWm4gKiBsYWIyeHl6KHopO1xuICAgIHJldHVybiBuZXcgUmdiKFxuICAgICAgbHJnYjJyZ2IoIDMuMTMzODU2MSAqIHggLSAxLjYxNjg2NjcgKiB5IC0gMC40OTA2MTQ2ICogeiksXG4gICAgICBscmdiMnJnYigtMC45Nzg3Njg0ICogeCArIDEuOTE2MTQxNSAqIHkgKyAwLjAzMzQ1NDAgKiB6KSxcbiAgICAgIGxyZ2IycmdiKCAwLjA3MTk0NTMgKiB4IC0gMC4yMjg5OTE0ICogeSArIDEuNDA1MjQyNyAqIHopLFxuICAgICAgdGhpcy5vcGFjaXR5XG4gICAgKTtcbiAgfVxufSkpO1xuXG5mdW5jdGlvbiB4eXoybGFiKHQpIHtcbiAgcmV0dXJuIHQgPiB0MyA/IE1hdGgucG93KHQsIDEgLyAzKSA6IHQgLyB0MiArIHQwO1xufVxuXG5mdW5jdGlvbiBsYWIyeHl6KHQpIHtcbiAgcmV0dXJuIHQgPiB0MSA/IHQgKiB0ICogdCA6IHQyICogKHQgLSB0MCk7XG59XG5cbmZ1bmN0aW9uIGxyZ2IycmdiKHgpIHtcbiAgcmV0dXJuIDI1NSAqICh4IDw9IDAuMDAzMTMwOCA/IDEyLjkyICogeCA6IDEuMDU1ICogTWF0aC5wb3coeCwgMSAvIDIuNCkgLSAwLjA1NSk7XG59XG5cbmZ1bmN0aW9uIHJnYjJscmdiKHgpIHtcbiAgcmV0dXJuICh4IC89IDI1NSkgPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbmZ1bmN0aW9uIGhjbENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEhjbCkgcmV0dXJuIG5ldyBIY2woby5oLCBvLmMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIExhYikpIG8gPSBsYWJDb252ZXJ0KG8pO1xuICBpZiAoby5hID09PSAwICYmIG8uYiA9PT0gMCkgcmV0dXJuIG5ldyBIY2woTmFOLCAwLCBvLmwsIG8ub3BhY2l0eSk7XG4gIHZhciBoID0gTWF0aC5hdGFuMihvLmIsIG8uYSkgKiByYWQyZGVnO1xuICByZXR1cm4gbmV3IEhjbChoIDwgMCA/IGggKyAzNjAgOiBoLCBNYXRoLnNxcnQoby5hICogby5hICsgby5iICogby5iKSwgby5sLCBvLm9wYWNpdHkpO1xufVxuXG5mdW5jdGlvbiBsY2gobCwgYywgaCwgb3BhY2l0eSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IGhjbENvbnZlcnQobCkgOiBuZXcgSGNsKGgsIGMsIGwsIG9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gaGNsKGgsIGMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBoY2xDb252ZXJ0KGgpIDogbmV3IEhjbChoLCBjLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEhjbChoLCBjLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLmMgPSArYztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoSGNsLCBoY2wsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIHJldHVybiBuZXcgSGNsKHRoaXMuaCwgdGhpcy5jLCB0aGlzLmwgKyBLICogKGsgPT0gbnVsbCA/IDEgOiBrKSwgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIG5ldyBIY2wodGhpcy5oLCB0aGlzLmMsIHRoaXMubCAtIEsgKiAoayA9PSBudWxsID8gMSA6IGspLCB0aGlzLm9wYWNpdHkpO1xuICB9LFxuICByZ2I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYWJDb252ZXJ0KHRoaXMpLnJnYigpO1xuICB9XG59KSk7XG5cbnZhciBBID0gLTAuMTQ4NjE7XG52YXIgQiA9ICsxLjc4Mjc3O1xudmFyIEMgPSAtMC4yOTIyNztcbnZhciBEID0gLTAuOTA2NDk7XG52YXIgRSA9ICsxLjk3Mjk0O1xudmFyIEVEID0gRSAqIEQ7XG52YXIgRUIgPSBFICogQjtcbnZhciBCQ19EQSA9IEIgKiBDIC0gRCAqIEE7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeENvbnZlcnQobykge1xuICBpZiAobyBpbnN0YW5jZW9mIEN1YmVoZWxpeCkgcmV0dXJuIG5ldyBDdWJlaGVsaXgoby5oLCBvLnMsIG8ubCwgby5vcGFjaXR5KTtcbiAgaWYgKCEobyBpbnN0YW5jZW9mIFJnYikpIG8gPSByZ2JDb252ZXJ0KG8pO1xuICB2YXIgciA9IG8uciAvIDI1NSxcbiAgICAgIGcgPSBvLmcgLyAyNTUsXG4gICAgICBiID0gby5iIC8gMjU1LFxuICAgICAgbCA9IChCQ19EQSAqIGIgKyBFRCAqIHIgLSBFQiAqIGcpIC8gKEJDX0RBICsgRUQgLSBFQiksXG4gICAgICBibCA9IGIgLSBsLFxuICAgICAgayA9IChFICogKGcgLSBsKSAtIEMgKiBibCkgLyBELFxuICAgICAgcyA9IE1hdGguc3FydChrICogayArIGJsICogYmwpIC8gKEUgKiBsICogKDEgLSBsKSksIC8vIE5hTiBpZiBsPTAgb3IgbD0xXG4gICAgICBoID0gcyA/IE1hdGguYXRhbjIoaywgYmwpICogcmFkMmRlZyAtIDEyMCA6IE5hTjtcbiAgcmV0dXJuIG5ldyBDdWJlaGVsaXgoaCA8IDAgPyBoICsgMzYwIDogaCwgcywgbCwgby5vcGFjaXR5KTtcbn1cblxuZnVuY3Rpb24gY3ViZWhlbGl4KGgsIHMsIGwsIG9wYWNpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjdWJlaGVsaXhDb252ZXJ0KGgpIDogbmV3IEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5ID09IG51bGwgPyAxIDogb3BhY2l0eSk7XG59XG5cbmZ1bmN0aW9uIEN1YmVoZWxpeChoLCBzLCBsLCBvcGFjaXR5KSB7XG4gIHRoaXMuaCA9ICtoO1xuICB0aGlzLnMgPSArcztcbiAgdGhpcy5sID0gK2w7XG4gIHRoaXMub3BhY2l0eSA9ICtvcGFjaXR5O1xufVxuXG5kZWZpbmUoQ3ViZWhlbGl4LCBjdWJlaGVsaXgsIGV4dGVuZChDb2xvciwge1xuICBicmlnaHRlcjogZnVuY3Rpb24oaykge1xuICAgIGsgPSBrID09IG51bGwgPyBicmlnaHRlciA6IE1hdGgucG93KGJyaWdodGVyLCBrKTtcbiAgICByZXR1cm4gbmV3IEN1YmVoZWxpeCh0aGlzLmgsIHRoaXMucywgdGhpcy5sICogaywgdGhpcy5vcGFjaXR5KTtcbiAgfSxcbiAgZGFya2VyOiBmdW5jdGlvbihrKSB7XG4gICAgayA9IGsgPT0gbnVsbCA/IGRhcmtlciA6IE1hdGgucG93KGRhcmtlciwgayk7XG4gICAgcmV0dXJuIG5ldyBDdWJlaGVsaXgodGhpcy5oLCB0aGlzLnMsIHRoaXMubCAqIGssIHRoaXMub3BhY2l0eSk7XG4gIH0sXG4gIHJnYjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGggPSBpc05hTih0aGlzLmgpID8gMCA6ICh0aGlzLmggKyAxMjApICogZGVnMnJhZCxcbiAgICAgICAgbCA9ICt0aGlzLmwsXG4gICAgICAgIGEgPSBpc05hTih0aGlzLnMpID8gMCA6IHRoaXMucyAqIGwgKiAoMSAtIGwpLFxuICAgICAgICBjb3NoID0gTWF0aC5jb3MoaCksXG4gICAgICAgIHNpbmggPSBNYXRoLnNpbihoKTtcbiAgICByZXR1cm4gbmV3IFJnYihcbiAgICAgIDI1NSAqIChsICsgYSAqIChBICogY29zaCArIEIgKiBzaW5oKSksXG4gICAgICAyNTUgKiAobCArIGEgKiAoQyAqIGNvc2ggKyBEICogc2luaCkpLFxuICAgICAgMjU1ICogKGwgKyBhICogKEUgKiBjb3NoKSksXG4gICAgICB0aGlzLm9wYWNpdHlcbiAgICApO1xuICB9XG59KSk7XG5cbmV4cG9ydHMuY29sb3IgPSBjb2xvcjtcbmV4cG9ydHMucmdiID0gcmdiO1xuZXhwb3J0cy5oc2wgPSBoc2w7XG5leHBvcnRzLmxhYiA9IGxhYjtcbmV4cG9ydHMuaGNsID0gaGNsO1xuZXhwb3J0cy5sY2ggPSBsY2g7XG5leHBvcnRzLmdyYXkgPSBncmF5O1xuZXhwb3J0cy5jdWJlaGVsaXggPSBjdWJlaGVsaXg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWNvbnRvdXIvIFZlcnNpb24gMS4yLjAuIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtYXJyYXknKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0FycmF5KSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxudmFyIGFzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufTtcblxudmFyIGFyZWEgPSBmdW5jdGlvbihyaW5nKSB7XG4gIHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuICB3aGlsZSAoKytpIDwgbikgYXJlYSArPSByaW5nW2kgLSAxXVsxXSAqIHJpbmdbaV1bMF0gLSByaW5nW2kgLSAxXVswXSAqIHJpbmdbaV1bMV07XG4gIHJldHVybiBhcmVhO1xufTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbihyaW5nLCBob2xlKSB7XG4gIHZhciBpID0gLTEsIG4gPSBob2xlLmxlbmd0aCwgYztcbiAgd2hpbGUgKCsraSA8IG4pIGlmIChjID0gcmluZ0NvbnRhaW5zKHJpbmcsIGhvbGVbaV0pKSByZXR1cm4gYztcbiAgcmV0dXJuIDA7XG59O1xuXG5mdW5jdGlvbiByaW5nQ29udGFpbnMocmluZywgcG9pbnQpIHtcbiAgdmFyIHggPSBwb2ludFswXSwgeSA9IHBvaW50WzFdLCBjb250YWlucyA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBqID0gbiAtIDE7IGkgPCBuOyBqID0gaSsrKSB7XG4gICAgdmFyIHBpID0gcmluZ1tpXSwgeGkgPSBwaVswXSwgeWkgPSBwaVsxXSwgcGogPSByaW5nW2pdLCB4aiA9IHBqWzBdLCB5aiA9IHBqWzFdO1xuICAgIGlmIChzZWdtZW50Q29udGFpbnMocGksIHBqLCBwb2ludCkpIHJldHVybiAwO1xuICAgIGlmICgoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoKHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKSkpIGNvbnRhaW5zID0gLWNvbnRhaW5zO1xuICB9XG4gIHJldHVybiBjb250YWlucztcbn1cblxuZnVuY3Rpb24gc2VnbWVudENvbnRhaW5zKGEsIGIsIGMpIHtcbiAgdmFyIGk7IHJldHVybiBjb2xsaW5lYXIoYSwgYiwgYykgJiYgd2l0aGluKGFbaSA9ICsoYVswXSA9PT0gYlswXSldLCBjW2ldLCBiW2ldKTtcbn1cblxuZnVuY3Rpb24gY29sbGluZWFyKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pID09PSAoY1swXSAtIGFbMF0pICogKGJbMV0gLSBhWzFdKTtcbn1cblxuZnVuY3Rpb24gd2l0aGluKHAsIHEsIHIpIHtcbiAgcmV0dXJuIHAgPD0gcSAmJiBxIDw9IHIgfHwgciA8PSBxICYmIHEgPD0gcDtcbn1cblxudmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgY2FzZXMgPSBbXG4gIFtdLFxuICBbW1sxLjAsIDEuNV0sIFswLjUsIDEuMF1dXSxcbiAgW1tbMS41LCAxLjBdLCBbMS4wLCAxLjVdXV0sXG4gIFtbWzEuNSwgMS4wXSwgWzAuNSwgMS4wXV1dLFxuICBbW1sxLjAsIDAuNV0sIFsxLjUsIDEuMF1dXSxcbiAgW1tbMS4wLCAxLjVdLCBbMC41LCAxLjBdXSwgW1sxLjAsIDAuNV0sIFsxLjUsIDEuMF1dXSxcbiAgW1tbMS4wLCAwLjVdLCBbMS4wLCAxLjVdXV0sXG4gIFtbWzEuMCwgMC41XSwgWzAuNSwgMS4wXV1dLFxuICBbW1swLjUsIDEuMF0sIFsxLjAsIDAuNV1dXSxcbiAgW1tbMS4wLCAxLjVdLCBbMS4wLCAwLjVdXV0sXG4gIFtbWzAuNSwgMS4wXSwgWzEuMCwgMC41XV0sIFtbMS41LCAxLjBdLCBbMS4wLCAxLjVdXV0sXG4gIFtbWzEuNSwgMS4wXSwgWzEuMCwgMC41XV1dLFxuICBbW1swLjUsIDEuMF0sIFsxLjUsIDEuMF1dXSxcbiAgW1tbMS4wLCAxLjVdLCBbMS41LCAxLjBdXV0sXG4gIFtbWzAuNSwgMS4wXSwgWzEuMCwgMS41XV1dLFxuICBbXVxuXTtcblxudmFyIGNvbnRvdXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkeCA9IDEsXG4gICAgICBkeSA9IDEsXG4gICAgICB0aHJlc2hvbGQgPSBkM0FycmF5LnRocmVzaG9sZFN0dXJnZXMsXG4gICAgICBzbW9vdGggPSBzbW9vdGhMaW5lYXI7XG5cbiAgZnVuY3Rpb24gY29udG91cnModmFsdWVzKSB7XG4gICAgdmFyIHR6ID0gdGhyZXNob2xkKHZhbHVlcyk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHZhciBkb21haW4gPSBkM0FycmF5LmV4dGVudCh2YWx1ZXMpLCBzdGFydCA9IGRvbWFpblswXSwgc3RvcCA9IGRvbWFpblsxXTtcbiAgICAgIHR6ID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgdHopO1xuICAgICAgdHogPSBkM0FycmF5LnJhbmdlKE1hdGguZmxvb3Ioc3RhcnQgLyB0eikgKiB0eiwgTWF0aC5mbG9vcihzdG9wIC8gdHopICogdHosIHR6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHogPSB0ei5zbGljZSgpLnNvcnQoYXNjZW5kaW5nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHoubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29udG91cih2YWx1ZXMsIHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEFjY3VtdWxhdGUsIHNtb290aCBjb250b3VyIHJpbmdzLCBhc3NpZ24gaG9sZXMgdG8gZXh0ZXJpb3IgcmluZ3MuXG4gIC8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9tYm9zdG9jay9zaGFwZWZpbGUvYmxvYi92MC42LjIvc2hwL3BvbHlnb24uanNcbiAgZnVuY3Rpb24gY29udG91cih2YWx1ZXMsIHZhbHVlKSB7XG4gICAgdmFyIHBvbHlnb25zID0gW10sXG4gICAgICAgIGhvbGVzID0gW107XG5cbiAgICBpc29yaW5ncyh2YWx1ZXMsIHZhbHVlLCBmdW5jdGlvbihyaW5nKSB7XG4gICAgICBzbW9vdGgocmluZywgdmFsdWVzLCB2YWx1ZSk7XG4gICAgICBpZiAoYXJlYShyaW5nKSA+IDApIHBvbHlnb25zLnB1c2goW3JpbmddKTtcbiAgICAgIGVsc2UgaG9sZXMucHVzaChyaW5nKTtcbiAgICB9KTtcblxuICAgIGhvbGVzLmZvckVhY2goZnVuY3Rpb24oaG9sZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29ucy5sZW5ndGgsIHBvbHlnb247IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKGNvbnRhaW5zKChwb2x5Z29uID0gcG9seWdvbnNbaV0pWzBdLCBob2xlKSAhPT0gLTEpIHtcbiAgICAgICAgICBwb2x5Z29uLnB1c2goaG9sZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uc1xuICAgIH07XG4gIH1cblxuICAvLyBNYXJjaGluZyBzcXVhcmVzIHdpdGggaXNvbGluZXMgc3RpdGNoZWQgaW50byByaW5ncy5cbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RvcG9qc29uL3RvcG9qc29uLWNsaWVudC9ibG9iL3YzLjAuMC9zcmMvc3RpdGNoLmpzXG4gIGZ1bmN0aW9uIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZyYWdtZW50QnlTdGFydCA9IG5ldyBBcnJheSxcbiAgICAgICAgZnJhZ21lbnRCeUVuZCA9IG5ldyBBcnJheSxcbiAgICAgICAgeCwgeSwgdDAsIHQxLCB0MiwgdDM7XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRoZSBmaXJzdCByb3cgKHkgPSAtMSwgdDIgPSB0MyA9IDApLlxuICAgIHggPSB5ID0gLTE7XG4gICAgdDEgPSB2YWx1ZXNbMF0gPj0gdmFsdWU7XG4gICAgY2FzZXNbdDEgPDwgMV0uZm9yRWFjaChzdGl0Y2gpO1xuICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgIHQwID0gdDEsIHQxID0gdmFsdWVzW3ggKyAxXSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QwIHwgdDEgPDwgMV0uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cbiAgICBjYXNlc1t0MSA8PCAwXS5mb3JFYWNoKHN0aXRjaCk7XG5cbiAgICAvLyBHZW5lcmFsIGNhc2UgZm9yIHRoZSBpbnRlcm1lZGlhdGUgcm93cy5cbiAgICB3aGlsZSAoKyt5IDwgZHkgLSAxKSB7XG4gICAgICB4ID0gLTE7XG4gICAgICB0MSA9IHZhbHVlc1t5ICogZHggKyBkeF0gPj0gdmFsdWU7XG4gICAgICB0MiA9IHZhbHVlc1t5ICogZHhdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDEgPDwgMSB8IHQyIDw8IDJdLmZvckVhY2goc3RpdGNoKTtcbiAgICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgICAgdDAgPSB0MSwgdDEgPSB2YWx1ZXNbeSAqIGR4ICsgZHggKyB4ICsgMV0gPj0gdmFsdWU7XG4gICAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgY2FzZXNbdDAgfCB0MSA8PCAxIHwgdDIgPDwgMiB8IHQzIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICAgIH1cbiAgICAgIGNhc2VzW3QxIHwgdDIgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGxhc3Qgcm93ICh5ID0gZHkgLSAxLCB0MCA9IHQxID0gMCkuXG4gICAgeCA9IC0xO1xuICAgIHQyID0gdmFsdWVzW3kgKiBkeF0gPj0gdmFsdWU7XG4gICAgY2FzZXNbdDIgPDwgMl0uZm9yRWFjaChzdGl0Y2gpO1xuICAgIHdoaWxlICgrK3ggPCBkeCAtIDEpIHtcbiAgICAgIHQzID0gdDIsIHQyID0gdmFsdWVzW3kgKiBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgIGNhc2VzW3QyIDw8IDIgfCB0MyA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuICAgIGNhc2VzW3QyIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIGZ1bmN0aW9uIHN0aXRjaChsaW5lKSB7XG4gICAgICB2YXIgc3RhcnQgPSBbbGluZVswXVswXSArIHgsIGxpbmVbMF1bMV0gKyB5XSxcbiAgICAgICAgICBlbmQgPSBbbGluZVsxXVswXSArIHgsIGxpbmVbMV1bMV0gKyB5XSxcbiAgICAgICAgICBzdGFydEluZGV4ID0gaW5kZXgoc3RhcnQpLFxuICAgICAgICAgIGVuZEluZGV4ID0gaW5kZXgoZW5kKSxcbiAgICAgICAgICBmLCBnO1xuICAgICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0SW5kZXhdKSB7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeVN0YXJ0W2VuZEluZGV4XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdO1xuICAgICAgICAgIGlmIChmID09PSBnKSB7XG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgICAgY2FsbGJhY2soZi5yaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtnLmVuZF0gPSB7c3RhcnQ6IGYuc3RhcnQsIGVuZDogZy5lbmQsIHJpbmc6IGYucmluZy5jb25jYXQoZy5yaW5nKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2YuZW5kXTtcbiAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgIGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRJbmRleF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICAgIGlmIChmID09PSBnKSB7XG4gICAgICAgICAgICBmLnJpbmcucHVzaChlbmQpO1xuICAgICAgICAgICAgY2FsbGJhY2soZi5yaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W2cuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmLmVuZF0gPSB7c3RhcnQ6IGcuc3RhcnQsIGVuZDogZi5lbmQsIHJpbmc6IGcucmluZy5jb25jYXQoZi5yaW5nKX07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICAgICAgZi5yaW5nLnVuc2hpZnQoc3RhcnQpO1xuICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0ID0gc3RhcnRJbmRleF0gPSBmO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbc3RhcnRJbmRleF0gPSBmcmFnbWVudEJ5RW5kW2VuZEluZGV4XSA9IHtzdGFydDogc3RhcnRJbmRleCwgZW5kOiBlbmRJbmRleCwgcmluZzogW3N0YXJ0LCBlbmRdfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRleChwb2ludCkge1xuICAgIHJldHVybiBwb2ludFswXSAqIDIgKyBwb2ludFsxXSAqIChkeCArIDEpICogNDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNtb290aExpbmVhcihyaW5nLCB2YWx1ZXMsIHZhbHVlKSB7XG4gICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICB2YXIgeCA9IHBvaW50WzBdLFxuICAgICAgICAgIHkgPSBwb2ludFsxXSxcbiAgICAgICAgICB4dCA9IHggfCAwLFxuICAgICAgICAgIHl0ID0geSB8IDAsXG4gICAgICAgICAgdjAsXG4gICAgICAgICAgdjEgPSB2YWx1ZXNbeXQgKiBkeCArIHh0XTtcbiAgICAgIGlmICh4ID4gMCAmJiB4IDwgZHggJiYgeHQgPT09IHgpIHtcbiAgICAgICAgdjAgPSB2YWx1ZXNbeXQgKiBkeCArIHh0IC0gMV07XG4gICAgICAgIHBvaW50WzBdID0geCArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID4gMCAmJiB5IDwgZHkgJiYgeXQgPT09IHkpIHtcbiAgICAgICAgdjAgPSB2YWx1ZXNbKHl0IC0gMSkgKiBkeCArIHh0XTtcbiAgICAgICAgcG9pbnRbMV0gPSB5ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29udG91cnMuY29udG91ciA9IGNvbnRvdXI7XG5cbiAgY29udG91cnMuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICB2YXIgXzAgPSBNYXRoLmNlaWwoX1swXSksIF8xID0gTWF0aC5jZWlsKF9bMV0pO1xuICAgIGlmICghKF8wID4gMCkgfHwgIShfMSA+IDApKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNpemVcIik7XG4gICAgcmV0dXJuIGR4ID0gXzAsIGR5ID0gXzEsIGNvbnRvdXJzO1xuICB9O1xuXG4gIGNvbnRvdXJzLnRocmVzaG9sZHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhyZXNob2xkID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBBcnJheS5pc0FycmF5KF8pID8gY29uc3RhbnQoc2xpY2UuY2FsbChfKSkgOiBjb25zdGFudChfKSwgY29udG91cnMpIDogdGhyZXNob2xkO1xuICB9O1xuXG4gIGNvbnRvdXJzLnNtb290aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzbW9vdGggPSBfID8gc21vb3RoTGluZWFyIDogbm9vcCwgY29udG91cnMpIDogc21vb3RoID09PSBzbW9vdGhMaW5lYXI7XG4gIH07XG5cbiAgcmV0dXJuIGNvbnRvdXJzO1xufTtcblxuLy8gVE9ETyBPcHRpbWl6ZSBlZGdlIGNhc2VzLlxuLy8gVE9ETyBPcHRpbWl6ZSBpbmRleCBjYWxjdWxhdGlvbi5cbi8vIFRPRE8gT3B0aW1pemUgYXJndW1lbnRzLlxuZnVuY3Rpb24gYmx1clgoc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgdmFyIG4gPSBzb3VyY2Uud2lkdGgsXG4gICAgICBtID0gc291cmNlLmhlaWdodCxcbiAgICAgIHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHNyID0gMDsgaSA8IG4gKyByOyArK2kpIHtcbiAgICAgIGlmIChpIDwgbikge1xuICAgICAgICBzciArPSBzb3VyY2UuZGF0YVtpICsgaiAqIG5dO1xuICAgICAgfVxuICAgICAgaWYgKGkgPj0gcikge1xuICAgICAgICBpZiAoaSA+PSB3KSB7XG4gICAgICAgICAgc3IgLT0gc291cmNlLmRhdGFbaSAtIHcgKyBqICogbl07XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmRhdGFbaSAtIHIgKyBqICogbl0gPSBzciAvIE1hdGgubWluKGkgKyAxLCBuIC0gMSArIHcgLSBpLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETyBPcHRpbWl6ZSBlZGdlIGNhc2VzLlxuLy8gVE9ETyBPcHRpbWl6ZSBpbmRleCBjYWxjdWxhdGlvbi5cbi8vIFRPRE8gT3B0aW1pemUgYXJndW1lbnRzLlxuZnVuY3Rpb24gYmx1clkoc291cmNlLCB0YXJnZXQsIHIpIHtcbiAgdmFyIG4gPSBzb3VyY2Uud2lkdGgsXG4gICAgICBtID0gc291cmNlLmhlaWdodCxcbiAgICAgIHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIHNyID0gMDsgaiA8IG0gKyByOyArK2opIHtcbiAgICAgIGlmIChqIDwgbSkge1xuICAgICAgICBzciArPSBzb3VyY2UuZGF0YVtpICsgaiAqIG5dO1xuICAgICAgfVxuICAgICAgaWYgKGogPj0gcikge1xuICAgICAgICBpZiAoaiA+PSB3KSB7XG4gICAgICAgICAgc3IgLT0gc291cmNlLmRhdGFbaSArIChqIC0gdykgKiBuXTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQuZGF0YVtpICsgKGogLSByKSAqIG5dID0gc3IgLyBNYXRoLm1pbihqICsgMSwgbSAtIDEgKyB3IC0gaiwgdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRZKGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbnZhciBkZW5zaXR5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB4ID0gZGVmYXVsdFgsXG4gICAgICB5ID0gZGVmYXVsdFksXG4gICAgICBkeCA9IDk2MCxcbiAgICAgIGR5ID0gNTAwLFxuICAgICAgciA9IDIwLCAvLyBibHVyIHJhZGl1c1xuICAgICAgayA9IDIsIC8vIGxvZzIoZ3JpZCBjZWxsIHNpemUpXG4gICAgICBvID0gciAqIDMsIC8vIGdyaWQgb2Zmc2V0LCB0byBwYWQgZm9yIGJsdXJcbiAgICAgIG4gPSAoZHggKyBvICogMikgPj4gaywgLy8gZ3JpZCB3aWR0aFxuICAgICAgbSA9IChkeSArIG8gKiAyKSA+PiBrLCAvLyBncmlkIGhlaWdodFxuICAgICAgdGhyZXNob2xkID0gY29uc3RhbnQoMjApO1xuXG4gIGZ1bmN0aW9uIGRlbnNpdHkoZGF0YSkge1xuICAgIHZhciB2YWx1ZXMwID0gbmV3IEZsb2F0MzJBcnJheShuICogbSksXG4gICAgICAgIHZhbHVlczEgPSBuZXcgRmxvYXQzMkFycmF5KG4gKiBtKTtcblxuICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbihkLCBpLCBkYXRhKSB7XG4gICAgICB2YXIgeGkgPSAoeChkLCBpLCBkYXRhKSArIG8pID4+IGssXG4gICAgICAgICAgeWkgPSAoeShkLCBpLCBkYXRhKSArIG8pID4+IGs7XG4gICAgICBpZiAoeGkgPj0gMCAmJiB4aSA8IG4gJiYgeWkgPj0gMCAmJiB5aSA8IG0pIHtcbiAgICAgICAgKyt2YWx1ZXMwW3hpICsgeWkgKiBuXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRPRE8gT3B0aW1pemUuXG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG4gICAgYmx1clgoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczB9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMX0sIHIgPj4gayk7XG4gICAgYmx1clkoe3dpZHRoOiBuLCBoZWlnaHQ6IG0sIGRhdGE6IHZhbHVlczF9LCB7d2lkdGg6IG4sIGhlaWdodDogbSwgZGF0YTogdmFsdWVzMH0sIHIgPj4gayk7XG5cbiAgICB2YXIgdHogPSB0aHJlc2hvbGQodmFsdWVzMCk7XG5cbiAgICAvLyBDb252ZXJ0IG51bWJlciBvZiB0aHJlc2hvbGRzIGludG8gdW5pZm9ybSB0aHJlc2hvbGRzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eikpIHtcbiAgICAgIHZhciBzdG9wID0gZDNBcnJheS5tYXgodmFsdWVzMCk7XG4gICAgICB0eiA9IGQzQXJyYXkudGlja1N0ZXAoMCwgc3RvcCwgdHopO1xuICAgICAgdHogPSBkM0FycmF5LnJhbmdlKDAsIE1hdGguZmxvb3Ioc3RvcCAvIHR6KSAqIHR6LCB0eik7XG4gICAgICB0ei5zaGlmdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb250b3VycygpXG4gICAgICAgIC50aHJlc2hvbGRzKHR6KVxuICAgICAgICAuc2l6ZShbbiwgbV0pXG4gICAgICAodmFsdWVzMClcbiAgICAgICAgLm1hcCh0cmFuc2Zvcm0pO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtKGdlb21ldHJ5KSB7XG4gICAgZ2VvbWV0cnkudmFsdWUgKj0gTWF0aC5wb3coMiwgLTIgKiBrKTsgLy8gRGVuc2l0eSBpbiBwb2ludHMgcGVyIHNxdWFyZSBwaXhlbC5cbiAgICBnZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvbHlnb24pO1xuICAgIHJldHVybiBnZW9tZXRyeTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zZm9ybVBvbHlnb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVJpbmcpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUmluZyhjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUG9pbnQpO1xuICB9XG5cbiAgLy8gVE9ETyBPcHRpbWl6ZS5cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlc1swXSA9IGNvb3JkaW5hdGVzWzBdICogTWF0aC5wb3coMiwgaykgLSBvO1xuICAgIGNvb3JkaW5hdGVzWzFdID0gY29vcmRpbmF0ZXNbMV0gKiBNYXRoLnBvdygyLCBrKSAtIG87XG4gIH1cblxuICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgbyA9IHIgKiAzO1xuICAgIG4gPSAoZHggKyBvICogMikgPj4gaztcbiAgICBtID0gKGR5ICsgbyAqIDIpID4+IGs7XG4gICAgcmV0dXJuIGRlbnNpdHk7XG4gIH1cblxuICBkZW5zaXR5LnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBkZW5zaXR5KSA6IHg7XG4gIH07XG5cbiAgZGVuc2l0eS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgZGVuc2l0eSkgOiB5O1xuICB9O1xuXG4gIGRlbnNpdHkuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICB2YXIgXzAgPSBNYXRoLmNlaWwoX1swXSksIF8xID0gTWF0aC5jZWlsKF9bMV0pO1xuICAgIGlmICghKF8wID49IDApICYmICEoXzAgPj0gMCkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2l6ZVwiKTtcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgcmVzaXplKCk7XG4gIH07XG5cbiAgZGVuc2l0eS5jZWxsU2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAxIDw8IGs7XG4gICAgaWYgKCEoKF8gPSArXykgPj0gMSkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2VsbCBzaXplXCIpO1xuICAgIHJldHVybiBrID0gTWF0aC5mbG9vcihNYXRoLmxvZyhfKSAvIE1hdGguTE4yKSwgcmVzaXplKCk7XG4gIH07XG5cbiAgZGVuc2l0eS50aHJlc2hvbGRzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRocmVzaG9sZCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogQXJyYXkuaXNBcnJheShfKSA/IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpIDogY29uc3RhbnQoXyksIGRlbnNpdHkpIDogdGhyZXNob2xkO1xuICB9O1xuXG4gIGRlbnNpdHkuYmFuZHdpZHRoID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIE1hdGguc3FydChyICogKHIgKyAxKSk7XG4gICAgaWYgKCEoKF8gPSArXykgPj0gMCkpIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmFuZHdpZHRoXCIpO1xuICAgIHJldHVybiByID0gTWF0aC5yb3VuZCgoTWF0aC5zcXJ0KDQgKiBfICogXyArIDEpIC0gMSkgLyAyKSwgcmVzaXplKCk7XG4gIH07XG5cbiAgcmV0dXJuIGRlbnNpdHk7XG59O1xuXG5leHBvcnRzLmNvbnRvdXJzID0gY29udG91cnM7XG5leHBvcnRzLmNvbnRvdXJEZW5zaXR5ID0gZGVuc2l0eTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZGlzcGF0Y2gvIFZlcnNpb24gMS4wLjMuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIG5vb3AgPSB7dmFsdWU6IGZ1bmN0aW9uKCkge319O1xuXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcmd1bWVudHMubGVuZ3RoLCBfID0ge30sIHQ7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoISh0ID0gYXJndW1lbnRzW2ldICsgXCJcIikgfHwgKHQgaW4gXykpIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgdHlwZTogXCIgKyB0KTtcbiAgICBfW3RdID0gW107XG4gIH1cbiAgcmV0dXJuIG5ldyBEaXNwYXRjaChfKTtcbn1cblxuZnVuY3Rpb24gRGlzcGF0Y2goXykge1xuICB0aGlzLl8gPSBfO1xufVxuXG5mdW5jdGlvbiBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZXMsIHR5cGVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICBpZiAodCAmJiAhdHlwZXMuaGFzT3duUHJvcGVydHkodCkpIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIgKyB0KTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuRGlzcGF0Y2gucHJvdG90eXBlID0gZGlzcGF0Y2gucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogRGlzcGF0Y2gsXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgXyA9IHRoaXMuXyxcbiAgICAgICAgVCA9IHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lICsgXCJcIiwgXyksXG4gICAgICAgIHQsXG4gICAgICAgIGkgPSAtMSxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xuXG4gICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmV0dXJuIHRoZSBjYWxsYmFjayBvZiB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSAmJiAodCA9IGdldChfW3RdLCB0eXBlbmFtZS5uYW1lKSkpIHJldHVybiB0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIGEgdHlwZSB3YXMgc3BlY2lmaWVkLCBzZXQgdGhlIGNhbGxiYWNrIGZvciB0aGUgZ2l2ZW4gdHlwZSBhbmQgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxuICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrOiBcIiArIGNhbGxiYWNrKTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgaWYgKHQgPSAodHlwZW5hbWUgPSBUW2ldKS50eXBlKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIGNhbGxiYWNrKTtcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xuICAgIGZvciAodmFyIHQgaW4gXykgY29weVt0XSA9IF9bdF0uc2xpY2UoKTtcbiAgICByZXR1cm4gbmV3IERpc3BhdGNoKGNvcHkpO1xuICB9LFxuICBjYWxsOiBmdW5jdGlvbih0eXBlLCB0aGF0KSB7XG4gICAgaWYgKChuID0gYXJndW1lbnRzLmxlbmd0aCAtIDIpID4gMCkgZm9yICh2YXIgYXJncyA9IG5ldyBBcnJheShuKSwgaSA9IDAsIG4sIHQ7IGkgPCBuOyArK2kpIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh0ID0gdGhpcy5fW3R5cGVdLCBpID0gMCwgbiA9IHQubGVuZ3RoOyBpIDwgbjsgKytpKSB0W2ldLnZhbHVlLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9LFxuICBhcHBseTogZnVuY3Rpb24odHlwZSwgdGhhdCwgYXJncykge1xuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdHlwZSk7XG4gICAgZm9yICh2YXIgdCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0KHR5cGUsIG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xuICAgIGlmICgoYyA9IHR5cGVbaV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBjLnZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXQodHlwZSwgbmFtZSwgY2FsbGJhY2spIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHR5cGVbaV0gPSBub29wLCB0eXBlID0gdHlwZS5zbGljZSgwLCBpKS5jb25jYXQodHlwZS5zbGljZShpICsgMSkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChjYWxsYmFjayAhPSBudWxsKSB0eXBlLnB1c2goe25hbWU6IG5hbWUsIHZhbHVlOiBjYWxsYmFja30pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuZXhwb3J0cy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1kcmFnLyBWZXJzaW9uIDEuMi4xLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtZGlzcGF0Y2gnLCAnZDMtc2VsZWN0aW9uJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNEaXNwYXRjaCxkM1NlbGVjdGlvbikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vcHJvcGFnYXRpb24oKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufVxuXG52YXIgbm9ldmVudCA9IGZ1bmN0aW9uKCkge1xuICBkM1NlbGVjdGlvbi5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBkM1NlbGVjdGlvbi5ldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbn07XG5cbnZhciBub2RyYWcgPSBmdW5jdGlvbih2aWV3KSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBub2V2ZW50LCB0cnVlKTtcbiAgaWYgKFwib25zZWxlY3RzdGFydFwiIGluIHJvb3QpIHtcbiAgICBzZWxlY3Rpb24ub24oXCJzZWxlY3RzdGFydC5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuX19ub3NlbGVjdCA9IHJvb3Quc3R5bGUuTW96VXNlclNlbGVjdDtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSBcIm5vbmVcIjtcbiAgfVxufTtcblxuZnVuY3Rpb24geWVzZHJhZyh2aWV3LCBub2NsaWNrKSB7XG4gIHZhciByb290ID0gdmlldy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICBzZWxlY3Rpb24gPSBkM1NlbGVjdGlvbi5zZWxlY3Qodmlldykub24oXCJkcmFnc3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgaWYgKG5vY2xpY2spIHtcbiAgICBzZWxlY3Rpb24ub24oXCJjbGljay5kcmFnXCIsIG5vZXZlbnQsIHRydWUpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGVjdGlvbi5vbihcImNsaWNrLmRyYWdcIiwgbnVsbCk7IH0sIDApO1xuICB9XG4gIGlmIChcIm9uc2VsZWN0c3RhcnRcIiBpbiByb290KSB7XG4gICAgc2VsZWN0aW9uLm9uKFwic2VsZWN0c3RhcnQuZHJhZ1wiLCBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICByb290LnN0eWxlLk1velVzZXJTZWxlY3QgPSByb290Ll9fbm9zZWxlY3Q7XG4gICAgZGVsZXRlIHJvb3QuX19ub3NlbGVjdDtcbiAgfVxufVxuXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIERyYWdFdmVudCh0YXJnZXQsIHR5cGUsIHN1YmplY3QsIGlkLCBhY3RpdmUsIHgsIHksIGR4LCBkeSwgZGlzcGF0Y2gkJDEpIHtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc3ViamVjdCA9IHN1YmplY3Q7XG4gIHRoaXMuaWRlbnRpZmllciA9IGlkO1xuICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgdGhpcy54ID0geDtcbiAgdGhpcy55ID0geTtcbiAgdGhpcy5keCA9IGR4O1xuICB0aGlzLmR5ID0gZHk7XG4gIHRoaXMuXyA9IGRpc3BhdGNoJCQxO1xufVxuXG5EcmFnRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2YWx1ZSA9IHRoaXMuXy5vbi5hcHBseSh0aGlzLl8sIGFyZ3VtZW50cyk7XG4gIHJldHVybiB2YWx1ZSA9PT0gdGhpcy5fID8gdGhpcyA6IHZhbHVlO1xufTtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbnRhaW5lcigpIHtcbiAgcmV0dXJuIHRoaXMucGFyZW50Tm9kZTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFN1YmplY3QoZCkge1xuICByZXR1cm4gZCA9PSBudWxsID8ge3g6IGQzU2VsZWN0aW9uLmV2ZW50LngsIHk6IGQzU2VsZWN0aW9uLmV2ZW50Lnl9IDogZDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvdWNoYWJsZSgpIHtcbiAgcmV0dXJuIFwib250b3VjaHN0YXJ0XCIgaW4gdGhpcztcbn1cblxudmFyIGRyYWcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZpbHRlciA9IGRlZmF1bHRGaWx0ZXIsXG4gICAgICBjb250YWluZXIgPSBkZWZhdWx0Q29udGFpbmVyLFxuICAgICAgc3ViamVjdCA9IGRlZmF1bHRTdWJqZWN0LFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIGdlc3R1cmVzID0ge30sXG4gICAgICBsaXN0ZW5lcnMgPSBkM0Rpc3BhdGNoLmRpc3BhdGNoKFwic3RhcnRcIiwgXCJkcmFnXCIsIFwiZW5kXCIpLFxuICAgICAgYWN0aXZlID0gMCxcbiAgICAgIG1vdXNlZG93bngsXG4gICAgICBtb3VzZWRvd255LFxuICAgICAgbW91c2Vtb3ZpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIGNsaWNrRGlzdGFuY2UyID0gMDtcblxuICBmdW5jdGlvbiBkcmFnKHNlbGVjdGlvbikge1xuICAgIHNlbGVjdGlvblxuICAgICAgICAub24oXCJtb3VzZWRvd24uZHJhZ1wiLCBtb3VzZWRvd25lZClcbiAgICAgIC5maWx0ZXIodG91Y2hhYmxlKVxuICAgICAgICAub24oXCJ0b3VjaHN0YXJ0LmRyYWdcIiwgdG91Y2hzdGFydGVkKVxuICAgICAgICAub24oXCJ0b3VjaG1vdmUuZHJhZ1wiLCB0b3VjaG1vdmVkKVxuICAgICAgICAub24oXCJ0b3VjaGVuZC5kcmFnIHRvdWNoY2FuY2VsLmRyYWdcIiwgdG91Y2hlbmRlZClcbiAgICAgICAgLnN0eWxlKFwidG91Y2gtYWN0aW9uXCIsIFwibm9uZVwiKVxuICAgICAgICAuc3R5bGUoXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIiwgXCJyZ2JhKDAsMCwwLDApXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gbW91c2Vkb3duZWQoKSB7XG4gICAgaWYgKHRvdWNoZW5kaW5nIHx8ICFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciBnZXN0dXJlID0gYmVmb3Jlc3RhcnQoXCJtb3VzZVwiLCBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgZDNTZWxlY3Rpb24ubW91c2UsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKCFnZXN0dXJlKSByZXR1cm47XG4gICAgZDNTZWxlY3Rpb24uc2VsZWN0KGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpLm9uKFwibW91c2Vtb3ZlLmRyYWdcIiwgbW91c2Vtb3ZlZCwgdHJ1ZSkub24oXCJtb3VzZXVwLmRyYWdcIiwgbW91c2V1cHBlZCwgdHJ1ZSk7XG4gICAgbm9kcmFnKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcpO1xuICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICBtb3VzZW1vdmluZyA9IGZhbHNlO1xuICAgIG1vdXNlZG93bnggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYO1xuICAgIG1vdXNlZG93bnkgPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRZO1xuICAgIGdlc3R1cmUoXCJzdGFydFwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdXNlbW92ZWQoKSB7XG4gICAgbm9ldmVudCgpO1xuICAgIGlmICghbW91c2Vtb3ZpbmcpIHtcbiAgICAgIHZhciBkeCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFggLSBtb3VzZWRvd254LCBkeSA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFkgLSBtb3VzZWRvd255O1xuICAgICAgbW91c2Vtb3ZpbmcgPSBkeCAqIGR4ICsgZHkgKiBkeSA+IGNsaWNrRGlzdGFuY2UyO1xuICAgIH1cbiAgICBnZXN0dXJlcy5tb3VzZShcImRyYWdcIik7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZXVwcGVkKCkge1xuICAgIGQzU2VsZWN0aW9uLnNlbGVjdChkM1NlbGVjdGlvbi5ldmVudC52aWV3KS5vbihcIm1vdXNlbW92ZS5kcmFnIG1vdXNldXAuZHJhZ1wiLCBudWxsKTtcbiAgICB5ZXNkcmFnKGQzU2VsZWN0aW9uLmV2ZW50LnZpZXcsIG1vdXNlbW92aW5nKTtcbiAgICBub2V2ZW50KCk7XG4gICAgZ2VzdHVyZXMubW91c2UoXCJlbmRcIik7XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaHN0YXJ0ZWQoKSB7XG4gICAgaWYgKCFmaWx0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSkgcmV0dXJuO1xuICAgIHZhciB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIGMgPSBjb250YWluZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBiZWZvcmVzdGFydCh0b3VjaGVzW2ldLmlkZW50aWZpZXIsIGMsIGQzU2VsZWN0aW9uLnRvdWNoLCB0aGlzLCBhcmd1bWVudHMpKSB7XG4gICAgICAgIG5vcHJvcGFnYXRpb24oKTtcbiAgICAgICAgZ2VzdHVyZShcInN0YXJ0XCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNobW92ZWQoKSB7XG4gICAgdmFyIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCBnZXN0dXJlO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKGdlc3R1cmUgPSBnZXN0dXJlc1t0b3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgIG5vZXZlbnQoKTtcbiAgICAgICAgZ2VzdHVyZShcImRyYWdcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdG91Y2hlbmRlZCgpIHtcbiAgICB2YXIgdG91Y2hlcyA9IGQzU2VsZWN0aW9uLmV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICBuID0gdG91Y2hlcy5sZW5ndGgsIGksIGdlc3R1cmU7XG5cbiAgICBpZiAodG91Y2hlbmRpbmcpIGNsZWFyVGltZW91dCh0b3VjaGVuZGluZyk7XG4gICAgdG91Y2hlbmRpbmcgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyB0b3VjaGVuZGluZyA9IG51bGw7IH0sIDUwMCk7IC8vIEdob3N0IGNsaWNrcyBhcmUgZGVsYXllZCFcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoZ2VzdHVyZSA9IGdlc3R1cmVzW3RvdWNoZXNbaV0uaWRlbnRpZmllcl0pIHtcbiAgICAgICAgbm9wcm9wYWdhdGlvbigpO1xuICAgICAgICBnZXN0dXJlKFwiZW5kXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZm9yZXN0YXJ0KGlkLCBjb250YWluZXIsIHBvaW50LCB0aGF0LCBhcmdzKSB7XG4gICAgdmFyIHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgcywgZHgsIGR5LFxuICAgICAgICBzdWJsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29weSgpO1xuXG4gICAgaWYgKCFkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIFwiYmVmb3Jlc3RhcnRcIiwgcywgaWQsIGFjdGl2ZSwgcFswXSwgcFsxXSwgMCwgMCwgc3VibGlzdGVuZXJzKSwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoKGQzU2VsZWN0aW9uLmV2ZW50LnN1YmplY3QgPSBzID0gc3ViamVjdC5hcHBseSh0aGF0LCBhcmdzKSkgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZHggPSBzLnggLSBwWzBdIHx8IDA7XG4gICAgICBkeSA9IHMueSAtIHBbMV0gfHwgMDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pKSByZXR1cm47XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gZ2VzdHVyZSh0eXBlKSB7XG4gICAgICB2YXIgcDAgPSBwLCBuO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdGFydFwiOiBnZXN0dXJlc1tpZF0gPSBnZXN0dXJlLCBuID0gYWN0aXZlKys7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5kXCI6IGRlbGV0ZSBnZXN0dXJlc1tpZF0sIC0tYWN0aXZlOyAvLyBub2JyZWFrXG4gICAgICAgIGNhc2UgXCJkcmFnXCI6IHAgPSBwb2ludChjb250YWluZXIsIGlkKSwgbiA9IGFjdGl2ZTsgYnJlYWs7XG4gICAgICB9XG4gICAgICBkM1NlbGVjdGlvbi5jdXN0b21FdmVudChuZXcgRHJhZ0V2ZW50KGRyYWcsIHR5cGUsIHMsIGlkLCBuLCBwWzBdICsgZHgsIHBbMV0gKyBkeSwgcFswXSAtIHAwWzBdLCBwWzFdIC0gcDBbMV0sIHN1Ymxpc3RlbmVycyksIHN1Ymxpc3RlbmVycy5hcHBseSwgc3VibGlzdGVuZXJzLCBbdHlwZSwgdGhhdCwgYXJnc10pO1xuICAgIH07XG4gIH1cblxuICBkcmFnLmZpbHRlciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmaWx0ZXIgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGRyYWcpIDogZmlsdGVyO1xuICB9O1xuXG4gIGRyYWcuY29udGFpbmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRhaW5lciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoXyksIGRyYWcpIDogY29udGFpbmVyO1xuICB9O1xuXG4gIGRyYWcuc3ViamVjdCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdWJqZWN0ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChfKSwgZHJhZykgOiBzdWJqZWN0O1xuICB9O1xuXG4gIGRyYWcudG91Y2hhYmxlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRvdWNoYWJsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgZHJhZykgOiB0b3VjaGFibGU7XG4gIH07XG5cbiAgZHJhZy5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyBkcmFnIDogdmFsdWU7XG4gIH07XG5cbiAgZHJhZy5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCBkcmFnKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIGRyYWc7XG59O1xuXG5leHBvcnRzLmRyYWcgPSBkcmFnO1xuZXhwb3J0cy5kcmFnRGlzYWJsZSA9IG5vZHJhZztcbmV4cG9ydHMuZHJhZ0VuYWJsZSA9IHllc2RyYWc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWRzdi8gVmVyc2lvbiAxLjAuOC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgRU9MID0ge307XG52YXIgRU9GID0ge307XG52YXIgUVVPVEUgPSAzNDtcbnZhciBORVdMSU5FID0gMTA7XG52YXIgUkVUVVJOID0gMTM7XG5cbmZ1bmN0aW9uIG9iamVjdENvbnZlcnRlcihjb2x1bW5zKSB7XG4gIHJldHVybiBuZXcgRnVuY3Rpb24oXCJkXCIsIFwicmV0dXJuIHtcIiArIGNvbHVtbnMubWFwKGZ1bmN0aW9uKG5hbWUsIGkpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobmFtZSkgKyBcIjogZFtcIiArIGkgKyBcIl1cIjtcbiAgfSkuam9pbihcIixcIikgKyBcIn1cIik7XG59XG5cbmZ1bmN0aW9uIGN1c3RvbUNvbnZlcnRlcihjb2x1bW5zLCBmKSB7XG4gIHZhciBvYmplY3QgPSBvYmplY3RDb252ZXJ0ZXIoY29sdW1ucyk7XG4gIHJldHVybiBmdW5jdGlvbihyb3csIGkpIHtcbiAgICByZXR1cm4gZihvYmplY3Qocm93KSwgaSwgY29sdW1ucyk7XG4gIH07XG59XG5cbi8vIENvbXB1dGUgdW5pcXVlIGNvbHVtbnMgaW4gb3JkZXIgb2YgZGlzY292ZXJ5LlxuZnVuY3Rpb24gaW5mZXJDb2x1bW5zKHJvd3MpIHtcbiAgdmFyIGNvbHVtblNldCA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICBjb2x1bW5zID0gW107XG5cbiAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgIGZvciAodmFyIGNvbHVtbiBpbiByb3cpIHtcbiAgICAgIGlmICghKGNvbHVtbiBpbiBjb2x1bW5TZXQpKSB7XG4gICAgICAgIGNvbHVtbnMucHVzaChjb2x1bW5TZXRbY29sdW1uXSA9IGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29sdW1ucztcbn1cblxudmFyIGRzdiA9IGZ1bmN0aW9uKGRlbGltaXRlcikge1xuICB2YXIgcmVGb3JtYXQgPSBuZXcgUmVnRXhwKFwiW1xcXCJcIiArIGRlbGltaXRlciArIFwiXFxuXFxyXVwiKSxcbiAgICAgIERFTElNSVRFUiA9IGRlbGltaXRlci5jaGFyQ29kZUF0KDApO1xuXG4gIGZ1bmN0aW9uIHBhcnNlKHRleHQsIGYpIHtcbiAgICB2YXIgY29udmVydCwgY29sdW1ucywgcm93cyA9IHBhcnNlUm93cyh0ZXh0LCBmdW5jdGlvbihyb3csIGkpIHtcbiAgICAgIGlmIChjb252ZXJ0KSByZXR1cm4gY29udmVydChyb3csIGkgLSAxKTtcbiAgICAgIGNvbHVtbnMgPSByb3csIGNvbnZlcnQgPSBmID8gY3VzdG9tQ29udmVydGVyKHJvdywgZikgOiBvYmplY3RDb252ZXJ0ZXIocm93KTtcbiAgICB9KTtcbiAgICByb3dzLmNvbHVtbnMgPSBjb2x1bW5zIHx8IFtdO1xuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VSb3dzKHRleHQsIGYpIHtcbiAgICB2YXIgcm93cyA9IFtdLCAvLyBvdXRwdXQgcm93c1xuICAgICAgICBOID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIEkgPSAwLCAvLyBjdXJyZW50IGNoYXJhY3RlciBpbmRleFxuICAgICAgICBuID0gMCwgLy8gY3VycmVudCBsaW5lIG51bWJlclxuICAgICAgICB0LCAvLyBjdXJyZW50IHRva2VuXG4gICAgICAgIGVvZiA9IE4gPD0gMCwgLy8gY3VycmVudCB0b2tlbiBmb2xsb3dlZCBieSBFT0Y/XG4gICAgICAgIGVvbCA9IGZhbHNlOyAvLyBjdXJyZW50IHRva2VuIGZvbGxvd2VkIGJ5IEVPTD9cblxuICAgIC8vIFN0cmlwIHRoZSB0cmFpbGluZyBuZXdsaW5lLlxuICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoTiAtIDEpID09PSBORVdMSU5FKSAtLU47XG4gICAgaWYgKHRleHQuY2hhckNvZGVBdChOIC0gMSkgPT09IFJFVFVSTikgLS1OO1xuXG4gICAgZnVuY3Rpb24gdG9rZW4oKSB7XG4gICAgICBpZiAoZW9mKSByZXR1cm4gRU9GO1xuICAgICAgaWYgKGVvbCkgcmV0dXJuIGVvbCA9IGZhbHNlLCBFT0w7XG5cbiAgICAgIC8vIFVuZXNjYXBlIHF1b3Rlcy5cbiAgICAgIHZhciBpLCBqID0gSSwgYztcbiAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaikgPT09IFFVT1RFKSB7XG4gICAgICAgIHdoaWxlIChJKysgPCBOICYmIHRleHQuY2hhckNvZGVBdChJKSAhPT0gUVVPVEUgfHwgdGV4dC5jaGFyQ29kZUF0KCsrSSkgPT09IFFVT1RFKTtcbiAgICAgICAgaWYgKChpID0gSSkgPj0gTikgZW9mID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoKGMgPSB0ZXh0LmNoYXJDb2RlQXQoSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiArIDEsIGkgLSAxKS5yZXBsYWNlKC9cIlwiL2csIFwiXFxcIlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gRmluZCBuZXh0IGRlbGltaXRlciBvciBuZXdsaW5lLlxuICAgICAgd2hpbGUgKEkgPCBOKSB7XG4gICAgICAgIGlmICgoYyA9IHRleHQuY2hhckNvZGVBdChpID0gSSsrKSkgPT09IE5FV0xJTkUpIGVvbCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGMgPT09IFJFVFVSTikgeyBlb2wgPSB0cnVlOyBpZiAodGV4dC5jaGFyQ29kZUF0KEkpID09PSBORVdMSU5FKSArK0k7IH1cbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gREVMSU1JVEVSKSBjb250aW51ZTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UoaiwgaSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiBsYXN0IHRva2VuIGJlZm9yZSBFT0YuXG4gICAgICByZXR1cm4gZW9mID0gdHJ1ZSwgdGV4dC5zbGljZShqLCBOKTtcbiAgICB9XG5cbiAgICB3aGlsZSAoKHQgPSB0b2tlbigpKSAhPT0gRU9GKSB7XG4gICAgICB2YXIgcm93ID0gW107XG4gICAgICB3aGlsZSAodCAhPT0gRU9MICYmIHQgIT09IEVPRikgcm93LnB1c2godCksIHQgPSB0b2tlbigpO1xuICAgICAgaWYgKGYgJiYgKHJvdyA9IGYocm93LCBuKyspKSA9PSBudWxsKSBjb250aW51ZTtcbiAgICAgIHJvd3MucHVzaChyb3cpO1xuICAgIH1cblxuICAgIHJldHVybiByb3dzO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICBpZiAoY29sdW1ucyA9PSBudWxsKSBjb2x1bW5zID0gaW5mZXJDb2x1bW5zKHJvd3MpO1xuICAgIHJldHVybiBbY29sdW1ucy5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oZGVsaW1pdGVyKV0uY29uY2F0KHJvd3MubWFwKGZ1bmN0aW9uKHJvdykge1xuICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICByZXR1cm4gZm9ybWF0VmFsdWUocm93W2NvbHVtbl0pO1xuICAgICAgfSkuam9pbihkZWxpbWl0ZXIpO1xuICAgIH0pKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0Um93cyhyb3dzKSB7XG4gICAgcmV0dXJuIHJvd3MubWFwKGZvcm1hdFJvdykuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFJvdyhyb3cpIHtcbiAgICByZXR1cm4gcm93Lm1hcChmb3JtYXRWYWx1ZSkuam9pbihkZWxpbWl0ZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VmFsdWUodGV4dCkge1xuICAgIHJldHVybiB0ZXh0ID09IG51bGwgPyBcIlwiXG4gICAgICAgIDogcmVGb3JtYXQudGVzdCh0ZXh0ICs9IFwiXCIpID8gXCJcXFwiXCIgKyB0ZXh0LnJlcGxhY2UoL1wiL2csIFwiXFxcIlxcXCJcIikgKyBcIlxcXCJcIlxuICAgICAgICA6IHRleHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhcnNlOiBwYXJzZSxcbiAgICBwYXJzZVJvd3M6IHBhcnNlUm93cyxcbiAgICBmb3JtYXQ6IGZvcm1hdCxcbiAgICBmb3JtYXRSb3dzOiBmb3JtYXRSb3dzXG4gIH07XG59O1xuXG52YXIgY3N2ID0gZHN2KFwiLFwiKTtcblxudmFyIGNzdlBhcnNlID0gY3N2LnBhcnNlO1xudmFyIGNzdlBhcnNlUm93cyA9IGNzdi5wYXJzZVJvd3M7XG52YXIgY3N2Rm9ybWF0ID0gY3N2LmZvcm1hdDtcbnZhciBjc3ZGb3JtYXRSb3dzID0gY3N2LmZvcm1hdFJvd3M7XG5cbnZhciB0c3YgPSBkc3YoXCJcXHRcIik7XG5cbnZhciB0c3ZQYXJzZSA9IHRzdi5wYXJzZTtcbnZhciB0c3ZQYXJzZVJvd3MgPSB0c3YucGFyc2VSb3dzO1xudmFyIHRzdkZvcm1hdCA9IHRzdi5mb3JtYXQ7XG52YXIgdHN2Rm9ybWF0Um93cyA9IHRzdi5mb3JtYXRSb3dzO1xuXG5leHBvcnRzLmRzdkZvcm1hdCA9IGRzdjtcbmV4cG9ydHMuY3N2UGFyc2UgPSBjc3ZQYXJzZTtcbmV4cG9ydHMuY3N2UGFyc2VSb3dzID0gY3N2UGFyc2VSb3dzO1xuZXhwb3J0cy5jc3ZGb3JtYXQgPSBjc3ZGb3JtYXQ7XG5leHBvcnRzLmNzdkZvcm1hdFJvd3MgPSBjc3ZGb3JtYXRSb3dzO1xuZXhwb3J0cy50c3ZQYXJzZSA9IHRzdlBhcnNlO1xuZXhwb3J0cy50c3ZQYXJzZVJvd3MgPSB0c3ZQYXJzZVJvd3M7XG5leHBvcnRzLnRzdkZvcm1hdCA9IHRzdkZvcm1hdDtcbmV4cG9ydHMudHN2Rm9ybWF0Um93cyA9IHRzdkZvcm1hdFJvd3M7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWVhc2UvIFZlcnNpb24gMS4wLjMuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbGluZWFyKHQpIHtcbiAgcmV0dXJuICt0O1xufVxuXG5mdW5jdGlvbiBxdWFkSW4odCkge1xuICByZXR1cm4gdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIHF1YWRPdXQodCkge1xuICByZXR1cm4gdCAqICgyIC0gdCk7XG59XG5cbmZ1bmN0aW9uIHF1YWRJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0IDogLS10ICogKDIgLSB0KSArIDEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbih0KSB7XG4gIHJldHVybiB0ICogdCAqIHQ7XG59XG5cbmZ1bmN0aW9uIGN1YmljT3V0KHQpIHtcbiAgcmV0dXJuIC0tdCAqIHQgKiB0ICsgMTtcbn1cblxuZnVuY3Rpb24gY3ViaWNJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IHQgKiB0ICogdCA6ICh0IC09IDIpICogdCAqIHQgKyAyKSAvIDI7XG59XG5cbnZhciBleHBvbmVudCA9IDM7XG5cbnZhciBwb2x5SW4gPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KHQsIGUpO1xuICB9XG5cbiAgcG9seUluLmV4cG9uZW50ID0gY3VzdG9tO1xuXG4gIHJldHVybiBwb2x5SW47XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5T3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShlKSB7XG4gIGUgPSArZTtcblxuICBmdW5jdGlvbiBwb2x5T3V0KHQpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSB0LCBlKTtcbiAgfVxuXG4gIHBvbHlPdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlPdXQ7XG59KShleHBvbmVudCk7XG5cbnZhciBwb2x5SW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGUpIHtcbiAgZSA9ICtlO1xuXG4gIGZ1bmN0aW9uIHBvbHlJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8PSAxID8gTWF0aC5wb3codCwgZSkgOiAyIC0gTWF0aC5wb3coMiAtIHQsIGUpKSAvIDI7XG4gIH1cblxuICBwb2x5SW5PdXQuZXhwb25lbnQgPSBjdXN0b207XG5cbiAgcmV0dXJuIHBvbHlJbk91dDtcbn0pKGV4cG9uZW50KTtcblxudmFyIHBpID0gTWF0aC5QSTtcbnZhciBoYWxmUGkgPSBwaSAvIDI7XG5cbmZ1bmN0aW9uIHNpbkluKHQpIHtcbiAgcmV0dXJuIDEgLSBNYXRoLmNvcyh0ICogaGFsZlBpKTtcbn1cblxuZnVuY3Rpb24gc2luT3V0KHQpIHtcbiAgcmV0dXJuIE1hdGguc2luKHQgKiBoYWxmUGkpO1xufVxuXG5mdW5jdGlvbiBzaW5Jbk91dCh0KSB7XG4gIHJldHVybiAoMSAtIE1hdGguY29zKHBpICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gZXhwSW4odCkge1xuICByZXR1cm4gTWF0aC5wb3coMiwgMTAgKiB0IC0gMTApO1xufVxuXG5mdW5jdGlvbiBleHBPdXQodCkge1xuICByZXR1cm4gMSAtIE1hdGgucG93KDIsIC0xMCAqIHQpO1xufVxuXG5mdW5jdGlvbiBleHBJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IE1hdGgucG93KDIsIDEwICogdCAtIDEwKSA6IDIgLSBNYXRoLnBvdygyLCAxMCAtIDEwICogdCkpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW4odCkge1xuICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gdCAqIHQpO1xufVxuXG5mdW5jdGlvbiBjaXJjbGVPdXQodCkge1xuICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLXQgKiB0KTtcbn1cblxuZnVuY3Rpb24gY2lyY2xlSW5PdXQodCkge1xuICByZXR1cm4gKCh0ICo9IDIpIDw9IDEgPyAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCkgOiBNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSAvIDI7XG59XG5cbnZhciBiMSA9IDQgLyAxMTtcbnZhciBiMiA9IDYgLyAxMTtcbnZhciBiMyA9IDggLyAxMTtcbnZhciBiNCA9IDMgLyA0O1xudmFyIGI1ID0gOSAvIDExO1xudmFyIGI2ID0gMTAgLyAxMTtcbnZhciBiNyA9IDE1IC8gMTY7XG52YXIgYjggPSAyMSAvIDIyO1xudmFyIGI5ID0gNjMgLyA2NDtcbnZhciBiMCA9IDEgLyBiMSAvIGIxO1xuXG5mdW5jdGlvbiBib3VuY2VJbih0KSB7XG4gIHJldHVybiAxIC0gYm91bmNlT3V0KDEgLSB0KTtcbn1cblxuZnVuY3Rpb24gYm91bmNlT3V0KHQpIHtcbiAgcmV0dXJuICh0ID0gK3QpIDwgYjEgPyBiMCAqIHQgKiB0IDogdCA8IGIzID8gYjAgKiAodCAtPSBiMikgKiB0ICsgYjQgOiB0IDwgYjYgPyBiMCAqICh0IC09IGI1KSAqIHQgKyBiNyA6IGIwICogKHQgLT0gYjgpICogdCArIGI5O1xufVxuXG5mdW5jdGlvbiBib3VuY2VJbk91dCh0KSB7XG4gIHJldHVybiAoKHQgKj0gMikgPD0gMSA/IDEgLSBib3VuY2VPdXQoMSAtIHQpIDogYm91bmNlT3V0KHQgLSAxKSArIDEpIC8gMjtcbn1cblxudmFyIG92ZXJzaG9vdCA9IDEuNzAxNTg7XG5cbnZhciBiYWNrSW4gPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbih0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogKChzICsgMSkgKiB0IC0gcyk7XG4gIH1cblxuICBiYWNrSW4ub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW47XG59KShvdmVyc2hvb3QpO1xuXG52YXIgYmFja091dCA9IChmdW5jdGlvbiBjdXN0b20ocykge1xuICBzID0gK3M7XG5cbiAgZnVuY3Rpb24gYmFja091dCh0KSB7XG4gICAgcmV0dXJuIC0tdCAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH1cblxuICBiYWNrT3V0Lm92ZXJzaG9vdCA9IGN1c3RvbTtcblxuICByZXR1cm4gYmFja091dDtcbn0pKG92ZXJzaG9vdCk7XG5cbnZhciBiYWNrSW5PdXQgPSAoZnVuY3Rpb24gY3VzdG9tKHMpIHtcbiAgcyA9ICtzO1xuXG4gIGZ1bmN0aW9uIGJhY2tJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCAqPSAyKSA8IDEgPyB0ICogdCAqICgocyArIDEpICogdCAtIHMpIDogKHQgLT0gMikgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAyKSAvIDI7XG4gIH1cblxuICBiYWNrSW5PdXQub3ZlcnNob290ID0gY3VzdG9tO1xuXG4gIHJldHVybiBiYWNrSW5PdXQ7XG59KShvdmVyc2hvb3QpO1xuXG52YXIgdGF1ID0gMiAqIE1hdGguUEk7XG52YXIgYW1wbGl0dWRlID0gMTtcbnZhciBwZXJpb2QgPSAwLjM7XG5cbnZhciBlbGFzdGljSW4gPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY0luKHQpIHtcbiAgICByZXR1cm4gYSAqIE1hdGgucG93KDIsIDEwICogLS10KSAqIE1hdGguc2luKChzIC0gdCkgLyBwKTtcbiAgfVxuXG4gIGVsYXN0aWNJbi5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNJbi5wZXJpb2QgPSBmdW5jdGlvbihwKSB7IHJldHVybiBjdXN0b20oYSwgcCk7IH07XG5cbiAgcmV0dXJuIGVsYXN0aWNJbjtcbn0pKGFtcGxpdHVkZSwgcGVyaW9kKTtcblxudmFyIGVsYXN0aWNPdXQgPSAoZnVuY3Rpb24gY3VzdG9tKGEsIHApIHtcbiAgdmFyIHMgPSBNYXRoLmFzaW4oMSAvIChhID0gTWF0aC5tYXgoMSwgYSkpKSAqIChwIC89IHRhdSk7XG5cbiAgZnVuY3Rpb24gZWxhc3RpY091dCh0KSB7XG4gICAgcmV0dXJuIDEgLSBhICogTWF0aC5wb3coMiwgLTEwICogKHQgPSArdCkpICogTWF0aC5zaW4oKHQgKyBzKSAvIHApO1xuICB9XG5cbiAgZWxhc3RpY091dC5hbXBsaXR1ZGUgPSBmdW5jdGlvbihhKSB7IHJldHVybiBjdXN0b20oYSwgcCAqIHRhdSk7IH07XG4gIGVsYXN0aWNPdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljT3V0O1xufSkoYW1wbGl0dWRlLCBwZXJpb2QpO1xuXG52YXIgZWxhc3RpY0luT3V0ID0gKGZ1bmN0aW9uIGN1c3RvbShhLCBwKSB7XG4gIHZhciBzID0gTWF0aC5hc2luKDEgLyAoYSA9IE1hdGgubWF4KDEsIGEpKSkgKiAocCAvPSB0YXUpO1xuXG4gIGZ1bmN0aW9uIGVsYXN0aWNJbk91dCh0KSB7XG4gICAgcmV0dXJuICgodCA9IHQgKiAyIC0gMSkgPCAwXG4gICAgICAgID8gYSAqIE1hdGgucG93KDIsIDEwICogdCkgKiBNYXRoLnNpbigocyAtIHQpIC8gcClcbiAgICAgICAgOiAyIC0gYSAqIE1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHMgKyB0KSAvIHApKSAvIDI7XG4gIH1cblxuICBlbGFzdGljSW5PdXQuYW1wbGl0dWRlID0gZnVuY3Rpb24oYSkgeyByZXR1cm4gY3VzdG9tKGEsIHAgKiB0YXUpOyB9O1xuICBlbGFzdGljSW5PdXQucGVyaW9kID0gZnVuY3Rpb24ocCkgeyByZXR1cm4gY3VzdG9tKGEsIHApOyB9O1xuXG4gIHJldHVybiBlbGFzdGljSW5PdXQ7XG59KShhbXBsaXR1ZGUsIHBlcmlvZCk7XG5cbmV4cG9ydHMuZWFzZUxpbmVhciA9IGxpbmVhcjtcbmV4cG9ydHMuZWFzZVF1YWQgPSBxdWFkSW5PdXQ7XG5leHBvcnRzLmVhc2VRdWFkSW4gPSBxdWFkSW47XG5leHBvcnRzLmVhc2VRdWFkT3V0ID0gcXVhZE91dDtcbmV4cG9ydHMuZWFzZVF1YWRJbk91dCA9IHF1YWRJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljID0gY3ViaWNJbk91dDtcbmV4cG9ydHMuZWFzZUN1YmljSW4gPSBjdWJpY0luO1xuZXhwb3J0cy5lYXNlQ3ViaWNPdXQgPSBjdWJpY091dDtcbmV4cG9ydHMuZWFzZUN1YmljSW5PdXQgPSBjdWJpY0luT3V0O1xuZXhwb3J0cy5lYXNlUG9seSA9IHBvbHlJbk91dDtcbmV4cG9ydHMuZWFzZVBvbHlJbiA9IHBvbHlJbjtcbmV4cG9ydHMuZWFzZVBvbHlPdXQgPSBwb2x5T3V0O1xuZXhwb3J0cy5lYXNlUG9seUluT3V0ID0gcG9seUluT3V0O1xuZXhwb3J0cy5lYXNlU2luID0gc2luSW5PdXQ7XG5leHBvcnRzLmVhc2VTaW5JbiA9IHNpbkluO1xuZXhwb3J0cy5lYXNlU2luT3V0ID0gc2luT3V0O1xuZXhwb3J0cy5lYXNlU2luSW5PdXQgPSBzaW5Jbk91dDtcbmV4cG9ydHMuZWFzZUV4cCA9IGV4cEluT3V0O1xuZXhwb3J0cy5lYXNlRXhwSW4gPSBleHBJbjtcbmV4cG9ydHMuZWFzZUV4cE91dCA9IGV4cE91dDtcbmV4cG9ydHMuZWFzZUV4cEluT3V0ID0gZXhwSW5PdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGUgPSBjaXJjbGVJbk91dDtcbmV4cG9ydHMuZWFzZUNpcmNsZUluID0gY2lyY2xlSW47XG5leHBvcnRzLmVhc2VDaXJjbGVPdXQgPSBjaXJjbGVPdXQ7XG5leHBvcnRzLmVhc2VDaXJjbGVJbk91dCA9IGNpcmNsZUluT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlID0gYm91bmNlT3V0O1xuZXhwb3J0cy5lYXNlQm91bmNlSW4gPSBib3VuY2VJbjtcbmV4cG9ydHMuZWFzZUJvdW5jZU91dCA9IGJvdW5jZU91dDtcbmV4cG9ydHMuZWFzZUJvdW5jZUluT3V0ID0gYm91bmNlSW5PdXQ7XG5leHBvcnRzLmVhc2VCYWNrID0gYmFja0luT3V0O1xuZXhwb3J0cy5lYXNlQmFja0luID0gYmFja0luO1xuZXhwb3J0cy5lYXNlQmFja091dCA9IGJhY2tPdXQ7XG5leHBvcnRzLmVhc2VCYWNrSW5PdXQgPSBiYWNrSW5PdXQ7XG5leHBvcnRzLmVhc2VFbGFzdGljID0gZWxhc3RpY091dDtcbmV4cG9ydHMuZWFzZUVsYXN0aWNJbiA9IGVsYXN0aWNJbjtcbmV4cG9ydHMuZWFzZUVsYXN0aWNPdXQgPSBlbGFzdGljT3V0O1xuZXhwb3J0cy5lYXNlRWxhc3RpY0luT3V0ID0gZWxhc3RpY0luT3V0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mZXRjaC8gVmVyc2lvbiAxLjEuMC4gQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kc3YnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWRzdiddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNEc3YpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNwb25zZUJsb2IocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG59XG5cbmZ1bmN0aW9uIGJsb2IoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlQmxvYik7XG59XG5cbmZ1bmN0aW9uIHJlc3BvbnNlQXJyYXlCdWZmZXIocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xufVxuXG5mdW5jdGlvbiBidWZmZXIoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlQXJyYXlCdWZmZXIpO1xufVxuXG5mdW5jdGlvbiByZXNwb25zZVRleHQocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG59XG5cbmZ1bmN0aW9uIHRleHQoaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlVGV4dCk7XG59XG5cbmZ1bmN0aW9uIGRzdlBhcnNlKHBhcnNlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCwgcm93KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGluaXQgPT09IFwiZnVuY3Rpb25cIikgcm93ID0gaW5pdCwgaW5pdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgcmV0dXJuIHBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkc3YoZGVsaW1pdGVyLCBpbnB1dCwgaW5pdCwgcm93KSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzICYmIHR5cGVvZiBpbml0ID09PSBcImZ1bmN0aW9uXCIpIHJvdyA9IGluaXQsIGluaXQgPSB1bmRlZmluZWQ7XG4gIHZhciBmb3JtYXQgPSBkM0Rzdi5kc3ZGb3JtYXQoZGVsaW1pdGVyKTtcbiAgcmV0dXJuIHRleHQoaW5wdXQsIGluaXQpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gZm9ybWF0LnBhcnNlKHJlc3BvbnNlLCByb3cpO1xuICB9KTtcbn1cblxudmFyIGNzdiA9IGRzdlBhcnNlKGQzRHN2LmNzdlBhcnNlKTtcbnZhciB0c3YgPSBkc3ZQYXJzZShkM0Rzdi50c3ZQYXJzZSk7XG5cbmZ1bmN0aW9uIGltYWdlKGlucHV0LCBpbml0KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2U7XG4gICAgZm9yICh2YXIga2V5IGluIGluaXQpIGltYWdlW2tleV0gPSBpbml0W2tleV07XG4gICAgaW1hZ2Uub25lcnJvciA9IHJlamVjdDtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHsgcmVzb2x2ZShpbWFnZSk7IH07XG4gICAgaW1hZ2Uuc3JjID0gaW5wdXQ7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNwb25zZUpzb24ocmVzcG9uc2UpIHtcbiAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG5cbmZ1bmN0aW9uIGpzb24oaW5wdXQsIGluaXQpIHtcbiAgcmV0dXJuIGZldGNoKGlucHV0LCBpbml0KS50aGVuKHJlc3BvbnNlSnNvbik7XG59XG5cbmZ1bmN0aW9uIHBhcnNlcih0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihpbnB1dCwgaW5pdCkgIHtcbiAgICByZXR1cm4gdGV4dChpbnB1dCwgaW5pdCkudGhlbihmdW5jdGlvbih0ZXh0JCQxKSB7XG4gICAgICByZXR1cm4gKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyh0ZXh0JCQxLCB0eXBlKTtcbiAgICB9KTtcbiAgfTtcbn1cblxudmFyIHhtbCA9IHBhcnNlcihcImFwcGxpY2F0aW9uL3htbFwiKTtcblxudmFyIGh0bWwgPSBwYXJzZXIoXCJ0ZXh0L2h0bWxcIik7XG5cbnZhciBzdmcgPSBwYXJzZXIoXCJpbWFnZS9zdmcreG1sXCIpO1xuXG5leHBvcnRzLmJsb2IgPSBibG9iO1xuZXhwb3J0cy5idWZmZXIgPSBidWZmZXI7XG5leHBvcnRzLmRzdiA9IGRzdjtcbmV4cG9ydHMuY3N2ID0gY3N2O1xuZXhwb3J0cy50c3YgPSB0c3Y7XG5leHBvcnRzLmltYWdlID0gaW1hZ2U7XG5leHBvcnRzLmpzb24gPSBqc29uO1xuZXhwb3J0cy50ZXh0ID0gdGV4dDtcbmV4cG9ydHMueG1sID0geG1sO1xuZXhwb3J0cy5odG1sID0gaHRtbDtcbmV4cG9ydHMuc3ZnID0gc3ZnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mb3JjZS8gVmVyc2lvbiAxLjEuMC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1xdWFkdHJlZScpLCByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyksIHJlcXVpcmUoJ2QzLWRpc3BhdGNoJyksIHJlcXVpcmUoJ2QzLXRpbWVyJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1xdWFkdHJlZScsICdkMy1jb2xsZWN0aW9uJywgJ2QzLWRpc3BhdGNoJywgJ2QzLXRpbWVyJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1F1YWR0cmVlLGQzQ29sbGVjdGlvbixkM0Rpc3BhdGNoLGQzVGltZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2VudGVyID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbm9kZXM7XG5cbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlLFxuICAgICAgICBzeCA9IDAsXG4gICAgICAgIHN5ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgc3ggKz0gbm9kZS54LCBzeSArPSBub2RlLnk7XG4gICAgfVxuXG4gICAgZm9yIChzeCA9IHN4IC8gbiAtIHgsIHN5ID0gc3kgLyBuIC0geSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgamlnZ2xlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxZS02O1xufTtcblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLnggKyBkLnZ4O1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueSArIGQudnk7XG59XG5cbnZhciBjb2xsaWRlID0gZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIHJhZGlpLFxuICAgICAgc3RyZW5ndGggPSAxLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQocmFkaXVzID09IG51bGwgPyAxIDogK3JhZGl1cyk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoKSB7XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIHRyZWUsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIHhpLFxuICAgICAgICB5aSxcbiAgICAgICAgcmksXG4gICAgICAgIHJpMjtcblxuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgaXRlcmF0aW9uczsgKytrKSB7XG4gICAgICB0cmVlID0gZDNRdWFkdHJlZS5xdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUoKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKCksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59O1xuXG5mdW5jdGlvbiBpbmRleChkKSB7XG4gIHJldHVybiBkLmluZGV4O1xufVxuXG5mdW5jdGlvbiBmaW5kKG5vZGVCeUlkLCBub2RlSWQpIHtcbiAgdmFyIG5vZGUgPSBub2RlQnlJZC5nZXQobm9kZUlkKTtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nOiBcIiArIG5vZGVJZCk7XG4gIHJldHVybiBub2RlO1xufVxuXG52YXIgbGluayA9IGZ1bmN0aW9uKGxpbmtzKSB7XG4gIHZhciBpZCA9IGluZGV4LFxuICAgICAgc3RyZW5ndGggPSBkZWZhdWx0U3RyZW5ndGgsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICBkaXN0YW5jZSA9IGNvbnN0YW50KDMwKSxcbiAgICAgIGRpc3RhbmNlcyxcbiAgICAgIG5vZGVzLFxuICAgICAgY291bnQsXG4gICAgICBiaWFzLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0cmVuZ3RoKGxpbmspIHtcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgayA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5rLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgbCwgYjsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgeCA9IHRhcmdldC54ICsgdGFyZ2V0LnZ4IC0gc291cmNlLnggLSBzb3VyY2UudnggfHwgamlnZ2xlKCk7XG4gICAgICAgIHkgPSB0YXJnZXQueSArIHRhcmdldC52eSAtIHNvdXJjZS55IC0gc291cmNlLnZ5IHx8IGppZ2dsZSgpO1xuICAgICAgICBsID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICBsID0gKGwgLSBkaXN0YW5jZXNbaV0pIC8gbCAqIGFscGhhICogc3RyZW5ndGhzW2ldO1xuICAgICAgICB4ICo9IGwsIHkgKj0gbDtcbiAgICAgICAgdGFyZ2V0LnZ4IC09IHggKiAoYiA9IGJpYXNbaV0pO1xuICAgICAgICB0YXJnZXQudnkgLT0geSAqIGI7XG4gICAgICAgIHNvdXJjZS52eCArPSB4ICogKGIgPSAxIC0gYik7XG4gICAgICAgIHNvdXJjZS52eSArPSB5ICogYjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBtID0gbGlua3MubGVuZ3RoLFxuICAgICAgICBub2RlQnlJZCA9IGQzQ29sbGVjdGlvbi5tYXAobm9kZXMsIGlkKSxcbiAgICAgICAgbGluaztcblxuICAgIGZvciAoaSA9IDAsIGNvdW50ID0gbmV3IEFycmF5KG4pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGxpbmsuaW5kZXggPSBpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnNvdXJjZSAhPT0gXCJvYmplY3RcIikgbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnNvdXJjZSk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsudGFyZ2V0ICE9PSBcIm9iamVjdFwiKSBsaW5rLnRhcmdldCA9IGZpbmQobm9kZUJ5SWQsIGxpbmsudGFyZ2V0KTtcbiAgICAgIGNvdW50W2xpbmsuc291cmNlLmluZGV4XSA9IChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gfHwgMCkgKyAxO1xuICAgICAgY291bnRbbGluay50YXJnZXQuaW5kZXhdID0gKGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgYmlhcyA9IG5ldyBBcnJheShtKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBiaWFzW2ldID0gY291bnRbbGluay5zb3VyY2UuaW5kZXhdIC8gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSArIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSk7XG4gICAgfVxuXG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplU3RyZW5ndGgoKTtcbiAgICBkaXN0YW5jZXMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVEaXN0YW5jZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0cmVuZ3RoKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSArc3RyZW5ndGgobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRGlzdGFuY2UoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGRpc3RhbmNlc1tpXSA9ICtkaXN0YW5jZShsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5saW5rcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsaW5rcyA9IF8sIGluaXRpYWxpemUoKSwgZm9yY2UpIDogbGlua3M7XG4gIH07XG5cbiAgZm9yY2UuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSBfLCBmb3JjZSkgOiBpZDtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplU3RyZW5ndGgoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2UgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCksIGZvcmNlKSA6IGRpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn07XG5cbmZ1bmN0aW9uIHgkMShkKSB7XG4gIHJldHVybiBkLng7XG59XG5cbmZ1bmN0aW9uIHkkMShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5cbnZhciBpbml0aWFsUmFkaXVzID0gMTA7XG52YXIgaW5pdGlhbEFuZ2xlID0gTWF0aC5QSSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcblxudmFyIHNpbXVsYXRpb24gPSBmdW5jdGlvbihub2Rlcykge1xuICB2YXIgc2ltdWxhdGlvbixcbiAgICAgIGFscGhhID0gMSxcbiAgICAgIGFscGhhTWluID0gMC4wMDEsXG4gICAgICBhbHBoYURlY2F5ID0gMSAtIE1hdGgucG93KGFscGhhTWluLCAxIC8gMzAwKSxcbiAgICAgIGFscGhhVGFyZ2V0ID0gMCxcbiAgICAgIHZlbG9jaXR5RGVjYXkgPSAwLjYsXG4gICAgICBmb3JjZXMgPSBkM0NvbGxlY3Rpb24ubWFwKCksXG4gICAgICBzdGVwcGVyID0gZDNUaW1lci50aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInRpY2tcIiwgXCJlbmRcIik7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKCkge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuXG4gICAgYWxwaGEgKz0gKGFscGhhVGFyZ2V0IC0gYWxwaGEpICogYWxwaGFEZWNheTtcblxuICAgIGZvcmNlcy5lYWNoKGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICBmb3JjZShhbHBoYSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAobm9kZS5meCA9PSBudWxsKSBub2RlLnggKz0gbm9kZS52eCAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgZWxzZSBub2RlLnggPSBub2RlLmZ4LCBub2RlLnZ4ID0gMDtcbiAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICBlbHNlIG5vZGUueSA9IG5vZGUuZnksIG5vZGUudnkgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IGlzTmFOKG5vZGUueSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiBNYXRoLnNxcnQoaSksIGFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZTtcbiAgICAgICAgbm9kZS54ID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBub2RlLnkgPSByYWRpdXMgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOYU4obm9kZS52eCkgfHwgaXNOYU4obm9kZS52eSkpIHtcbiAgICAgICAgbm9kZS52eCA9IG5vZGUudnkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzKTtcbiAgICByZXR1cm4gZm9yY2U7XG4gIH1cblxuICBpbml0aWFsaXplTm9kZXMoKTtcblxuICByZXR1cm4gc2ltdWxhdGlvbiA9IHtcbiAgICB0aWNrOiB0aWNrLFxuXG4gICAgcmVzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5yZXN0YXJ0KHN0ZXApLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnN0b3AoKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gXywgaW5pdGlhbGl6ZU5vZGVzKCksIGZvcmNlcy5lYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogbm9kZXM7XG4gICAgfSxcblxuICAgIGFscGhhOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhO1xuICAgIH0sXG5cbiAgICBhbHBoYU1pbjogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcbiAgICB9LFxuXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFEZWNheSA9ICtfLCBzaW11bGF0aW9uKSA6ICthbHBoYURlY2F5O1xuICAgIH0sXG5cbiAgICBhbHBoYVRhcmdldDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFUYXJnZXQgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYVRhcmdldDtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHlEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xuICAgIH0sXG5cbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKChfID09IG51bGwgPyBmb3JjZXMucmVtb3ZlKG5hbWUpIDogZm9yY2VzLnNldChuYW1lLCBpbml0aWFsaXplRm9yY2UoXykpKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbih4LCB5LCByYWRpdXMpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGR4LFxuICAgICAgICAgIGR5LFxuICAgICAgICAgIGQyLFxuICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgY2xvc2VzdDtcblxuICAgICAgaWYgKHJhZGl1cyA9PSBudWxsKSByYWRpdXMgPSBJbmZpbml0eTtcbiAgICAgIGVsc2UgcmFkaXVzICo9IHJhZGl1cztcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGR4ID0geCAtIG5vZGUueDtcbiAgICAgICAgZHkgPSB5IC0gbm9kZS55O1xuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICBpZiAoZDIgPCByYWRpdXMpIGNsb3Nlc3QgPSBub2RlLCByYWRpdXMgPSBkMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb3Nlc3Q7XG4gICAgfSxcblxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAoZXZlbnQub24obmFtZSwgXyksIHNpbXVsYXRpb24pIDogZXZlbnQub24obmFtZSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIG1hbnlCb2R5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIG5vZGUsXG4gICAgICBhbHBoYSxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoLTMwKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlTWluMiA9IDEsXG4gICAgICBkaXN0YW5jZU1heDIgPSBJbmZpbml0eSxcbiAgICAgIHRoZXRhMiA9IDAuODE7XG5cbiAgZnVuY3Rpb24gZm9yY2UoXykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCB0cmVlID0gZDNRdWFkdHJlZS5xdWFkdHJlZShub2RlcywgeCQxLCB5JDEpLnZpc2l0QWZ0ZXIoYWNjdW11bGF0ZSk7XG4gICAgZm9yIChhbHBoYSA9IF8sIGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHRyZWUudmlzaXQoYXBwbHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgc3RyZW5ndGhzW25vZGUuaW5kZXhdID0gK3N0cmVuZ3RoKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGUocXVhZCkge1xuICAgIHZhciBzdHJlbmd0aCA9IDAsIHEsIGMsIHdlaWdodCA9IDAsIHgsIHksIGk7XG5cbiAgICAvLyBGb3IgaW50ZXJuYWwgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY2hpbGQgcXVhZHJhbnRzLlxuICAgIGlmIChxdWFkLmxlbmd0aCkge1xuICAgICAgZm9yICh4ID0geSA9IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIGlmICgocSA9IHF1YWRbaV0pICYmIChjID0gTWF0aC5hYnMocS52YWx1ZSkpKSB7XG4gICAgICAgICAgc3RyZW5ndGggKz0gcS52YWx1ZSwgd2VpZ2h0ICs9IGMsIHggKz0gYyAqIHEueCwgeSArPSBjICogcS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWFkLnggPSB4IC8gd2VpZ2h0O1xuICAgICAgcXVhZC55ID0geSAvIHdlaWdodDtcbiAgICB9XG5cbiAgICAvLyBGb3IgbGVhZiBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjb2luY2lkZW50IHF1YWRyYW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHEgPSBxdWFkO1xuICAgICAgcS54ID0gcS5kYXRhLng7XG4gICAgICBxLnkgPSBxLmRhdGEueTtcbiAgICAgIGRvIHN0cmVuZ3RoICs9IHN0cmVuZ3Roc1txLmRhdGEuaW5kZXhdO1xuICAgICAgd2hpbGUgKHEgPSBxLm5leHQpO1xuICAgIH1cblxuICAgIHF1YWQudmFsdWUgPSBzdHJlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgxLCBfLCB4Mikge1xuICAgIGlmICghcXVhZC52YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgeCA9IHF1YWQueCAtIG5vZGUueCxcbiAgICAgICAgeSA9IHF1YWQueSAtIG5vZGUueSxcbiAgICAgICAgdyA9IHgyIC0geDEsXG4gICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgLy8gQXBwbHkgdGhlIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBpZiBwb3NzaWJsZS5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodyAqIHcgLyB0aGV0YTIgPCBsKSB7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWF4Mikge1xuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZSgpLCBsICs9IHkgKiB5O1xuICAgICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICAgICAgbm9kZS52eCArPSB4ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgICAgbm9kZS52eSArPSB5ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXG4gICAgZWxzZSBpZiAocXVhZC5sZW5ndGggfHwgbCA+PSBkaXN0YW5jZU1heDIpIHJldHVybjtcblxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmIChxdWFkLmRhdGEgIT09IG5vZGUgfHwgcXVhZC5uZXh0KSB7XG4gICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZSgpLCBsICs9IHggKiB4O1xuICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUoKSwgbCArPSB5ICogeTtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgIH1cblxuICAgIGRvIGlmIChxdWFkLmRhdGEgIT09IG5vZGUpIHtcbiAgICAgIHcgPSBzdHJlbmd0aHNbcXVhZC5kYXRhLmluZGV4XSAqIGFscGhhIC8gbDtcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XG4gICAgICBub2RlLnZ5ICs9IHkgKiB3O1xuICAgIH0gd2hpbGUgKHF1YWQgPSBxdWFkLm5leHQpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxudmFyIHJhZGlhbCA9IGZ1bmN0aW9uKHJhZGl1cywgeCwgeSkge1xuICB2YXIgbm9kZXMsXG4gICAgICBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICByYWRpdXNlcztcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudCgrcmFkaXVzKTtcbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV0sXG4gICAgICAgICAgZHggPSBub2RlLnggLSB4IHx8IDFlLTYsXG4gICAgICAgICAgZHkgPSBub2RlLnkgLSB5IHx8IDFlLTYsXG4gICAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgayA9IChyYWRpdXNlc1tpXSAtIHIpICogc3RyZW5ndGhzW2ldICogYWxwaGEgLyByO1xuICAgICAgbm9kZS52eCArPSBkeCAqIGs7XG4gICAgICBub2RlLnZ5ICs9IGR5ICogaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgcmFkaXVzZXMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmFkaXVzZXNbaV0gPSArcmFkaXVzKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTihyYWRpdXNlc1tpXSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF8sIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufTtcblxudmFyIHgkMiA9IGZ1bmN0aW9uKHgpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeHo7XG5cbiAgaWYgKHR5cGVvZiB4ICE9PSBcImZ1bmN0aW9uXCIpIHggPSBjb25zdGFudCh4ID09IG51bGwgPyAwIDogK3gpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eCArPSAoeHpbaV0gLSBub2RlLngpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHh6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHh6W2ldID0gK3gobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeDtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59O1xuXG52YXIgeSQyID0gZnVuY3Rpb24oeSkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB5ejtcblxuICBpZiAodHlwZW9mIHkgIT09IFwiZnVuY3Rpb25cIikgeSA9IGNvbnN0YW50KHkgPT0gbnVsbCA/IDAgOiAreSk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ5ICs9ICh5eltpXSAtIG5vZGUueSkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeXogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeXpbaV0gPSAreShub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn07XG5cbmV4cG9ydHMuZm9yY2VDZW50ZXIgPSBjZW50ZXI7XG5leHBvcnRzLmZvcmNlQ29sbGlkZSA9IGNvbGxpZGU7XG5leHBvcnRzLmZvcmNlTGluayA9IGxpbms7XG5leHBvcnRzLmZvcmNlTWFueUJvZHkgPSBtYW55Qm9keTtcbmV4cG9ydHMuZm9yY2VSYWRpYWwgPSByYWRpYWw7XG5leHBvcnRzLmZvcmNlU2ltdWxhdGlvbiA9IHNpbXVsYXRpb247XG5leHBvcnRzLmZvcmNlWCA9IHgkMjtcbmV4cG9ydHMuZm9yY2VZID0geSQyO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy1mb3JtYXQvIFZlcnNpb24gMS4zLjAuIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQ29tcHV0ZXMgdGhlIGRlY2ltYWwgY29lZmZpY2llbnQgYW5kIGV4cG9uZW50IG9mIHRoZSBzcGVjaWZpZWQgbnVtYmVyIHggd2l0aFxuLy8gc2lnbmlmaWNhbnQgZGlnaXRzIHAsIHdoZXJlIHggaXMgcG9zaXRpdmUgYW5kIHAgaXMgaW4gWzEsIDIxXSBvciB1bmRlZmluZWQuXG4vLyBGb3IgZXhhbXBsZSwgZm9ybWF0RGVjaW1hbCgxLjIzKSByZXR1cm5zIFtcIjEyM1wiLCAwXS5cbnZhciBmb3JtYXREZWNpbWFsID0gZnVuY3Rpb24oeCwgcCkge1xuICBpZiAoKGkgPSAoeCA9IHAgPyB4LnRvRXhwb25lbnRpYWwocCAtIDEpIDogeC50b0V4cG9uZW50aWFsKCkpLmluZGV4T2YoXCJlXCIpKSA8IDApIHJldHVybiBudWxsOyAvLyBOYU4sIMKxSW5maW5pdHlcbiAgdmFyIGksIGNvZWZmaWNpZW50ID0geC5zbGljZSgwLCBpKTtcblxuICAvLyBUaGUgc3RyaW5nIHJldHVybmVkIGJ5IHRvRXhwb25lbnRpYWwgZWl0aGVyIGhhcyB0aGUgZm9ybSBcXGRcXC5cXGQrZVstK11cXGQrXG4gIC8vIChlLmcuLCAxLjJlKzMpIG9yIHRoZSBmb3JtIFxcZGVbLStdXFxkKyAoZS5nLiwgMWUrMykuXG4gIHJldHVybiBbXG4gICAgY29lZmZpY2llbnQubGVuZ3RoID4gMSA/IGNvZWZmaWNpZW50WzBdICsgY29lZmZpY2llbnQuc2xpY2UoMikgOiBjb2VmZmljaWVudCxcbiAgICAreC5zbGljZShpICsgMSlcbiAgXTtcbn07XG5cbnZhciBleHBvbmVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHggPSBmb3JtYXREZWNpbWFsKE1hdGguYWJzKHgpKSwgeCA/IHhbMV0gOiBOYU47XG59O1xuXG52YXIgZm9ybWF0R3JvdXAgPSBmdW5jdGlvbihncm91cGluZywgdGhvdXNhbmRzKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgd2lkdGgpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgdCA9IFtdLFxuICAgICAgICBqID0gMCxcbiAgICAgICAgZyA9IGdyb3VwaW5nWzBdLFxuICAgICAgICBsZW5ndGggPSAwO1xuXG4gICAgd2hpbGUgKGkgPiAwICYmIGcgPiAwKSB7XG4gICAgICBpZiAobGVuZ3RoICsgZyArIDEgPiB3aWR0aCkgZyA9IE1hdGgubWF4KDEsIHdpZHRoIC0gbGVuZ3RoKTtcbiAgICAgIHQucHVzaCh2YWx1ZS5zdWJzdHJpbmcoaSAtPSBnLCBpICsgZykpO1xuICAgICAgaWYgKChsZW5ndGggKz0gZyArIDEpID4gd2lkdGgpIGJyZWFrO1xuICAgICAgZyA9IGdyb3VwaW5nW2ogPSAoaiArIDEpICUgZ3JvdXBpbmcubGVuZ3RoXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdC5yZXZlcnNlKCkuam9pbih0aG91c2FuZHMpO1xuICB9O1xufTtcblxudmFyIGZvcm1hdE51bWVyYWxzID0gZnVuY3Rpb24obnVtZXJhbHMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1swLTldL2csIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBudW1lcmFsc1sraV07XG4gICAgfSk7XG4gIH07XG59O1xuXG4vLyBbW2ZpbGxdYWxpZ25dW3NpZ25dW3N5bWJvbF1bMF1bd2lkdGhdWyxdWy5wcmVjaXNpb25dW35dW3R5cGVdXG52YXIgcmUgPSAvXig/OiguKT8oWzw+PV5dKSk/KFsrXFwtXFwoIF0pPyhbJCNdKT8oMCk/KFxcZCspPygsKT8oXFwuXFxkKyk/KH4pPyhbYS16JV0pPyQvaTtcblxuZnVuY3Rpb24gZm9ybWF0U3BlY2lmaWVyKHNwZWNpZmllcikge1xuICByZXR1cm4gbmV3IEZvcm1hdFNwZWNpZmllcihzcGVjaWZpZXIpO1xufVxuXG5mb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlID0gRm9ybWF0U3BlY2lmaWVyLnByb3RvdHlwZTsgLy8gaW5zdGFuY2VvZlxuXG5mdW5jdGlvbiBGb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSB7XG4gIGlmICghKG1hdGNoID0gcmUuZXhlYyhzcGVjaWZpZXIpKSkgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmb3JtYXQ6IFwiICsgc3BlY2lmaWVyKTtcbiAgdmFyIG1hdGNoO1xuICB0aGlzLmZpbGwgPSBtYXRjaFsxXSB8fCBcIiBcIjtcbiAgdGhpcy5hbGlnbiA9IG1hdGNoWzJdIHx8IFwiPlwiO1xuICB0aGlzLnNpZ24gPSBtYXRjaFszXSB8fCBcIi1cIjtcbiAgdGhpcy5zeW1ib2wgPSBtYXRjaFs0XSB8fCBcIlwiO1xuICB0aGlzLnplcm8gPSAhIW1hdGNoWzVdO1xuICB0aGlzLndpZHRoID0gbWF0Y2hbNl0gJiYgK21hdGNoWzZdO1xuICB0aGlzLmNvbW1hID0gISFtYXRjaFs3XTtcbiAgdGhpcy5wcmVjaXNpb24gPSBtYXRjaFs4XSAmJiArbWF0Y2hbOF0uc2xpY2UoMSk7XG4gIHRoaXMudHJpbSA9ICEhbWF0Y2hbOV07XG4gIHRoaXMudHlwZSA9IG1hdGNoWzEwXSB8fCBcIlwiO1xufVxuXG5Gb3JtYXRTcGVjaWZpZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmZpbGxcbiAgICAgICsgdGhpcy5hbGlnblxuICAgICAgKyB0aGlzLnNpZ25cbiAgICAgICsgdGhpcy5zeW1ib2xcbiAgICAgICsgKHRoaXMuemVybyA/IFwiMFwiIDogXCJcIilcbiAgICAgICsgKHRoaXMud2lkdGggPT0gbnVsbCA/IFwiXCIgOiBNYXRoLm1heCgxLCB0aGlzLndpZHRoIHwgMCkpXG4gICAgICArICh0aGlzLmNvbW1hID8gXCIsXCIgOiBcIlwiKVxuICAgICAgKyAodGhpcy5wcmVjaXNpb24gPT0gbnVsbCA/IFwiXCIgOiBcIi5cIiArIE1hdGgubWF4KDAsIHRoaXMucHJlY2lzaW9uIHwgMCkpXG4gICAgICArICh0aGlzLnRyaW0gPyBcIn5cIiA6IFwiXCIpXG4gICAgICArIHRoaXMudHlwZTtcbn07XG5cbi8vIFRyaW1zIGluc2lnbmlmaWNhbnQgemVyb3MsIGUuZy4sIHJlcGxhY2VzIDEuMjAwMGsgd2l0aCAxLjJrLlxudmFyIGZvcm1hdFRyaW0gPSBmdW5jdGlvbihzKSB7XG4gIG91dDogZm9yICh2YXIgbiA9IHMubGVuZ3RoLCBpID0gMSwgaTAgPSAtMSwgaTE7IGkgPCBuOyArK2kpIHtcbiAgICBzd2l0Y2ggKHNbaV0pIHtcbiAgICAgIGNhc2UgXCIuXCI6IGkwID0gaTEgPSBpOyBicmVhaztcbiAgICAgIGNhc2UgXCIwXCI6IGlmIChpMCA9PT0gMCkgaTAgPSBpOyBpMSA9IGk7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogaWYgKGkwID4gMCkgeyBpZiAoIStzW2ldKSBicmVhayBvdXQ7IGkwID0gMDsgfSBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGkwID4gMCA/IHMuc2xpY2UoMCwgaTApICsgcy5zbGljZShpMSArIDEpIDogcztcbn07XG5cbnZhciBwcmVmaXhFeHBvbmVudDtcblxudmFyIGZvcm1hdFByZWZpeEF1dG8gPSBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV0sXG4gICAgICBpID0gZXhwb25lbnQgLSAocHJlZml4RXhwb25lbnQgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCAvIDMpKSkgKiAzKSArIDEsXG4gICAgICBuID0gY29lZmZpY2llbnQubGVuZ3RoO1xuICByZXR1cm4gaSA9PT0gbiA/IGNvZWZmaWNpZW50XG4gICAgICA6IGkgPiBuID8gY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoaSAtIG4gKyAxKS5qb2luKFwiMFwiKVxuICAgICAgOiBpID4gMCA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGkpICsgXCIuXCIgKyBjb2VmZmljaWVudC5zbGljZShpKVxuICAgICAgOiBcIjAuXCIgKyBuZXcgQXJyYXkoMSAtIGkpLmpvaW4oXCIwXCIpICsgZm9ybWF0RGVjaW1hbCh4LCBNYXRoLm1heCgwLCBwICsgaSAtIDEpKVswXTsgLy8gbGVzcyB0aGFuIDF5IVxufTtcblxudmFyIGZvcm1hdFJvdW5kZWQgPSBmdW5jdGlvbih4LCBwKSB7XG4gIHZhciBkID0gZm9ybWF0RGVjaW1hbCh4LCBwKTtcbiAgaWYgKCFkKSByZXR1cm4geCArIFwiXCI7XG4gIHZhciBjb2VmZmljaWVudCA9IGRbMF0sXG4gICAgICBleHBvbmVudCA9IGRbMV07XG4gIHJldHVybiBleHBvbmVudCA8IDAgPyBcIjAuXCIgKyBuZXcgQXJyYXkoLWV4cG9uZW50KS5qb2luKFwiMFwiKSArIGNvZWZmaWNpZW50XG4gICAgICA6IGNvZWZmaWNpZW50Lmxlbmd0aCA+IGV4cG9uZW50ICsgMSA/IGNvZWZmaWNpZW50LnNsaWNlKDAsIGV4cG9uZW50ICsgMSkgKyBcIi5cIiArIGNvZWZmaWNpZW50LnNsaWNlKGV4cG9uZW50ICsgMSlcbiAgICAgIDogY29lZmZpY2llbnQgKyBuZXcgQXJyYXkoZXhwb25lbnQgLSBjb2VmZmljaWVudC5sZW5ndGggKyAyKS5qb2luKFwiMFwiKTtcbn07XG5cbnZhciBmb3JtYXRUeXBlcyA9IHtcbiAgXCIlXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuICh4ICogMTAwKS50b0ZpeGVkKHApOyB9LFxuICBcImJcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygyKTsgfSxcbiAgXCJjXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggKyBcIlwiOyB9LFxuICBcImRcIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZygxMCk7IH0sXG4gIFwiZVwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRXhwb25lbnRpYWwocCk7IH0sXG4gIFwiZlwiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvRml4ZWQocCk7IH0sXG4gIFwiZ1wiOiBmdW5jdGlvbih4LCBwKSB7IHJldHVybiB4LnRvUHJlY2lzaW9uKHApOyB9LFxuICBcIm9cIjogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KS50b1N0cmluZyg4KTsgfSxcbiAgXCJwXCI6IGZ1bmN0aW9uKHgsIHApIHsgcmV0dXJuIGZvcm1hdFJvdW5kZWQoeCAqIDEwMCwgcCk7IH0sXG4gIFwiclwiOiBmb3JtYXRSb3VuZGVkLFxuICBcInNcIjogZm9ybWF0UHJlZml4QXV0byxcbiAgXCJYXCI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgucm91bmQoeCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0sXG4gIFwieFwiOiBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLnJvdW5kKHgpLnRvU3RyaW5nKDE2KTsgfVxufTtcblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geDtcbn07XG5cbnZhciBwcmVmaXhlcyA9IFtcInlcIixcInpcIixcImFcIixcImZcIixcInBcIixcIm5cIixcIsK1XCIsXCJtXCIsXCJcIixcImtcIixcIk1cIixcIkdcIixcIlRcIixcIlBcIixcIkVcIixcIlpcIixcIllcIl07XG5cbnZhciBmb3JtYXRMb2NhbGUgPSBmdW5jdGlvbihsb2NhbGUpIHtcbiAgdmFyIGdyb3VwID0gbG9jYWxlLmdyb3VwaW5nICYmIGxvY2FsZS50aG91c2FuZHMgPyBmb3JtYXRHcm91cChsb2NhbGUuZ3JvdXBpbmcsIGxvY2FsZS50aG91c2FuZHMpIDogaWRlbnRpdHksXG4gICAgICBjdXJyZW5jeSA9IGxvY2FsZS5jdXJyZW5jeSxcbiAgICAgIGRlY2ltYWwgPSBsb2NhbGUuZGVjaW1hbCxcbiAgICAgIG51bWVyYWxzID0gbG9jYWxlLm51bWVyYWxzID8gZm9ybWF0TnVtZXJhbHMobG9jYWxlLm51bWVyYWxzKSA6IGlkZW50aXR5LFxuICAgICAgcGVyY2VudCA9IGxvY2FsZS5wZXJjZW50IHx8IFwiJVwiO1xuXG4gIGZ1bmN0aW9uIG5ld0Zvcm1hdChzcGVjaWZpZXIpIHtcbiAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKTtcblxuICAgIHZhciBmaWxsID0gc3BlY2lmaWVyLmZpbGwsXG4gICAgICAgIGFsaWduID0gc3BlY2lmaWVyLmFsaWduLFxuICAgICAgICBzaWduID0gc3BlY2lmaWVyLnNpZ24sXG4gICAgICAgIHN5bWJvbCA9IHNwZWNpZmllci5zeW1ib2wsXG4gICAgICAgIHplcm8gPSBzcGVjaWZpZXIuemVybyxcbiAgICAgICAgd2lkdGggPSBzcGVjaWZpZXIud2lkdGgsXG4gICAgICAgIGNvbW1hID0gc3BlY2lmaWVyLmNvbW1hLFxuICAgICAgICBwcmVjaXNpb24gPSBzcGVjaWZpZXIucHJlY2lzaW9uLFxuICAgICAgICB0cmltID0gc3BlY2lmaWVyLnRyaW0sXG4gICAgICAgIHR5cGUgPSBzcGVjaWZpZXIudHlwZTtcblxuICAgIC8vIFRoZSBcIm5cIiB0eXBlIGlzIGFuIGFsaWFzIGZvciBcIixnXCIuXG4gICAgaWYgKHR5cGUgPT09IFwiblwiKSBjb21tYSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIFRoZSBcIlwiIHR5cGUsIGFuZCBhbnkgaW52YWxpZCB0eXBlLCBpcyBhbiBhbGlhcyBmb3IgXCIuMTJ+Z1wiLlxuICAgIGVsc2UgaWYgKCFmb3JtYXRUeXBlc1t0eXBlXSkgcHJlY2lzaW9uID09IG51bGwgJiYgKHByZWNpc2lvbiA9IDEyKSwgdHJpbSA9IHRydWUsIHR5cGUgPSBcImdcIjtcblxuICAgIC8vIElmIHplcm8gZmlsbCBpcyBzcGVjaWZpZWQsIHBhZGRpbmcgZ29lcyBhZnRlciBzaWduIGFuZCBiZWZvcmUgZGlnaXRzLlxuICAgIGlmICh6ZXJvIHx8IChmaWxsID09PSBcIjBcIiAmJiBhbGlnbiA9PT0gXCI9XCIpKSB6ZXJvID0gdHJ1ZSwgZmlsbCA9IFwiMFwiLCBhbGlnbiA9IFwiPVwiO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXG4gICAgLy8gRm9yIFNJLXByZWZpeCwgdGhlIHN1ZmZpeCBpcyBsYXppbHkgY29tcHV0ZWQuXG4gICAgdmFyIHByZWZpeCA9IHN5bWJvbCA9PT0gXCIkXCIgPyBjdXJyZW5jeVswXSA6IHN5bWJvbCA9PT0gXCIjXCIgJiYgL1tib3hYXS8udGVzdCh0eXBlKSA/IFwiMFwiICsgdHlwZS50b0xvd2VyQ2FzZSgpIDogXCJcIixcbiAgICAgICAgc3VmZml4ID0gc3ltYm9sID09PSBcIiRcIiA/IGN1cnJlbmN5WzFdIDogL1slcF0vLnRlc3QodHlwZSkgPyBwZXJjZW50IDogXCJcIjtcblxuICAgIC8vIFdoYXQgZm9ybWF0IGZ1bmN0aW9uIHNob3VsZCB3ZSB1c2U/XG4gICAgLy8gSXMgdGhpcyBhbiBpbnRlZ2VyIHR5cGU/XG4gICAgLy8gQ2FuIHRoaXMgdHlwZSBnZW5lcmF0ZSBleHBvbmVudGlhbCBub3RhdGlvbj9cbiAgICB2YXIgZm9ybWF0VHlwZSA9IGZvcm1hdFR5cGVzW3R5cGVdLFxuICAgICAgICBtYXliZVN1ZmZpeCA9IC9bZGVmZ3BycyVdLy50ZXN0KHR5cGUpO1xuXG4gICAgLy8gU2V0IHRoZSBkZWZhdWx0IHByZWNpc2lvbiBpZiBub3Qgc3BlY2lmaWVkLFxuICAgIC8vIG9yIGNsYW1wIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uIHRvIHRoZSBzdXBwb3J0ZWQgcmFuZ2UuXG4gICAgLy8gRm9yIHNpZ25pZmljYW50IHByZWNpc2lvbiwgaXQgbXVzdCBiZSBpbiBbMSwgMjFdLlxuICAgIC8vIEZvciBmaXhlZCBwcmVjaXNpb24sIGl0IG11c3QgYmUgaW4gWzAsIDIwXS5cbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDZcbiAgICAgICAgOiAvW2dwcnNdLy50ZXN0KHR5cGUpID8gTWF0aC5tYXgoMSwgTWF0aC5taW4oMjEsIHByZWNpc2lvbikpXG4gICAgICAgIDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHByZWNpc2lvbikpO1xuXG4gICAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlKSB7XG4gICAgICB2YXIgdmFsdWVQcmVmaXggPSBwcmVmaXgsXG4gICAgICAgICAgdmFsdWVTdWZmaXggPSBzdWZmaXgsXG4gICAgICAgICAgaSwgbiwgYztcblxuICAgICAgaWYgKHR5cGUgPT09IFwiY1wiKSB7XG4gICAgICAgIHZhbHVlU3VmZml4ID0gZm9ybWF0VHlwZSh2YWx1ZSkgKyB2YWx1ZVN1ZmZpeDtcbiAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XG5cbiAgICAgICAgLy8gUGVyZm9ybSB0aGUgaW5pdGlhbCBmb3JtYXR0aW5nLlxuICAgICAgICB2YXIgdmFsdWVOZWdhdGl2ZSA9IHZhbHVlIDwgMDtcbiAgICAgICAgdmFsdWUgPSBmb3JtYXRUeXBlKE1hdGguYWJzKHZhbHVlKSwgcHJlY2lzaW9uKTtcblxuICAgICAgICAvLyBUcmltIGluc2lnbmlmaWNhbnQgemVyb3MuXG4gICAgICAgIGlmICh0cmltKSB2YWx1ZSA9IGZvcm1hdFRyaW0odmFsdWUpO1xuXG4gICAgICAgIC8vIElmIGEgbmVnYXRpdmUgdmFsdWUgcm91bmRzIHRvIHplcm8gZHVyaW5nIGZvcm1hdHRpbmcsIHRyZWF0IGFzIHBvc2l0aXZlLlxuICAgICAgICBpZiAodmFsdWVOZWdhdGl2ZSAmJiArdmFsdWUgPT09IDApIHZhbHVlTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBwcmVmaXggYW5kIHN1ZmZpeC5cbiAgICAgICAgdmFsdWVQcmVmaXggPSAodmFsdWVOZWdhdGl2ZSA/IChzaWduID09PSBcIihcIiA/IHNpZ24gOiBcIi1cIikgOiBzaWduID09PSBcIi1cIiB8fCBzaWduID09PSBcIihcIiA/IFwiXCIgOiBzaWduKSArIHZhbHVlUHJlZml4O1xuICAgICAgICB2YWx1ZVN1ZmZpeCA9ICh0eXBlID09PSBcInNcIiA/IHByZWZpeGVzWzggKyBwcmVmaXhFeHBvbmVudCAvIDNdIDogXCJcIikgKyB2YWx1ZVN1ZmZpeCArICh2YWx1ZU5lZ2F0aXZlICYmIHNpZ24gPT09IFwiKFwiID8gXCIpXCIgOiBcIlwiKTtcblxuICAgICAgICAvLyBCcmVhayB0aGUgZm9ybWF0dGVkIHZhbHVlIGludG8gdGhlIGludGVnZXIg4oCcdmFsdWXigJ0gcGFydCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBncm91cGVkLCBhbmQgZnJhY3Rpb25hbCBvciBleHBvbmVudGlhbCDigJxzdWZmaXjigJ0gcGFydCB0aGF0IGlzIG5vdC5cbiAgICAgICAgaWYgKG1heWJlU3VmZml4KSB7XG4gICAgICAgICAgaSA9IC0xLCBuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgICAgICBpZiAoYyA9IHZhbHVlLmNoYXJDb2RlQXQoaSksIDQ4ID4gYyB8fCBjID4gNTcpIHtcbiAgICAgICAgICAgICAgdmFsdWVTdWZmaXggPSAoYyA9PT0gNDYgPyBkZWNpbWFsICsgdmFsdWUuc2xpY2UoaSArIDEpIDogdmFsdWUuc2xpY2UoaSkpICsgdmFsdWVTdWZmaXg7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgbm90IFwiMFwiLCBncm91cGluZyBpcyBhcHBsaWVkIGJlZm9yZSBwYWRkaW5nLlxuICAgICAgaWYgKGNvbW1hICYmICF6ZXJvKSB2YWx1ZSA9IGdyb3VwKHZhbHVlLCBJbmZpbml0eSk7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIHBhZGRpbmcuXG4gICAgICB2YXIgbGVuZ3RoID0gdmFsdWVQcmVmaXgubGVuZ3RoICsgdmFsdWUubGVuZ3RoICsgdmFsdWVTdWZmaXgubGVuZ3RoLFxuICAgICAgICAgIHBhZGRpbmcgPSBsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgOiBcIlwiO1xuXG4gICAgICAvLyBJZiB0aGUgZmlsbCBjaGFyYWN0ZXIgaXMgXCIwXCIsIGdyb3VwaW5nIGlzIGFwcGxpZWQgYWZ0ZXIgcGFkZGluZy5cbiAgICAgIGlmIChjb21tYSAmJiB6ZXJvKSB2YWx1ZSA9IGdyb3VwKHBhZGRpbmcgKyB2YWx1ZSwgcGFkZGluZy5sZW5ndGggPyB3aWR0aCAtIHZhbHVlU3VmZml4Lmxlbmd0aCA6IEluZmluaXR5KSwgcGFkZGluZyA9IFwiXCI7XG5cbiAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBmaW5hbCBvdXRwdXQgYmFzZWQgb24gdGhlIGRlc2lyZWQgYWxpZ25tZW50LlxuICAgICAgc3dpdGNoIChhbGlnbikge1xuICAgICAgICBjYXNlIFwiPFwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgdmFsdWUgKyB2YWx1ZVN1ZmZpeCArIHBhZGRpbmc7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiPVwiOiB2YWx1ZSA9IHZhbHVlUHJlZml4ICsgcGFkZGluZyArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgICBjYXNlIFwiXlwiOiB2YWx1ZSA9IHBhZGRpbmcuc2xpY2UoMCwgbGVuZ3RoID0gcGFkZGluZy5sZW5ndGggPj4gMSkgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXggKyBwYWRkaW5nLnNsaWNlKGxlbmd0aCk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB2YWx1ZSA9IHBhZGRpbmcgKyB2YWx1ZVByZWZpeCArIHZhbHVlICsgdmFsdWVTdWZmaXg7IGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVtZXJhbHModmFsdWUpO1xuICAgIH1cblxuICAgIGZvcm1hdC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNwZWNpZmllciArIFwiXCI7XG4gICAgfTtcblxuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cblxuICBmdW5jdGlvbiBmb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSkge1xuICAgIHZhciBmID0gbmV3Rm9ybWF0KChzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyKSwgc3BlY2lmaWVyLnR5cGUgPSBcImZcIiwgc3BlY2lmaWVyKSksXG4gICAgICAgIGUgPSBNYXRoLm1heCgtOCwgTWF0aC5taW4oOCwgTWF0aC5mbG9vcihleHBvbmVudCh2YWx1ZSkgLyAzKSkpICogMyxcbiAgICAgICAgayA9IE1hdGgucG93KDEwLCAtZSksXG4gICAgICAgIHByZWZpeCA9IHByZWZpeGVzWzggKyBlIC8gM107XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZihrICogdmFsdWUpICsgcHJlZml4O1xuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZvcm1hdDogbmV3Rm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeDogZm9ybWF0UHJlZml4XG4gIH07XG59O1xuXG52YXIgbG9jYWxlO1xuXG5cblxuZGVmYXVsdExvY2FsZSh7XG4gIGRlY2ltYWw6IFwiLlwiLFxuICB0aG91c2FuZHM6IFwiLFwiLFxuICBncm91cGluZzogWzNdLFxuICBjdXJyZW5jeTogW1wiJFwiLCBcIlwiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMuZm9ybWF0ID0gbG9jYWxlLmZvcm1hdDtcbiAgZXhwb3J0cy5mb3JtYXRQcmVmaXggPSBsb2NhbGUuZm9ybWF0UHJlZml4O1xuICByZXR1cm4gbG9jYWxlO1xufVxuXG52YXIgcHJlY2lzaW9uRml4ZWQgPSBmdW5jdGlvbihzdGVwKSB7XG4gIHJldHVybiBNYXRoLm1heCgwLCAtZXhwb25lbnQoTWF0aC5hYnMoc3RlcCkpKTtcbn07XG5cbnZhciBwcmVjaXNpb25QcmVmaXggPSBmdW5jdGlvbihzdGVwLCB2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5tYXgoLTgsIE1hdGgubWluKDgsIE1hdGguZmxvb3IoZXhwb25lbnQodmFsdWUpIC8gMykpKSAqIDMgLSBleHBvbmVudChNYXRoLmFicyhzdGVwKSkpO1xufTtcblxudmFyIHByZWNpc2lvblJvdW5kID0gZnVuY3Rpb24oc3RlcCwgbWF4KSB7XG4gIHN0ZXAgPSBNYXRoLmFicyhzdGVwKSwgbWF4ID0gTWF0aC5hYnMobWF4KSAtIHN0ZXA7XG4gIHJldHVybiBNYXRoLm1heCgwLCBleHBvbmVudChtYXgpIC0gZXhwb25lbnQoc3RlcCkpICsgMTtcbn07XG5cbmV4cG9ydHMuZm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLmZvcm1hdExvY2FsZSA9IGZvcm1hdExvY2FsZTtcbmV4cG9ydHMuZm9ybWF0U3BlY2lmaWVyID0gZm9ybWF0U3BlY2lmaWVyO1xuZXhwb3J0cy5wcmVjaXNpb25GaXhlZCA9IHByZWNpc2lvbkZpeGVkO1xuZXhwb3J0cy5wcmVjaXNpb25QcmVmaXggPSBwcmVjaXNpb25QcmVmaXg7XG5leHBvcnRzLnByZWNpc2lvblJvdW5kID0gcHJlY2lzaW9uUm91bmQ7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWdlby8gVmVyc2lvbiAxLjEwLjAuIENvcHlyaWdodCAyMDE4IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtYXJyYXknKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5J10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0FycmF5KSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gQWRkcyBmbG9hdGluZyBwb2ludCBudW1iZXJzIHdpdGggdHdpY2UgdGhlIG5vcm1hbCBwcmVjaXNpb24uXG4vLyBSZWZlcmVuY2U6IEouIFIuIFNoZXdjaHVrLCBBZGFwdGl2ZSBQcmVjaXNpb24gRmxvYXRpbmctUG9pbnQgQXJpdGhtZXRpYyBhbmRcbi8vIEZhc3QgUm9idXN0IEdlb21ldHJpYyBQcmVkaWNhdGVzLCBEaXNjcmV0ZSAmIENvbXB1dGF0aW9uYWwgR2VvbWV0cnkgMTgoMylcbi8vIDMwNeKAkzM2MyAoMTk5NykuXG4vLyBDb2RlIGFkYXB0ZWQgZnJvbSBHZW9ncmFwaGljTGliIGJ5IENoYXJsZXMgRi4gRi4gS2FybmV5LFxuLy8gaHR0cDovL2dlb2dyYXBoaWNsaWIuc291cmNlZm9yZ2UubmV0L1xuXG5mdW5jdGlvbiBhZGRlcigpIHtcbiAgcmV0dXJuIG5ldyBBZGRlcjtcbn1cblxuZnVuY3Rpb24gQWRkZXIoKSB7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuQWRkZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogQWRkZXIsXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnMgPSAvLyByb3VuZGVkIHZhbHVlXG4gICAgdGhpcy50ID0gMDsgLy8gZXhhY3QgZXJyb3JcbiAgfSxcbiAgYWRkOiBmdW5jdGlvbih5KSB7XG4gICAgYWRkKHRlbXAsIHksIHRoaXMudCk7XG4gICAgYWRkKHRoaXMsIHRlbXAucywgdGhpcy5zKTtcbiAgICBpZiAodGhpcy5zKSB0aGlzLnQgKz0gdGVtcC50O1xuICAgIGVsc2UgdGhpcy5zID0gdGVtcC50O1xuICB9LFxuICB2YWx1ZU9mOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zO1xuICB9XG59O1xuXG52YXIgdGVtcCA9IG5ldyBBZGRlcjtcblxuZnVuY3Rpb24gYWRkKGFkZGVyLCBhLCBiKSB7XG4gIHZhciB4ID0gYWRkZXIucyA9IGEgKyBiLFxuICAgICAgYnYgPSB4IC0gYSxcbiAgICAgIGF2ID0geCAtIGJ2O1xuICBhZGRlci50ID0gKGEgLSBhdikgKyAoYiAtIGJ2KTtcbn1cblxudmFyIGVwc2lsb24gPSAxZS02O1xudmFyIGVwc2lsb24yID0gMWUtMTI7XG52YXIgcGkgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSA9IHBpIC8gMjtcbnZhciBxdWFydGVyUGkgPSBwaSAvIDQ7XG52YXIgdGF1ID0gcGkgKiAyO1xuXG52YXIgZGVncmVlcyA9IDE4MCAvIHBpO1xudmFyIHJhZGlhbnMgPSBwaSAvIDE4MDtcblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGF0YW4gPSBNYXRoLmF0YW47XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZXhwID0gTWF0aC5leHA7XG5cbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBwb3cgPSBNYXRoLnBvdztcbnZhciBzaW4gPSBNYXRoLnNpbjtcbnZhciBzaWduID0gTWF0aC5zaWduIHx8IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggPiAwID8gMSA6IHggPCAwID8gLTEgOiAwOyB9O1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgdGFuID0gTWF0aC50YW47XG5cbmZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+IDEgPyBoYWxmUGkgOiB4IDwgLTEgPyAtaGFsZlBpIDogTWF0aC5hc2luKHgpO1xufVxuXG5mdW5jdGlvbiBoYXZlcnNpbih4KSB7XG4gIHJldHVybiAoeCA9IHNpbih4IC8gMikpICogeDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHN0cmVhbUdlb21ldHJ5KGdlb21ldHJ5LCBzdHJlYW0pIHtcbiAgaWYgKGdlb21ldHJ5ICYmIHN0cmVhbUdlb21ldHJ5VHlwZS5oYXNPd25Qcm9wZXJ0eShnZW9tZXRyeS50eXBlKSkge1xuICAgIHN0cmVhbUdlb21ldHJ5VHlwZVtnZW9tZXRyeS50eXBlXShnZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufVxuXG52YXIgc3RyZWFtT2JqZWN0VHlwZSA9IHtcbiAgRmVhdHVyZTogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QuZ2VvbWV0cnksIHN0cmVhbSk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBmZWF0dXJlcyA9IG9iamVjdC5mZWF0dXJlcywgaSA9IC0xLCBuID0gZmVhdHVyZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1HZW9tZXRyeShmZWF0dXJlc1tpXS5nZW9tZXRyeSwgc3RyZWFtKTtcbiAgfVxufTtcblxudmFyIHN0cmVhbUdlb21ldHJ5VHlwZSA9IHtcbiAgU3BoZXJlOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbS5zcGhlcmUoKTtcbiAgfSxcbiAgUG9pbnQ6IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0LmNvb3JkaW5hdGVzO1xuICAgIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTXVsdGlQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBvYmplY3QuY29vcmRpbmF0ZXMsIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgb2JqZWN0ID0gY29vcmRpbmF0ZXNbaV0sIHN0cmVhbS5wb2ludChvYmplY3RbMF0sIG9iamVjdFsxXSwgb2JqZWN0WzJdKTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICBzdHJlYW1MaW5lKG9iamVjdC5jb29yZGluYXRlcywgc3RyZWFtLCAwKTtcbiAgfSxcbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDApO1xuICB9LFxuICBQb2x5Z29uOiBmdW5jdGlvbihvYmplY3QsIHN0cmVhbSkge1xuICAgIHN0cmVhbVBvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBzdHJlYW0pO1xuICB9LFxuICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uKG9iamVjdCwgc3RyZWFtKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXNbaV0sIHN0cmVhbSk7XG4gIH0sXG4gIEdlb21ldHJ5Q29sbGVjdGlvbjogZnVuY3Rpb24ob2JqZWN0LCBzdHJlYW0pIHtcbiAgICB2YXIgZ2VvbWV0cmllcyA9IG9iamVjdC5nZW9tZXRyaWVzLCBpID0gLTEsIG4gPSBnZW9tZXRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgc3RyZWFtR2VvbWV0cnkoZ2VvbWV0cmllc1tpXSwgc3RyZWFtKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc3RyZWFtTGluZShjb29yZGluYXRlcywgc3RyZWFtLCBjbG9zZWQpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IGNvb3JkaW5hdGVzLmxlbmd0aCAtIGNsb3NlZCwgY29vcmRpbmF0ZTtcbiAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICB3aGlsZSAoKytpIDwgbikgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0ucG9pbnQoY29vcmRpbmF0ZVswXSwgY29vcmRpbmF0ZVsxXSwgY29vcmRpbmF0ZVsyXSk7XG4gIHN0cmVhbS5saW5lRW5kKCk7XG59XG5cbmZ1bmN0aW9uIHN0cmVhbVBvbHlnb24oY29vcmRpbmF0ZXMsIHN0cmVhbSkge1xuICB2YXIgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gIHdoaWxlICgrK2kgPCBuKSBzdHJlYW1MaW5lKGNvb3JkaW5hdGVzW2ldLCBzdHJlYW0sIDEpO1xuICBzdHJlYW0ucG9seWdvbkVuZCgpO1xufVxuXG5mdW5jdGlvbiBnZW9TdHJlYW0ob2JqZWN0LCBzdHJlYW0pIHtcbiAgaWYgKG9iamVjdCAmJiBzdHJlYW1PYmplY3RUeXBlLmhhc093blByb3BlcnR5KG9iamVjdC50eXBlKSkge1xuICAgIHN0cmVhbU9iamVjdFR5cGVbb2JqZWN0LnR5cGVdKG9iamVjdCwgc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW1HZW9tZXRyeShvYmplY3QsIHN0cmVhbSk7XG4gIH1cbn1cblxudmFyIGFyZWFSaW5nU3VtID0gYWRkZXIoKTtcblxudmFyIGFyZWFTdW0gPSBhZGRlcigpO1xudmFyIGxhbWJkYTAwO1xudmFyIHBoaTAwO1xudmFyIGxhbWJkYTA7XG52YXIgY29zUGhpMDtcbnZhciBzaW5QaGkwO1xuXG52YXIgYXJlYVN0cmVhbSA9IHtcbiAgcG9pbnQ6IG5vb3AsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBhcmVhUmluZ1N1bS5yZXNldCgpO1xuICAgIGFyZWFTdHJlYW0ubGluZVN0YXJ0ID0gYXJlYVJpbmdTdGFydDtcbiAgICBhcmVhU3RyZWFtLmxpbmVFbmQgPSBhcmVhUmluZ0VuZDtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWFSaW5nID0gK2FyZWFSaW5nU3VtO1xuICAgIGFyZWFTdW0uYWRkKGFyZWFSaW5nIDwgMCA/IHRhdSArIGFyZWFSaW5nIDogYXJlYVJpbmcpO1xuICAgIHRoaXMubGluZVN0YXJ0ID0gdGhpcy5saW5lRW5kID0gdGhpcy5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN1bS5hZGQodGF1KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYXJlYVJpbmdTdGFydCgpIHtcbiAgYXJlYVN0cmVhbS5wb2ludCA9IGFyZWFQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBhcmVhUmluZ0VuZCgpIHtcbiAgYXJlYVBvaW50KGxhbWJkYTAwLCBwaGkwMCk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGFyZWFTdHJlYW0ucG9pbnQgPSBhcmVhUG9pbnQ7XG4gIGxhbWJkYTAwID0gbGFtYmRhLCBwaGkwMCA9IHBoaTtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zKHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGkpLCBzaW5QaGkwID0gc2luKHBoaSk7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHBoaSA9IHBoaSAvIDIgKyBxdWFydGVyUGk7IC8vIGhhbGYgdGhlIGFuZ3VsYXIgZGlzdGFuY2UgZnJvbSBzb3V0aCBwb2xlXG5cbiAgLy8gU3BoZXJpY2FsIGV4Y2VzcyBFIGZvciBhIHNwaGVyaWNhbCB0cmlhbmdsZSB3aXRoIHZlcnRpY2VzOiBzb3V0aCBwb2xlLFxuICAvLyBwcmV2aW91cyBwb2ludCwgY3VycmVudCBwb2ludC4gIFVzZXMgYSBmb3JtdWxhIGRlcml2ZWQgZnJvbSBDYWdub2xp4oCZc1xuICAvLyB0aGVvcmVtLiAgU2VlIFRvZGh1bnRlciwgU3BoZXJpY2FsIFRyaWcuICgxODcxKSwgU2VjLiAxMDMsIEVxLiAoMikuXG4gIHZhciBkTGFtYmRhID0gbGFtYmRhIC0gbGFtYmRhMCxcbiAgICAgIHNkTGFtYmRhID0gZExhbWJkYSA+PSAwID8gMSA6IC0xLFxuICAgICAgYWRMYW1iZGEgPSBzZExhbWJkYSAqIGRMYW1iZGEsXG4gICAgICBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHNpblBoaSA9IHNpbihwaGkpLFxuICAgICAgayA9IHNpblBoaTAgKiBzaW5QaGksXG4gICAgICB1ID0gY29zUGhpMCAqIGNvc1BoaSArIGsgKiBjb3MoYWRMYW1iZGEpLFxuICAgICAgdiA9IGsgKiBzZExhbWJkYSAqIHNpbihhZExhbWJkYSk7XG4gIGFyZWFSaW5nU3VtLmFkZChhdGFuMih2LCB1KSk7XG5cbiAgLy8gQWR2YW5jZSB0aGUgcHJldmlvdXMgcG9pbnRzLlxuICBsYW1iZGEwID0gbGFtYmRhLCBjb3NQaGkwID0gY29zUGhpLCBzaW5QaGkwID0gc2luUGhpO1xufVxuXG5mdW5jdGlvbiBhcmVhKG9iamVjdCkge1xuICBhcmVhU3VtLnJlc2V0KCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIGFyZWFTdHJlYW0pO1xuICByZXR1cm4gYXJlYVN1bSAqIDI7XG59XG5cbmZ1bmN0aW9uIHNwaGVyaWNhbChjYXJ0ZXNpYW4pIHtcbiAgcmV0dXJuIFthdGFuMihjYXJ0ZXNpYW5bMV0sIGNhcnRlc2lhblswXSksIGFzaW4oY2FydGVzaWFuWzJdKV07XG59XG5cbmZ1bmN0aW9uIGNhcnRlc2lhbihzcGhlcmljYWwpIHtcbiAgdmFyIGxhbWJkYSA9IHNwaGVyaWNhbFswXSwgcGhpID0gc3BoZXJpY2FsWzFdLCBjb3NQaGkgPSBjb3MocGhpKTtcbiAgcmV0dXJuIFtjb3NQaGkgKiBjb3MobGFtYmRhKSwgY29zUGhpICogc2luKGxhbWJkYSksIHNpbihwaGkpXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuRG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuQ3Jvc3MoYSwgYikge1xuICByZXR1cm4gW2FbMV0gKiBiWzJdIC0gYVsyXSAqIGJbMV0sIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1dO1xufVxuXG4vLyBUT0RPIHJldHVybiBhXG5mdW5jdGlvbiBjYXJ0ZXNpYW5BZGRJblBsYWNlKGEsIGIpIHtcbiAgYVswXSArPSBiWzBdLCBhWzFdICs9IGJbMV0sIGFbMl0gKz0gYlsyXTtcbn1cblxuZnVuY3Rpb24gY2FydGVzaWFuU2NhbGUodmVjdG9yLCBrKSB7XG4gIHJldHVybiBbdmVjdG9yWzBdICogaywgdmVjdG9yWzFdICogaywgdmVjdG9yWzJdICoga107XG59XG5cbi8vIFRPRE8gcmV0dXJuIGRcbmZ1bmN0aW9uIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoZCkge1xuICB2YXIgbCA9IHNxcnQoZFswXSAqIGRbMF0gKyBkWzFdICogZFsxXSArIGRbMl0gKiBkWzJdKTtcbiAgZFswXSAvPSBsLCBkWzFdIC89IGwsIGRbMl0gLz0gbDtcbn1cblxudmFyIGxhbWJkYTAkMTtcbnZhciBwaGkwO1xudmFyIGxhbWJkYTE7XG52YXIgcGhpMTtcbnZhciBsYW1iZGEyO1xudmFyIGxhbWJkYTAwJDE7XG52YXIgcGhpMDAkMTtcbnZhciBwMDtcbnZhciBkZWx0YVN1bSA9IGFkZGVyKCk7XG52YXIgcmFuZ2VzO1xudmFyIHJhbmdlJDE7XG5cbnZhciBib3VuZHNTdHJlYW0gPSB7XG4gIHBvaW50OiBib3VuZHNQb2ludCxcbiAgbGluZVN0YXJ0OiBib3VuZHNMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IGJvdW5kc0xpbmVFbmQsXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUmluZ1BvaW50O1xuICAgIGJvdW5kc1N0cmVhbS5saW5lU3RhcnQgPSBib3VuZHNSaW5nU3RhcnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVFbmQgPSBib3VuZHNSaW5nRW5kO1xuICAgIGRlbHRhU3VtLnJlc2V0KCk7XG4gICAgYXJlYVN0cmVhbS5wb2x5Z29uU3RhcnQoKTtcbiAgfSxcbiAgcG9seWdvbkVuZDogZnVuY3Rpb24oKSB7XG4gICAgYXJlYVN0cmVhbS5wb2x5Z29uRW5kKCk7XG4gICAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gICAgYm91bmRzU3RyZWFtLmxpbmVTdGFydCA9IGJvdW5kc0xpbmVTdGFydDtcbiAgICBib3VuZHNTdHJlYW0ubGluZUVuZCA9IGJvdW5kc0xpbmVFbmQ7XG4gICAgaWYgKGFyZWFSaW5nU3VtIDwgMCkgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKSwgcGhpMCA9IC0ocGhpMSA9IDkwKTtcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA+IGVwc2lsb24pIHBoaTEgPSA5MDtcbiAgICBlbHNlIGlmIChkZWx0YVN1bSA8IC1lcHNpbG9uKSBwaGkwID0gLTkwO1xuICAgIHJhbmdlJDFbMF0gPSBsYW1iZGEwJDEsIHJhbmdlJDFbMV0gPSBsYW1iZGExO1xuICB9XG59O1xuXG5mdW5jdGlvbiBib3VuZHNQb2ludChsYW1iZGEsIHBoaSkge1xuICByYW5nZXMucHVzaChyYW5nZSQxID0gW2xhbWJkYTAkMSA9IGxhbWJkYSwgbGFtYmRhMSA9IGxhbWJkYV0pO1xuICBpZiAocGhpIDwgcGhpMCkgcGhpMCA9IHBoaTtcbiAgaWYgKHBoaSA+IHBoaTEpIHBoaTEgPSBwaGk7XG59XG5cbmZ1bmN0aW9uIGxpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICB2YXIgcCA9IGNhcnRlc2lhbihbbGFtYmRhICogcmFkaWFucywgcGhpICogcmFkaWFuc10pO1xuICBpZiAocDApIHtcbiAgICB2YXIgbm9ybWFsID0gY2FydGVzaWFuQ3Jvc3MocDAsIHApLFxuICAgICAgICBlcXVhdG9yaWFsID0gW25vcm1hbFsxXSwgLW5vcm1hbFswXSwgMF0sXG4gICAgICAgIGluZmxlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhlcXVhdG9yaWFsLCBub3JtYWwpO1xuICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW5mbGVjdGlvbik7XG4gICAgaW5mbGVjdGlvbiA9IHNwaGVyaWNhbChpbmZsZWN0aW9uKTtcbiAgICB2YXIgZGVsdGEgPSBsYW1iZGEgLSBsYW1iZGEyLFxuICAgICAgICBzaWduJCQxID0gZGVsdGEgPiAwID8gMSA6IC0xLFxuICAgICAgICBsYW1iZGFpID0gaW5mbGVjdGlvblswXSAqIGRlZ3JlZXMgKiBzaWduJCQxLFxuICAgICAgICBwaGlpLFxuICAgICAgICBhbnRpbWVyaWRpYW4gPSBhYnMoZGVsdGEpID4gMTgwO1xuICAgIGlmIChhbnRpbWVyaWRpYW4gXiAoc2lnbiQkMSAqIGxhbWJkYTIgPCBsYW1iZGFpICYmIGxhbWJkYWkgPCBzaWduJCQxICogbGFtYmRhKSkge1xuICAgICAgcGhpaSA9IGluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPiBwaGkxKSBwaGkxID0gcGhpaTtcbiAgICB9IGVsc2UgaWYgKGxhbWJkYWkgPSAobGFtYmRhaSArIDM2MCkgJSAzNjAgLSAxODAsIGFudGltZXJpZGlhbiBeIChzaWduJCQxICogbGFtYmRhMiA8IGxhbWJkYWkgJiYgbGFtYmRhaSA8IHNpZ24kJDEgKiBsYW1iZGEpKSB7XG4gICAgICBwaGlpID0gLWluZmxlY3Rpb25bMV0gKiBkZWdyZWVzO1xuICAgICAgaWYgKHBoaWkgPCBwaGkwKSBwaGkwID0gcGhpaTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gICAgICBpZiAocGhpID4gcGhpMSkgcGhpMSA9IHBoaTtcbiAgICB9XG4gICAgaWYgKGFudGltZXJpZGlhbikge1xuICAgICAgaWYgKGxhbWJkYSA8IGxhbWJkYTIpIHtcbiAgICAgICAgaWYgKGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYW5nbGUobGFtYmRhLCBsYW1iZGExKSA+IGFuZ2xlKGxhbWJkYTAkMSwgbGFtYmRhMSkpIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxhbWJkYTEgPj0gbGFtYmRhMCQxKSB7XG4gICAgICAgIGlmIChsYW1iZGEgPCBsYW1iZGEwJDEpIGxhbWJkYTAkMSA9IGxhbWJkYTtcbiAgICAgICAgaWYgKGxhbWJkYSA+IGxhbWJkYTEpIGxhbWJkYTEgPSBsYW1iZGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobGFtYmRhID4gbGFtYmRhMikge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEwJDEsIGxhbWJkYSkgPiBhbmdsZShsYW1iZGEwJDEsIGxhbWJkYTEpKSBsYW1iZGExID0gbGFtYmRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmdsZShsYW1iZGEsIGxhbWJkYTEpID4gYW5nbGUobGFtYmRhMCQxLCBsYW1iZGExKSkgbGFtYmRhMCQxID0gbGFtYmRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJhbmdlcy5wdXNoKHJhbmdlJDEgPSBbbGFtYmRhMCQxID0gbGFtYmRhLCBsYW1iZGExID0gbGFtYmRhXSk7XG4gIH1cbiAgaWYgKHBoaSA8IHBoaTApIHBoaTAgPSBwaGk7XG4gIGlmIChwaGkgPiBwaGkxKSBwaGkxID0gcGhpO1xuICBwMCA9IHAsIGxhbWJkYTIgPSBsYW1iZGE7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0xpbmVTdGFydCgpIHtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gbGluZVBvaW50O1xufVxuXG5mdW5jdGlvbiBib3VuZHNMaW5lRW5kKCkge1xuICByYW5nZSQxWzBdID0gbGFtYmRhMCQxLCByYW5nZSQxWzFdID0gbGFtYmRhMTtcbiAgYm91bmRzU3RyZWFtLnBvaW50ID0gYm91bmRzUG9pbnQ7XG4gIHAwID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYm91bmRzUmluZ1BvaW50KGxhbWJkYSwgcGhpKSB7XG4gIGlmIChwMCkge1xuICAgIHZhciBkZWx0YSA9IGxhbWJkYSAtIGxhbWJkYTI7XG4gICAgZGVsdGFTdW0uYWRkKGFicyhkZWx0YSkgPiAxODAgPyBkZWx0YSArIChkZWx0YSA+IDAgPyAzNjAgOiAtMzYwKSA6IGRlbHRhKTtcbiAgfSBlbHNlIHtcbiAgICBsYW1iZGEwMCQxID0gbGFtYmRhLCBwaGkwMCQxID0gcGhpO1xuICB9XG4gIGFyZWFTdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICBsaW5lUG9pbnQobGFtYmRhLCBwaGkpO1xufVxuXG5mdW5jdGlvbiBib3VuZHNSaW5nU3RhcnQoKSB7XG4gIGFyZWFTdHJlYW0ubGluZVN0YXJ0KCk7XG59XG5cbmZ1bmN0aW9uIGJvdW5kc1JpbmdFbmQoKSB7XG4gIGJvdW5kc1JpbmdQb2ludChsYW1iZGEwMCQxLCBwaGkwMCQxKTtcbiAgYXJlYVN0cmVhbS5saW5lRW5kKCk7XG4gIGlmIChhYnMoZGVsdGFTdW0pID4gZXBzaWxvbikgbGFtYmRhMCQxID0gLShsYW1iZGExID0gMTgwKTtcbiAgcmFuZ2UkMVswXSA9IGxhbWJkYTAkMSwgcmFuZ2UkMVsxXSA9IGxhbWJkYTE7XG4gIHAwID0gbnVsbDtcbn1cblxuLy8gRmluZHMgdGhlIGxlZnQtcmlnaHQgZGlzdGFuY2UgYmV0d2VlbiB0d28gbG9uZ2l0dWRlcy5cbi8vIFRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIChsYW1iZGExIC0gbGFtYmRhMCArIDM2MMKwKSAlIDM2MMKwLCBleGNlcHQgdGhhdCB3ZSB3YW50XG4vLyB0aGUgZGlzdGFuY2UgYmV0d2VlbiDCsTE4MMKwIHRvIGJlIDM2MMKwLlxuZnVuY3Rpb24gYW5nbGUobGFtYmRhMCwgbGFtYmRhMSkge1xuICByZXR1cm4gKGxhbWJkYTEgLT0gbGFtYmRhMCkgPCAwID8gbGFtYmRhMSArIDM2MCA6IGxhbWJkYTE7XG59XG5cbmZ1bmN0aW9uIHJhbmdlQ29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXTtcbn1cblxuZnVuY3Rpb24gcmFuZ2VDb250YWlucyhyYW5nZSQkMSwgeCkge1xuICByZXR1cm4gcmFuZ2UkJDFbMF0gPD0gcmFuZ2UkJDFbMV0gPyByYW5nZSQkMVswXSA8PSB4ICYmIHggPD0gcmFuZ2UkJDFbMV0gOiB4IDwgcmFuZ2UkJDFbMF0gfHwgcmFuZ2UkJDFbMV0gPCB4O1xufVxuXG5mdW5jdGlvbiBib3VuZHMoZmVhdHVyZSkge1xuICB2YXIgaSwgbiwgYSwgYiwgbWVyZ2VkLCBkZWx0YU1heCwgZGVsdGE7XG5cbiAgcGhpMSA9IGxhbWJkYTEgPSAtKGxhbWJkYTAkMSA9IHBoaTAgPSBJbmZpbml0eSk7XG4gIHJhbmdlcyA9IFtdO1xuICBnZW9TdHJlYW0oZmVhdHVyZSwgYm91bmRzU3RyZWFtKTtcblxuICAvLyBGaXJzdCwgc29ydCByYW5nZXMgYnkgdGhlaXIgbWluaW11bSBsb25naXR1ZGVzLlxuICBpZiAobiA9IHJhbmdlcy5sZW5ndGgpIHtcbiAgICByYW5nZXMuc29ydChyYW5nZUNvbXBhcmUpO1xuXG4gICAgLy8gVGhlbiwgbWVyZ2UgYW55IHJhbmdlcyB0aGF0IG92ZXJsYXAuXG4gICAgZm9yIChpID0gMSwgYSA9IHJhbmdlc1swXSwgbWVyZ2VkID0gW2FdOyBpIDwgbjsgKytpKSB7XG4gICAgICBiID0gcmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlQ29udGFpbnMoYSwgYlswXSkgfHwgcmFuZ2VDb250YWlucyhhLCBiWzFdKSkge1xuICAgICAgICBpZiAoYW5nbGUoYVswXSwgYlsxXSkgPiBhbmdsZShhWzBdLCBhWzFdKSkgYVsxXSA9IGJbMV07XG4gICAgICAgIGlmIChhbmdsZShiWzBdLCBhWzFdKSA+IGFuZ2xlKGFbMF0sIGFbMV0pKSBhWzBdID0gYlswXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lcmdlZC5wdXNoKGEgPSBiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGaW5hbGx5LCBmaW5kIHRoZSBsYXJnZXN0IGdhcCBiZXR3ZWVuIHRoZSBtZXJnZWQgcmFuZ2VzLlxuICAgIC8vIFRoZSBmaW5hbCBib3VuZGluZyBib3ggd2lsbCBiZSB0aGUgaW52ZXJzZSBvZiB0aGlzIGdhcC5cbiAgICBmb3IgKGRlbHRhTWF4ID0gLUluZmluaXR5LCBuID0gbWVyZ2VkLmxlbmd0aCAtIDEsIGkgPSAwLCBhID0gbWVyZ2VkW25dOyBpIDw9IG47IGEgPSBiLCArK2kpIHtcbiAgICAgIGIgPSBtZXJnZWRbaV07XG4gICAgICBpZiAoKGRlbHRhID0gYW5nbGUoYVsxXSwgYlswXSkpID4gZGVsdGFNYXgpIGRlbHRhTWF4ID0gZGVsdGEsIGxhbWJkYTAkMSA9IGJbMF0sIGxhbWJkYTEgPSBhWzFdO1xuICAgIH1cbiAgfVxuXG4gIHJhbmdlcyA9IHJhbmdlJDEgPSBudWxsO1xuXG4gIHJldHVybiBsYW1iZGEwJDEgPT09IEluZmluaXR5IHx8IHBoaTAgPT09IEluZmluaXR5XG4gICAgICA/IFtbTmFOLCBOYU5dLCBbTmFOLCBOYU5dXVxuICAgICAgOiBbW2xhbWJkYTAkMSwgcGhpMF0sIFtsYW1iZGExLCBwaGkxXV07XG59XG5cbnZhciBXMDtcbnZhciBXMTtcbnZhciBYMDtcbnZhciBZMDtcbnZhciBaMDtcbnZhciBYMTtcbnZhciBZMTtcbnZhciBaMTtcbnZhciBYMjtcbnZhciBZMjtcbnZhciBaMjtcbnZhciBsYW1iZGEwMCQyO1xudmFyIHBoaTAwJDI7XG52YXIgeDA7XG52YXIgeTA7XG52YXIgejA7IC8vIHByZXZpb3VzIHBvaW50XG5cbnZhciBjZW50cm9pZFN0cmVhbSA9IHtcbiAgc3BoZXJlOiBub29wLFxuICBwb2ludDogY2VudHJvaWRQb2ludCxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCxcbiAgbGluZUVuZDogY2VudHJvaWRMaW5lRW5kLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZFJpbmdFbmQ7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVTdGFydCA9IGNlbnRyb2lkTGluZVN0YXJ0O1xuICAgIGNlbnRyb2lkU3RyZWFtLmxpbmVFbmQgPSBjZW50cm9pZExpbmVFbmQ7XG4gIH1cbn07XG5cbi8vIEFyaXRobWV0aWMgbWVhbiBvZiBDYXJ0ZXNpYW4gdmVjdG9ycy5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oY29zUGhpICogY29zKGxhbWJkYSksIGNvc1BoaSAqIHNpbihsYW1iZGEpLCBzaW4ocGhpKSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeCwgeSwgeikge1xuICArK1cwO1xuICBYMCArPSAoeCAtIFgwKSAvIFcwO1xuICBZMCArPSAoeSAtIFkwKSAvIFcwO1xuICBaMCArPSAoeiAtIFowKSAvIFcwO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZExpbmVQb2ludEZpcnN0O1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludEZpcnN0KGxhbWJkYSwgcGhpKSB7XG4gIGxhbWJkYSAqPSByYWRpYW5zLCBwaGkgKj0gcmFkaWFucztcbiAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpO1xuICB4MCA9IGNvc1BoaSAqIGNvcyhsYW1iZGEpO1xuICB5MCA9IGNvc1BoaSAqIHNpbihsYW1iZGEpO1xuICB6MCA9IHNpbihwaGkpO1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkTGluZVBvaW50O1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVQb2ludChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIHggPSBjb3NQaGkgKiBjb3MobGFtYmRhKSxcbiAgICAgIHkgPSBjb3NQaGkgKiBzaW4obGFtYmRhKSxcbiAgICAgIHogPSBzaW4ocGhpKSxcbiAgICAgIHcgPSBhdGFuMihzcXJ0KCh3ID0geTAgKiB6IC0gejAgKiB5KSAqIHcgKyAodyA9IHowICogeCAtIHgwICogeikgKiB3ICsgKHcgPSB4MCAqIHkgLSB5MCAqIHgpICogdyksIHgwICogeCArIHkwICogeSArIHowICogeik7XG4gIFcxICs9IHc7XG4gIFgxICs9IHcgKiAoeDAgKyAoeDAgPSB4KSk7XG4gIFkxICs9IHcgKiAoeTAgKyAoeTAgPSB5KSk7XG4gIFoxICs9IHcgKiAoejAgKyAoejAgPSB6KSk7XG4gIGNlbnRyb2lkUG9pbnRDYXJ0ZXNpYW4oeDAsIHkwLCB6MCk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkTGluZUVuZCgpIHtcbiAgY2VudHJvaWRTdHJlYW0ucG9pbnQgPSBjZW50cm9pZFBvaW50O1xufVxuXG4vLyBTZWUgSi4gRS4gQnJvY2ssIFRoZSBJbmVydGlhIFRlbnNvciBmb3IgYSBTcGhlcmljYWwgVHJpYW5nbGUsXG4vLyBKLiBBcHBsaWVkIE1lY2hhbmljcyA0MiwgMjM5ICgxOTc1KS5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ1N0YXJ0KCkge1xuICBjZW50cm9pZFN0cmVhbS5wb2ludCA9IGNlbnRyb2lkUmluZ1BvaW50Rmlyc3Q7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCgpIHtcbiAgY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhMDAkMiwgcGhpMDAkMik7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRQb2ludDtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEwMCQyID0gbGFtYmRhLCBwaGkwMCQyID0gcGhpO1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGNlbnRyb2lkU3RyZWFtLnBvaW50ID0gY2VudHJvaWRSaW5nUG9pbnQ7XG4gIHZhciBjb3NQaGkgPSBjb3MocGhpKTtcbiAgeDAgPSBjb3NQaGkgKiBjb3MobGFtYmRhKTtcbiAgeTAgPSBjb3NQaGkgKiBzaW4obGFtYmRhKTtcbiAgejAgPSBzaW4ocGhpKTtcbiAgY2VudHJvaWRQb2ludENhcnRlc2lhbih4MCwgeTAsIHowKTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICB4ID0gY29zUGhpICogY29zKGxhbWJkYSksXG4gICAgICB5ID0gY29zUGhpICogc2luKGxhbWJkYSksXG4gICAgICB6ID0gc2luKHBoaSksXG4gICAgICBjeCA9IHkwICogeiAtIHowICogeSxcbiAgICAgIGN5ID0gejAgKiB4IC0geDAgKiB6LFxuICAgICAgY3ogPSB4MCAqIHkgLSB5MCAqIHgsXG4gICAgICBtID0gc3FydChjeCAqIGN4ICsgY3kgKiBjeSArIGN6ICogY3opLFxuICAgICAgdyA9IGFzaW4obSksIC8vIGxpbmUgd2VpZ2h0ID0gYW5nbGVcbiAgICAgIHYgPSBtICYmIC13IC8gbTsgLy8gYXJlYSB3ZWlnaHQgbXVsdGlwbGllclxuICBYMiArPSB2ICogY3g7XG4gIFkyICs9IHYgKiBjeTtcbiAgWjIgKz0gdiAqIGN6O1xuICBXMSArPSB3O1xuICBYMSArPSB3ICogKHgwICsgKHgwID0geCkpO1xuICBZMSArPSB3ICogKHkwICsgKHkwID0geSkpO1xuICBaMSArPSB3ICogKHowICsgKHowID0geikpO1xuICBjZW50cm9pZFBvaW50Q2FydGVzaWFuKHgwLCB5MCwgejApO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZChvYmplY3QpIHtcbiAgVzAgPSBXMSA9XG4gIFgwID0gWTAgPSBaMCA9XG4gIFgxID0gWTEgPSBaMSA9XG4gIFgyID0gWTIgPSBaMiA9IDA7XG4gIGdlb1N0cmVhbShvYmplY3QsIGNlbnRyb2lkU3RyZWFtKTtcblxuICB2YXIgeCA9IFgyLFxuICAgICAgeSA9IFkyLFxuICAgICAgeiA9IFoyLFxuICAgICAgbSA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICAvLyBJZiB0aGUgYXJlYS13ZWlnaHRlZCBjY2VudHJvaWQgaXMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbGVuZ3RoLXdlaWdodGVkIGNjZW50cm9pZC5cbiAgaWYgKG0gPCBlcHNpbG9uMikge1xuICAgIHggPSBYMSwgeSA9IFkxLCB6ID0gWjE7XG4gICAgLy8gSWYgdGhlIGZlYXR1cmUgaGFzIHplcm8gbGVuZ3RoLCBmYWxsIGJhY2sgdG8gYXJpdGhtZXRpYyBtZWFuIG9mIHBvaW50IHZlY3RvcnMuXG4gICAgaWYgKFcxIDwgZXBzaWxvbikgeCA9IFgwLCB5ID0gWTAsIHogPSBaMDtcbiAgICBtID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgIC8vIElmIHRoZSBmZWF0dXJlIHN0aWxsIGhhcyBhbiB1bmRlZmluZWQgY2NlbnRyb2lkLCB0aGVuIHJldHVybi5cbiAgICBpZiAobSA8IGVwc2lsb24yKSByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuXG4gIHJldHVybiBbYXRhbjIoeSwgeCkgKiBkZWdyZWVzLCBhc2luKHogLyBzcXJ0KG0pKSAqIGRlZ3JlZXNdO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29tcG9zZShhLCBiKSB7XG5cbiAgZnVuY3Rpb24gY29tcG9zZSh4LCB5KSB7XG4gICAgcmV0dXJuIHggPSBhKHgsIHkpLCBiKHhbMF0sIHhbMV0pO1xuICB9XG5cbiAgaWYgKGEuaW52ZXJ0ICYmIGIuaW52ZXJ0KSBjb21wb3NlLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA9IGIuaW52ZXJ0KHgsIHkpLCB4ICYmIGEuaW52ZXJ0KHhbMF0sIHhbMV0pO1xuICB9O1xuXG4gIHJldHVybiBjb21wb3NlO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbklkZW50aXR5KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhID4gcGkgPyBsYW1iZGEgLSB0YXUgOiBsYW1iZGEgPCAtcGkgPyBsYW1iZGEgKyB0YXUgOiBsYW1iZGEsIHBoaV07XG59XG5cbnJvdGF0aW9uSWRlbnRpdHkuaW52ZXJ0ID0gcm90YXRpb25JZGVudGl0eTtcblxuZnVuY3Rpb24gcm90YXRlUmFkaWFucyhkZWx0YUxhbWJkYSwgZGVsdGFQaGksIGRlbHRhR2FtbWEpIHtcbiAgcmV0dXJuIChkZWx0YUxhbWJkYSAlPSB0YXUpID8gKGRlbHRhUGhpIHx8IGRlbHRhR2FtbWEgPyBjb21wb3NlKHJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSwgcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkpXG4gICAgOiByb3RhdGlvbkxhbWJkYShkZWx0YUxhbWJkYSkpXG4gICAgOiAoZGVsdGFQaGkgfHwgZGVsdGFHYW1tYSA/IHJvdGF0aW9uUGhpR2FtbWEoZGVsdGFQaGksIGRlbHRhR2FtbWEpXG4gICAgOiByb3RhdGlvbklkZW50aXR5KTtcbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKSB7XG4gIHJldHVybiBmdW5jdGlvbihsYW1iZGEsIHBoaSkge1xuICAgIHJldHVybiBsYW1iZGEgKz0gZGVsdGFMYW1iZGEsIFtsYW1iZGEgPiBwaSA/IGxhbWJkYSAtIHRhdSA6IGxhbWJkYSA8IC1waSA/IGxhbWJkYSArIHRhdSA6IGxhbWJkYSwgcGhpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25MYW1iZGEoZGVsdGFMYW1iZGEpIHtcbiAgdmFyIHJvdGF0aW9uID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKGRlbHRhTGFtYmRhKTtcbiAgcm90YXRpb24uaW52ZXJ0ID0gZm9yd2FyZFJvdGF0aW9uTGFtYmRhKC1kZWx0YUxhbWJkYSk7XG4gIHJldHVybiByb3RhdGlvbjtcbn1cblxuZnVuY3Rpb24gcm90YXRpb25QaGlHYW1tYShkZWx0YVBoaSwgZGVsdGFHYW1tYSkge1xuICB2YXIgY29zRGVsdGFQaGkgPSBjb3MoZGVsdGFQaGkpLFxuICAgICAgc2luRGVsdGFQaGkgPSBzaW4oZGVsdGFQaGkpLFxuICAgICAgY29zRGVsdGFHYW1tYSA9IGNvcyhkZWx0YUdhbW1hKSxcbiAgICAgIHNpbkRlbHRhR2FtbWEgPSBzaW4oZGVsdGFHYW1tYSk7XG5cbiAgZnVuY3Rpb24gcm90YXRpb24obGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgY29zUGhpID0gY29zKHBoaSksXG4gICAgICAgIHggPSBjb3MobGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeSA9IHNpbihsYW1iZGEpICogY29zUGhpLFxuICAgICAgICB6ID0gc2luKHBoaSksXG4gICAgICAgIGsgPSB6ICogY29zRGVsdGFQaGkgKyB4ICogc2luRGVsdGFQaGk7XG4gICAgcmV0dXJuIFtcbiAgICAgIGF0YW4yKHkgKiBjb3NEZWx0YUdhbW1hIC0gayAqIHNpbkRlbHRhR2FtbWEsIHggKiBjb3NEZWx0YVBoaSAtIHogKiBzaW5EZWx0YVBoaSksXG4gICAgICBhc2luKGsgKiBjb3NEZWx0YUdhbW1hICsgeSAqIHNpbkRlbHRhR2FtbWEpXG4gICAgXTtcbiAgfVxuXG4gIHJvdGF0aW9uLmludmVydCA9IGZ1bmN0aW9uKGxhbWJkYSwgcGhpKSB7XG4gICAgdmFyIGNvc1BoaSA9IGNvcyhwaGkpLFxuICAgICAgICB4ID0gY29zKGxhbWJkYSkgKiBjb3NQaGksXG4gICAgICAgIHkgPSBzaW4obGFtYmRhKSAqIGNvc1BoaSxcbiAgICAgICAgeiA9IHNpbihwaGkpLFxuICAgICAgICBrID0geiAqIGNvc0RlbHRhR2FtbWEgLSB5ICogc2luRGVsdGFHYW1tYTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSAqIGNvc0RlbHRhR2FtbWEgKyB6ICogc2luRGVsdGFHYW1tYSwgeCAqIGNvc0RlbHRhUGhpICsgayAqIHNpbkRlbHRhUGhpKSxcbiAgICAgIGFzaW4oayAqIGNvc0RlbHRhUGhpIC0geCAqIHNpbkRlbHRhUGhpKVxuICAgIF07XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0aW9uO1xufVxuXG5mdW5jdGlvbiByb3RhdGlvbihyb3RhdGUpIHtcbiAgcm90YXRlID0gcm90YXRlUmFkaWFucyhyb3RhdGVbMF0gKiByYWRpYW5zLCByb3RhdGVbMV0gKiByYWRpYW5zLCByb3RhdGUubGVuZ3RoID4gMiA/IHJvdGF0ZVsyXSAqIHJhZGlhbnMgOiAwKTtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGNvb3JkaW5hdGVzKSB7XG4gICAgY29vcmRpbmF0ZXMgPSByb3RhdGUoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oY29vcmRpbmF0ZXMpIHtcbiAgICBjb29yZGluYXRlcyA9IHJvdGF0ZS5pbnZlcnQoY29vcmRpbmF0ZXNbMF0gKiByYWRpYW5zLCBjb29yZGluYXRlc1sxXSAqIHJhZGlhbnMpO1xuICAgIHJldHVybiBjb29yZGluYXRlc1swXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlc1sxXSAqPSBkZWdyZWVzLCBjb29yZGluYXRlcztcbiAgfTtcblxuICByZXR1cm4gZm9yd2FyZDtcbn1cblxuLy8gR2VuZXJhdGVzIGEgY2lyY2xlIGNlbnRlcmVkIGF0IFswwrAsIDDCsF0sIHdpdGggYSBnaXZlbiByYWRpdXMgYW5kIHByZWNpc2lvbi5cbmZ1bmN0aW9uIGNpcmNsZVN0cmVhbShzdHJlYW0sIHJhZGl1cywgZGVsdGEsIGRpcmVjdGlvbiwgdDAsIHQxKSB7XG4gIGlmICghZGVsdGEpIHJldHVybjtcbiAgdmFyIGNvc1JhZGl1cyA9IGNvcyhyYWRpdXMpLFxuICAgICAgc2luUmFkaXVzID0gc2luKHJhZGl1cyksXG4gICAgICBzdGVwID0gZGlyZWN0aW9uICogZGVsdGE7XG4gIGlmICh0MCA9PSBudWxsKSB7XG4gICAgdDAgPSByYWRpdXMgKyBkaXJlY3Rpb24gKiB0YXU7XG4gICAgdDEgPSByYWRpdXMgLSBzdGVwIC8gMjtcbiAgfSBlbHNlIHtcbiAgICB0MCA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQwKTtcbiAgICB0MSA9IGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHQxKTtcbiAgICBpZiAoZGlyZWN0aW9uID4gMCA/IHQwIDwgdDEgOiB0MCA+IHQxKSB0MCArPSBkaXJlY3Rpb24gKiB0YXU7XG4gIH1cbiAgZm9yICh2YXIgcG9pbnQsIHQgPSB0MDsgZGlyZWN0aW9uID4gMCA/IHQgPiB0MSA6IHQgPCB0MTsgdCAtPSBzdGVwKSB7XG4gICAgcG9pbnQgPSBzcGhlcmljYWwoW2Nvc1JhZGl1cywgLXNpblJhZGl1cyAqIGNvcyh0KSwgLXNpblJhZGl1cyAqIHNpbih0KV0pO1xuICAgIHN0cmVhbS5wb2ludChwb2ludFswXSwgcG9pbnRbMV0pO1xuICB9XG59XG5cbi8vIFJldHVybnMgdGhlIHNpZ25lZCBhbmdsZSBvZiBhIGNhcnRlc2lhbiBwb2ludCByZWxhdGl2ZSB0byBbY29zUmFkaXVzLCAwLCAwXS5cbmZ1bmN0aW9uIGNpcmNsZVJhZGl1cyhjb3NSYWRpdXMsIHBvaW50KSB7XG4gIHBvaW50ID0gY2FydGVzaWFuKHBvaW50KSwgcG9pbnRbMF0gLT0gY29zUmFkaXVzO1xuICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKHBvaW50KTtcbiAgdmFyIHJhZGl1cyA9IGFjb3MoLXBvaW50WzFdKTtcbiAgcmV0dXJuICgoLXBvaW50WzJdIDwgMCA/IC1yYWRpdXMgOiByYWRpdXMpICsgdGF1IC0gZXBzaWxvbikgJSB0YXU7XG59XG5cbmZ1bmN0aW9uIGNpcmNsZSgpIHtcbiAgdmFyIGNlbnRlciA9IGNvbnN0YW50KFswLCAwXSksXG4gICAgICByYWRpdXMgPSBjb25zdGFudCg5MCksXG4gICAgICBwcmVjaXNpb24gPSBjb25zdGFudCg2KSxcbiAgICAgIHJpbmcsXG4gICAgICByb3RhdGUsXG4gICAgICBzdHJlYW0gPSB7cG9pbnQ6IHBvaW50fTtcblxuICBmdW5jdGlvbiBwb2ludCh4LCB5KSB7XG4gICAgcmluZy5wdXNoKHggPSByb3RhdGUoeCwgeSkpO1xuICAgIHhbMF0gKj0gZGVncmVlcywgeFsxXSAqPSBkZWdyZWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY2lyY2xlKCkge1xuICAgIHZhciBjID0gY2VudGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIgPSByYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnMsXG4gICAgICAgIHAgPSBwcmVjaXNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSAqIHJhZGlhbnM7XG4gICAgcmluZyA9IFtdO1xuICAgIHJvdGF0ZSA9IHJvdGF0ZVJhZGlhbnMoLWNbMF0gKiByYWRpYW5zLCAtY1sxXSAqIHJhZGlhbnMsIDApLmludmVydDtcbiAgICBjaXJjbGVTdHJlYW0oc3RyZWFtLCByLCBwLCAxKTtcbiAgICBjID0ge3R5cGU6IFwiUG9seWdvblwiLCBjb29yZGluYXRlczogW3JpbmddfTtcbiAgICByaW5nID0gcm90YXRlID0gbnVsbDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGNpcmNsZS5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2VudGVyID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChbK19bMF0sICtfWzFdXSksIGNpcmNsZSkgOiBjZW50ZXI7XG4gIH07XG5cbiAgY2lyY2xlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgY2lyY2xlKSA6IHJhZGl1cztcbiAgfTtcblxuICBjaXJjbGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNpc2lvbiA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBjaXJjbGUpIDogcHJlY2lzaW9uO1xuICB9O1xuXG4gIHJldHVybiBjaXJjbGU7XG59XG5cbmZ1bmN0aW9uIGNsaXBCdWZmZXIoKSB7XG4gIHZhciBsaW5lcyA9IFtdLFxuICAgICAgbGluZTtcbiAgcmV0dXJuIHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgbGluZS5wdXNoKFt4LCB5XSk7XG4gICAgfSxcbiAgICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgbGluZXMucHVzaChsaW5lID0gW10pO1xuICAgIH0sXG4gICAgbGluZUVuZDogbm9vcCxcbiAgICByZWpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGxpbmVzLmxlbmd0aCA+IDEpIGxpbmVzLnB1c2gobGluZXMucG9wKCkuY29uY2F0KGxpbmVzLnNoaWZ0KCkpKTtcbiAgICB9LFxuICAgIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbGluZXM7XG4gICAgICBsaW5lcyA9IFtdO1xuICAgICAgbGluZSA9IG51bGw7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9pbnRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhYnMoYVswXSAtIGJbMF0pIDwgZXBzaWxvbiAmJiBhYnMoYVsxXSAtIGJbMV0pIDwgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gSW50ZXJzZWN0aW9uKHBvaW50LCBwb2ludHMsIG90aGVyLCBlbnRyeSkge1xuICB0aGlzLnggPSBwb2ludDtcbiAgdGhpcy56ID0gcG9pbnRzO1xuICB0aGlzLm8gPSBvdGhlcjsgLy8gYW5vdGhlciBpbnRlcnNlY3Rpb25cbiAgdGhpcy5lID0gZW50cnk7IC8vIGlzIGFuIGVudHJ5P1xuICB0aGlzLnYgPSBmYWxzZTsgLy8gdmlzaXRlZFxuICB0aGlzLm4gPSB0aGlzLnAgPSBudWxsOyAvLyBuZXh0ICYgcHJldmlvdXNcbn1cblxuLy8gQSBnZW5lcmFsaXplZCBwb2x5Z29uIGNsaXBwaW5nIGFsZ29yaXRobTogZ2l2ZW4gYSBwb2x5Z29uIHRoYXQgaGFzIGJlZW4gY3V0XG4vLyBpbnRvIGl0cyB2aXNpYmxlIGxpbmUgc2VnbWVudHMsIGFuZCByZWpvaW5zIHRoZSBzZWdtZW50cyBieSBpbnRlcnBvbGF0aW5nXG4vLyBhbG9uZyB0aGUgY2xpcCBlZGdlLlxuZnVuY3Rpb24gY2xpcFJlam9pbihzZWdtZW50cywgY29tcGFyZUludGVyc2VjdGlvbiwgc3RhcnRJbnNpZGUsIGludGVycG9sYXRlLCBzdHJlYW0pIHtcbiAgdmFyIHN1YmplY3QgPSBbXSxcbiAgICAgIGNsaXAgPSBbXSxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgIGlmICgobiA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPD0gMCkgcmV0dXJuO1xuICAgIHZhciBuLCBwMCA9IHNlZ21lbnRbMF0sIHAxID0gc2VnbWVudFtuXSwgeDtcblxuICAgIC8vIElmIHRoZSBmaXJzdCBhbmQgbGFzdCBwb2ludHMgb2YgYSBzZWdtZW50IGFyZSBjb2luY2lkZW50LCB0aGVuIHRyZWF0IGFzIGFcbiAgICAvLyBjbG9zZWQgcmluZy4gVE9ETyBpZiBhbGwgcmluZ3MgYXJlIGNsb3NlZCwgdGhlbiB0aGUgd2luZGluZyBvcmRlciBvZiB0aGVcbiAgICAvLyBleHRlcmlvciByaW5nIHNob3VsZCBiZSBjaGVja2VkLlxuICAgIGlmIChwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHN0cmVhbS5wb2ludCgocDAgPSBzZWdtZW50W2ldKVswXSwgcDBbMV0pO1xuICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDAsIHNlZ21lbnQsIG51bGwsIHRydWUpKTtcbiAgICBjbGlwLnB1c2goeC5vID0gbmV3IEludGVyc2VjdGlvbihwMCwgbnVsbCwgeCwgZmFsc2UpKTtcbiAgICBzdWJqZWN0LnB1c2goeCA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIHNlZ21lbnQsIG51bGwsIGZhbHNlKSk7XG4gICAgY2xpcC5wdXNoKHgubyA9IG5ldyBJbnRlcnNlY3Rpb24ocDEsIG51bGwsIHgsIHRydWUpKTtcbiAgfSk7XG5cbiAgaWYgKCFzdWJqZWN0Lmxlbmd0aCkgcmV0dXJuO1xuXG4gIGNsaXAuc29ydChjb21wYXJlSW50ZXJzZWN0aW9uKTtcbiAgbGluayhzdWJqZWN0KTtcbiAgbGluayhjbGlwKTtcblxuICBmb3IgKGkgPSAwLCBuID0gY2xpcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjbGlwW2ldLmUgPSBzdGFydEluc2lkZSA9ICFzdGFydEluc2lkZTtcbiAgfVxuXG4gIHZhciBzdGFydCA9IHN1YmplY3RbMF0sXG4gICAgICBwb2ludHMsXG4gICAgICBwb2ludDtcblxuICB3aGlsZSAoMSkge1xuICAgIC8vIEZpbmQgZmlyc3QgdW52aXNpdGVkIGludGVyc2VjdGlvbi5cbiAgICB2YXIgY3VycmVudCA9IHN0YXJ0LFxuICAgICAgICBpc1N1YmplY3QgPSB0cnVlO1xuICAgIHdoaWxlIChjdXJyZW50LnYpIGlmICgoY3VycmVudCA9IGN1cnJlbnQubikgPT09IHN0YXJ0KSByZXR1cm47XG4gICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICBkbyB7XG4gICAgICBjdXJyZW50LnYgPSBjdXJyZW50Lm8udiA9IHRydWU7XG4gICAgICBpZiAoY3VycmVudC5lKSB7XG4gICAgICAgIGlmIChpc1N1YmplY3QpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwLCBuID0gcG9pbnRzLmxlbmd0aDsgaSA8IG47ICsraSkgc3RyZWFtLnBvaW50KChwb2ludCA9IHBvaW50c1tpXSlbMF0sIHBvaW50WzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShjdXJyZW50LngsIGN1cnJlbnQubi54LCAxLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNTdWJqZWN0KSB7XG4gICAgICAgICAgcG9pbnRzID0gY3VycmVudC5wLno7XG4gICAgICAgICAgZm9yIChpID0gcG9pbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSBzdHJlYW0ucG9pbnQoKHBvaW50ID0gcG9pbnRzW2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVycG9sYXRlKGN1cnJlbnQueCwgY3VycmVudC5wLngsIC0xLCBzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnA7XG4gICAgICB9XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5vO1xuICAgICAgcG9pbnRzID0gY3VycmVudC56O1xuICAgICAgaXNTdWJqZWN0ID0gIWlzU3ViamVjdDtcbiAgICB9IHdoaWxlICghY3VycmVudC52KTtcbiAgICBzdHJlYW0ubGluZUVuZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmsoYXJyYXkpIHtcbiAgaWYgKCEobiA9IGFycmF5Lmxlbmd0aCkpIHJldHVybjtcbiAgdmFyIG4sXG4gICAgICBpID0gMCxcbiAgICAgIGEgPSBhcnJheVswXSxcbiAgICAgIGI7XG4gIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgYS5uID0gYiA9IGFycmF5W2ldO1xuICAgIGIucCA9IGE7XG4gICAgYSA9IGI7XG4gIH1cbiAgYS5uID0gYiA9IGFycmF5WzBdO1xuICBiLnAgPSBhO1xufVxuXG52YXIgc3VtID0gYWRkZXIoKTtcblxuZnVuY3Rpb24gcG9seWdvbkNvbnRhaW5zKHBvbHlnb24sIHBvaW50KSB7XG4gIHZhciBsYW1iZGEgPSBwb2ludFswXSxcbiAgICAgIHBoaSA9IHBvaW50WzFdLFxuICAgICAgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBub3JtYWwgPSBbc2luKGxhbWJkYSksIC1jb3MobGFtYmRhKSwgMF0sXG4gICAgICBhbmdsZSA9IDAsXG4gICAgICB3aW5kaW5nID0gMDtcblxuICBzdW0ucmVzZXQoKTtcblxuICBpZiAoc2luUGhpID09PSAxKSBwaGkgPSBoYWxmUGkgKyBlcHNpbG9uO1xuICBlbHNlIGlmIChzaW5QaGkgPT09IC0xKSBwaGkgPSAtaGFsZlBpIC0gZXBzaWxvbjtcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHBvbHlnb24ubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKCEobSA9IChyaW5nID0gcG9seWdvbltpXSkubGVuZ3RoKSkgY29udGludWU7XG4gICAgdmFyIHJpbmcsXG4gICAgICAgIG0sXG4gICAgICAgIHBvaW50MCA9IHJpbmdbbSAtIDFdLFxuICAgICAgICBsYW1iZGEwID0gcG9pbnQwWzBdLFxuICAgICAgICBwaGkwID0gcG9pbnQwWzFdIC8gMiArIHF1YXJ0ZXJQaSxcbiAgICAgICAgc2luUGhpMCA9IHNpbihwaGkwKSxcbiAgICAgICAgY29zUGhpMCA9IGNvcyhwaGkwKTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbTsgKytqLCBsYW1iZGEwID0gbGFtYmRhMSwgc2luUGhpMCA9IHNpblBoaTEsIGNvc1BoaTAgPSBjb3NQaGkxLCBwb2ludDAgPSBwb2ludDEpIHtcbiAgICAgIHZhciBwb2ludDEgPSByaW5nW2pdLFxuICAgICAgICAgIGxhbWJkYTEgPSBwb2ludDFbMF0sXG4gICAgICAgICAgcGhpMSA9IHBvaW50MVsxXSAvIDIgKyBxdWFydGVyUGksXG4gICAgICAgICAgc2luUGhpMSA9IHNpbihwaGkxKSxcbiAgICAgICAgICBjb3NQaGkxID0gY29zKHBoaTEpLFxuICAgICAgICAgIGRlbHRhID0gbGFtYmRhMSAtIGxhbWJkYTAsXG4gICAgICAgICAgc2lnbiQkMSA9IGRlbHRhID49IDAgPyAxIDogLTEsXG4gICAgICAgICAgYWJzRGVsdGEgPSBzaWduJCQxICogZGVsdGEsXG4gICAgICAgICAgYW50aW1lcmlkaWFuID0gYWJzRGVsdGEgPiBwaSxcbiAgICAgICAgICBrID0gc2luUGhpMCAqIHNpblBoaTE7XG5cbiAgICAgIHN1bS5hZGQoYXRhbjIoayAqIHNpZ24kJDEgKiBzaW4oYWJzRGVsdGEpLCBjb3NQaGkwICogY29zUGhpMSArIGsgKiBjb3MoYWJzRGVsdGEpKSk7XG4gICAgICBhbmdsZSArPSBhbnRpbWVyaWRpYW4gPyBkZWx0YSArIHNpZ24kJDEgKiB0YXUgOiBkZWx0YTtcblxuICAgICAgLy8gQXJlIHRoZSBsb25naXR1ZGVzIGVpdGhlciBzaWRlIG9mIHRoZSBwb2ludOKAmXMgbWVyaWRpYW4gKGxhbWJkYSksXG4gICAgICAvLyBhbmQgYXJlIHRoZSBsYXRpdHVkZXMgc21hbGxlciB0aGFuIHRoZSBwYXJhbGxlbCAocGhpKT9cbiAgICAgIGlmIChhbnRpbWVyaWRpYW4gXiBsYW1iZGEwID49IGxhbWJkYSBeIGxhbWJkYTEgPj0gbGFtYmRhKSB7XG4gICAgICAgIHZhciBhcmMgPSBjYXJ0ZXNpYW5Dcm9zcyhjYXJ0ZXNpYW4ocG9pbnQwKSwgY2FydGVzaWFuKHBvaW50MSkpO1xuICAgICAgICBjYXJ0ZXNpYW5Ob3JtYWxpemVJblBsYWNlKGFyYyk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb24gPSBjYXJ0ZXNpYW5Dcm9zcyhub3JtYWwsIGFyYyk7XG4gICAgICAgIGNhcnRlc2lhbk5vcm1hbGl6ZUluUGxhY2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgdmFyIHBoaUFyYyA9IChhbnRpbWVyaWRpYW4gXiBkZWx0YSA+PSAwID8gLTEgOiAxKSAqIGFzaW4oaW50ZXJzZWN0aW9uWzJdKTtcbiAgICAgICAgaWYgKHBoaSA+IHBoaUFyYyB8fCBwaGkgPT09IHBoaUFyYyAmJiAoYXJjWzBdIHx8IGFyY1sxXSkpIHtcbiAgICAgICAgICB3aW5kaW5nICs9IGFudGltZXJpZGlhbiBeIGRlbHRhID49IDAgPyAxIDogLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaXJzdCwgZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIFNvdXRoIHBvbGUgaXMgaW5zaWRlIG9yIG91dHNpZGU6XG4gIC8vXG4gIC8vIEl0IGlzIGluc2lkZSBpZjpcbiAgLy8gKiB0aGUgcG9seWdvbiB3aW5kcyBhcm91bmQgaXQgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLlxuICAvLyAqIHRoZSBwb2x5Z29uIGRvZXMgbm90IChjdW11bGF0aXZlbHkpIHdpbmQgYXJvdW5kIGl0LCBidXQgaGFzIGEgbmVnYXRpdmVcbiAgLy8gICAoY291bnRlci1jbG9ja3dpc2UpIGFyZWEuXG4gIC8vXG4gIC8vIFNlY29uZCwgY291bnQgdGhlIChzaWduZWQpIG51bWJlciBvZiB0aW1lcyBhIHNlZ21lbnQgY3Jvc3NlcyBhIGxhbWJkYVxuICAvLyBmcm9tIHRoZSBwb2ludCB0byB0aGUgU291dGggcG9sZS4gIElmIGl0IGlzIHplcm8sIHRoZW4gdGhlIHBvaW50IGlzIHRoZVxuICAvLyBzYW1lIHNpZGUgYXMgdGhlIFNvdXRoIHBvbGUuXG5cbiAgcmV0dXJuIChhbmdsZSA8IC1lcHNpbG9uIHx8IGFuZ2xlIDwgZXBzaWxvbiAmJiBzdW0gPCAtZXBzaWxvbikgXiAod2luZGluZyAmIDEpO1xufVxuXG5mdW5jdGlvbiBjbGlwKHBvaW50VmlzaWJsZSwgY2xpcExpbmUsIGludGVycG9sYXRlLCBzdGFydCkge1xuICByZXR1cm4gZnVuY3Rpb24oc2luaykge1xuICAgIHZhciBsaW5lID0gY2xpcExpbmUoc2luayksXG4gICAgICAgIHJpbmdCdWZmZXIgPSBjbGlwQnVmZmVyKCksXG4gICAgICAgIHJpbmdTaW5rID0gY2xpcExpbmUocmluZ0J1ZmZlciksXG4gICAgICAgIHBvbHlnb25TdGFydGVkID0gZmFsc2UsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHNlZ21lbnRzLFxuICAgICAgICByaW5nO1xuXG4gICAgdmFyIGNsaXAgPSB7XG4gICAgICBwb2ludDogcG9pbnQsXG4gICAgICBsaW5lU3RhcnQ6IGxpbmVTdGFydCxcbiAgICAgIGxpbmVFbmQ6IGxpbmVFbmQsXG4gICAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnRSaW5nO1xuICAgICAgICBjbGlwLmxpbmVTdGFydCA9IHJpbmdTdGFydDtcbiAgICAgICAgY2xpcC5saW5lRW5kID0gcmluZ0VuZDtcbiAgICAgICAgc2VnbWVudHMgPSBbXTtcbiAgICAgICAgcG9seWdvbiA9IFtdO1xuICAgICAgfSxcbiAgICAgIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGlwLnBvaW50ID0gcG9pbnQ7XG4gICAgICAgIGNsaXAubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgICAgICBjbGlwLmxpbmVFbmQgPSBsaW5lRW5kO1xuICAgICAgICBzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpO1xuICAgICAgICB2YXIgc3RhcnRJbnNpZGUgPSBwb2x5Z29uQ29udGFpbnMocG9seWdvbiwgc3RhcnQpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNsaXBSZWpvaW4oc2VnbWVudHMsIGNvbXBhcmVJbnRlcnNlY3Rpb24sIHN0YXJ0SW5zaWRlLCBpbnRlcnBvbGF0ZSwgc2luayk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRJbnNpZGUpIHtcbiAgICAgICAgICBpZiAoIXBvbHlnb25TdGFydGVkKSBzaW5rLnBvbHlnb25TdGFydCgpLCBwb2x5Z29uU3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgc2luay5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzaW5rKTtcbiAgICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9seWdvblN0YXJ0ZWQpIHNpbmsucG9seWdvbkVuZCgpLCBwb2x5Z29uU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBzZWdtZW50cyA9IHBvbHlnb24gPSBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwaGVyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHNpbmsucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgIGludGVycG9sYXRlKG51bGwsIG51bGwsIDEsIHNpbmspO1xuICAgICAgICBzaW5rLmxpbmVFbmQoKTtcbiAgICAgICAgc2luay5wb2x5Z29uRW5kKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICBpZiAocG9pbnRWaXNpYmxlKGxhbWJkYSwgcGhpKSkgc2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRMaW5lKGxhbWJkYSwgcGhpKSB7XG4gICAgICBsaW5lLnBvaW50KGxhbWJkYSwgcGhpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lU3RhcnQoKSB7XG4gICAgICBjbGlwLnBvaW50ID0gcG9pbnRMaW5lO1xuICAgICAgbGluZS5saW5lU3RhcnQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgY2xpcC5wb2ludCA9IHBvaW50O1xuICAgICAgbGluZS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRSaW5nKGxhbWJkYSwgcGhpKSB7XG4gICAgICByaW5nLnB1c2goW2xhbWJkYSwgcGhpXSk7XG4gICAgICByaW5nU2luay5wb2ludChsYW1iZGEsIHBoaSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgcmluZ1NpbmsubGluZVN0YXJ0KCk7XG4gICAgICByaW5nID0gW107XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ0VuZCgpIHtcbiAgICAgIHBvaW50UmluZyhyaW5nWzBdWzBdLCByaW5nWzBdWzFdKTtcbiAgICAgIHJpbmdTaW5rLmxpbmVFbmQoKTtcblxuICAgICAgdmFyIGNsZWFuID0gcmluZ1NpbmsuY2xlYW4oKSxcbiAgICAgICAgICByaW5nU2VnbWVudHMgPSByaW5nQnVmZmVyLnJlc3VsdCgpLFxuICAgICAgICAgIGksIG4gPSByaW5nU2VnbWVudHMubGVuZ3RoLCBtLFxuICAgICAgICAgIHNlZ21lbnQsXG4gICAgICAgICAgcG9pbnQ7XG5cbiAgICAgIHJpbmcucG9wKCk7XG4gICAgICBwb2x5Z29uLnB1c2gocmluZyk7XG4gICAgICByaW5nID0gbnVsbDtcblxuICAgICAgaWYgKCFuKSByZXR1cm47XG5cbiAgICAgIC8vIE5vIGludGVyc2VjdGlvbnMuXG4gICAgICBpZiAoY2xlYW4gJiAxKSB7XG4gICAgICAgIHNlZ21lbnQgPSByaW5nU2VnbWVudHNbMF07XG4gICAgICAgIGlmICgobSA9IHNlZ21lbnQubGVuZ3RoIC0gMSkgPiAwKSB7XG4gICAgICAgICAgaWYgKCFwb2x5Z29uU3RhcnRlZCkgc2luay5wb2x5Z29uU3RhcnQoKSwgcG9seWdvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgIHNpbmsubGluZVN0YXJ0KCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG07ICsraSkgc2luay5wb2ludCgocG9pbnQgPSBzZWdtZW50W2ldKVswXSwgcG9pbnRbMV0pO1xuICAgICAgICAgIHNpbmsubGluZUVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUmVqb2luIGNvbm5lY3RlZCBzZWdtZW50cy5cbiAgICAgIC8vIFRPRE8gcmV1c2UgcmluZ0J1ZmZlci5yZWpvaW4oKT9cbiAgICAgIGlmIChuID4gMSAmJiBjbGVhbiAmIDIpIHJpbmdTZWdtZW50cy5wdXNoKHJpbmdTZWdtZW50cy5wb3AoKS5jb25jYXQocmluZ1NlZ21lbnRzLnNoaWZ0KCkpKTtcblxuICAgICAgc2VnbWVudHMucHVzaChyaW5nU2VnbWVudHMuZmlsdGVyKHZhbGlkU2VnbWVudCkpO1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB2YWxpZFNlZ21lbnQoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudC5sZW5ndGggPiAxO1xufVxuXG4vLyBJbnRlcnNlY3Rpb25zIGFyZSBzb3J0ZWQgYWxvbmcgdGhlIGNsaXAgZWRnZS4gRm9yIGJvdGggYW50aW1lcmlkaWFuIGN1dHRpbmdcbi8vIGFuZCBjaXJjbGUgY2xpcHBpbmcsIHRoZSBzYW1lIGNvbXBhcmlzb24gaXMgdXNlZC5cbmZ1bmN0aW9uIGNvbXBhcmVJbnRlcnNlY3Rpb24oYSwgYikge1xuICByZXR1cm4gKChhID0gYS54KVswXSA8IDAgPyBhWzFdIC0gaGFsZlBpIC0gZXBzaWxvbiA6IGhhbGZQaSAtIGFbMV0pXG4gICAgICAgLSAoKGIgPSBiLngpWzBdIDwgMCA/IGJbMV0gLSBoYWxmUGkgLSBlcHNpbG9uIDogaGFsZlBpIC0gYlsxXSk7XG59XG5cbnZhciBjbGlwQW50aW1lcmlkaWFuID0gY2xpcChcbiAgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9LFxuICBjbGlwQW50aW1lcmlkaWFuTGluZSxcbiAgY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlLFxuICBbLXBpLCAtaGFsZlBpXVxuKTtcblxuLy8gVGFrZXMgYSBsaW5lIGFuZCBjdXRzIGludG8gdmlzaWJsZSBzZWdtZW50cy4gUmV0dXJuIHZhbHVlczogMCAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMgb3IgdGhlIGxpbmUgd2FzIGVtcHR5OyAxIC0gbm8gaW50ZXJzZWN0aW9uczsgMiAtIHRoZXJlIHdlcmVcbi8vIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgc2hvdWxkIGJlIHJlam9pbmVkLlxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkxpbmUoc3RyZWFtKSB7XG4gIHZhciBsYW1iZGEwID0gTmFOLFxuICAgICAgcGhpMCA9IE5hTixcbiAgICAgIHNpZ24wID0gTmFOLFxuICAgICAgY2xlYW47IC8vIG5vIGludGVyc2VjdGlvbnNcblxuICByZXR1cm4ge1xuICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgICBjbGVhbiA9IDE7XG4gICAgfSxcbiAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhMSwgcGhpMSkge1xuICAgICAgdmFyIHNpZ24xID0gbGFtYmRhMSA+IDAgPyBwaSA6IC1waSxcbiAgICAgICAgICBkZWx0YSA9IGFicyhsYW1iZGExIC0gbGFtYmRhMCk7XG4gICAgICBpZiAoYWJzKGRlbHRhIC0gcGkpIDwgZXBzaWxvbikgeyAvLyBsaW5lIGNyb3NzZXMgYSBwb2xlXG4gICAgICAgIHN0cmVhbS5wb2ludChsYW1iZGEwLCBwaGkwID0gKHBoaTAgKyBwaGkxKSAvIDIgPiAwID8gaGFsZlBpIDogLWhhbGZQaSk7XG4gICAgICAgIHN0cmVhbS5wb2ludChzaWduMCwgcGhpMCk7XG4gICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24xLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KGxhbWJkYTEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24wICE9PSBzaWduMSAmJiBkZWx0YSA+PSBwaSkgeyAvLyBsaW5lIGNyb3NzZXMgYW50aW1lcmlkaWFuXG4gICAgICAgIGlmIChhYnMobGFtYmRhMCAtIHNpZ24wKSA8IGVwc2lsb24pIGxhbWJkYTAgLT0gc2lnbjAgKiBlcHNpbG9uOyAvLyBoYW5kbGUgZGVnZW5lcmFjaWVzXG4gICAgICAgIGlmIChhYnMobGFtYmRhMSAtIHNpZ24xKSA8IGVwc2lsb24pIGxhbWJkYTEgLT0gc2lnbjEgKiBlcHNpbG9uO1xuICAgICAgICBwaGkwID0gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKTtcbiAgICAgICAgc3RyZWFtLnBvaW50KHNpZ24wLCBwaGkwKTtcbiAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICBzdHJlYW0ucG9pbnQoc2lnbjEsIHBoaTApO1xuICAgICAgICBjbGVhbiA9IDA7XG4gICAgICB9XG4gICAgICBzdHJlYW0ucG9pbnQobGFtYmRhMCA9IGxhbWJkYTEsIHBoaTAgPSBwaGkxKTtcbiAgICAgIHNpZ24wID0gc2lnbjE7XG4gICAgfSxcbiAgICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICBsYW1iZGEwID0gcGhpMCA9IE5hTjtcbiAgICB9LFxuICAgIGNsZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAyIC0gY2xlYW47IC8vIGlmIGludGVyc2VjdGlvbnMsIHJlam9pbiBmaXJzdCBhbmQgbGFzdCBzZWdtZW50c1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVyc2VjdChsYW1iZGEwLCBwaGkwLCBsYW1iZGExLCBwaGkxKSB7XG4gIHZhciBjb3NQaGkwLFxuICAgICAgY29zUGhpMSxcbiAgICAgIHNpbkxhbWJkYTBMYW1iZGExID0gc2luKGxhbWJkYTAgLSBsYW1iZGExKTtcbiAgcmV0dXJuIGFicyhzaW5MYW1iZGEwTGFtYmRhMSkgPiBlcHNpbG9uXG4gICAgICA/IGF0YW4oKHNpbihwaGkwKSAqIChjb3NQaGkxID0gY29zKHBoaTEpKSAqIHNpbihsYW1iZGExKVxuICAgICAgICAgIC0gc2luKHBoaTEpICogKGNvc1BoaTAgPSBjb3MocGhpMCkpICogc2luKGxhbWJkYTApKVxuICAgICAgICAgIC8gKGNvc1BoaTAgKiBjb3NQaGkxICogc2luTGFtYmRhMExhbWJkYTEpKVxuICAgICAgOiAocGhpMCArIHBoaTEpIC8gMjtcbn1cblxuZnVuY3Rpb24gY2xpcEFudGltZXJpZGlhbkludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICB2YXIgcGhpO1xuICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgcGhpID0gZGlyZWN0aW9uICogaGFsZlBpO1xuICAgIHN0cmVhbS5wb2ludCgtcGksIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KDAsIHBoaSk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCBwaGkpO1xuICAgIHN0cmVhbS5wb2ludChwaSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KHBpLCAtcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgLXBoaSk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgMCk7XG4gICAgc3RyZWFtLnBvaW50KC1waSwgcGhpKTtcbiAgfSBlbHNlIGlmIChhYnMoZnJvbVswXSAtIHRvWzBdKSA+IGVwc2lsb24pIHtcbiAgICB2YXIgbGFtYmRhID0gZnJvbVswXSA8IHRvWzBdID8gcGkgOiAtcGk7XG4gICAgcGhpID0gZGlyZWN0aW9uICogbGFtYmRhIC8gMjtcbiAgICBzdHJlYW0ucG9pbnQoLWxhbWJkYSwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQoMCwgcGhpKTtcbiAgICBzdHJlYW0ucG9pbnQobGFtYmRhLCBwaGkpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5wb2ludCh0b1swXSwgdG9bMV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsaXBDaXJjbGUocmFkaXVzKSB7XG4gIHZhciBjciA9IGNvcyhyYWRpdXMpLFxuICAgICAgZGVsdGEgPSA2ICogcmFkaWFucyxcbiAgICAgIHNtYWxsUmFkaXVzID0gY3IgPiAwLFxuICAgICAgbm90SGVtaXNwaGVyZSA9IGFicyhjcikgPiBlcHNpbG9uOyAvLyBUT0RPIG9wdGltaXNlIGZvciB0aGlzIGNvbW1vbiBjYXNlXG5cbiAgZnVuY3Rpb24gaW50ZXJwb2xhdGUoZnJvbSwgdG8sIGRpcmVjdGlvbiwgc3RyZWFtKSB7XG4gICAgY2lyY2xlU3RyZWFtKHN0cmVhbSwgcmFkaXVzLCBkZWx0YSwgZGlyZWN0aW9uLCBmcm9tLCB0byk7XG4gIH1cblxuICBmdW5jdGlvbiB2aXNpYmxlKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIGNvcyhsYW1iZGEpICogY29zKHBoaSkgPiBjcjtcbiAgfVxuXG4gIC8vIFRha2VzIGEgbGluZSBhbmQgY3V0cyBpbnRvIHZpc2libGUgc2VnbWVudHMuIFJldHVybiB2YWx1ZXMgdXNlZCBmb3IgcG9seWdvblxuICAvLyBjbGlwcGluZzogMCAtIHRoZXJlIHdlcmUgaW50ZXJzZWN0aW9ucyBvciB0aGUgbGluZSB3YXMgZW1wdHk7IDEgLSBub1xuICAvLyBpbnRlcnNlY3Rpb25zIDIgLSB0aGVyZSB3ZXJlIGludGVyc2VjdGlvbnMsIGFuZCB0aGUgZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHNcbiAgLy8gc2hvdWxkIGJlIHJlam9pbmVkLlxuICBmdW5jdGlvbiBjbGlwTGluZShzdHJlYW0pIHtcbiAgICB2YXIgcG9pbnQwLCAvLyBwcmV2aW91cyBwb2ludFxuICAgICAgICBjMCwgLy8gY29kZSBmb3IgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAsIC8vIHZpc2liaWxpdHkgb2YgcHJldmlvdXMgcG9pbnRcbiAgICAgICAgdjAwLCAvLyB2aXNpYmlsaXR5IG9mIGZpcnN0IHBvaW50XG4gICAgICAgIGNsZWFuOyAvLyBubyBpbnRlcnNlY3Rpb25zXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHYwMCA9IHYwID0gZmFsc2U7XG4gICAgICAgIGNsZWFuID0gMTtcbiAgICAgIH0sXG4gICAgICBwb2ludDogZnVuY3Rpb24obGFtYmRhLCBwaGkpIHtcbiAgICAgICAgdmFyIHBvaW50MSA9IFtsYW1iZGEsIHBoaV0sXG4gICAgICAgICAgICBwb2ludDIsXG4gICAgICAgICAgICB2ID0gdmlzaWJsZShsYW1iZGEsIHBoaSksXG4gICAgICAgICAgICBjID0gc21hbGxSYWRpdXNcbiAgICAgICAgICAgICAgPyB2ID8gMCA6IGNvZGUobGFtYmRhLCBwaGkpXG4gICAgICAgICAgICAgIDogdiA/IGNvZGUobGFtYmRhICsgKGxhbWJkYSA8IDAgPyBwaSA6IC1waSksIHBoaSkgOiAwO1xuICAgICAgICBpZiAoIXBvaW50MCAmJiAodjAwID0gdjAgPSB2KSkgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAvLyBIYW5kbGUgZGVnZW5lcmFjaWVzLlxuICAgICAgICAvLyBUT0RPIGlnbm9yZSBpZiBub3QgY2xpcHBpbmcgcG9seWdvbnMuXG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgaWYgKCFwb2ludDIgfHwgcG9pbnRFcXVhbChwb2ludDAsIHBvaW50MikgfHwgcG9pbnRFcXVhbChwb2ludDEsIHBvaW50MikpIHtcbiAgICAgICAgICAgIHBvaW50MVswXSArPSBlcHNpbG9uO1xuICAgICAgICAgICAgcG9pbnQxWzFdICs9IGVwc2lsb247XG4gICAgICAgICAgICB2ID0gdmlzaWJsZShwb2ludDFbMF0sIHBvaW50MVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICE9PSB2MCkge1xuICAgICAgICAgIGNsZWFuID0gMDtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgLy8gb3V0c2lkZSBnb2luZyBpblxuICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgcG9pbnQyID0gaW50ZXJzZWN0KHBvaW50MSwgcG9pbnQwKTtcbiAgICAgICAgICAgIHN0cmVhbS5wb2ludChwb2ludDJbMF0sIHBvaW50MlsxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2lkZSBnb2luZyBvdXRcbiAgICAgICAgICAgIHBvaW50MiA9IGludGVyc2VjdChwb2ludDAsIHBvaW50MSk7XG4gICAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQyWzBdLCBwb2ludDJbMV0pO1xuICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnQwID0gcG9pbnQyO1xuICAgICAgICB9IGVsc2UgaWYgKG5vdEhlbWlzcGhlcmUgJiYgcG9pbnQwICYmIHNtYWxsUmFkaXVzIF4gdikge1xuICAgICAgICAgIHZhciB0O1xuICAgICAgICAgIC8vIElmIHRoZSBjb2RlcyBmb3IgdHdvIHBvaW50cyBhcmUgZGlmZmVyZW50LCBvciBhcmUgYm90aCB6ZXJvLFxuICAgICAgICAgIC8vIGFuZCB0aGVyZSB0aGlzIHNlZ21lbnQgaW50ZXJzZWN0cyB3aXRoIHRoZSBzbWFsbCBjaXJjbGUuXG4gICAgICAgICAgaWYgKCEoYyAmIGMwKSAmJiAodCA9IGludGVyc2VjdChwb2ludDEsIHBvaW50MCwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICBjbGVhbiA9IDA7XG4gICAgICAgICAgICBpZiAoc21hbGxSYWRpdXMpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0cmVhbS5wb2ludCh0WzFdWzBdLCB0WzFdWzFdKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgICAgICAgc3RyZWFtLmxpbmVTdGFydCgpO1xuICAgICAgICAgICAgICBzdHJlYW0ucG9pbnQodFswXVswXSwgdFswXVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2ICYmICghcG9pbnQwIHx8ICFwb2ludEVxdWFsKHBvaW50MCwgcG9pbnQxKSkpIHtcbiAgICAgICAgICBzdHJlYW0ucG9pbnQocG9pbnQxWzBdLCBwb2ludDFbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50MCA9IHBvaW50MSwgdjAgPSB2LCBjMCA9IGM7XG4gICAgICB9LFxuICAgICAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh2MCkgc3RyZWFtLmxpbmVFbmQoKTtcbiAgICAgICAgcG9pbnQwID0gbnVsbDtcbiAgICAgIH0sXG4gICAgICAvLyBSZWpvaW4gZmlyc3QgYW5kIGxhc3Qgc2VnbWVudHMgaWYgdGhlcmUgd2VyZSBpbnRlcnNlY3Rpb25zIGFuZCB0aGUgZmlyc3RcbiAgICAgIC8vIGFuZCBsYXN0IHBvaW50cyB3ZXJlIHZpc2libGUuXG4gICAgICBjbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjbGVhbiB8ICgodjAwICYmIHYwKSA8PCAxKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gSW50ZXJzZWN0cyB0aGUgZ3JlYXQgY2lyY2xlIGJldHdlZW4gYSBhbmQgYiB3aXRoIHRoZSBjbGlwIGNpcmNsZS5cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGEsIGIsIHR3bykge1xuICAgIHZhciBwYSA9IGNhcnRlc2lhbihhKSxcbiAgICAgICAgcGIgPSBjYXJ0ZXNpYW4oYik7XG5cbiAgICAvLyBXZSBoYXZlIHR3byBwbGFuZXMsIG4xLnAgPSBkMSBhbmQgbjIucCA9IGQyLlxuICAgIC8vIEZpbmQgaW50ZXJzZWN0aW9uIGxpbmUgcCh0KSA9IGMxIG4xICsgYzIgbjIgKyB0IChuMSDiqK8gbjIpLlxuICAgIHZhciBuMSA9IFsxLCAwLCAwXSwgLy8gbm9ybWFsXG4gICAgICAgIG4yID0gY2FydGVzaWFuQ3Jvc3MocGEsIHBiKSxcbiAgICAgICAgbjJuMiA9IGNhcnRlc2lhbkRvdChuMiwgbjIpLFxuICAgICAgICBuMW4yID0gbjJbMF0sIC8vIGNhcnRlc2lhbkRvdChuMSwgbjIpLFxuICAgICAgICBkZXRlcm1pbmFudCA9IG4ybjIgLSBuMW4yICogbjFuMjtcblxuICAgIC8vIFR3byBwb2xhciBwb2ludHMuXG4gICAgaWYgKCFkZXRlcm1pbmFudCkgcmV0dXJuICF0d28gJiYgYTtcblxuICAgIHZhciBjMSA9ICBjciAqIG4ybjIgLyBkZXRlcm1pbmFudCxcbiAgICAgICAgYzIgPSAtY3IgKiBuMW4yIC8gZGV0ZXJtaW5hbnQsXG4gICAgICAgIG4xeG4yID0gY2FydGVzaWFuQ3Jvc3MobjEsIG4yKSxcbiAgICAgICAgQSA9IGNhcnRlc2lhblNjYWxlKG4xLCBjMSksXG4gICAgICAgIEIgPSBjYXJ0ZXNpYW5TY2FsZShuMiwgYzIpO1xuICAgIGNhcnRlc2lhbkFkZEluUGxhY2UoQSwgQik7XG5cbiAgICAvLyBTb2x2ZSB8cCh0KXxeMiA9IDEuXG4gICAgdmFyIHUgPSBuMXhuMixcbiAgICAgICAgdyA9IGNhcnRlc2lhbkRvdChBLCB1KSxcbiAgICAgICAgdXUgPSBjYXJ0ZXNpYW5Eb3QodSwgdSksXG4gICAgICAgIHQyID0gdyAqIHcgLSB1dSAqIChjYXJ0ZXNpYW5Eb3QoQSwgQSkgLSAxKTtcblxuICAgIGlmICh0MiA8IDApIHJldHVybjtcblxuICAgIHZhciB0ID0gc3FydCh0MiksXG4gICAgICAgIHEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgLSB0KSAvIHV1KTtcbiAgICBjYXJ0ZXNpYW5BZGRJblBsYWNlKHEsIEEpO1xuICAgIHEgPSBzcGhlcmljYWwocSk7XG5cbiAgICBpZiAoIXR3bykgcmV0dXJuIHE7XG5cbiAgICAvLyBUd28gaW50ZXJzZWN0aW9uIHBvaW50cy5cbiAgICB2YXIgbGFtYmRhMCA9IGFbMF0sXG4gICAgICAgIGxhbWJkYTEgPSBiWzBdLFxuICAgICAgICBwaGkwID0gYVsxXSxcbiAgICAgICAgcGhpMSA9IGJbMV0sXG4gICAgICAgIHo7XG5cbiAgICBpZiAobGFtYmRhMSA8IGxhbWJkYTApIHogPSBsYW1iZGEwLCBsYW1iZGEwID0gbGFtYmRhMSwgbGFtYmRhMSA9IHo7XG5cbiAgICB2YXIgZGVsdGEgPSBsYW1iZGExIC0gbGFtYmRhMCxcbiAgICAgICAgcG9sYXIgPSBhYnMoZGVsdGEgLSBwaSkgPCBlcHNpbG9uLFxuICAgICAgICBtZXJpZGlhbiA9IHBvbGFyIHx8IGRlbHRhIDwgZXBzaWxvbjtcblxuICAgIGlmICghcG9sYXIgJiYgcGhpMSA8IHBoaTApIHogPSBwaGkwLCBwaGkwID0gcGhpMSwgcGhpMSA9IHo7XG5cbiAgICAvLyBDaGVjayB0aGF0IHRoZSBmaXJzdCBwb2ludCBpcyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgaWYgKG1lcmlkaWFuXG4gICAgICAgID8gcG9sYXJcbiAgICAgICAgICA/IHBoaTAgKyBwaGkxID4gMCBeIHFbMV0gPCAoYWJzKHFbMF0gLSBsYW1iZGEwKSA8IGVwc2lsb24gPyBwaGkwIDogcGhpMSlcbiAgICAgICAgICA6IHBoaTAgPD0gcVsxXSAmJiBxWzFdIDw9IHBoaTFcbiAgICAgICAgOiBkZWx0YSA+IHBpIF4gKGxhbWJkYTAgPD0gcVswXSAmJiBxWzBdIDw9IGxhbWJkYTEpKSB7XG4gICAgICB2YXIgcTEgPSBjYXJ0ZXNpYW5TY2FsZSh1LCAoLXcgKyB0KSAvIHV1KTtcbiAgICAgIGNhcnRlc2lhbkFkZEluUGxhY2UocTEsIEEpO1xuICAgICAgcmV0dXJuIFtxLCBzcGhlcmljYWwocTEpXTtcbiAgICB9XG4gIH1cblxuICAvLyBHZW5lcmF0ZXMgYSA0LWJpdCB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhdGlvbiBvZiBhIHBvaW50IHJlbGF0aXZlIHRvXG4gIC8vIHRoZSBzbWFsbCBjaXJjbGUncyBib3VuZGluZyBib3guXG4gIGZ1bmN0aW9uIGNvZGUobGFtYmRhLCBwaGkpIHtcbiAgICB2YXIgciA9IHNtYWxsUmFkaXVzID8gcmFkaXVzIDogcGkgLSByYWRpdXMsXG4gICAgICAgIGNvZGUgPSAwO1xuICAgIGlmIChsYW1iZGEgPCAtcikgY29kZSB8PSAxOyAvLyBsZWZ0XG4gICAgZWxzZSBpZiAobGFtYmRhID4gcikgY29kZSB8PSAyOyAvLyByaWdodFxuICAgIGlmIChwaGkgPCAtcikgY29kZSB8PSA0OyAvLyBiZWxvd1xuICAgIGVsc2UgaWYgKHBoaSA+IHIpIGNvZGUgfD0gODsgLy8gYWJvdmVcbiAgICByZXR1cm4gY29kZTtcbiAgfVxuXG4gIHJldHVybiBjbGlwKHZpc2libGUsIGNsaXBMaW5lLCBpbnRlcnBvbGF0ZSwgc21hbGxSYWRpdXMgPyBbMCwgLXJhZGl1c10gOiBbLXBpLCByYWRpdXMgLSBwaV0pO1xufVxuXG5mdW5jdGlvbiBjbGlwTGluZShhLCBiLCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgdDAgPSAwLFxuICAgICAgdDEgPSAxLFxuICAgICAgZHggPSBieCAtIGF4LFxuICAgICAgZHkgPSBieSAtIGF5LFxuICAgICAgcjtcblxuICByID0geDAgLSBheDtcbiAgaWYgKCFkeCAmJiByID4gMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9XG5cbiAgciA9IHgxIC0gYXg7XG4gIGlmICghZHggJiYgciA8IDApIHJldHVybjtcbiAgciAvPSBkeDtcbiAgaWYgKGR4IDwgMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH0gZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgaWYgKHIgPCB0MCkgcmV0dXJuO1xuICAgIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgfVxuXG4gIHIgPSB5MCAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geTEgLSBheTtcbiAgaWYgKCFkeSAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR5O1xuICBpZiAoZHkgPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeSA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgaWYgKHQwID4gMCkgYVswXSA9IGF4ICsgdDAgKiBkeCwgYVsxXSA9IGF5ICsgdDAgKiBkeTtcbiAgaWYgKHQxIDwgMSkgYlswXSA9IGF4ICsgdDEgKiBkeCwgYlsxXSA9IGF5ICsgdDEgKiBkeTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBjbGlwTWF4ID0gMWU5O1xudmFyIGNsaXBNaW4gPSAtY2xpcE1heDtcblxuLy8gVE9ETyBVc2UgZDMtcG9seWdvbuKAmXMgcG9seWdvbkNvbnRhaW5zIGhlcmUgZm9yIHRoZSByaW5nIGNoZWNrP1xuLy8gVE9ETyBFbGltaW5hdGUgZHVwbGljYXRlIGJ1ZmZlcmluZyBpbiBjbGlwQnVmZmVyIGFuZCBwb2x5Z29uLnB1c2g/XG5cbmZ1bmN0aW9uIGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpIHtcblxuICBmdW5jdGlvbiB2aXNpYmxlKHgsIHkpIHtcbiAgICByZXR1cm4geDAgPD0geCAmJiB4IDw9IHgxICYmIHkwIDw9IHkgJiYgeSA8PSB5MTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVycG9sYXRlKGZyb20sIHRvLCBkaXJlY3Rpb24sIHN0cmVhbSkge1xuICAgIHZhciBhID0gMCwgYTEgPSAwO1xuICAgIGlmIChmcm9tID09IG51bGxcbiAgICAgICAgfHwgKGEgPSBjb3JuZXIoZnJvbSwgZGlyZWN0aW9uKSkgIT09IChhMSA9IGNvcm5lcih0bywgZGlyZWN0aW9uKSlcbiAgICAgICAgfHwgY29tcGFyZVBvaW50KGZyb20sIHRvKSA8IDAgXiBkaXJlY3Rpb24gPiAwKSB7XG4gICAgICBkbyBzdHJlYW0ucG9pbnQoYSA9PT0gMCB8fCBhID09PSAzID8geDAgOiB4MSwgYSA+IDEgPyB5MSA6IHkwKTtcbiAgICAgIHdoaWxlICgoYSA9IChhICsgZGlyZWN0aW9uICsgNCkgJSA0KSAhPT0gYTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ucG9pbnQodG9bMF0sIHRvWzFdKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JuZXIocCwgZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIGFicyhwWzBdIC0geDApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAwIDogM1xuICAgICAgICA6IGFicyhwWzBdIC0geDEpIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAyIDogMVxuICAgICAgICA6IGFicyhwWzFdIC0geTApIDwgZXBzaWxvbiA/IGRpcmVjdGlvbiA+IDAgPyAxIDogMFxuICAgICAgICA6IGRpcmVjdGlvbiA+IDAgPyAzIDogMjsgLy8gYWJzKHBbMV0gLSB5MSkgPCBlcHNpbG9uXG4gIH1cblxuICBmdW5jdGlvbiBjb21wYXJlSW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gY29tcGFyZVBvaW50KGEueCwgYi54KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBhcmVQb2ludChhLCBiKSB7XG4gICAgdmFyIGNhID0gY29ybmVyKGEsIDEpLFxuICAgICAgICBjYiA9IGNvcm5lcihiLCAxKTtcbiAgICByZXR1cm4gY2EgIT09IGNiID8gY2EgLSBjYlxuICAgICAgICA6IGNhID09PSAwID8gYlsxXSAtIGFbMV1cbiAgICAgICAgOiBjYSA9PT0gMSA/IGFbMF0gLSBiWzBdXG4gICAgICAgIDogY2EgPT09IDIgPyBhWzFdIC0gYlsxXVxuICAgICAgICA6IGJbMF0gLSBhWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHZhciBhY3RpdmVTdHJlYW0gPSBzdHJlYW0sXG4gICAgICAgIGJ1ZmZlclN0cmVhbSA9IGNsaXBCdWZmZXIoKSxcbiAgICAgICAgc2VnbWVudHMsXG4gICAgICAgIHBvbHlnb24sXG4gICAgICAgIHJpbmcsXG4gICAgICAgIHhfXywgeV9fLCB2X18sIC8vIGZpcnN0IHBvaW50XG4gICAgICAgIHhfLCB5Xywgdl8sIC8vIHByZXZpb3VzIHBvaW50XG4gICAgICAgIGZpcnN0LFxuICAgICAgICBjbGVhbjtcblxuICAgIHZhciBjbGlwU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBwb2x5Z29uU3RhcnQsXG4gICAgICBwb2x5Z29uRW5kOiBwb2x5Z29uRW5kXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIGlmICh2aXNpYmxlKHgsIHkpKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9seWdvbkluc2lkZSgpIHtcbiAgICAgIHZhciB3aW5kaW5nID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwb2x5Z29uLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBmb3IgKHZhciByaW5nID0gcG9seWdvbltpXSwgaiA9IDEsIG0gPSByaW5nLmxlbmd0aCwgcG9pbnQgPSByaW5nWzBdLCBhMCwgYTEsIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07IGogPCBtOyArK2opIHtcbiAgICAgICAgICBhMCA9IGIwLCBhMSA9IGIxLCBwb2ludCA9IHJpbmdbal0sIGIwID0gcG9pbnRbMF0sIGIxID0gcG9pbnRbMV07XG4gICAgICAgICAgaWYgKGExIDw9IHkxKSB7IGlmIChiMSA+IHkxICYmIChiMCAtIGEwKSAqICh5MSAtIGExKSA+IChiMSAtIGExKSAqICh4MCAtIGEwKSkgKyt3aW5kaW5nOyB9XG4gICAgICAgICAgZWxzZSB7IGlmIChiMSA8PSB5MSAmJiAoYjAgLSBhMCkgKiAoeTEgLSBhMSkgPCAoYjEgLSBhMSkgKiAoeDAgLSBhMCkpIC0td2luZGluZzsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aW5kaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1ZmZlciBnZW9tZXRyeSB3aXRoaW4gYSBwb2x5Z29uIGFuZCB0aGVuIGNsaXAgaXQgZW4gbWFzc2UuXG4gICAgZnVuY3Rpb24gcG9seWdvblN0YXJ0KCkge1xuICAgICAgYWN0aXZlU3RyZWFtID0gYnVmZmVyU3RyZWFtLCBzZWdtZW50cyA9IFtdLCBwb2x5Z29uID0gW10sIGNsZWFuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2x5Z29uRW5kKCkge1xuICAgICAgdmFyIHN0YXJ0SW5zaWRlID0gcG9seWdvbkluc2lkZSgpLFxuICAgICAgICAgIGNsZWFuSW5zaWRlID0gY2xlYW4gJiYgc3RhcnRJbnNpZGUsXG4gICAgICAgICAgdmlzaWJsZSA9IChzZWdtZW50cyA9IGQzQXJyYXkubWVyZ2Uoc2VnbWVudHMpKS5sZW5ndGg7XG4gICAgICBpZiAoY2xlYW5JbnNpZGUgfHwgdmlzaWJsZSkge1xuICAgICAgICBzdHJlYW0ucG9seWdvblN0YXJ0KCk7XG4gICAgICAgIGlmIChjbGVhbkluc2lkZSkge1xuICAgICAgICAgIHN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBpbnRlcnBvbGF0ZShudWxsLCBudWxsLCAxLCBzdHJlYW0pO1xuICAgICAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICBjbGlwUmVqb2luKHNlZ21lbnRzLCBjb21wYXJlSW50ZXJzZWN0aW9uLCBzdGFydEluc2lkZSwgaW50ZXJwb2xhdGUsIHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLnBvbHlnb25FbmQoKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZVN0cmVhbSA9IHN0cmVhbSwgc2VnbWVudHMgPSBwb2x5Z29uID0gcmluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVN0YXJ0KCkge1xuICAgICAgY2xpcFN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICAgIGlmIChwb2x5Z29uKSBwb2x5Z29uLnB1c2gocmluZyA9IFtdKTtcbiAgICAgIGZpcnN0ID0gdHJ1ZTtcbiAgICAgIHZfID0gZmFsc2U7XG4gICAgICB4XyA9IHlfID0gTmFOO1xuICAgIH1cblxuICAgIC8vIFRPRE8gcmF0aGVyIHRoYW4gc3BlY2lhbC1jYXNlIHBvbHlnb25zLCBzaW1wbHkgaGFuZGxlIHRoZW0gc2VwYXJhdGVseS5cbiAgICAvLyBJZGVhbGx5LCBjb2luY2lkZW50IGludGVyc2VjdGlvbiBwb2ludHMgc2hvdWxkIGJlIGppdHRlcmVkIHRvIGF2b2lkXG4gICAgLy8gY2xpcHBpbmcgaXNzdWVzLlxuICAgIGZ1bmN0aW9uIGxpbmVFbmQoKSB7XG4gICAgICBpZiAoc2VnbWVudHMpIHtcbiAgICAgICAgbGluZVBvaW50KHhfXywgeV9fKTtcbiAgICAgICAgaWYgKHZfXyAmJiB2XykgYnVmZmVyU3RyZWFtLnJlam9pbigpO1xuICAgICAgICBzZWdtZW50cy5wdXNoKGJ1ZmZlclN0cmVhbS5yZXN1bHQoKSk7XG4gICAgICB9XG4gICAgICBjbGlwU3RyZWFtLnBvaW50ID0gcG9pbnQ7XG4gICAgICBpZiAodl8pIGFjdGl2ZVN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KHgsIHkpIHtcbiAgICAgIHZhciB2ID0gdmlzaWJsZSh4LCB5KTtcbiAgICAgIGlmIChwb2x5Z29uKSByaW5nLnB1c2goW3gsIHldKTtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICB4X18gPSB4LCB5X18gPSB5LCB2X18gPSB2O1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ICYmIHZfKSBhY3RpdmVTdHJlYW0ucG9pbnQoeCwgeSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBhID0gW3hfID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeF8pKSwgeV8gPSBNYXRoLm1heChjbGlwTWluLCBNYXRoLm1pbihjbGlwTWF4LCB5XykpXSxcbiAgICAgICAgICAgICAgYiA9IFt4ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeCkpLCB5ID0gTWF0aC5tYXgoY2xpcE1pbiwgTWF0aC5taW4oY2xpcE1heCwgeSkpXTtcbiAgICAgICAgICBpZiAoY2xpcExpbmUoYSwgYiwgeDAsIHkwLCB4MSwgeTEpKSB7XG4gICAgICAgICAgICBpZiAoIXZfKSB7XG4gICAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3RyZWFtLnBvaW50KGJbMF0sIGJbMV0pO1xuICAgICAgICAgICAgaWYgKCF2KSBhY3RpdmVTdHJlYW0ubGluZUVuZCgpO1xuICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHYpIHtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5saW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGFjdGl2ZVN0cmVhbS5wb2ludCh4LCB5KTtcbiAgICAgICAgICAgIGNsZWFuID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB4XyA9IHgsIHlfID0geSwgdl8gPSB2O1xuICAgIH1cblxuICAgIHJldHVybiBjbGlwU3RyZWFtO1xuICB9O1xufVxuXG5mdW5jdGlvbiBleHRlbnQoKSB7XG4gIHZhciB4MCA9IDAsXG4gICAgICB5MCA9IDAsXG4gICAgICB4MSA9IDk2MCxcbiAgICAgIHkxID0gNTAwLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbSxcbiAgICAgIGNsaXA7XG5cbiAgcmV0dXJuIGNsaXAgPSB7XG4gICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IGNsaXBSZWN0YW5nbGUoeDAsIHkwLCB4MSwgeTEpKGNhY2hlU3RyZWFtID0gc3RyZWFtKTtcbiAgICB9LFxuICAgIGV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXVswXSwgeTAgPSArX1swXVsxXSwgeDEgPSArX1sxXVswXSwgeTEgPSArX1sxXVsxXSwgY2FjaGUgPSBjYWNoZVN0cmVhbSA9IG51bGwsIGNsaXApIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgfVxuICB9O1xufVxuXG52YXIgbGVuZ3RoU3VtID0gYWRkZXIoKTtcbnZhciBsYW1iZGEwJDI7XG52YXIgc2luUGhpMCQxO1xudmFyIGNvc1BoaTAkMTtcblxudmFyIGxlbmd0aFN0cmVhbSA9IHtcbiAgc3BoZXJlOiBub29wLFxuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBsZW5ndGhMaW5lU3RhcnQsXG4gIGxpbmVFbmQ6IG5vb3AsXG4gIHBvbHlnb25TdGFydDogbm9vcCxcbiAgcG9seWdvbkVuZDogbm9vcFxufTtcblxuZnVuY3Rpb24gbGVuZ3RoTGluZVN0YXJ0KCkge1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludEZpcnN0O1xuICBsZW5ndGhTdHJlYW0ubGluZUVuZCA9IGxlbmd0aExpbmVFbmQ7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aExpbmVFbmQoKSB7XG4gIGxlbmd0aFN0cmVhbS5wb2ludCA9IGxlbmd0aFN0cmVhbS5saW5lRW5kID0gbm9vcDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnRGaXJzdChsYW1iZGEsIHBoaSkge1xuICBsYW1iZGEgKj0gcmFkaWFucywgcGhpICo9IHJhZGlhbnM7XG4gIGxhbWJkYTAkMiA9IGxhbWJkYSwgc2luUGhpMCQxID0gc2luKHBoaSksIGNvc1BoaTAkMSA9IGNvcyhwaGkpO1xuICBsZW5ndGhTdHJlYW0ucG9pbnQgPSBsZW5ndGhQb2ludDtcbn1cblxuZnVuY3Rpb24gbGVuZ3RoUG9pbnQobGFtYmRhLCBwaGkpIHtcbiAgbGFtYmRhICo9IHJhZGlhbnMsIHBoaSAqPSByYWRpYW5zO1xuICB2YXIgc2luUGhpID0gc2luKHBoaSksXG4gICAgICBjb3NQaGkgPSBjb3MocGhpKSxcbiAgICAgIGRlbHRhID0gYWJzKGxhbWJkYSAtIGxhbWJkYTAkMiksXG4gICAgICBjb3NEZWx0YSA9IGNvcyhkZWx0YSksXG4gICAgICBzaW5EZWx0YSA9IHNpbihkZWx0YSksXG4gICAgICB4ID0gY29zUGhpICogc2luRGVsdGEsXG4gICAgICB5ID0gY29zUGhpMCQxICogc2luUGhpIC0gc2luUGhpMCQxICogY29zUGhpICogY29zRGVsdGEsXG4gICAgICB6ID0gc2luUGhpMCQxICogc2luUGhpICsgY29zUGhpMCQxICogY29zUGhpICogY29zRGVsdGE7XG4gIGxlbmd0aFN1bS5hZGQoYXRhbjIoc3FydCh4ICogeCArIHkgKiB5KSwgeikpO1xuICBsYW1iZGEwJDIgPSBsYW1iZGEsIHNpblBoaTAkMSA9IHNpblBoaSwgY29zUGhpMCQxID0gY29zUGhpO1xufVxuXG5mdW5jdGlvbiBsZW5ndGgob2JqZWN0KSB7XG4gIGxlbmd0aFN1bS5yZXNldCgpO1xuICBnZW9TdHJlYW0ob2JqZWN0LCBsZW5ndGhTdHJlYW0pO1xuICByZXR1cm4gK2xlbmd0aFN1bTtcbn1cblxudmFyIGNvb3JkaW5hdGVzID0gW251bGwsIG51bGxdO1xudmFyIG9iamVjdCA9IHt0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcblxuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICBjb29yZGluYXRlc1swXSA9IGE7XG4gIGNvb3JkaW5hdGVzWzFdID0gYjtcbiAgcmV0dXJuIGxlbmd0aChvYmplY3QpO1xufVxuXG52YXIgY29udGFpbnNPYmplY3RUeXBlID0ge1xuICBGZWF0dXJlOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zR2VvbWV0cnkob2JqZWN0Lmdlb21ldHJ5LCBwb2ludCk7XG4gIH0sXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGZlYXR1cmVzID0gb2JqZWN0LmZlYXR1cmVzLCBpID0gLTEsIG4gPSBmZWF0dXJlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGZlYXR1cmVzW2ldLmdlb21ldHJ5LCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNvbnRhaW5zR2VvbWV0cnlUeXBlID0ge1xuICBTcGhlcmU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBQb2ludDogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvaW50KG9iamVjdC5jb29yZGluYXRlcywgcG9pbnQpO1xuICB9LFxuICBNdWx0aVBvaW50OiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzID0gb2JqZWN0LmNvb3JkaW5hdGVzLCBpID0gLTEsIG4gPSBjb29yZGluYXRlcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc1BvaW50KGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc0xpbmUob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNMaW5lKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHJldHVybiBjb250YWluc1BvbHlnb24ob2JqZWN0LmNvb3JkaW5hdGVzLCBwb2ludCk7XG4gIH0sXG4gIE11bHRpUG9seWdvbjogZnVuY3Rpb24ob2JqZWN0LCBwb2ludCkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IG9iamVjdC5jb29yZGluYXRlcywgaSA9IC0xLCBuID0gY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoY29udGFpbnNQb2x5Z29uKGNvb3JkaW5hdGVzW2ldLCBwb2ludCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgR2VvbWV0cnlDb2xsZWN0aW9uOiBmdW5jdGlvbihvYmplY3QsIHBvaW50KSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBvYmplY3QuZ2VvbWV0cmllcywgaSA9IC0xLCBuID0gZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgd2hpbGUgKCsraSA8IG4pIGlmIChjb250YWluc0dlb21ldHJ5KGdlb21ldHJpZXNbaV0sIHBvaW50KSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjb250YWluc0dlb21ldHJ5KGdlb21ldHJ5LCBwb2ludCkge1xuICByZXR1cm4gZ2VvbWV0cnkgJiYgY29udGFpbnNHZW9tZXRyeVR5cGUuaGFzT3duUHJvcGVydHkoZ2VvbWV0cnkudHlwZSlcbiAgICAgID8gY29udGFpbnNHZW9tZXRyeVR5cGVbZ2VvbWV0cnkudHlwZV0oZ2VvbWV0cnksIHBvaW50KVxuICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNQb2ludChjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgcmV0dXJuIGRpc3RhbmNlKGNvb3JkaW5hdGVzLCBwb2ludCkgPT09IDA7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zTGluZShjb29yZGluYXRlcywgcG9pbnQpIHtcbiAgdmFyIGFiID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIGNvb3JkaW5hdGVzWzFdKSxcbiAgICAgIGFvID0gZGlzdGFuY2UoY29vcmRpbmF0ZXNbMF0sIHBvaW50KSxcbiAgICAgIG9iID0gZGlzdGFuY2UocG9pbnQsIGNvb3JkaW5hdGVzWzFdKTtcbiAgcmV0dXJuIGFvICsgb2IgPD0gYWIgKyBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBjb250YWluc1BvbHlnb24oY29vcmRpbmF0ZXMsIHBvaW50KSB7XG4gIHJldHVybiAhIXBvbHlnb25Db250YWlucyhjb29yZGluYXRlcy5tYXAocmluZ1JhZGlhbnMpLCBwb2ludFJhZGlhbnMocG9pbnQpKTtcbn1cblxuZnVuY3Rpb24gcmluZ1JhZGlhbnMocmluZykge1xuICByZXR1cm4gcmluZyA9IHJpbmcubWFwKHBvaW50UmFkaWFucyksIHJpbmcucG9wKCksIHJpbmc7XG59XG5cbmZ1bmN0aW9uIHBvaW50UmFkaWFucyhwb2ludCkge1xuICByZXR1cm4gW3BvaW50WzBdICogcmFkaWFucywgcG9pbnRbMV0gKiByYWRpYW5zXTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMob2JqZWN0LCBwb2ludCkge1xuICByZXR1cm4gKG9iamVjdCAmJiBjb250YWluc09iamVjdFR5cGUuaGFzT3duUHJvcGVydHkob2JqZWN0LnR5cGUpXG4gICAgICA/IGNvbnRhaW5zT2JqZWN0VHlwZVtvYmplY3QudHlwZV1cbiAgICAgIDogY29udGFpbnNHZW9tZXRyeSkob2JqZWN0LCBwb2ludCk7XG59XG5cbmZ1bmN0aW9uIGdyYXRpY3VsZVgoeTAsIHkxLCBkeSkge1xuICB2YXIgeSA9IGQzQXJyYXkucmFuZ2UoeTAsIHkxIC0gZXBzaWxvbiwgZHkpLmNvbmNhdCh5MSk7XG4gIHJldHVybiBmdW5jdGlvbih4KSB7IHJldHVybiB5Lm1hcChmdW5jdGlvbih5KSB7IHJldHVybiBbeCwgeV07IH0pOyB9O1xufVxuXG5mdW5jdGlvbiBncmF0aWN1bGVZKHgwLCB4MSwgZHgpIHtcbiAgdmFyIHggPSBkM0FycmF5LnJhbmdlKHgwLCB4MSAtIGVwc2lsb24sIGR4KS5jb25jYXQoeDEpO1xuICByZXR1cm4gZnVuY3Rpb24oeSkgeyByZXR1cm4geC5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gW3gsIHldOyB9KTsgfTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlKCkge1xuICB2YXIgeDEsIHgwLCBYMSwgWDAsXG4gICAgICB5MSwgeTAsIFkxLCBZMCxcbiAgICAgIGR4ID0gMTAsIGR5ID0gZHgsIERYID0gOTAsIERZID0gMzYwLFxuICAgICAgeCwgeSwgWCwgWSxcbiAgICAgIHByZWNpc2lvbiA9IDIuNTtcblxuICBmdW5jdGlvbiBncmF0aWN1bGUoKSB7XG4gICAgcmV0dXJuIHt0eXBlOiBcIk11bHRpTGluZVN0cmluZ1wiLCBjb29yZGluYXRlczogbGluZXMoKX07XG4gIH1cblxuICBmdW5jdGlvbiBsaW5lcygpIHtcbiAgICByZXR1cm4gZDNBcnJheS5yYW5nZShjZWlsKFgwIC8gRFgpICogRFgsIFgxLCBEWCkubWFwKFgpXG4gICAgICAgIC5jb25jYXQoZDNBcnJheS5yYW5nZShjZWlsKFkwIC8gRFkpICogRFksIFkxLCBEWSkubWFwKFkpKVxuICAgICAgICAuY29uY2F0KGQzQXJyYXkucmFuZ2UoY2VpbCh4MCAvIGR4KSAqIGR4LCB4MSwgZHgpLmZpbHRlcihmdW5jdGlvbih4KSB7IHJldHVybiBhYnMoeCAlIERYKSA+IGVwc2lsb247IH0pLm1hcCh4KSlcbiAgICAgICAgLmNvbmNhdChkM0FycmF5LnJhbmdlKGNlaWwoeTAgLyBkeSkgKiBkeSwgeTEsIGR5KS5maWx0ZXIoZnVuY3Rpb24oeSkgeyByZXR1cm4gYWJzKHkgJSBEWSkgPiBlcHNpbG9uOyB9KS5tYXAoeSkpO1xuICB9XG5cbiAgZ3JhdGljdWxlLmxpbmVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxpbmVzKCkubWFwKGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7IHJldHVybiB7dHlwZTogXCJMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc307IH0pO1xuICB9O1xuXG4gIGdyYXRpY3VsZS5vdXRsaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgY29vcmRpbmF0ZXM6IFtcbiAgICAgICAgWChYMCkuY29uY2F0KFxuICAgICAgICBZKFkxKS5zbGljZSgxKSxcbiAgICAgICAgWChYMSkucmV2ZXJzZSgpLnNsaWNlKDEpLFxuICAgICAgICBZKFkwKS5yZXZlcnNlKCkuc2xpY2UoMSkpXG4gICAgICBdXG4gICAgfTtcbiAgfTtcblxuICBncmF0aWN1bGUuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGdyYXRpY3VsZS5leHRlbnRNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuZXh0ZW50TWFqb3IoXykuZXh0ZW50TWlub3IoXyk7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbWDAsIFkwXSwgW1gxLCBZMV1dO1xuICAgIFgwID0gK19bMF1bMF0sIFgxID0gK19bMV1bMF07XG4gICAgWTAgPSArX1swXVsxXSwgWTEgPSArX1sxXVsxXTtcbiAgICBpZiAoWDAgPiBYMSkgXyA9IFgwLCBYMCA9IFgxLCBYMSA9IF87XG4gICAgaWYgKFkwID4gWTEpIF8gPSBZMCwgWTAgPSBZMSwgWTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLmV4dGVudE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtbeDAsIHkwXSwgW3gxLCB5MV1dO1xuICAgIHgwID0gK19bMF1bMF0sIHgxID0gK19bMV1bMF07XG4gICAgeTAgPSArX1swXVsxXSwgeTEgPSArX1sxXVsxXTtcbiAgICBpZiAoeDAgPiB4MSkgXyA9IHgwLCB4MCA9IHgxLCB4MSA9IF87XG4gICAgaWYgKHkwID4geTEpIF8gPSB5MCwgeTAgPSB5MSwgeTEgPSBfO1xuICAgIHJldHVybiBncmF0aWN1bGUucHJlY2lzaW9uKHByZWNpc2lvbik7XG4gIH07XG5cbiAgZ3JhdGljdWxlLnN0ZXAgPSBmdW5jdGlvbihfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZ3JhdGljdWxlLnN0ZXBNaW5vcigpO1xuICAgIHJldHVybiBncmF0aWN1bGUuc3RlcE1ham9yKF8pLnN0ZXBNaW5vcihfKTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1ham9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtEWCwgRFldO1xuICAgIERYID0gK19bMF0sIERZID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUuc3RlcE1pbm9yID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIFtkeCwgZHldO1xuICAgIGR4ID0gK19bMF0sIGR5ID0gK19bMV07XG4gICAgcmV0dXJuIGdyYXRpY3VsZTtcbiAgfTtcblxuICBncmF0aWN1bGUucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHByZWNpc2lvbjtcbiAgICBwcmVjaXNpb24gPSArXztcbiAgICB4ID0gZ3JhdGljdWxlWCh5MCwgeTEsIDkwKTtcbiAgICB5ID0gZ3JhdGljdWxlWSh4MCwgeDEsIHByZWNpc2lvbik7XG4gICAgWCA9IGdyYXRpY3VsZVgoWTAsIFkxLCA5MCk7XG4gICAgWSA9IGdyYXRpY3VsZVkoWDAsIFgxLCBwcmVjaXNpb24pO1xuICAgIHJldHVybiBncmF0aWN1bGU7XG4gIH07XG5cbiAgcmV0dXJuIGdyYXRpY3VsZVxuICAgICAgLmV4dGVudE1ham9yKFtbLTE4MCwgLTkwICsgZXBzaWxvbl0sIFsxODAsIDkwIC0gZXBzaWxvbl1dKVxuICAgICAgLmV4dGVudE1pbm9yKFtbLTE4MCwgLTgwIC0gZXBzaWxvbl0sIFsxODAsIDgwICsgZXBzaWxvbl1dKTtcbn1cblxuZnVuY3Rpb24gZ3JhdGljdWxlMTAoKSB7XG4gIHJldHVybiBncmF0aWN1bGUoKSgpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShhLCBiKSB7XG4gIHZhciB4MCA9IGFbMF0gKiByYWRpYW5zLFxuICAgICAgeTAgPSBhWzFdICogcmFkaWFucyxcbiAgICAgIHgxID0gYlswXSAqIHJhZGlhbnMsXG4gICAgICB5MSA9IGJbMV0gKiByYWRpYW5zLFxuICAgICAgY3kwID0gY29zKHkwKSxcbiAgICAgIHN5MCA9IHNpbih5MCksXG4gICAgICBjeTEgPSBjb3MoeTEpLFxuICAgICAgc3kxID0gc2luKHkxKSxcbiAgICAgIGt4MCA9IGN5MCAqIGNvcyh4MCksXG4gICAgICBreTAgPSBjeTAgKiBzaW4oeDApLFxuICAgICAga3gxID0gY3kxICogY29zKHgxKSxcbiAgICAgIGt5MSA9IGN5MSAqIHNpbih4MSksXG4gICAgICBkID0gMiAqIGFzaW4oc3FydChoYXZlcnNpbih5MSAtIHkwKSArIGN5MCAqIGN5MSAqIGhhdmVyc2luKHgxIC0geDApKSksXG4gICAgICBrID0gc2luKGQpO1xuXG4gIHZhciBpbnRlcnBvbGF0ZSA9IGQgPyBmdW5jdGlvbih0KSB7XG4gICAgdmFyIEIgPSBzaW4odCAqPSBkKSAvIGssXG4gICAgICAgIEEgPSBzaW4oZCAtIHQpIC8gayxcbiAgICAgICAgeCA9IEEgKiBreDAgKyBCICoga3gxLFxuICAgICAgICB5ID0gQSAqIGt5MCArIEIgKiBreTEsXG4gICAgICAgIHogPSBBICogc3kwICsgQiAqIHN5MTtcbiAgICByZXR1cm4gW1xuICAgICAgYXRhbjIoeSwgeCkgKiBkZWdyZWVzLFxuICAgICAgYXRhbjIoeiwgc3FydCh4ICogeCArIHkgKiB5KSkgKiBkZWdyZWVzXG4gICAgXTtcbiAgfSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBbeDAgKiBkZWdyZWVzLCB5MCAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIGludGVycG9sYXRlLmRpc3RhbmNlID0gZDtcblxuICByZXR1cm4gaW50ZXJwb2xhdGU7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5cbnZhciBhcmVhU3VtJDEgPSBhZGRlcigpO1xudmFyIGFyZWFSaW5nU3VtJDEgPSBhZGRlcigpO1xudmFyIHgwMDtcbnZhciB5MDA7XG52YXIgeDAkMTtcbnZhciB5MCQxO1xuXG52YXIgYXJlYVN0cmVhbSQxID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBub29wLFxuICBsaW5lRW5kOiBub29wLFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIGFyZWFTdHJlYW0kMS5saW5lU3RhcnQgPSBhcmVhUmluZ1N0YXJ0JDE7XG4gICAgYXJlYVN0cmVhbSQxLmxpbmVFbmQgPSBhcmVhUmluZ0VuZCQxO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICBhcmVhU3RyZWFtJDEubGluZVN0YXJ0ID0gYXJlYVN0cmVhbSQxLmxpbmVFbmQgPSBhcmVhU3RyZWFtJDEucG9pbnQgPSBub29wO1xuICAgIGFyZWFTdW0kMS5hZGQoYWJzKGFyZWFSaW5nU3VtJDEpKTtcbiAgICBhcmVhUmluZ1N1bSQxLnJlc2V0KCk7XG4gIH0sXG4gIHJlc3VsdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZWEgPSBhcmVhU3VtJDEgLyAyO1xuICAgIGFyZWFTdW0kMS5yZXNldCgpO1xuICAgIHJldHVybiBhcmVhO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhcmVhUmluZ1N0YXJ0JDEoKSB7XG4gIGFyZWFTdHJlYW0kMS5wb2ludCA9IGFyZWFQb2ludEZpcnN0JDE7XG59XG5cbmZ1bmN0aW9uIGFyZWFQb2ludEZpcnN0JDEoeCwgeSkge1xuICBhcmVhU3RyZWFtJDEucG9pbnQgPSBhcmVhUG9pbnQkMTtcbiAgeDAwID0geDAkMSA9IHgsIHkwMCA9IHkwJDEgPSB5O1xufVxuXG5mdW5jdGlvbiBhcmVhUG9pbnQkMSh4LCB5KSB7XG4gIGFyZWFSaW5nU3VtJDEuYWRkKHkwJDEgKiB4IC0geDAkMSAqIHkpO1xuICB4MCQxID0geCwgeTAkMSA9IHk7XG59XG5cbmZ1bmN0aW9uIGFyZWFSaW5nRW5kJDEoKSB7XG4gIGFyZWFQb2ludCQxKHgwMCwgeTAwKTtcbn1cblxudmFyIHgwJDIgPSBJbmZpbml0eTtcbnZhciB5MCQyID0geDAkMjtcbnZhciB4MSA9IC14MCQyO1xudmFyIHkxID0geDE7XG5cbnZhciBib3VuZHNTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IGJvdW5kc1BvaW50JDEsXG4gIGxpbmVTdGFydDogbm9vcCxcbiAgbGluZUVuZDogbm9vcCxcbiAgcG9seWdvblN0YXJ0OiBub29wLFxuICBwb2x5Z29uRW5kOiBub29wLFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib3VuZHMgPSBbW3gwJDIsIHkwJDJdLCBbeDEsIHkxXV07XG4gICAgeDEgPSB5MSA9IC0oeTAkMiA9IHgwJDIgPSBJbmZpbml0eSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfVxufTtcblxuZnVuY3Rpb24gYm91bmRzUG9pbnQkMSh4LCB5KSB7XG4gIGlmICh4IDwgeDAkMikgeDAkMiA9IHg7XG4gIGlmICh4ID4geDEpIHgxID0geDtcbiAgaWYgKHkgPCB5MCQyKSB5MCQyID0geTtcbiAgaWYgKHkgPiB5MSkgeTEgPSB5O1xufVxuXG4vLyBUT0RPIEVuZm9yY2UgcG9zaXRpdmUgYXJlYSBmb3IgZXh0ZXJpb3IsIG5lZ2F0aXZlIGFyZWEgZm9yIGludGVyaW9yP1xuXG52YXIgWDAkMSA9IDA7XG52YXIgWTAkMSA9IDA7XG52YXIgWjAkMSA9IDA7XG52YXIgWDEkMSA9IDA7XG52YXIgWTEkMSA9IDA7XG52YXIgWjEkMSA9IDA7XG52YXIgWDIkMSA9IDA7XG52YXIgWTIkMSA9IDA7XG52YXIgWjIkMSA9IDA7XG52YXIgeDAwJDE7XG52YXIgeTAwJDE7XG52YXIgeDAkMztcbnZhciB5MCQzO1xuXG52YXIgY2VudHJvaWRTdHJlYW0kMSA9IHtcbiAgcG9pbnQ6IGNlbnRyb2lkUG9pbnQkMSxcbiAgbGluZVN0YXJ0OiBjZW50cm9pZExpbmVTdGFydCQxLFxuICBsaW5lRW5kOiBjZW50cm9pZExpbmVFbmQkMSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBjZW50cm9pZFN0cmVhbSQxLmxpbmVTdGFydCA9IGNlbnRyb2lkUmluZ1N0YXJ0JDE7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lRW5kID0gY2VudHJvaWRSaW5nRW5kJDE7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50JDE7XG4gICAgY2VudHJvaWRTdHJlYW0kMS5saW5lU3RhcnQgPSBjZW50cm9pZExpbmVTdGFydCQxO1xuICAgIGNlbnRyb2lkU3RyZWFtJDEubGluZUVuZCA9IGNlbnRyb2lkTGluZUVuZCQxO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjZW50cm9pZCA9IFoyJDEgPyBbWDIkMSAvIFoyJDEsIFkyJDEgLyBaMiQxXVxuICAgICAgICA6IFoxJDEgPyBbWDEkMSAvIFoxJDEsIFkxJDEgLyBaMSQxXVxuICAgICAgICA6IFowJDEgPyBbWDAkMSAvIFowJDEsIFkwJDEgLyBaMCQxXVxuICAgICAgICA6IFtOYU4sIE5hTl07XG4gICAgWDAkMSA9IFkwJDEgPSBaMCQxID1cbiAgICBYMSQxID0gWTEkMSA9IFoxJDEgPVxuICAgIFgyJDEgPSBZMiQxID0gWjIkMSA9IDA7XG4gICAgcmV0dXJuIGNlbnRyb2lkO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50JDEoeCwgeSkge1xuICBYMCQxICs9IHg7XG4gIFkwJDEgKz0geTtcbiAgKytaMCQxO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVTdGFydCQxKCkge1xuICBjZW50cm9pZFN0cmVhbSQxLnBvaW50ID0gY2VudHJvaWRQb2ludEZpcnN0TGluZTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRQb2ludEZpcnN0TGluZSh4LCB5KSB7XG4gIGNlbnRyb2lkU3RyZWFtJDEucG9pbnQgPSBjZW50cm9pZFBvaW50TGluZTtcbiAgY2VudHJvaWRQb2ludCQxKHgwJDMgPSB4LCB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRMaW5lKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwJDMsIGR5ID0geSAtIHkwJDMsIHogPSBzcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgWDEkMSArPSB6ICogKHgwJDMgKyB4KSAvIDI7XG4gIFkxJDEgKz0geiAqICh5MCQzICsgeSkgLyAyO1xuICBaMSQxICs9IHo7XG4gIGNlbnRyb2lkUG9pbnQkMSh4MCQzID0geCwgeTAkMyA9IHkpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZExpbmVFbmQkMSgpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnQkMTtcbn1cblxuZnVuY3Rpb24gY2VudHJvaWRSaW5nU3RhcnQkMSgpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRGaXJzdFJpbmc7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUmluZ0VuZCQxKCkge1xuICBjZW50cm9pZFBvaW50UmluZyh4MDAkMSwgeTAwJDEpO1xufVxuXG5mdW5jdGlvbiBjZW50cm9pZFBvaW50Rmlyc3RSaW5nKHgsIHkpIHtcbiAgY2VudHJvaWRTdHJlYW0kMS5wb2ludCA9IGNlbnRyb2lkUG9pbnRSaW5nO1xuICBjZW50cm9pZFBvaW50JDEoeDAwJDEgPSB4MCQzID0geCwgeTAwJDEgPSB5MCQzID0geSk7XG59XG5cbmZ1bmN0aW9uIGNlbnRyb2lkUG9pbnRSaW5nKHgsIHkpIHtcbiAgdmFyIGR4ID0geCAtIHgwJDMsXG4gICAgICBkeSA9IHkgLSB5MCQzLFxuICAgICAgeiA9IHNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIFgxJDEgKz0geiAqICh4MCQzICsgeCkgLyAyO1xuICBZMSQxICs9IHogKiAoeTAkMyArIHkpIC8gMjtcbiAgWjEkMSArPSB6O1xuXG4gIHogPSB5MCQzICogeCAtIHgwJDMgKiB5O1xuICBYMiQxICs9IHogKiAoeDAkMyArIHgpO1xuICBZMiQxICs9IHogKiAoeTAkMyArIHkpO1xuICBaMiQxICs9IHogKiAzO1xuICBjZW50cm9pZFBvaW50JDEoeDAkMyA9IHgsIHkwJDMgPSB5KTtcbn1cblxuZnVuY3Rpb24gUGF0aENvbnRleHQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuUGF0aENvbnRleHQucHJvdG90eXBlID0ge1xuICBfcmFkaXVzOiA0LjUsXG4gIHBvaW50UmFkaXVzOiBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JhZGl1cyA9IF8sIHRoaXM7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSA9PT0gMCkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIHRoaXMuX3BvaW50ID0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4ICsgdGhpcy5fcmFkaXVzLCB5KTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5hcmMoeCwgeSwgdGhpcy5fcmFkaXVzLCAwLCB0YXUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHJlc3VsdDogbm9vcFxufTtcblxudmFyIGxlbmd0aFN1bSQxID0gYWRkZXIoKTtcbnZhciBsZW5ndGhSaW5nO1xudmFyIHgwMCQyO1xudmFyIHkwMCQyO1xudmFyIHgwJDQ7XG52YXIgeTAkNDtcblxudmFyIGxlbmd0aFN0cmVhbSQxID0ge1xuICBwb2ludDogbm9vcCxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50Rmlyc3QkMTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGxlbmd0aFJpbmcpIGxlbmd0aFBvaW50JDEoeDAwJDIsIHkwMCQyKTtcbiAgICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IG5vb3A7XG4gIH0sXG4gIHBvbHlnb25TdGFydDogZnVuY3Rpb24oKSB7XG4gICAgbGVuZ3RoUmluZyA9IHRydWU7XG4gIH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGxlbmd0aFJpbmcgPSBudWxsO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBsZW5ndGggPSArbGVuZ3RoU3VtJDE7XG4gICAgbGVuZ3RoU3VtJDEucmVzZXQoKTtcbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9XG59O1xuXG5mdW5jdGlvbiBsZW5ndGhQb2ludEZpcnN0JDEoeCwgeSkge1xuICBsZW5ndGhTdHJlYW0kMS5wb2ludCA9IGxlbmd0aFBvaW50JDE7XG4gIHgwMCQyID0geDAkNCA9IHgsIHkwMCQyID0geTAkNCA9IHk7XG59XG5cbmZ1bmN0aW9uIGxlbmd0aFBvaW50JDEoeCwgeSkge1xuICB4MCQ0IC09IHgsIHkwJDQgLT0geTtcbiAgbGVuZ3RoU3VtJDEuYWRkKHNxcnQoeDAkNCAqIHgwJDQgKyB5MCQ0ICogeTAkNCkpO1xuICB4MCQ0ID0geCwgeTAkNCA9IHk7XG59XG5cbmZ1bmN0aW9uIFBhdGhTdHJpbmcoKSB7XG4gIHRoaXMuX3N0cmluZyA9IFtdO1xufVxuXG5QYXRoU3RyaW5nLnByb3RvdHlwZSA9IHtcbiAgX3JhZGl1czogNC41LFxuICBfY2lyY2xlOiBjaXJjbGUkMSg0LjUpLFxuICBwb2ludFJhZGl1czogZnVuY3Rpb24oXykge1xuICAgIGlmICgoXyA9ICtfKSAhPT0gdGhpcy5fcmFkaXVzKSB0aGlzLl9yYWRpdXMgPSBfLCB0aGlzLl9jaXJjbGUgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgPT09IDApIHRoaXMuX3N0cmluZy5wdXNoKFwiWlwiKTtcbiAgICB0aGlzLl9wb2ludCA9IE5hTjtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHtcbiAgICAgICAgdGhpcy5fc3RyaW5nLnB1c2goXCJNXCIsIHgsIFwiLFwiLCB5KTtcbiAgICAgICAgdGhpcy5fcG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIkxcIiwgeCwgXCIsXCIsIHkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgaWYgKHRoaXMuX2NpcmNsZSA9PSBudWxsKSB0aGlzLl9jaXJjbGUgPSBjaXJjbGUkMSh0aGlzLl9yYWRpdXMpO1xuICAgICAgICB0aGlzLl9zdHJpbmcucHVzaChcIk1cIiwgeCwgXCIsXCIsIHksIHRoaXMuX2NpcmNsZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fc3RyaW5nLmxlbmd0aCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX3N0cmluZy5qb2luKFwiXCIpO1xuICAgICAgdGhpcy5fc3RyaW5nID0gW107XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNpcmNsZSQxKHJhZGl1cykge1xuICByZXR1cm4gXCJtMCxcIiArIHJhZGl1c1xuICAgICAgKyBcImFcIiArIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIgMCAxLDEgMCxcIiArIC0yICogcmFkaXVzXG4gICAgICArIFwiYVwiICsgcmFkaXVzICsgXCIsXCIgKyByYWRpdXMgKyBcIiAwIDEsMSAwLFwiICsgMiAqIHJhZGl1c1xuICAgICAgKyBcInpcIjtcbn1cblxuZnVuY3Rpb24gaW5kZXgocHJvamVjdGlvbiwgY29udGV4dCkge1xuICB2YXIgcG9pbnRSYWRpdXMgPSA0LjUsXG4gICAgICBwcm9qZWN0aW9uU3RyZWFtLFxuICAgICAgY29udGV4dFN0cmVhbTtcblxuICBmdW5jdGlvbiBwYXRoKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9pbnRSYWRpdXMgPT09IFwiZnVuY3Rpb25cIikgY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrcG9pbnRSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGNvbnRleHRTdHJlYW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHRTdHJlYW0ucmVzdWx0KCk7XG4gIH1cblxuICBwYXRoLmFyZWEgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBnZW9TdHJlYW0ob2JqZWN0LCBwcm9qZWN0aW9uU3RyZWFtKGFyZWFTdHJlYW0kMSkpO1xuICAgIHJldHVybiBhcmVhU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5tZWFzdXJlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgZ2VvU3RyZWFtKG9iamVjdCwgcHJvamVjdGlvblN0cmVhbShsZW5ndGhTdHJlYW0kMSkpO1xuICAgIHJldHVybiBsZW5ndGhTdHJlYW0kMS5yZXN1bHQoKTtcbiAgfTtcblxuICBwYXRoLmJvdW5kcyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oYm91bmRzU3RyZWFtJDEpKTtcbiAgICByZXR1cm4gYm91bmRzU3RyZWFtJDEucmVzdWx0KCk7XG4gIH07XG5cbiAgcGF0aC5jZW50cm9pZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb25TdHJlYW0oY2VudHJvaWRTdHJlYW0kMSkpO1xuICAgIHJldHVybiBjZW50cm9pZFN0cmVhbSQxLnJlc3VsdCgpO1xuICB9O1xuXG4gIHBhdGgucHJvamVjdGlvbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwcm9qZWN0aW9uU3RyZWFtID0gXyA9PSBudWxsID8gKHByb2plY3Rpb24gPSBudWxsLCBpZGVudGl0eSkgOiAocHJvamVjdGlvbiA9IF8pLnN0cmVhbSwgcGF0aCkgOiBwcm9qZWN0aW9uO1xuICB9O1xuXG4gIHBhdGguY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb250ZXh0O1xuICAgIGNvbnRleHRTdHJlYW0gPSBfID09IG51bGwgPyAoY29udGV4dCA9IG51bGwsIG5ldyBQYXRoU3RyaW5nKSA6IG5ldyBQYXRoQ29udGV4dChjb250ZXh0ID0gXyk7XG4gICAgaWYgKHR5cGVvZiBwb2ludFJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSBjb250ZXh0U3RyZWFtLnBvaW50UmFkaXVzKHBvaW50UmFkaXVzKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICBwYXRoLnBvaW50UmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHBvaW50UmFkaXVzO1xuICAgIHBvaW50UmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiAoY29udGV4dFN0cmVhbS5wb2ludFJhZGl1cygrXyksICtfKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcblxuICByZXR1cm4gcGF0aC5wcm9qZWN0aW9uKHByb2plY3Rpb24pLmNvbnRleHQoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShtZXRob2RzKSB7XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiB0cmFuc2Zvcm1lcihtZXRob2RzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1lcihtZXRob2RzKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICB2YXIgcyA9IG5ldyBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZm9yICh2YXIga2V5IGluIG1ldGhvZHMpIHNba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICBzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICByZXR1cm4gcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtKCkge31cblxuVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRyYW5zZm9ybVN0cmVhbSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdGhpcy5zdHJlYW0ucG9pbnQoeCwgeSk7IH0sXG4gIHNwaGVyZTogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLnNwaGVyZSgpOyB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5saW5lU3RhcnQoKTsgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHRoaXMuc3RyZWFtLmxpbmVFbmQoKTsgfSxcbiAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgdGhpcy5zdHJlYW0ucG9seWdvblN0YXJ0KCk7IH0sXG4gIHBvbHlnb25FbmQ6IGZ1bmN0aW9uKCkgeyB0aGlzLnN0cmVhbS5wb2x5Z29uRW5kKCk7IH1cbn07XG5cbmZ1bmN0aW9uIGZpdChwcm9qZWN0aW9uLCBmaXRCb3VuZHMsIG9iamVjdCkge1xuICB2YXIgY2xpcCA9IHByb2plY3Rpb24uY2xpcEV4dGVudCAmJiBwcm9qZWN0aW9uLmNsaXBFeHRlbnQoKTtcbiAgcHJvamVjdGlvbi5zY2FsZSgxNTApLnRyYW5zbGF0ZShbMCwgMF0pO1xuICBpZiAoY2xpcCAhPSBudWxsKSBwcm9qZWN0aW9uLmNsaXBFeHRlbnQobnVsbCk7XG4gIGdlb1N0cmVhbShvYmplY3QsIHByb2plY3Rpb24uc3RyZWFtKGJvdW5kc1N0cmVhbSQxKSk7XG4gIGZpdEJvdW5kcyhib3VuZHNTdHJlYW0kMS5yZXN1bHQoKSk7XG4gIGlmIChjbGlwICE9IG51bGwpIHByb2plY3Rpb24uY2xpcEV4dGVudChjbGlwKTtcbiAgcmV0dXJuIHByb2plY3Rpb247XG59XG5cbmZ1bmN0aW9uIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCkge1xuICByZXR1cm4gZml0KHByb2plY3Rpb24sIGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgdyA9IGV4dGVudFsxXVswXSAtIGV4dGVudFswXVswXSxcbiAgICAgICAgaCA9IGV4dGVudFsxXVsxXSAtIGV4dGVudFswXVsxXSxcbiAgICAgICAgayA9IE1hdGgubWluKHcgLyAoYlsxXVswXSAtIGJbMF1bMF0pLCBoIC8gKGJbMV1bMV0gLSBiWzBdWzFdKSksXG4gICAgICAgIHggPSArZXh0ZW50WzBdWzBdICsgKHcgLSBrICogKGJbMV1bMF0gKyBiWzBdWzBdKSkgLyAyLFxuICAgICAgICB5ID0gK2V4dGVudFswXVsxXSArIChoIC0gayAqIChiWzFdWzFdICsgYlswXVsxXSkpIC8gMjtcbiAgICBwcm9qZWN0aW9uLnNjYWxlKDE1MCAqIGspLnRyYW5zbGF0ZShbeCwgeV0pO1xuICB9LCBvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBmaXRTaXplKHByb2plY3Rpb24sIHNpemUsIG9iamVjdCkge1xuICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIFtbMCwgMF0sIHNpemVdLCBvYmplY3QpO1xufVxuXG5mdW5jdGlvbiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciB3ID0gK3dpZHRoLFxuICAgICAgICBrID0gdyAvIChiWzFdWzBdIC0gYlswXVswXSksXG4gICAgICAgIHggPSAodyAtIGsgKiAoYlsxXVswXSArIGJbMF1bMF0pKSAvIDIsXG4gICAgICAgIHkgPSAtayAqIGJbMF1bMV07XG4gICAgcHJvamVjdGlvbi5zY2FsZSgxNTAgKiBrKS50cmFuc2xhdGUoW3gsIHldKTtcbiAgfSwgb2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KSB7XG4gIHJldHVybiBmaXQocHJvamVjdGlvbiwgZnVuY3Rpb24oYikge1xuICAgIHZhciBoID0gK2hlaWdodCxcbiAgICAgICAgayA9IGggLyAoYlsxXVsxXSAtIGJbMF1bMV0pLFxuICAgICAgICB4ID0gLWsgKiBiWzBdWzBdLFxuICAgICAgICB5ID0gKGggLSBrICogKGJbMV1bMV0gKyBiWzBdWzFdKSkgLyAyO1xuICAgIHByb2plY3Rpb24uc2NhbGUoMTUwICogaykudHJhbnNsYXRlKFt4LCB5XSk7XG4gIH0sIG9iamVjdCk7XG59XG5cbnZhciBtYXhEZXB0aCA9IDE2O1xudmFyIGNvc01pbkRpc3RhbmNlID0gY29zKDMwICogcmFkaWFucyk7IC8vIGNvcyhtaW5pbXVtIGFuZ3VsYXIgZGlzdGFuY2UpXG5cbmZ1bmN0aW9uIHJlc2FtcGxlKHByb2plY3QsIGRlbHRhMikge1xuICByZXR1cm4gK2RlbHRhMiA/IHJlc2FtcGxlJDEocHJvamVjdCwgZGVsdGEyKSA6IHJlc2FtcGxlTm9uZShwcm9qZWN0KTtcbn1cblxuZnVuY3Rpb24gcmVzYW1wbGVOb25lKHByb2plY3QpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybWVyKHtcbiAgICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgeCA9IHByb2plY3QoeCwgeSk7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4WzBdLCB4WzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNhbXBsZSQxKHByb2plY3QsIGRlbHRhMikge1xuXG4gIGZ1bmN0aW9uIHJlc2FtcGxlTGluZVRvKHgwLCB5MCwgbGFtYmRhMCwgYTAsIGIwLCBjMCwgeDEsIHkxLCBsYW1iZGExLCBhMSwgYjEsIGMxLCBkZXB0aCwgc3RyZWFtKSB7XG4gICAgdmFyIGR4ID0geDEgLSB4MCxcbiAgICAgICAgZHkgPSB5MSAtIHkwLFxuICAgICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGlmIChkMiA+IDQgKiBkZWx0YTIgJiYgZGVwdGgtLSkge1xuICAgICAgdmFyIGEgPSBhMCArIGExLFxuICAgICAgICAgIGIgPSBiMCArIGIxLFxuICAgICAgICAgIGMgPSBjMCArIGMxLFxuICAgICAgICAgIG0gPSBzcXJ0KGEgKiBhICsgYiAqIGIgKyBjICogYyksXG4gICAgICAgICAgcGhpMiA9IGFzaW4oYyAvPSBtKSxcbiAgICAgICAgICBsYW1iZGEyID0gYWJzKGFicyhjKSAtIDEpIDwgZXBzaWxvbiB8fCBhYnMobGFtYmRhMCAtIGxhbWJkYTEpIDwgZXBzaWxvbiA/IChsYW1iZGEwICsgbGFtYmRhMSkgLyAyIDogYXRhbjIoYiwgYSksXG4gICAgICAgICAgcCA9IHByb2plY3QobGFtYmRhMiwgcGhpMiksXG4gICAgICAgICAgeDIgPSBwWzBdLFxuICAgICAgICAgIHkyID0gcFsxXSxcbiAgICAgICAgICBkeDIgPSB4MiAtIHgwLFxuICAgICAgICAgIGR5MiA9IHkyIC0geTAsXG4gICAgICAgICAgZHogPSBkeSAqIGR4MiAtIGR4ICogZHkyO1xuICAgICAgaWYgKGR6ICogZHogLyBkMiA+IGRlbHRhMiAvLyBwZXJwZW5kaWN1bGFyIHByb2plY3RlZCBkaXN0YW5jZVxuICAgICAgICAgIHx8IGFicygoZHggKiBkeDIgKyBkeSAqIGR5MikgLyBkMiAtIDAuNSkgPiAwLjMgLy8gbWlkcG9pbnQgY2xvc2UgdG8gYW4gZW5kXG4gICAgICAgICAgfHwgYTAgKiBhMSArIGIwICogYjEgKyBjMCAqIGMxIDwgY29zTWluRGlzdGFuY2UpIHsgLy8gYW5ndWxhciBkaXN0YW5jZVxuICAgICAgICByZXNhbXBsZUxpbmVUbyh4MCwgeTAsIGxhbWJkYTAsIGEwLCBiMCwgYzAsIHgyLCB5MiwgbGFtYmRhMiwgYSAvPSBtLCBiIC89IG0sIGMsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgICBzdHJlYW0ucG9pbnQoeDIsIHkyKTtcbiAgICAgICAgcmVzYW1wbGVMaW5lVG8oeDIsIHkyLCBsYW1iZGEyLCBhLCBiLCBjLCB4MSwgeTEsIGxhbWJkYTEsIGExLCBiMSwgYzEsIGRlcHRoLCBzdHJlYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgdmFyIGxhbWJkYTAwLCB4MDAsIHkwMCwgYTAwLCBiMDAsIGMwMCwgLy8gZmlyc3QgcG9pbnRcbiAgICAgICAgbGFtYmRhMCwgeDAsIHkwLCBhMCwgYjAsIGMwOyAvLyBwcmV2aW91cyBwb2ludFxuXG4gICAgdmFyIHJlc2FtcGxlU3RyZWFtID0ge1xuICAgICAgcG9pbnQ6IHBvaW50LFxuICAgICAgbGluZVN0YXJ0OiBsaW5lU3RhcnQsXG4gICAgICBsaW5lRW5kOiBsaW5lRW5kLFxuICAgICAgcG9seWdvblN0YXJ0OiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25TdGFydCgpOyByZXNhbXBsZVN0cmVhbS5saW5lU3RhcnQgPSByaW5nU3RhcnQ7IH0sXG4gICAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgc3RyZWFtLnBvbHlnb25FbmQoKTsgcmVzYW1wbGVTdHJlYW0ubGluZVN0YXJ0ID0gbGluZVN0YXJ0OyB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHBvaW50KHgsIHkpIHtcbiAgICAgIHggPSBwcm9qZWN0KHgsIHkpO1xuICAgICAgc3RyZWFtLnBvaW50KHhbMF0sIHhbMV0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpbmVTdGFydCgpIHtcbiAgICAgIHgwID0gTmFOO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBsaW5lUG9pbnQ7XG4gICAgICBzdHJlYW0ubGluZVN0YXJ0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZVBvaW50KGxhbWJkYSwgcGhpKSB7XG4gICAgICB2YXIgYyA9IGNhcnRlc2lhbihbbGFtYmRhLCBwaGldKSwgcCA9IHByb2plY3QobGFtYmRhLCBwaGkpO1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MCA9IHBbMF0sIHkwID0gcFsxXSwgbGFtYmRhMCA9IGxhbWJkYSwgYTAgPSBjWzBdLCBiMCA9IGNbMV0sIGMwID0gY1syXSwgbWF4RGVwdGgsIHN0cmVhbSk7XG4gICAgICBzdHJlYW0ucG9pbnQoeDAsIHkwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaW5lRW5kKCkge1xuICAgICAgcmVzYW1wbGVTdHJlYW0ucG9pbnQgPSBwb2ludDtcbiAgICAgIHN0cmVhbS5saW5lRW5kKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmluZ1N0YXJ0KCkge1xuICAgICAgbGluZVN0YXJ0KCk7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IHJpbmdQb2ludDtcbiAgICAgIHJlc2FtcGxlU3RyZWFtLmxpbmVFbmQgPSByaW5nRW5kO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJpbmdQb2ludChsYW1iZGEsIHBoaSkge1xuICAgICAgbGluZVBvaW50KGxhbWJkYTAwID0gbGFtYmRhLCBwaGkpLCB4MDAgPSB4MCwgeTAwID0geTAsIGEwMCA9IGEwLCBiMDAgPSBiMCwgYzAwID0gYzA7XG4gICAgICByZXNhbXBsZVN0cmVhbS5wb2ludCA9IGxpbmVQb2ludDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByaW5nRW5kKCkge1xuICAgICAgcmVzYW1wbGVMaW5lVG8oeDAsIHkwLCBsYW1iZGEwLCBhMCwgYjAsIGMwLCB4MDAsIHkwMCwgbGFtYmRhMDAsIGEwMCwgYjAwLCBjMDAsIG1heERlcHRoLCBzdHJlYW0pO1xuICAgICAgcmVzYW1wbGVTdHJlYW0ubGluZUVuZCA9IGxpbmVFbmQ7XG4gICAgICBsaW5lRW5kKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc2FtcGxlU3RyZWFtO1xuICB9O1xufVxuXG52YXIgdHJhbnNmb3JtUmFkaWFucyA9IHRyYW5zZm9ybWVyKHtcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICogcmFkaWFucywgeSAqIHJhZGlhbnMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtUm90YXRlKHJvdGF0ZSkge1xuICByZXR1cm4gdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB2YXIgciA9IHJvdGF0ZSh4LCB5KTtcbiAgICAgIHJldHVybiB0aGlzLnN0cmVhbS5wb2ludChyWzBdLCByWzFdKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZShrLCBkeCwgZHkpIHtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtJCQxKHgsIHkpIHtcbiAgICByZXR1cm4gW2R4ICsgayAqIHgsIGR5IC0gayAqIHldO1xuICB9XG4gIHRyYW5zZm9ybSQkMS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFsoeCAtIGR4KSAvIGssIChkeSAtIHkpIC8ga107XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm0kJDE7XG59XG5cbmZ1bmN0aW9uIHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIGR4LCBkeSwgYWxwaGEpIHtcbiAgdmFyIGNvc0FscGhhID0gY29zKGFscGhhKSxcbiAgICAgIHNpbkFscGhhID0gc2luKGFscGhhKSxcbiAgICAgIGEgPSBjb3NBbHBoYSAqIGssXG4gICAgICBiID0gc2luQWxwaGEgKiBrLFxuICAgICAgYWkgPSBjb3NBbHBoYSAvIGssXG4gICAgICBiaSA9IHNpbkFscGhhIC8gayxcbiAgICAgIGNpID0gKHNpbkFscGhhICogZHkgLSBjb3NBbHBoYSAqIGR4KSAvIGssXG4gICAgICBmaSA9IChzaW5BbHBoYSAqIGR4ICsgY29zQWxwaGEgKiBkeSkgLyBrO1xuICBmdW5jdGlvbiB0cmFuc2Zvcm0kJDEoeCwgeSkge1xuICAgIHJldHVybiBbYSAqIHggLSBiICogeSArIGR4LCBkeSAtIGIgKiB4IC0gYSAqIHldO1xuICB9XG4gIHRyYW5zZm9ybSQkMS5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIFthaSAqIHggLSBiaSAqIHkgKyBjaSwgZmkgLSBiaSAqIHggLSBhaSAqIHldO1xuICB9O1xuICByZXR1cm4gdHJhbnNmb3JtJCQxO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgcmV0dXJuIHByb2plY3Rpb25NdXRhdG9yKGZ1bmN0aW9uKCkgeyByZXR1cm4gcHJvamVjdDsgfSkoKTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdGlvbk11dGF0b3IocHJvamVjdEF0KSB7XG4gIHZhciBwcm9qZWN0LFxuICAgICAgayA9IDE1MCwgLy8gc2NhbGVcbiAgICAgIHggPSA0ODAsIHkgPSAyNTAsIC8vIHRyYW5zbGF0ZVxuICAgICAgbGFtYmRhID0gMCwgcGhpID0gMCwgLy8gY2VudGVyXG4gICAgICBkZWx0YUxhbWJkYSA9IDAsIGRlbHRhUGhpID0gMCwgZGVsdGFHYW1tYSA9IDAsIHJvdGF0ZSwgLy8gcHJlLXJvdGF0ZVxuICAgICAgYWxwaGEgPSAwLCAvLyBwb3N0LXJvdGF0ZVxuICAgICAgdGhldGEgPSBudWxsLCBwcmVjbGlwID0gY2xpcEFudGltZXJpZGlhbiwgLy8gcHJlLWNsaXAgYW5nbGVcbiAgICAgIHgwID0gbnVsbCwgeTAsIHgxLCB5MSwgcG9zdGNsaXAgPSBpZGVudGl0eSwgLy8gcG9zdC1jbGlwIGV4dGVudFxuICAgICAgZGVsdGEyID0gMC41LCAvLyBwcmVjaXNpb25cbiAgICAgIHByb2plY3RSZXNhbXBsZSxcbiAgICAgIHByb2plY3RUcmFuc2Zvcm0sXG4gICAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLFxuICAgICAgY2FjaGUsXG4gICAgICBjYWNoZVN0cmVhbTtcblxuICBmdW5jdGlvbiBwcm9qZWN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIHByb2plY3RSb3RhdGVUcmFuc2Zvcm0ocG9pbnRbMF0gKiByYWRpYW5zLCBwb2ludFsxXSAqIHJhZGlhbnMpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52ZXJ0KHBvaW50KSB7XG4gICAgcG9pbnQgPSBwcm9qZWN0Um90YXRlVHJhbnNmb3JtLmludmVydChwb2ludFswXSwgcG9pbnRbMV0pO1xuICAgIHJldHVybiBwb2ludCAmJiBbcG9pbnRbMF0gKiBkZWdyZWVzLCBwb2ludFsxXSAqIGRlZ3JlZXNdO1xuICB9XG5cbiAgcHJvamVjdGlvbi5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSB0cmFuc2Zvcm1SYWRpYW5zKHRyYW5zZm9ybVJvdGF0ZShyb3RhdGUpKHByZWNsaXAocHJvamVjdFJlc2FtcGxlKHBvc3RjbGlwKGNhY2hlU3RyZWFtID0gc3RyZWFtKSkpKSk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjbGlwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHByZWNsaXAgPSBfLCB0aGV0YSA9IHVuZGVmaW5lZCwgcmVzZXQoKSkgOiBwcmVjbGlwO1xuICB9O1xuXG4gIHByb2plY3Rpb24ucG9zdGNsaXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfLCB4MCA9IHkwID0geDEgPSB5MSA9IG51bGwsIHJlc2V0KCkpIDogcG9zdGNsaXA7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jbGlwQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJlY2xpcCA9ICtfID8gY2xpcENpcmNsZSh0aGV0YSA9IF8gKiByYWRpYW5zKSA6ICh0aGV0YSA9IG51bGwsIGNsaXBBbnRpbWVyaWRpYW4pLCByZXNldCgpKSA6IHRoZXRhICogZGVncmVlcztcbiAgfTtcblxuICBwcm9qZWN0aW9uLmNsaXBFeHRlbnQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChrID0gK18sIHJlY2VudGVyKCkpIDogaztcbiAgfTtcblxuICBwcm9qZWN0aW9uLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK19bMF0sIHkgPSArX1sxXSwgcmVjZW50ZXIoKSkgOiBbeCwgeV07XG4gIH07XG5cbiAgcHJvamVjdGlvbi5jZW50ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobGFtYmRhID0gX1swXSAlIDM2MCAqIHJhZGlhbnMsIHBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCByZWNlbnRlcigpKSA6IFtsYW1iZGEgKiBkZWdyZWVzLCBwaGkgKiBkZWdyZWVzXTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLnJvdGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkZWx0YUxhbWJkYSA9IF9bMF0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YVBoaSA9IF9bMV0gJSAzNjAgKiByYWRpYW5zLCBkZWx0YUdhbW1hID0gXy5sZW5ndGggPiAyID8gX1syXSAlIDM2MCAqIHJhZGlhbnMgOiAwLCByZWNlbnRlcigpKSA6IFtkZWx0YUxhbWJkYSAqIGRlZ3JlZXMsIGRlbHRhUGhpICogZGVncmVlcywgZGVsdGFHYW1tYSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHByb2plY3Rpb24uYW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSBfICUgMzYwICogcmFkaWFucywgcmVjZW50ZXIoKSkgOiBhbHBoYSAqIGRlZ3JlZXM7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5wcmVjaXNpb24gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocHJvamVjdFJlc2FtcGxlID0gcmVzYW1wbGUocHJvamVjdFRyYW5zZm9ybSwgZGVsdGEyID0gXyAqIF8pLCByZXNldCgpKSA6IHNxcnQoZGVsdGEyKTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChwcm9qZWN0aW9uLCBleHRlbnQsIG9iamVjdCk7XG4gIH07XG5cbiAgcHJvamVjdGlvbi5maXRTaXplID0gZnVuY3Rpb24oc2l6ZSwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdFdpZHRoID0gZnVuY3Rpb24od2lkdGgsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRXaWR0aChwcm9qZWN0aW9uLCB3aWR0aCwgb2JqZWN0KTtcbiAgfTtcblxuICBwcm9qZWN0aW9uLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChwcm9qZWN0aW9uLCBoZWlnaHQsIG9iamVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVjZW50ZXIoKSB7XG4gICAgdmFyIGNlbnRlciA9IHNjYWxlVHJhbnNsYXRlUm90YXRlKGssIDAsIDAsIGFscGhhKS5hcHBseShudWxsLCBwcm9qZWN0KGxhbWJkYSwgcGhpKSksXG4gICAgICAgIHRyYW5zZm9ybSQkMSA9IChhbHBoYSA/IHNjYWxlVHJhbnNsYXRlUm90YXRlIDogc2NhbGVUcmFuc2xhdGUpKGssIHggLSBjZW50ZXJbMF0sIHkgLSBjZW50ZXJbMV0sIGFscGhhKTtcbiAgICByb3RhdGUgPSByb3RhdGVSYWRpYW5zKGRlbHRhTGFtYmRhLCBkZWx0YVBoaSwgZGVsdGFHYW1tYSk7XG4gICAgcHJvamVjdFRyYW5zZm9ybSA9IGNvbXBvc2UocHJvamVjdCwgdHJhbnNmb3JtJCQxKTtcbiAgICBwcm9qZWN0Um90YXRlVHJhbnNmb3JtID0gY29tcG9zZShyb3RhdGUsIHByb2plY3RUcmFuc2Zvcm0pO1xuICAgIHByb2plY3RSZXNhbXBsZSA9IHJlc2FtcGxlKHByb2plY3RUcmFuc2Zvcm0sIGRlbHRhMik7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBwcm9qZWN0ID0gcHJvamVjdEF0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcHJvamVjdGlvbi5pbnZlcnQgPSBwcm9qZWN0LmludmVydCAmJiBpbnZlcnQ7XG4gICAgcmV0dXJuIHJlY2VudGVyKCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbmljUHJvamVjdGlvbihwcm9qZWN0QXQpIHtcbiAgdmFyIHBoaTAgPSAwLFxuICAgICAgcGhpMSA9IHBpIC8gMyxcbiAgICAgIG0gPSBwcm9qZWN0aW9uTXV0YXRvcihwcm9qZWN0QXQpLFxuICAgICAgcCA9IG0ocGhpMCwgcGhpMSk7XG5cbiAgcC5wYXJhbGxlbHMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBtKHBoaTAgPSBfWzBdICogcmFkaWFucywgcGhpMSA9IF9bMV0gKiByYWRpYW5zKSA6IFtwaGkwICogZGVncmVlcywgcGhpMSAqIGRlZ3JlZXNdO1xuICB9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBjeWxpbmRyaWNhbEVxdWFsQXJlYVJhdyhwaGkwKSB7XG4gIHZhciBjb3NQaGkwID0gY29zKHBoaTApO1xuXG4gIGZ1bmN0aW9uIGZvcndhcmQobGFtYmRhLCBwaGkpIHtcbiAgICByZXR1cm4gW2xhbWJkYSAqIGNvc1BoaTAsIHNpbihwaGkpIC8gY29zUGhpMF07XG4gIH1cblxuICBmb3J3YXJkLmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gW3ggLyBjb3NQaGkwLCBhc2luKHkgKiBjb3NQaGkwKV07XG4gIH07XG5cbiAgcmV0dXJuIGZvcndhcmQ7XG59XG5cbmZ1bmN0aW9uIGNvbmljRXF1YWxBcmVhUmF3KHkwLCB5MSkge1xuICB2YXIgc3kwID0gc2luKHkwKSwgbiA9IChzeTAgKyBzaW4oeTEpKSAvIDI7XG5cbiAgLy8gQXJlIHRoZSBwYXJhbGxlbHMgc3ltbWV0cmljYWwgYXJvdW5kIHRoZSBFcXVhdG9yP1xuICBpZiAoYWJzKG4pIDwgZXBzaWxvbikgcmV0dXJuIGN5bGluZHJpY2FsRXF1YWxBcmVhUmF3KHkwKTtcblxuICB2YXIgYyA9IDEgKyBzeTAgKiAoMiAqIG4gLSBzeTApLCByMCA9IHNxcnQoYykgLyBuO1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIHZhciByID0gc3FydChjIC0gMiAqIG4gKiBzaW4oeSkpIC8gbjtcbiAgICByZXR1cm4gW3IgKiBzaW4oeCAqPSBuKSwgcjAgLSByICogY29zKHgpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciByMHkgPSByMCAtIHk7XG4gICAgcmV0dXJuIFthdGFuMih4LCBhYnMocjB5KSkgLyBuICogc2lnbihyMHkpLCBhc2luKChjIC0gKHggKiB4ICsgcjB5ICogcjB5KSAqIG4gKiBuKSAvICgyICogbikpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVhbEFyZWEoKSB7XG4gIHJldHVybiBjb25pY1Byb2plY3Rpb24oY29uaWNFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTU1LjQyNClcbiAgICAgIC5jZW50ZXIoWzAsIDMzLjY0NDJdKTtcbn1cblxuZnVuY3Rpb24gYWxiZXJzKCkge1xuICByZXR1cm4gY29uaWNFcXVhbEFyZWEoKVxuICAgICAgLnBhcmFsbGVscyhbMjkuNSwgNDUuNV0pXG4gICAgICAuc2NhbGUoMTA3MClcbiAgICAgIC50cmFuc2xhdGUoWzQ4MCwgMjUwXSlcbiAgICAgIC5yb3RhdGUoWzk2LCAwXSlcbiAgICAgIC5jZW50ZXIoWy0wLjYsIDM4LjddKTtcbn1cblxuLy8gVGhlIHByb2plY3Rpb25zIG11c3QgaGF2ZSBtdXR1YWxseSBleGNsdXNpdmUgY2xpcCByZWdpb25zIG9uIHRoZSBzcGhlcmUsXG4vLyBhcyB0aGlzIHdpbGwgYXZvaWQgZW1pdHRpbmcgaW50ZXJsZWF2aW5nIGxpbmVzIGFuZCBwb2x5Z29ucy5cbmZ1bmN0aW9uIG11bHRpcGxleChzdHJlYW1zKSB7XG4gIHZhciBuID0gc3RyZWFtcy5sZW5ndGg7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9pbnQoeCwgeSk7IH0sXG4gICAgc3BoZXJlOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0uc3BoZXJlKCk7IH0sXG4gICAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ubGluZVN0YXJ0KCk7IH0sXG4gICAgbGluZUVuZDogZnVuY3Rpb24oKSB7IHZhciBpID0gLTE7IHdoaWxlICgrK2kgPCBuKSBzdHJlYW1zW2ldLmxpbmVFbmQoKTsgfSxcbiAgICBwb2x5Z29uU3RhcnQ6IGZ1bmN0aW9uKCkgeyB2YXIgaSA9IC0xOyB3aGlsZSAoKytpIDwgbikgc3RyZWFtc1tpXS5wb2x5Z29uU3RhcnQoKTsgfSxcbiAgICBwb2x5Z29uRW5kOiBmdW5jdGlvbigpIHsgdmFyIGkgPSAtMTsgd2hpbGUgKCsraSA8IG4pIHN0cmVhbXNbaV0ucG9seWdvbkVuZCgpOyB9XG4gIH07XG59XG5cbi8vIEEgY29tcG9zaXRlIHByb2plY3Rpb24gZm9yIHRoZSBVbml0ZWQgU3RhdGVzLCBjb25maWd1cmVkIGJ5IGRlZmF1bHQgZm9yXG4vLyA5NjDDlzUwMC4gVGhlIHByb2plY3Rpb24gYWxzbyB3b3JrcyBxdWl0ZSB3ZWxsIGF0IDk2MMOXNjAwIGlmIHlvdSBjaGFuZ2UgdGhlXG4vLyBzY2FsZSB0byAxMjg1IGFuZCBhZGp1c3QgdGhlIHRyYW5zbGF0ZSBhY2NvcmRpbmdseS4gVGhlIHNldCBvZiBzdGFuZGFyZFxuLy8gcGFyYWxsZWxzIGZvciBlYWNoIHJlZ2lvbiBjb21lcyBmcm9tIFVTR1MsIHdoaWNoIGlzIHB1Ymxpc2hlZCBoZXJlOlxuLy8gaHR0cDovL2Vnc2MudXNncy5nb3YvaXNiL3B1YnMvTWFwUHJvamVjdGlvbnMvcHJvamVjdGlvbnMuaHRtbCNhbGJlcnNcbmZ1bmN0aW9uIGFsYmVyc1VzYSgpIHtcbiAgdmFyIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBsb3dlcjQ4ID0gYWxiZXJzKCksIGxvd2VyNDhQb2ludCxcbiAgICAgIGFsYXNrYSA9IGNvbmljRXF1YWxBcmVhKCkucm90YXRlKFsxNTQsIDBdKS5jZW50ZXIoWy0yLCA1OC41XSkucGFyYWxsZWxzKFs1NSwgNjVdKSwgYWxhc2thUG9pbnQsIC8vIEVQU0c6MzMzOFxuICAgICAgaGF3YWlpID0gY29uaWNFcXVhbEFyZWEoKS5yb3RhdGUoWzE1NywgMF0pLmNlbnRlcihbLTMsIDE5LjldKS5wYXJhbGxlbHMoWzgsIDE4XSksIGhhd2FpaVBvaW50LCAvLyBFU1JJOjEwMjAwN1xuICAgICAgcG9pbnQsIHBvaW50U3RyZWFtID0ge3BvaW50OiBmdW5jdGlvbih4LCB5KSB7IHBvaW50ID0gW3gsIHldOyB9fTtcblxuICBmdW5jdGlvbiBhbGJlcnNVc2EoY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgeCA9IGNvb3JkaW5hdGVzWzBdLCB5ID0gY29vcmRpbmF0ZXNbMV07XG4gICAgcmV0dXJuIHBvaW50ID0gbnVsbCwgKGxvd2VyNDhQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChhbGFza2FQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpXG4gICAgICAgIHx8IChoYXdhaWlQb2ludC5wb2ludCh4LCB5KSwgcG9pbnQpO1xuICB9XG5cbiAgYWxiZXJzVXNhLmludmVydCA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGsgPSBsb3dlcjQ4LnNjYWxlKCksXG4gICAgICAgIHQgPSBsb3dlcjQ4LnRyYW5zbGF0ZSgpLFxuICAgICAgICB4ID0gKGNvb3JkaW5hdGVzWzBdIC0gdFswXSkgLyBrLFxuICAgICAgICB5ID0gKGNvb3JkaW5hdGVzWzFdIC0gdFsxXSkgLyBrO1xuICAgIHJldHVybiAoeSA+PSAwLjEyMCAmJiB5IDwgMC4yMzQgJiYgeCA+PSAtMC40MjUgJiYgeCA8IC0wLjIxNCA/IGFsYXNrYVxuICAgICAgICA6IHkgPj0gMC4xNjYgJiYgeSA8IDAuMjM0ICYmIHggPj0gLTAuMjE0ICYmIHggPCAtMC4xMTUgPyBoYXdhaWlcbiAgICAgICAgOiBsb3dlcjQ4KS5pbnZlcnQoY29vcmRpbmF0ZXMpO1xuICB9O1xuXG4gIGFsYmVyc1VzYS5zdHJlYW0gPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICByZXR1cm4gY2FjaGUgJiYgY2FjaGVTdHJlYW0gPT09IHN0cmVhbSA/IGNhY2hlIDogY2FjaGUgPSBtdWx0aXBsZXgoW2xvd2VyNDguc3RyZWFtKGNhY2hlU3RyZWFtID0gc3RyZWFtKSwgYWxhc2thLnN0cmVhbShzdHJlYW0pLCBoYXdhaWkuc3RyZWFtKHN0cmVhbSldKTtcbiAgfTtcblxuICBhbGJlcnNVc2EucHJlY2lzaW9uID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDgucHJlY2lzaW9uKCk7XG4gICAgbG93ZXI0OC5wcmVjaXNpb24oXyksIGFsYXNrYS5wcmVjaXNpb24oXyksIGhhd2FpaS5wcmVjaXNpb24oXyk7XG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnNjYWxlID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGxvd2VyNDguc2NhbGUoKTtcbiAgICBsb3dlcjQ4LnNjYWxlKF8pLCBhbGFza2Euc2NhbGUoXyAqIDAuMzUpLCBoYXdhaWkuc2NhbGUoXyk7XG4gICAgcmV0dXJuIGFsYmVyc1VzYS50cmFuc2xhdGUobG93ZXI0OC50cmFuc2xhdGUoKSk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBsb3dlcjQ4LnRyYW5zbGF0ZSgpO1xuICAgIHZhciBrID0gbG93ZXI0OC5zY2FsZSgpLCB4ID0gK19bMF0sIHkgPSArX1sxXTtcblxuICAgIGxvd2VyNDhQb2ludCA9IGxvd2VyNDhcbiAgICAgICAgLnRyYW5zbGF0ZShfKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQ1NSAqIGssIHkgLSAwLjIzOCAqIGtdLCBbeCArIDAuNDU1ICogaywgeSArIDAuMjM4ICoga11dKVxuICAgICAgICAuc3RyZWFtKHBvaW50U3RyZWFtKTtcblxuICAgIGFsYXNrYVBvaW50ID0gYWxhc2thXG4gICAgICAgIC50cmFuc2xhdGUoW3ggLSAwLjMwNyAqIGssIHkgKyAwLjIwMSAqIGtdKVxuICAgICAgICAuY2xpcEV4dGVudChbW3ggLSAwLjQyNSAqIGsgKyBlcHNpbG9uLCB5ICsgMC4xMjAgKiBrICsgZXBzaWxvbl0sIFt4IC0gMC4yMTQgKiBrIC0gZXBzaWxvbiwgeSArIDAuMjM0ICogayAtIGVwc2lsb25dXSlcbiAgICAgICAgLnN0cmVhbShwb2ludFN0cmVhbSk7XG5cbiAgICBoYXdhaWlQb2ludCA9IGhhd2FpaVxuICAgICAgICAudHJhbnNsYXRlKFt4IC0gMC4yMDUgKiBrLCB5ICsgMC4yMTIgKiBrXSlcbiAgICAgICAgLmNsaXBFeHRlbnQoW1t4IC0gMC4yMTQgKiBrICsgZXBzaWxvbiwgeSArIDAuMTY2ICogayArIGVwc2lsb25dLCBbeCAtIDAuMTE1ICogayAtIGVwc2lsb24sIHkgKyAwLjIzNCAqIGsgLSBlcHNpbG9uXV0pXG4gICAgICAgIC5zdHJlYW0ocG9pbnRTdHJlYW0pO1xuXG4gICAgcmV0dXJuIHJlc2V0KCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEV4dGVudCA9IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEV4dGVudChhbGJlcnNVc2EsIGV4dGVudCwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0U2l6ZSA9IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgIHJldHVybiBmaXRTaXplKGFsYmVyc1VzYSwgc2l6ZSwgb2JqZWN0KTtcbiAgfTtcblxuICBhbGJlcnNVc2EuZml0V2lkdGggPSBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdFdpZHRoKGFsYmVyc1VzYSwgd2lkdGgsIG9iamVjdCk7XG4gIH07XG5cbiAgYWxiZXJzVXNhLmZpdEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgcmV0dXJuIGZpdEhlaWdodChhbGJlcnNVc2EsIGhlaWdodCwgb2JqZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBjYWNoZSA9IGNhY2hlU3RyZWFtID0gbnVsbDtcbiAgICByZXR1cm4gYWxiZXJzVXNhO1xuICB9XG5cbiAgcmV0dXJuIGFsYmVyc1VzYS5zY2FsZSgxMDcwKTtcbn1cblxuZnVuY3Rpb24gYXppbXV0aGFsUmF3KHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIGN4ID0gY29zKHgpLFxuICAgICAgICBjeSA9IGNvcyh5KSxcbiAgICAgICAgayA9IHNjYWxlKGN4ICogY3kpO1xuICAgIHJldHVybiBbXG4gICAgICBrICogY3kgKiBzaW4oeCksXG4gICAgICBrICogc2luKHkpXG4gICAgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhemltdXRoYWxJbnZlcnQoYW5nbGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgeiA9IHNxcnQoeCAqIHggKyB5ICogeSksXG4gICAgICAgIGMgPSBhbmdsZSh6KSxcbiAgICAgICAgc2MgPSBzaW4oYyksXG4gICAgICAgIGNjID0gY29zKGMpO1xuICAgIHJldHVybiBbXG4gICAgICBhdGFuMih4ICogc2MsIHogKiBjYyksXG4gICAgICBhc2luKHogJiYgeSAqIHNjIC8geilcbiAgICBdO1xuICB9XG59XG5cbnZhciBhemltdXRoYWxFcXVhbEFyZWFSYXcgPSBhemltdXRoYWxSYXcoZnVuY3Rpb24oY3hjeSkge1xuICByZXR1cm4gc3FydCgyIC8gKDEgKyBjeGN5KSk7XG59KTtcblxuYXppbXV0aGFsRXF1YWxBcmVhUmF3LmludmVydCA9IGF6aW11dGhhbEludmVydChmdW5jdGlvbih6KSB7XG4gIHJldHVybiAyICogYXNpbih6IC8gMik7XG59KTtcblxuZnVuY3Rpb24gYXppbXV0aGFsRXF1YWxBcmVhKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihhemltdXRoYWxFcXVhbEFyZWFSYXcpXG4gICAgICAuc2NhbGUoMTI0Ljc1KVxuICAgICAgLmNsaXBBbmdsZSgxODAgLSAxZS0zKTtcbn1cblxudmFyIGF6aW11dGhhbEVxdWlkaXN0YW50UmF3ID0gYXppbXV0aGFsUmF3KGZ1bmN0aW9uKGMpIHtcbiAgcmV0dXJuIChjID0gYWNvcyhjKSkgJiYgYyAvIHNpbihjKTtcbn0pO1xuXG5hemltdXRoYWxFcXVpZGlzdGFudFJhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoZnVuY3Rpb24oeikge1xuICByZXR1cm4gejtcbn0pO1xuXG5mdW5jdGlvbiBhemltdXRoYWxFcXVpZGlzdGFudCgpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oYXppbXV0aGFsRXF1aWRpc3RhbnRSYXcpXG4gICAgICAuc2NhbGUoNzkuNDE4OClcbiAgICAgIC5jbGlwQW5nbGUoMTgwIC0gMWUtMyk7XG59XG5cbmZ1bmN0aW9uIG1lcmNhdG9yUmF3KGxhbWJkYSwgcGhpKSB7XG4gIHJldHVybiBbbGFtYmRhLCBsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpXTtcbn1cblxubWVyY2F0b3JSYXcuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gW3gsIDIgKiBhdGFuKGV4cCh5KSkgLSBoYWxmUGldO1xufTtcblxuZnVuY3Rpb24gbWVyY2F0b3IoKSB7XG4gIHJldHVybiBtZXJjYXRvclByb2plY3Rpb24obWVyY2F0b3JSYXcpXG4gICAgICAuc2NhbGUoOTYxIC8gdGF1KTtcbn1cblxuZnVuY3Rpb24gbWVyY2F0b3JQcm9qZWN0aW9uKHByb2plY3QpIHtcbiAgdmFyIG0gPSBwcm9qZWN0aW9uKHByb2plY3QpLFxuICAgICAgY2VudGVyID0gbS5jZW50ZXIsXG4gICAgICBzY2FsZSA9IG0uc2NhbGUsXG4gICAgICB0cmFuc2xhdGUgPSBtLnRyYW5zbGF0ZSxcbiAgICAgIGNsaXBFeHRlbnQgPSBtLmNsaXBFeHRlbnQsXG4gICAgICB4MCA9IG51bGwsIHkwLCB4MSwgeTE7IC8vIGNsaXAgZXh0ZW50XG5cbiAgbS5zY2FsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZShfKSwgcmVjbGlwKCkpIDogc2NhbGUoKTtcbiAgfTtcblxuICBtLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0cmFuc2xhdGUoXyksIHJlY2xpcCgpKSA6IHRyYW5zbGF0ZSgpO1xuICB9O1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNlbnRlcihfKSwgcmVjbGlwKCkpIDogY2VudGVyKCk7XG4gIH07XG5cbiAgbS5jbGlwRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IHgwID0geTAgPSB4MSA9IHkxID0gbnVsbCA6ICh4MCA9ICtfWzBdWzBdLCB5MCA9ICtfWzBdWzFdLCB4MSA9ICtfWzFdWzBdLCB5MSA9ICtfWzFdWzFdKSwgcmVjbGlwKCkpIDogeDAgPT0gbnVsbCA/IG51bGwgOiBbW3gwLCB5MF0sIFt4MSwgeTFdXTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWNsaXAoKSB7XG4gICAgdmFyIGsgPSBwaSAqIHNjYWxlKCksXG4gICAgICAgIHQgPSBtKHJvdGF0aW9uKG0ucm90YXRlKCkpLmludmVydChbMCwgMF0pKTtcbiAgICByZXR1cm4gY2xpcEV4dGVudCh4MCA9PSBudWxsXG4gICAgICAgID8gW1t0WzBdIC0gaywgdFsxXSAtIGtdLCBbdFswXSArIGssIHRbMV0gKyBrXV0gOiBwcm9qZWN0ID09PSBtZXJjYXRvclJhd1xuICAgICAgICA/IFtbTWF0aC5tYXgodFswXSAtIGssIHgwKSwgeTBdLCBbTWF0aC5taW4odFswXSArIGssIHgxKSwgeTFdXVxuICAgICAgICA6IFtbeDAsIE1hdGgubWF4KHRbMV0gLSBrLCB5MCldLCBbeDEsIE1hdGgubWluKHRbMV0gKyBrLCB5MSldXSk7XG4gIH1cblxuICByZXR1cm4gcmVjbGlwKCk7XG59XG5cbmZ1bmN0aW9uIHRhbnkoeSkge1xuICByZXR1cm4gdGFuKChoYWxmUGkgKyB5KSAvIDIpO1xufVxuXG5mdW5jdGlvbiBjb25pY0NvbmZvcm1hbFJhdyh5MCwgeTEpIHtcbiAgdmFyIGN5MCA9IGNvcyh5MCksXG4gICAgICBuID0geTAgPT09IHkxID8gc2luKHkwKSA6IGxvZyhjeTAgLyBjb3MoeTEpKSAvIGxvZyh0YW55KHkxKSAvIHRhbnkoeTApKSxcbiAgICAgIGYgPSBjeTAgKiBwb3codGFueSh5MCksIG4pIC8gbjtcblxuICBpZiAoIW4pIHJldHVybiBtZXJjYXRvclJhdztcblxuICBmdW5jdGlvbiBwcm9qZWN0KHgsIHkpIHtcbiAgICBpZiAoZiA+IDApIHsgaWYgKHkgPCAtaGFsZlBpICsgZXBzaWxvbikgeSA9IC1oYWxmUGkgKyBlcHNpbG9uOyB9XG4gICAgZWxzZSB7IGlmICh5ID4gaGFsZlBpIC0gZXBzaWxvbikgeSA9IGhhbGZQaSAtIGVwc2lsb247IH1cbiAgICB2YXIgciA9IGYgLyBwb3codGFueSh5KSwgbik7XG4gICAgcmV0dXJuIFtyICogc2luKG4gKiB4KSwgZiAtIHIgKiBjb3MobiAqIHgpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBmeSA9IGYgLSB5LCByID0gc2lnbihuKSAqIHNxcnQoeCAqIHggKyBmeSAqIGZ5KTtcbiAgICByZXR1cm4gW2F0YW4yKHgsIGFicyhmeSkpIC8gbiAqIHNpZ24oZnkpLCAyICogYXRhbihwb3coZiAvIHIsIDEgLyBuKSkgLSBoYWxmUGldO1xuICB9O1xuXG4gIHJldHVybiBwcm9qZWN0O1xufVxuXG5mdW5jdGlvbiBjb25pY0NvbmZvcm1hbCgpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0NvbmZvcm1hbFJhdylcbiAgICAgIC5zY2FsZSgxMDkuNSlcbiAgICAgIC5wYXJhbGxlbHMoWzMwLCAzMF0pO1xufVxuXG5mdW5jdGlvbiBlcXVpcmVjdGFuZ3VsYXJSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsYW1iZGEsIHBoaV07XG59XG5cbmVxdWlyZWN0YW5ndWxhclJhdy5pbnZlcnQgPSBlcXVpcmVjdGFuZ3VsYXJSYXc7XG5cbmZ1bmN0aW9uIGVxdWlyZWN0YW5ndWxhcigpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZXF1aXJlY3Rhbmd1bGFyUmF3KVxuICAgICAgLnNjYWxlKDE1Mi42Myk7XG59XG5cbmZ1bmN0aW9uIGNvbmljRXF1aWRpc3RhbnRSYXcoeTAsIHkxKSB7XG4gIHZhciBjeTAgPSBjb3MoeTApLFxuICAgICAgbiA9IHkwID09PSB5MSA/IHNpbih5MCkgOiAoY3kwIC0gY29zKHkxKSkgLyAoeTEgLSB5MCksXG4gICAgICBnID0gY3kwIC8gbiArIHkwO1xuXG4gIGlmIChhYnMobikgPCBlcHNpbG9uKSByZXR1cm4gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuXG4gIGZ1bmN0aW9uIHByb2plY3QoeCwgeSkge1xuICAgIHZhciBneSA9IGcgLSB5LCBueCA9IG4gKiB4O1xuICAgIHJldHVybiBbZ3kgKiBzaW4obngpLCBnIC0gZ3kgKiBjb3MobngpXTtcbiAgfVxuXG4gIHByb2plY3QuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBneSA9IGcgLSB5O1xuICAgIHJldHVybiBbYXRhbjIoeCwgYWJzKGd5KSkgLyBuICogc2lnbihneSksIGcgLSBzaWduKG4pICogc3FydCh4ICogeCArIGd5ICogZ3kpXTtcbiAgfTtcblxuICByZXR1cm4gcHJvamVjdDtcbn1cblxuZnVuY3Rpb24gY29uaWNFcXVpZGlzdGFudCgpIHtcbiAgcmV0dXJuIGNvbmljUHJvamVjdGlvbihjb25pY0VxdWlkaXN0YW50UmF3KVxuICAgICAgLnNjYWxlKDEzMS4xNTQpXG4gICAgICAuY2VudGVyKFswLCAxMy45Mzg5XSk7XG59XG5cbmZ1bmN0aW9uIGdub21vbmljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gY29zKHgpICogY3k7XG4gIHJldHVybiBbY3kgKiBzaW4oeCkgLyBrLCBzaW4oeSkgLyBrXTtcbn1cblxuZ25vbW9uaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGF0YW4pO1xuXG5mdW5jdGlvbiBnbm9tb25pYygpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24oZ25vbW9uaWNSYXcpXG4gICAgICAuc2NhbGUoMTQ0LjA0OSlcbiAgICAgIC5jbGlwQW5nbGUoNjApO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZSQxKGt4LCBreSwgdHgsIHR5KSB7XG4gIHJldHVybiBreCA9PT0gMSAmJiBreSA9PT0gMSAmJiB0eCA9PT0gMCAmJiB0eSA9PT0gMCA/IGlkZW50aXR5IDogdHJhbnNmb3JtZXIoe1xuICAgIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0cmVhbS5wb2ludCh4ICoga3ggKyB0eCwgeSAqIGt5ICsgdHkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5JDEoKSB7XG4gIHZhciBrID0gMSwgdHggPSAwLCB0eSA9IDAsIHN4ID0gMSwgc3kgPSAxLCB0cmFuc2Zvcm0kJDEgPSBpZGVudGl0eSwgLy8gc2NhbGUsIHRyYW5zbGF0ZSBhbmQgcmVmbGVjdFxuICAgICAgeDAgPSBudWxsLCB5MCwgeDEsIHkxLCAvLyBjbGlwIGV4dGVudFxuICAgICAgcG9zdGNsaXAgPSBpZGVudGl0eSxcbiAgICAgIGNhY2hlLFxuICAgICAgY2FjaGVTdHJlYW0sXG4gICAgICBwcm9qZWN0aW9uO1xuXG4gIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIGNhY2hlID0gY2FjaGVTdHJlYW0gPSBudWxsO1xuICAgIHJldHVybiBwcm9qZWN0aW9uO1xuICB9XG5cbiAgcmV0dXJuIHByb2plY3Rpb24gPSB7XG4gICAgc3RyZWFtOiBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIHJldHVybiBjYWNoZSAmJiBjYWNoZVN0cmVhbSA9PT0gc3RyZWFtID8gY2FjaGUgOiBjYWNoZSA9IHRyYW5zZm9ybSQkMShwb3N0Y2xpcChjYWNoZVN0cmVhbSA9IHN0cmVhbSkpO1xuICAgIH0sXG4gICAgcG9zdGNsaXA6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBvc3RjbGlwID0gXywgeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCByZXNldCgpKSA6IHBvc3RjbGlwO1xuICAgIH0sXG4gICAgY2xpcEV4dGVudDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocG9zdGNsaXAgPSBfID09IG51bGwgPyAoeDAgPSB5MCA9IHgxID0geTEgPSBudWxsLCBpZGVudGl0eSkgOiBjbGlwUmVjdGFuZ2xlKHgwID0gK19bMF1bMF0sIHkwID0gK19bMF1bMV0sIHgxID0gK19bMV1bMF0sIHkxID0gK19bMV1bMV0pLCByZXNldCgpKSA6IHgwID09IG51bGwgPyBudWxsIDogW1t4MCwgeTBdLCBbeDEsIHkxXV07XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMSgoayA9ICtfKSAqIHN4LCBrICogc3ksIHR4LCB0eSksIHJlc2V0KCkpIDogaztcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiBzeSwgdHggPSArX1swXSwgdHkgPSArX1sxXSksIHJlc2V0KCkpIDogW3R4LCB0eV07XG4gICAgfSxcbiAgICByZWZsZWN0WDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogKHN4ID0gXyA/IC0xIDogMSksIGsgKiBzeSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeCA8IDA7XG4gICAgfSxcbiAgICByZWZsZWN0WTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodHJhbnNmb3JtJCQxID0gc2NhbGVUcmFuc2xhdGUkMShrICogc3gsIGsgKiAoc3kgPSBfID8gLTEgOiAxKSwgdHgsIHR5KSwgcmVzZXQoKSkgOiBzeSA8IDA7XG4gICAgfSxcbiAgICBmaXRFeHRlbnQ6IGZ1bmN0aW9uKGV4dGVudCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0RXh0ZW50KHByb2plY3Rpb24sIGV4dGVudCwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdFNpemU6IGZ1bmN0aW9uKHNpemUsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGZpdFNpemUocHJvamVjdGlvbiwgc2l6ZSwgb2JqZWN0KTtcbiAgICB9LFxuICAgIGZpdFdpZHRoOiBmdW5jdGlvbih3aWR0aCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0V2lkdGgocHJvamVjdGlvbiwgd2lkdGgsIG9iamVjdCk7XG4gICAgfSxcbiAgICBmaXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgb2JqZWN0KSB7XG4gICAgICByZXR1cm4gZml0SGVpZ2h0KHByb2plY3Rpb24sIGhlaWdodCwgb2JqZWN0KTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5hdHVyYWxFYXJ0aDFSYXcobGFtYmRhLCBwaGkpIHtcbiAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgcmV0dXJuIFtcbiAgICBsYW1iZGEgKiAoMC44NzA3IC0gMC4xMzE5NzkgKiBwaGkyICsgcGhpNCAqICgtMC4wMTM3OTEgKyBwaGk0ICogKDAuMDAzOTcxICogcGhpMiAtIDAuMDAxNTI5ICogcGhpNCkpKSxcbiAgICBwaGkgKiAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICsgcGhpNCAqICgtMC4wNDQ0NzUgKyAwLjAyODg3NCAqIHBoaTIgLSAwLjAwNTkxNiAqIHBoaTQpKSlcbiAgXTtcbn1cblxubmF0dXJhbEVhcnRoMVJhdy5pbnZlcnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBwaGkgPSB5LCBpID0gMjUsIGRlbHRhO1xuICBkbyB7XG4gICAgdmFyIHBoaTIgPSBwaGkgKiBwaGksIHBoaTQgPSBwaGkyICogcGhpMjtcbiAgICBwaGkgLT0gZGVsdGEgPSAocGhpICogKDEuMDA3MjI2ICsgcGhpMiAqICgwLjAxNTA4NSArIHBoaTQgKiAoLTAuMDQ0NDc1ICsgMC4wMjg4NzQgKiBwaGkyIC0gMC4wMDU5MTYgKiBwaGk0KSkpIC0geSkgL1xuICAgICAgICAoMS4wMDcyMjYgKyBwaGkyICogKDAuMDE1MDg1ICogMyArIHBoaTQgKiAoLTAuMDQ0NDc1ICogNyArIDAuMDI4ODc0ICogOSAqIHBoaTIgLSAwLjAwNTkxNiAqIDExICogcGhpNCkpKTtcbiAgfSB3aGlsZSAoYWJzKGRlbHRhKSA+IGVwc2lsb24gJiYgLS1pID4gMCk7XG4gIHJldHVybiBbXG4gICAgeCAvICgwLjg3MDcgKyAocGhpMiA9IHBoaSAqIHBoaSkgKiAoLTAuMTMxOTc5ICsgcGhpMiAqICgtMC4wMTM3OTEgKyBwaGkyICogcGhpMiAqIHBoaTIgKiAoMC4wMDM5NzEgLSAwLjAwMTUyOSAqIHBoaTIpKSkpLFxuICAgIHBoaVxuICBdO1xufTtcblxuZnVuY3Rpb24gbmF0dXJhbEVhcnRoMSgpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24obmF0dXJhbEVhcnRoMVJhdylcbiAgICAgIC5zY2FsZSgxNzUuMjk1KTtcbn1cblxuZnVuY3Rpb24gb3J0aG9ncmFwaGljUmF3KHgsIHkpIHtcbiAgcmV0dXJuIFtjb3MoeSkgKiBzaW4oeCksIHNpbih5KV07XG59XG5cbm9ydGhvZ3JhcGhpY1Jhdy5pbnZlcnQgPSBhemltdXRoYWxJbnZlcnQoYXNpbik7XG5cbmZ1bmN0aW9uIG9ydGhvZ3JhcGhpYygpIHtcbiAgcmV0dXJuIHByb2plY3Rpb24ob3J0aG9ncmFwaGljUmF3KVxuICAgICAgLnNjYWxlKDI0OS41KVxuICAgICAgLmNsaXBBbmdsZSg5MCArIGVwc2lsb24pO1xufVxuXG5mdW5jdGlvbiBzdGVyZW9ncmFwaGljUmF3KHgsIHkpIHtcbiAgdmFyIGN5ID0gY29zKHkpLCBrID0gMSArIGNvcyh4KSAqIGN5O1xuICByZXR1cm4gW2N5ICogc2luKHgpIC8gaywgc2luKHkpIC8ga107XG59XG5cbnN0ZXJlb2dyYXBoaWNSYXcuaW52ZXJ0ID0gYXppbXV0aGFsSW52ZXJ0KGZ1bmN0aW9uKHopIHtcbiAgcmV0dXJuIDIgKiBhdGFuKHopO1xufSk7XG5cbmZ1bmN0aW9uIHN0ZXJlb2dyYXBoaWMoKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uKHN0ZXJlb2dyYXBoaWNSYXcpXG4gICAgICAuc2NhbGUoMjUwKVxuICAgICAgLmNsaXBBbmdsZSgxNDIpO1xufVxuXG5mdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3JSYXcobGFtYmRhLCBwaGkpIHtcbiAgcmV0dXJuIFtsb2codGFuKChoYWxmUGkgKyBwaGkpIC8gMikpLCAtbGFtYmRhXTtcbn1cblxudHJhbnN2ZXJzZU1lcmNhdG9yUmF3LmludmVydCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIFsteSwgMiAqIGF0YW4oZXhwKHgpKSAtIGhhbGZQaV07XG59O1xuXG5mdW5jdGlvbiB0cmFuc3ZlcnNlTWVyY2F0b3IoKSB7XG4gIHZhciBtID0gbWVyY2F0b3JQcm9qZWN0aW9uKHRyYW5zdmVyc2VNZXJjYXRvclJhdyksXG4gICAgICBjZW50ZXIgPSBtLmNlbnRlcixcbiAgICAgIHJvdGF0ZSA9IG0ucm90YXRlO1xuXG4gIG0uY2VudGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gY2VudGVyKFstX1sxXSwgX1swXV0pIDogKF8gPSBjZW50ZXIoKSwgW19bMV0sIC1fWzBdXSk7XG4gIH07XG5cbiAgbS5yb3RhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyByb3RhdGUoW19bMF0sIF9bMV0sIF8ubGVuZ3RoID4gMiA/IF9bMl0gKyA5MCA6IDkwXSkgOiAoXyA9IHJvdGF0ZSgpLCBbX1swXSwgX1sxXSwgX1syXSAtIDkwXSk7XG4gIH07XG5cbiAgcmV0dXJuIHJvdGF0ZShbMCwgMCwgOTBdKVxuICAgICAgLnNjYWxlKDE1OS4xNTUpO1xufVxuXG5leHBvcnRzLmdlb0FyZWEgPSBhcmVhO1xuZXhwb3J0cy5nZW9Cb3VuZHMgPSBib3VuZHM7XG5leHBvcnRzLmdlb0NlbnRyb2lkID0gY2VudHJvaWQ7XG5leHBvcnRzLmdlb0NpcmNsZSA9IGNpcmNsZTtcbmV4cG9ydHMuZ2VvQ2xpcEFudGltZXJpZGlhbiA9IGNsaXBBbnRpbWVyaWRpYW47XG5leHBvcnRzLmdlb0NsaXBDaXJjbGUgPSBjbGlwQ2lyY2xlO1xuZXhwb3J0cy5nZW9DbGlwRXh0ZW50ID0gZXh0ZW50O1xuZXhwb3J0cy5nZW9DbGlwUmVjdGFuZ2xlID0gY2xpcFJlY3RhbmdsZTtcbmV4cG9ydHMuZ2VvQ29udGFpbnMgPSBjb250YWlucztcbmV4cG9ydHMuZ2VvRGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZ2VvR3JhdGljdWxlID0gZ3JhdGljdWxlO1xuZXhwb3J0cy5nZW9HcmF0aWN1bGUxMCA9IGdyYXRpY3VsZTEwO1xuZXhwb3J0cy5nZW9JbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuZXhwb3J0cy5nZW9MZW5ndGggPSBsZW5ndGg7XG5leHBvcnRzLmdlb1BhdGggPSBpbmRleDtcbmV4cG9ydHMuZ2VvQWxiZXJzID0gYWxiZXJzO1xuZXhwb3J0cy5nZW9BbGJlcnNVc2EgPSBhbGJlcnNVc2E7XG5leHBvcnRzLmdlb0F6aW11dGhhbEVxdWFsQXJlYSA9IGF6aW11dGhhbEVxdWFsQXJlYTtcbmV4cG9ydHMuZ2VvQXppbXV0aGFsRXF1YWxBcmVhUmF3ID0gYXppbXV0aGFsRXF1YWxBcmVhUmF3O1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudCA9IGF6aW11dGhhbEVxdWlkaXN0YW50O1xuZXhwb3J0cy5nZW9BemltdXRoYWxFcXVpZGlzdGFudFJhdyA9IGF6aW11dGhhbEVxdWlkaXN0YW50UmF3O1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbCA9IGNvbmljQ29uZm9ybWFsO1xuZXhwb3J0cy5nZW9Db25pY0NvbmZvcm1hbFJhdyA9IGNvbmljQ29uZm9ybWFsUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYSA9IGNvbmljRXF1YWxBcmVhO1xuZXhwb3J0cy5nZW9Db25pY0VxdWFsQXJlYVJhdyA9IGNvbmljRXF1YWxBcmVhUmF3O1xuZXhwb3J0cy5nZW9Db25pY0VxdWlkaXN0YW50ID0gY29uaWNFcXVpZGlzdGFudDtcbmV4cG9ydHMuZ2VvQ29uaWNFcXVpZGlzdGFudFJhdyA9IGNvbmljRXF1aWRpc3RhbnRSYXc7XG5leHBvcnRzLmdlb0VxdWlyZWN0YW5ndWxhciA9IGVxdWlyZWN0YW5ndWxhcjtcbmV4cG9ydHMuZ2VvRXF1aXJlY3Rhbmd1bGFyUmF3ID0gZXF1aXJlY3Rhbmd1bGFyUmF3O1xuZXhwb3J0cy5nZW9Hbm9tb25pYyA9IGdub21vbmljO1xuZXhwb3J0cy5nZW9Hbm9tb25pY1JhdyA9IGdub21vbmljUmF3O1xuZXhwb3J0cy5nZW9JZGVudGl0eSA9IGlkZW50aXR5JDE7XG5leHBvcnRzLmdlb1Byb2plY3Rpb24gPSBwcm9qZWN0aW9uO1xuZXhwb3J0cy5nZW9Qcm9qZWN0aW9uTXV0YXRvciA9IHByb2plY3Rpb25NdXRhdG9yO1xuZXhwb3J0cy5nZW9NZXJjYXRvciA9IG1lcmNhdG9yO1xuZXhwb3J0cy5nZW9NZXJjYXRvclJhdyA9IG1lcmNhdG9yUmF3O1xuZXhwb3J0cy5nZW9OYXR1cmFsRWFydGgxID0gbmF0dXJhbEVhcnRoMTtcbmV4cG9ydHMuZ2VvTmF0dXJhbEVhcnRoMVJhdyA9IG5hdHVyYWxFYXJ0aDFSYXc7XG5leHBvcnRzLmdlb09ydGhvZ3JhcGhpYyA9IG9ydGhvZ3JhcGhpYztcbmV4cG9ydHMuZ2VvT3J0aG9ncmFwaGljUmF3ID0gb3J0aG9ncmFwaGljUmF3O1xuZXhwb3J0cy5nZW9TdGVyZW9ncmFwaGljID0gc3RlcmVvZ3JhcGhpYztcbmV4cG9ydHMuZ2VvU3RlcmVvZ3JhcGhpY1JhdyA9IHN0ZXJlb2dyYXBoaWNSYXc7XG5leHBvcnRzLmdlb1RyYW5zdmVyc2VNZXJjYXRvciA9IHRyYW5zdmVyc2VNZXJjYXRvcjtcbmV4cG9ydHMuZ2VvVHJhbnN2ZXJzZU1lcmNhdG9yUmF3ID0gdHJhbnN2ZXJzZU1lcmNhdG9yUmF3O1xuZXhwb3J0cy5nZW9Sb3RhdGlvbiA9IHJvdGF0aW9uO1xuZXhwb3J0cy5nZW9TdHJlYW0gPSBnZW9TdHJlYW07XG5leHBvcnRzLmdlb1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtaGllcmFyY2h5LyBWZXJzaW9uIDEuMS42LiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXBhcmF0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG5mdW5jdGlvbiBtZWFuWChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKG1lYW5YUmVkdWNlLCAwKSAvIGNoaWxkcmVuLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbWVhblhSZWR1Y2UoeCwgYykge1xuICByZXR1cm4geCArIGMueDtcbn1cblxuZnVuY3Rpb24gbWF4WShjaGlsZHJlbikge1xuICByZXR1cm4gMSArIGNoaWxkcmVuLnJlZHVjZShtYXhZUmVkdWNlLCAwKTtcbn1cblxuZnVuY3Rpb24gbWF4WVJlZHVjZSh5LCBjKSB7XG4gIHJldHVybiBNYXRoLm1heCh5LCBjLnkpO1xufVxuXG5mdW5jdGlvbiBsZWFmTGVmdChub2RlKSB7XG4gIHZhciBjaGlsZHJlbjtcbiAgd2hpbGUgKGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbikgbm9kZSA9IGNoaWxkcmVuWzBdO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gbGVhZlJpZ2h0KG5vZGUpIHtcbiAgdmFyIGNoaWxkcmVuO1xuICB3aGlsZSAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSBub2RlID0gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIHJldHVybiBub2RlO1xufVxuXG52YXIgY2x1c3RlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VwYXJhdGlvbiA9IGRlZmF1bHRTZXBhcmF0aW9uLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbHVzdGVyKHJvb3QpIHtcbiAgICB2YXIgcHJldmlvdXNOb2RlLFxuICAgICAgICB4ID0gMDtcblxuICAgIC8vIEZpcnN0IHdhbGssIGNvbXB1dGluZyB0aGUgaW5pdGlhbCB4ICYgeSB2YWx1ZXMuXG4gICAgcm9vdC5lYWNoQWZ0ZXIoZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgICBub2RlLnggPSBtZWFuWChjaGlsZHJlbik7XG4gICAgICAgIG5vZGUueSA9IG1heFkoY2hpbGRyZW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS54ID0gcHJldmlvdXNOb2RlID8geCArPSBzZXBhcmF0aW9uKG5vZGUsIHByZXZpb3VzTm9kZSkgOiAwO1xuICAgICAgICBub2RlLnkgPSAwO1xuICAgICAgICBwcmV2aW91c05vZGUgPSBub2RlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGxlZnQgPSBsZWFmTGVmdChyb290KSxcbiAgICAgICAgcmlnaHQgPSBsZWFmUmlnaHQocm9vdCksXG4gICAgICAgIHgwID0gbGVmdC54IC0gc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICB4MSA9IHJpZ2h0LnggKyBzZXBhcmF0aW9uKHJpZ2h0LCBsZWZ0KSAvIDI7XG5cbiAgICAvLyBTZWNvbmQgd2Fsaywgbm9ybWFsaXppbmcgeCAmIHkgdG8gdGhlIGRlc2lyZWQgc2l6ZS5cbiAgICByZXR1cm4gcm9vdC5lYWNoQWZ0ZXIobm9kZVNpemUgPyBmdW5jdGlvbihub2RlKSB7XG4gICAgICBub2RlLnggPSAobm9kZS54IC0gcm9vdC54KSAqIGR4O1xuICAgICAgbm9kZS55ID0gKHJvb3QueSAtIG5vZGUueSkgKiBkeTtcbiAgICB9IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgbm9kZS54ID0gKG5vZGUueCAtIHgwKSAvICh4MSAtIHgwKSAqIGR4O1xuICAgICAgbm9kZS55ID0gKDEgLSAocm9vdC55ID8gbm9kZS55IC8gcm9vdC55IDogMSkpICogZHk7XG4gICAgfSk7XG4gIH1cblxuICBjbHVzdGVyLnNlcGFyYXRpb24gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc2VwYXJhdGlvbiA9IHgsIGNsdXN0ZXIpIDogc2VwYXJhdGlvbjtcbiAgfTtcblxuICBjbHVzdGVyLnNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSBmYWxzZSwgZHggPSAreFswXSwgZHkgPSAreFsxXSwgY2x1c3RlcikgOiAobm9kZVNpemUgPyBudWxsIDogW2R4LCBkeV0pO1xuICB9O1xuXG4gIGNsdXN0ZXIubm9kZVNpemUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobm9kZVNpemUgPSB0cnVlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBjbHVzdGVyKSA6IChub2RlU2l6ZSA/IFtkeCwgZHldIDogbnVsbCk7XG4gIH07XG5cbiAgcmV0dXJuIGNsdXN0ZXI7XG59O1xuXG5mdW5jdGlvbiBjb3VudChub2RlKSB7XG4gIHZhciBzdW0gPSAwLFxuICAgICAgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuLFxuICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKCFpKSBzdW0gPSAxO1xuICBlbHNlIHdoaWxlICgtLWkgPj0gMCkgc3VtICs9IGNoaWxkcmVuW2ldLnZhbHVlO1xuICBub2RlLnZhbHVlID0gc3VtO1xufVxuXG52YXIgbm9kZV9jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5lYWNoQWZ0ZXIoY291bnQpO1xufTtcblxudmFyIG5vZGVfZWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgY3VycmVudCwgbmV4dCA9IFtub2RlXSwgY2hpbGRyZW4sIGksIG47XG4gIGRvIHtcbiAgICBjdXJyZW50ID0gbmV4dC5yZXZlcnNlKCksIG5leHQgPSBbXTtcbiAgICB3aGlsZSAobm9kZSA9IGN1cnJlbnQucG9wKCkpIHtcbiAgICAgIGNhbGxiYWNrKG5vZGUpLCBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbmV4dC5wdXNoKGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKG5leHQubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgbm9kZV9lYWNoQmVmb3JlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXSwgY2hpbGRyZW4sIGk7XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBjYWxsYmFjayhub2RlKSwgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbikgZm9yIChpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBub2RlX2VhY2hBZnRlciA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBub2RlID0gdGhpcywgbm9kZXMgPSBbbm9kZV0sIG5leHQgPSBbXSwgY2hpbGRyZW4sIGksIG47XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBuZXh0LnB1c2gobm9kZSksIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4pIGZvciAoaSA9IDAsIG4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGVzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobm9kZSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhub2RlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciBub2RlX3N1bSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hBZnRlcihmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHN1bSA9ICt2YWx1ZShub2RlLmRhdGEpIHx8IDAsXG4gICAgICAgIGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbixcbiAgICAgICAgaSA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoLS1pID49IDApIHN1bSArPSBjaGlsZHJlbltpXS52YWx1ZTtcbiAgICBub2RlLnZhbHVlID0gc3VtO1xuICB9KTtcbn07XG5cbnZhciBub2RlX3NvcnQgPSBmdW5jdGlvbihjb21wYXJlKSB7XG4gIHJldHVybiB0aGlzLmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBub2RlX3BhdGggPSBmdW5jdGlvbihlbmQpIHtcbiAgdmFyIHN0YXJ0ID0gdGhpcyxcbiAgICAgIGFuY2VzdG9yID0gbGVhc3RDb21tb25BbmNlc3RvcihzdGFydCwgZW5kKSxcbiAgICAgIG5vZGVzID0gW3N0YXJ0XTtcbiAgd2hpbGUgKHN0YXJ0ICE9PSBhbmNlc3Rvcikge1xuICAgIHN0YXJ0ID0gc3RhcnQucGFyZW50O1xuICAgIG5vZGVzLnB1c2goc3RhcnQpO1xuICB9XG4gIHZhciBrID0gbm9kZXMubGVuZ3RoO1xuICB3aGlsZSAoZW5kICE9PSBhbmNlc3Rvcikge1xuICAgIG5vZGVzLnNwbGljZShrLCAwLCBlbmQpO1xuICAgIGVuZCA9IGVuZC5wYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxuZnVuY3Rpb24gbGVhc3RDb21tb25BbmNlc3RvcihhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gYTtcbiAgdmFyIGFOb2RlcyA9IGEuYW5jZXN0b3JzKCksXG4gICAgICBiTm9kZXMgPSBiLmFuY2VzdG9ycygpLFxuICAgICAgYyA9IG51bGw7XG4gIGEgPSBhTm9kZXMucG9wKCk7XG4gIGIgPSBiTm9kZXMucG9wKCk7XG4gIHdoaWxlIChhID09PSBiKSB7XG4gICAgYyA9IGE7XG4gICAgYSA9IGFOb2Rlcy5wb3AoKTtcbiAgICBiID0gYk5vZGVzLnBvcCgpO1xuICB9XG4gIHJldHVybiBjO1xufVxuXG52YXIgbm9kZV9hbmNlc3RvcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLCBub2RlcyA9IFtub2RlXTtcbiAgd2hpbGUgKG5vZGUgPSBub2RlLnBhcmVudCkge1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufTtcblxudmFyIG5vZGVfZGVzY2VuZGFudHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzID0gW107XG4gIHRoaXMuZWFjaChmdW5jdGlvbihub2RlKSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfSk7XG4gIHJldHVybiBub2Rlcztcbn07XG5cbnZhciBub2RlX2xlYXZlcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbGVhdmVzID0gW107XG4gIHRoaXMuZWFjaEJlZm9yZShmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBsZWF2ZXMucHVzaChub2RlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGVhdmVzO1xufTtcblxudmFyIG5vZGVfbGlua3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLCBsaW5rcyA9IFtdO1xuICByb290LmVhY2goZnVuY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICE9PSByb290KSB7IC8vIERvbuKAmXQgaW5jbHVkZSB0aGUgcm9vdOKAmXMgcGFyZW50LCBpZiBhbnkuXG4gICAgICBsaW5rcy5wdXNoKHtzb3VyY2U6IG5vZGUucGFyZW50LCB0YXJnZXQ6IG5vZGV9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbGlua3M7XG59O1xuXG5mdW5jdGlvbiBoaWVyYXJjaHkoZGF0YSwgY2hpbGRyZW4pIHtcbiAgdmFyIHJvb3QgPSBuZXcgTm9kZShkYXRhKSxcbiAgICAgIHZhbHVlZCA9ICtkYXRhLnZhbHVlICYmIChyb290LnZhbHVlID0gZGF0YS52YWx1ZSksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbcm9vdF0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcyxcbiAgICAgIGksXG4gICAgICBuO1xuXG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSBjaGlsZHJlbiA9IGRlZmF1bHRDaGlsZHJlbjtcblxuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgaWYgKHZhbHVlZCkgbm9kZS52YWx1ZSA9ICtub2RlLmRhdGEudmFsdWU7XG4gICAgaWYgKChjaGlsZHMgPSBjaGlsZHJlbihub2RlLmRhdGEpKSAmJiAobiA9IGNoaWxkcy5sZW5ndGgpKSB7XG4gICAgICBub2RlLmNoaWxkcmVuID0gbmV3IEFycmF5KG4pO1xuICAgICAgZm9yIChpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG5vZGVzLnB1c2goY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldID0gbmV3IE5vZGUoY2hpbGRzW2ldKSk7XG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG5vZGU7XG4gICAgICAgIGNoaWxkLmRlcHRoID0gbm9kZS5kZXB0aCArIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJvb3QuZWFjaEJlZm9yZShjb21wdXRlSGVpZ2h0KTtcbn1cblxuZnVuY3Rpb24gbm9kZV9jb3B5KCkge1xuICByZXR1cm4gaGllcmFyY2h5KHRoaXMpLmVhY2hCZWZvcmUoY29weURhdGEpO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2hpbGRyZW4oZCkge1xuICByZXR1cm4gZC5jaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY29weURhdGEobm9kZSkge1xuICBub2RlLmRhdGEgPSBub2RlLmRhdGEuZGF0YTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUhlaWdodChub2RlKSB7XG4gIHZhciBoZWlnaHQgPSAwO1xuICBkbyBub2RlLmhlaWdodCA9IGhlaWdodDtcbiAgd2hpbGUgKChub2RlID0gbm9kZS5wYXJlbnQpICYmIChub2RlLmhlaWdodCA8ICsraGVpZ2h0KSk7XG59XG5cbmZ1bmN0aW9uIE5vZGUoZGF0YSkge1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmRlcHRoID1cbiAgdGhpcy5oZWlnaHQgPSAwO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG59XG5cbk5vZGUucHJvdG90eXBlID0gaGllcmFyY2h5LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IE5vZGUsXG4gIGNvdW50OiBub2RlX2NvdW50LFxuICBlYWNoOiBub2RlX2VhY2gsXG4gIGVhY2hBZnRlcjogbm9kZV9lYWNoQWZ0ZXIsXG4gIGVhY2hCZWZvcmU6IG5vZGVfZWFjaEJlZm9yZSxcbiAgc3VtOiBub2RlX3N1bSxcbiAgc29ydDogbm9kZV9zb3J0LFxuICBwYXRoOiBub2RlX3BhdGgsXG4gIGFuY2VzdG9yczogbm9kZV9hbmNlc3RvcnMsXG4gIGRlc2NlbmRhbnRzOiBub2RlX2Rlc2NlbmRhbnRzLFxuICBsZWF2ZXM6IG5vZGVfbGVhdmVzLFxuICBsaW5rczogbm9kZV9saW5rcyxcbiAgY29weTogbm9kZV9jb3B5XG59O1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIHNodWZmbGUoYXJyYXkpIHtcbiAgdmFyIG0gPSBhcnJheS5sZW5ndGgsXG4gICAgICB0LFxuICAgICAgaTtcblxuICB3aGlsZSAobSkge1xuICAgIGkgPSBNYXRoLnJhbmRvbSgpICogbS0tIHwgMDtcbiAgICB0ID0gYXJyYXlbbV07XG4gICAgYXJyYXlbbV0gPSBhcnJheVtpXTtcbiAgICBhcnJheVtpXSA9IHQ7XG4gIH1cblxuICByZXR1cm4gYXJyYXk7XG59XG5cbnZhciBlbmNsb3NlID0gZnVuY3Rpb24oY2lyY2xlcykge1xuICB2YXIgaSA9IDAsIG4gPSAoY2lyY2xlcyA9IHNodWZmbGUoc2xpY2UuY2FsbChjaXJjbGVzKSkpLmxlbmd0aCwgQiA9IFtdLCBwLCBlO1xuXG4gIHdoaWxlIChpIDwgbikge1xuICAgIHAgPSBjaXJjbGVzW2ldO1xuICAgIGlmIChlICYmIGVuY2xvc2VzV2VhayhlLCBwKSkgKytpO1xuICAgIGVsc2UgZSA9IGVuY2xvc2VCYXNpcyhCID0gZXh0ZW5kQmFzaXMoQiwgcCkpLCBpID0gMDtcbiAgfVxuXG4gIHJldHVybiBlO1xufTtcblxuZnVuY3Rpb24gZXh0ZW5kQmFzaXMoQiwgcCkge1xuICB2YXIgaSwgajtcblxuICBpZiAoZW5jbG9zZXNXZWFrQWxsKHAsIEIpKSByZXR1cm4gW3BdO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGVuY2xvc2VzTm90KHAsIEJbaV0pXG4gICAgICAgICYmIGVuY2xvc2VzV2Vha0FsbChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCKSkge1xuICAgICAgcmV0dXJuIFtCW2ldLCBwXTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIEIgbXVzdCBoYXZlIGF0IGxlYXN0IHR3byBlbGVtZW50cy5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBCLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAoZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcClcbiAgICAgICAgICAmJiBlbmNsb3Nlc05vdChlbmNsb3NlQmFzaXMyKEJbaV0sIHApLCBCW2pdKVxuICAgICAgICAgICYmIGVuY2xvc2VzTm90KGVuY2xvc2VCYXNpczIoQltqXSwgcCksIEJbaV0pXG4gICAgICAgICAgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpKSB7XG4gICAgICAgIHJldHVybiBbQltpXSwgQltqXSwgcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBzb21ldGhpbmcgaXMgdmVyeSB3cm9uZy5cbiAgdGhyb3cgbmV3IEVycm9yO1xufVxuXG5mdW5jdGlvbiBlbmNsb3Nlc05vdChhLCBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPCAwIHx8IGRyICogZHIgPCBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yICsgMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKGEsIEIpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBCLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFlbmNsb3Nlc1dlYWsoYSwgQltpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpcyhCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6IHJldHVybiBlbmNsb3NlQmFzaXMxKEJbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGVuY2xvc2VCYXNpczIoQlswXSwgQlsxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKGEpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBhLngsXG4gICAgeTogYS55LFxuICAgIHI6IGEuclxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKGEsIGIpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDIxID0geDIgLSB4MSwgeTIxID0geTIgLSB5MSwgcjIxID0gcjIgLSByMSxcbiAgICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIHtcbiAgICB4OiAoeDEgKyB4MiArIHgyMSAvIGwgKiByMjEpIC8gMixcbiAgICB5OiAoeTEgKyB5MiArIHkyMSAvIGwgKiByMjEpIC8gMixcbiAgICByOiAobCArIHIxICsgcjIpIC8gMlxuICB9O1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMzKGEsIGIsIGMpIHtcbiAgdmFyIHgxID0gYS54LCB5MSA9IGEueSwgcjEgPSBhLnIsXG4gICAgICB4MiA9IGIueCwgeTIgPSBiLnksIHIyID0gYi5yLFxuICAgICAgeDMgPSBjLngsIHkzID0gYy55LCByMyA9IGMucixcbiAgICAgIGEyID0geDEgLSB4MixcbiAgICAgIGEzID0geDEgLSB4MyxcbiAgICAgIGIyID0geTEgLSB5MixcbiAgICAgIGIzID0geTEgLSB5MyxcbiAgICAgIGMyID0gcjIgLSByMSxcbiAgICAgIGMzID0gcjMgLSByMSxcbiAgICAgIGQxID0geDEgKiB4MSArIHkxICogeTEgLSByMSAqIHIxLFxuICAgICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICAgIGQzID0gZDEgLSB4MyAqIHgzIC0geTMgKiB5MyArIHIzICogcjMsXG4gICAgICBhYiA9IGEzICogYjIgLSBhMiAqIGIzLFxuICAgICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICAgIHhiID0gKGIzICogYzIgLSBiMiAqIGMzKSAvIGFiLFxuICAgICAgeWEgPSAoYTMgKiBkMiAtIGEyICogZDMpIC8gKGFiICogMikgLSB5MSxcbiAgICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgICAgQSA9IHhiICogeGIgKyB5YiAqIHliIC0gMSxcbiAgICAgIEIgPSAyICogKHIxICsgeGEgKiB4YiArIHlhICogeWIpLFxuICAgICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICAgIHIgPSAtKEEgPyAoQiArIE1hdGguc3FydChCICogQiAtIDQgKiBBICogQykpIC8gKDIgKiBBKSA6IEMgLyBCKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB4MSArIHhhICsgeGIgKiByLFxuICAgIHk6IHkxICsgeWEgKyB5YiAqIHIsXG4gICAgcjogclxuICB9O1xufVxuXG5mdW5jdGlvbiBwbGFjZShiLCBhLCBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCwgeCwgYTIsXG4gICAgICBkeSA9IGIueSAtIGEueSwgeSwgYjIsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICBpZiAoZDIpIHtcbiAgICBhMiA9IGEuciArIGMuciwgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnIsIGIyICo9IGIyO1xuICAgIGlmIChhMiA+IGIyKSB7XG4gICAgICB4ID0gKGQyICsgYjIgLSBhMikgLyAoMiAqIGQyKTtcbiAgICAgIHkgPSBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgYjIgLyBkMiAtIHggKiB4KSk7XG4gICAgICBjLnggPSBiLnggLSB4ICogZHggLSB5ICogZHk7XG4gICAgICBjLnkgPSBiLnkgLSB4ICogZHkgKyB5ICogZHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSAoZDIgKyBhMiAtIGIyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBhMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGEueCArIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGEueSArIHggKiBkeSArIHkgKiBkeDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYy54ID0gYS54ICsgYy5yO1xuICAgIGMueSA9IGEueTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgdmFyIGRyID0gYS5yICsgYi5yIC0gMWUtNiwgZHggPSBiLnggLSBhLngsIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gc2NvcmUobm9kZSkge1xuICB2YXIgYSA9IG5vZGUuXyxcbiAgICAgIGIgPSBub2RlLm5leHQuXyxcbiAgICAgIGFiID0gYS5yICsgYi5yLFxuICAgICAgZHggPSAoYS54ICogYi5yICsgYi54ICogYS5yKSAvIGFiLFxuICAgICAgZHkgPSAoYS55ICogYi5yICsgYi55ICogYS5yKSAvIGFiO1xuICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIE5vZGUkMShjaXJjbGUpIHtcbiAgdGhpcy5fID0gY2lyY2xlO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcGFja0VuY2xvc2UoY2lyY2xlcykge1xuICBpZiAoIShuID0gY2lyY2xlcy5sZW5ndGgpKSByZXR1cm4gMDtcblxuICB2YXIgYSwgYiwgYywgbiwgYWEsIGNhLCBpLCBqLCBrLCBzaiwgc2s7XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF0sIGEueCA9IDAsIGEueSA9IDA7XG4gIGlmICghKG4gPiAxKSkgcmV0dXJuIGEucjtcblxuICAvLyBQbGFjZSB0aGUgc2Vjb25kIGNpcmNsZS5cbiAgYiA9IGNpcmNsZXNbMV0sIGEueCA9IC1iLnIsIGIueCA9IGEuciwgYi55ID0gMDtcbiAgaWYgKCEobiA+IDIpKSByZXR1cm4gYS5yICsgYi5yO1xuXG4gIC8vIFBsYWNlIHRoZSB0aGlyZCBjaXJjbGUuXG4gIHBsYWNlKGIsIGEsIGMgPSBjaXJjbGVzWzJdKTtcblxuICAvLyBJbml0aWFsaXplIHRoZSBmcm9udC1jaGFpbiB1c2luZyB0aGUgZmlyc3QgdGhyZWUgY2lyY2xlcyBhLCBiIGFuZCBjLlxuICBhID0gbmV3IE5vZGUkMShhKSwgYiA9IG5ldyBOb2RlJDEoYiksIGMgPSBuZXcgTm9kZSQxKGMpO1xuICBhLm5leHQgPSBjLnByZXZpb3VzID0gYjtcbiAgYi5uZXh0ID0gYS5wcmV2aW91cyA9IGM7XG4gIGMubmV4dCA9IGIucHJldmlvdXMgPSBhO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGxhY2UgZWFjaCByZW1haW5pbmcgY2lyY2xl4oCmXG4gIHBhY2s6IGZvciAoaSA9IDM7IGkgPCBuOyArK2kpIHtcbiAgICBwbGFjZShhLl8sIGIuXywgYyA9IGNpcmNsZXNbaV0pLCBjID0gbmV3IE5vZGUkMShjKTtcblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaW50ZXJzZWN0aW5nIGNpcmNsZSBvbiB0aGUgZnJvbnQtY2hhaW4sIGlmIGFueS5cbiAgICAvLyDigJxDbG9zZW5lc3PigJ0gaXMgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UgYWxvbmcgdGhlIGZyb250LWNoYWluLlxuICAgIC8vIOKAnEFoZWFk4oCdIG9yIOKAnGJlaGluZOKAnSBpcyBsaWtld2lzZSBkZXRlcm1pbmVkIGJ5IGxpbmVhciBkaXN0YW5jZS5cbiAgICBqID0gYi5uZXh0LCBrID0gYS5wcmV2aW91cywgc2ogPSBiLl8uciwgc2sgPSBhLl8ucjtcbiAgICBkbyB7XG4gICAgICBpZiAoc2ogPD0gc2spIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoai5fLCBjLl8pKSB7XG4gICAgICAgICAgYiA9IGosIGEubmV4dCA9IGIsIGIucHJldmlvdXMgPSBhLCAtLWk7XG4gICAgICAgICAgY29udGludWUgcGFjaztcbiAgICAgICAgfVxuICAgICAgICBzaiArPSBqLl8uciwgaiA9IGoubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGsuXywgYy5fKSkge1xuICAgICAgICAgIGEgPSBrLCBhLm5leHQgPSBiLCBiLnByZXZpb3VzID0gYSwgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2sgKz0gay5fLnIsIGsgPSBrLnByZXZpb3VzO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGogIT09IGsubmV4dCk7XG5cbiAgICAvLyBTdWNjZXNzISBJbnNlcnQgdGhlIG5ldyBjaXJjbGUgYyBiZXR3ZWVuIGEgYW5kIGIuXG4gICAgYy5wcmV2aW91cyA9IGEsIGMubmV4dCA9IGIsIGEubmV4dCA9IGIucHJldmlvdXMgPSBiID0gYztcblxuICAgIC8vIENvbXB1dGUgdGhlIG5ldyBjbG9zZXN0IGNpcmNsZSBwYWlyIHRvIHRoZSBjZW50cm9pZC5cbiAgICBhYSA9IHNjb3JlKGEpO1xuICAgIHdoaWxlICgoYyA9IGMubmV4dCkgIT09IGIpIHtcbiAgICAgIGlmICgoY2EgPSBzY29yZShjKSkgPCBhYSkge1xuICAgICAgICBhID0gYywgYWEgPSBjYTtcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IGEubmV4dDtcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVuY2xvc2luZyBjaXJjbGUgb2YgdGhlIGZyb250IGNoYWluLlxuICBhID0gW2IuX10sIGMgPSBiOyB3aGlsZSAoKGMgPSBjLm5leHQpICE9PSBiKSBhLnB1c2goYy5fKTsgYyA9IGVuY2xvc2UoYSk7XG5cbiAgLy8gVHJhbnNsYXRlIHRoZSBjaXJjbGVzIHRvIHB1dCB0aGUgZW5jbG9zaW5nIGNpcmNsZSBhcm91bmQgdGhlIG9yaWdpbi5cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYSA9IGNpcmNsZXNbaV0sIGEueCAtPSBjLngsIGEueSAtPSBjLnk7XG5cbiAgcmV0dXJuIGMucjtcbn1cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oY2lyY2xlcykge1xuICBwYWNrRW5jbG9zZShjaXJjbGVzKTtcbiAgcmV0dXJuIGNpcmNsZXM7XG59O1xuXG5mdW5jdGlvbiBvcHRpb25hbChmKSB7XG4gIHJldHVybiBmID09IG51bGwgPyBudWxsIDogcmVxdWlyZWQoZik7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVkKGYpIHtcbiAgaWYgKHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBFcnJvcjtcbiAgcmV0dXJuIGY7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50WmVybygpIHtcbiAgcmV0dXJuIDA7XG59XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24gZGVmYXVsdFJhZGl1cyhkKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSk7XG59XG5cbnZhciBpbmRleCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmFkaXVzID0gbnVsbCxcbiAgICAgIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmcgPSBjb25zdGFudFplcm87XG5cbiAgZnVuY3Rpb24gcGFjayhyb290KSB7XG4gICAgcm9vdC54ID0gZHggLyAyLCByb290LnkgPSBkeSAvIDI7XG4gICAgaWYgKHJhZGl1cykge1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKHJhZGl1c0xlYWYocmFkaXVzKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCAwLjUpKVxuICAgICAgICAgIC5lYWNoQmVmb3JlKHRyYW5zbGF0ZUNoaWxkKDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKHJhZGl1c0xlYWYoZGVmYXVsdFJhZGl1cykpXG4gICAgICAgICAgLmVhY2hBZnRlcihwYWNrQ2hpbGRyZW4oY29uc3RhbnRaZXJvLCAxKSlcbiAgICAgICAgICAuZWFjaEFmdGVyKHBhY2tDaGlsZHJlbihwYWRkaW5nLCByb290LnIgLyBNYXRoLm1pbihkeCwgZHkpKSlcbiAgICAgICAgICAuZWFjaEJlZm9yZSh0cmFuc2xhdGVDaGlsZChNYXRoLm1pbihkeCwgZHkpIC8gKDIgKiByb290LnIpKSk7XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgcGFjay5yYWRpdXMgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gb3B0aW9uYWwoeCksIHBhY2spIDogcmFkaXVzO1xuICB9O1xuXG4gIHBhY2suc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYWNrKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHBhY2sucGFkZGluZyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHBhY2spIDogcGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gcGFjaztcbn07XG5cbmZ1bmN0aW9uIHJhZGl1c0xlYWYocmFkaXVzKSB7XG4gIHJldHVybiBmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSB7XG4gICAgICBub2RlLnIgPSBNYXRoLm1heCgwLCArcmFkaXVzKG5vZGUpIHx8IDApO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFja0NoaWxkcmVuKHBhZGRpbmcsIGspIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGRyZW4sXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgICAgIHIgPSBwYWRkaW5nKG5vZGUpICogayB8fCAwLFxuICAgICAgICAgIGU7XG5cbiAgICAgIGlmIChyKSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBjaGlsZHJlbltpXS5yICs9IHI7XG4gICAgICBlID0gcGFja0VuY2xvc2UoY2hpbGRyZW4pO1xuICAgICAgaWYgKHIpIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIGNoaWxkcmVuW2ldLnIgLT0gcjtcbiAgICAgIG5vZGUuciA9IGUgKyByO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlQ2hpbGQoaykge1xuICByZXR1cm4gZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudDtcbiAgICBub2RlLnIgKj0gaztcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBub2RlLnggPSBwYXJlbnQueCArIGsgKiBub2RlLng7XG4gICAgICBub2RlLnkgPSBwYXJlbnQueSArIGsgKiBub2RlLnk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcm91bmROb2RlID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLngwID0gTWF0aC5yb3VuZChub2RlLngwKTtcbiAgbm9kZS55MCA9IE1hdGgucm91bmQobm9kZS55MCk7XG4gIG5vZGUueDEgPSBNYXRoLnJvdW5kKG5vZGUueDEpO1xuICBub2RlLnkxID0gTWF0aC5yb3VuZChub2RlLnkxKTtcbn07XG5cbnZhciB0cmVlbWFwRGljZSA9IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIG5vZGVzID0gcGFyZW50LmNoaWxkcmVuLFxuICAgICAgbm9kZSxcbiAgICAgIGkgPSAtMSxcbiAgICAgIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBrID0gcGFyZW50LnZhbHVlICYmICh4MSAtIHgwKSAvIHBhcmVudC52YWx1ZTtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS55MCA9IHkwLCBub2RlLnkxID0geTE7XG4gICAgbm9kZS54MCA9IHgwLCBub2RlLngxID0geDAgKz0gbm9kZS52YWx1ZSAqIGs7XG4gIH1cbn07XG5cbnZhciBwYXJ0aXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGR4ID0gMSxcbiAgICAgIGR5ID0gMSxcbiAgICAgIHBhZGRpbmcgPSAwLFxuICAgICAgcm91bmQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBwYXJ0aXRpb24ocm9vdCkge1xuICAgIHZhciBuID0gcm9vdC5oZWlnaHQgKyAxO1xuICAgIHJvb3QueDAgPVxuICAgIHJvb3QueTAgPSBwYWRkaW5nO1xuICAgIHJvb3QueDEgPSBkeDtcbiAgICByb290LnkxID0gZHkgLyBuO1xuICAgIHJvb3QuZWFjaEJlZm9yZShwb3NpdGlvbk5vZGUoZHksIG4pKTtcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKGR5LCBuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIHRyZWVtYXBEaWNlKG5vZGUsIG5vZGUueDAsIGR5ICogKG5vZGUuZGVwdGggKyAxKSAvIG4sIG5vZGUueDEsIGR5ICogKG5vZGUuZGVwdGggKyAyKSAvIG4pO1xuICAgICAgfVxuICAgICAgdmFyIHgwID0gbm9kZS54MCxcbiAgICAgICAgICB5MCA9IG5vZGUueTAsXG4gICAgICAgICAgeDEgPSBub2RlLngxIC0gcGFkZGluZyxcbiAgICAgICAgICB5MSA9IG5vZGUueTEgLSBwYWRkaW5nO1xuICAgICAgaWYgKHgxIDwgeDApIHgwID0geDEgPSAoeDAgKyB4MSkgLyAyO1xuICAgICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgbm9kZS54MCA9IHgwO1xuICAgICAgbm9kZS55MCA9IHkwO1xuICAgICAgbm9kZS54MSA9IHgxO1xuICAgICAgbm9kZS55MSA9IHkxO1xuICAgIH07XG4gIH1cblxuICBwYXJ0aXRpb24ucm91bmQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocm91bmQgPSAhIXgsIHBhcnRpdGlvbikgOiByb3VuZDtcbiAgfTtcblxuICBwYXJ0aXRpb24uc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCBwYXJ0aXRpb24pIDogW2R4LCBkeV07XG4gIH07XG5cbiAgcGFydGl0aW9uLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZyA9ICt4LCBwYXJ0aXRpb24pIDogcGFkZGluZztcbiAgfTtcblxuICByZXR1cm4gcGFydGl0aW9uO1xufTtcblxudmFyIGtleVByZWZpeCA9IFwiJFwiO1xudmFyIHByZXJvb3QgPSB7ZGVwdGg6IC0xfTtcbnZhciBhbWJpZ3VvdXMgPSB7fTtcblxuZnVuY3Rpb24gZGVmYXVsdElkKGQpIHtcbiAgcmV0dXJuIGQuaWQ7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRQYXJlbnRJZChkKSB7XG4gIHJldHVybiBkLnBhcmVudElkO1xufVxuXG52YXIgc3RyYXRpZnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkID0gZGVmYXVsdElkLFxuICAgICAgcGFyZW50SWQgPSBkZWZhdWx0UGFyZW50SWQ7XG5cbiAgZnVuY3Rpb24gc3RyYXRpZnkoZGF0YSkge1xuICAgIHZhciBkLFxuICAgICAgICBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZXMgPSBuZXcgQXJyYXkobiksXG4gICAgICAgIG5vZGVJZCxcbiAgICAgICAgbm9kZUtleSxcbiAgICAgICAgbm9kZUJ5S2V5ID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBkID0gZGF0YVtpXSwgbm9kZSA9IG5vZGVzW2ldID0gbmV3IE5vZGUoZCk7XG4gICAgICBpZiAoKG5vZGVJZCA9IGlkKGQsIGksIGRhdGEpKSAhPSBudWxsICYmIChub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgbm9kZUtleSA9IGtleVByZWZpeCArIChub2RlLmlkID0gbm9kZUlkKTtcbiAgICAgICAgbm9kZUJ5S2V5W25vZGVLZXldID0gbm9kZUtleSBpbiBub2RlQnlLZXkgPyBhbWJpZ3VvdXMgOiBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZUlkID0gcGFyZW50SWQoZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgICBpZiAobm9kZUlkID09IG51bGwgfHwgIShub2RlSWQgKz0gXCJcIikpIHtcbiAgICAgICAgaWYgKHJvb3QpIHRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIHJvb3RzXCIpO1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IG5vZGVCeUtleVtrZXlQcmVmaXggKyBub2RlSWRdO1xuICAgICAgICBpZiAoIXBhcmVudCkgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZzogXCIgKyBub2RlSWQpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBhbWJpZ3VvdXMpIHRocm93IG5ldyBFcnJvcihcImFtYmlndW91czogXCIgKyBub2RlSWQpO1xuICAgICAgICBpZiAocGFyZW50LmNoaWxkcmVuKSBwYXJlbnQuY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgZWxzZSBwYXJlbnQuY2hpbGRyZW4gPSBbbm9kZV07XG4gICAgICAgIG5vZGUucGFyZW50ID0gcGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghcm9vdCkgdGhyb3cgbmV3IEVycm9yKFwibm8gcm9vdFwiKTtcbiAgICByb290LnBhcmVudCA9IHByZXJvb3Q7XG4gICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHsgbm9kZS5kZXB0aCA9IG5vZGUucGFyZW50LmRlcHRoICsgMTsgLS1uOyB9KS5lYWNoQmVmb3JlKGNvbXB1dGVIZWlnaHQpO1xuICAgIHJvb3QucGFyZW50ID0gbnVsbDtcbiAgICBpZiAobiA+IDApIHRocm93IG5ldyBFcnJvcihcImN5Y2xlXCIpO1xuXG4gICAgcmV0dXJuIHJvb3Q7XG4gIH1cblxuICBzdHJhdGlmeS5pZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBpZDtcbiAgfTtcblxuICBzdHJhdGlmeS5wYXJlbnRJZCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYXJlbnRJZCA9IHJlcXVpcmVkKHgpLCBzdHJhdGlmeSkgOiBwYXJlbnRJZDtcbiAgfTtcblxuICByZXR1cm4gc3RyYXRpZnk7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2VwYXJhdGlvbiQxKGEsIGIpIHtcbiAgcmV0dXJuIGEucGFyZW50ID09PSBiLnBhcmVudCA/IDEgOiAyO1xufVxuXG4vLyBmdW5jdGlvbiByYWRpYWxTZXBhcmF0aW9uKGEsIGIpIHtcbi8vICAgcmV0dXJuIChhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMikgLyBhLmRlcHRoO1xuLy8gfVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gdHJhdmVyc2UgdGhlIGxlZnQgY29udG91ciBvZiBhIHN1YnRyZWUgKG9yXG4vLyBzdWJmb3Jlc3QpLiBJdCByZXR1cm5zIHRoZSBzdWNjZXNzb3Igb2YgdiBvbiB0aGlzIGNvbnRvdXIuIFRoaXMgc3VjY2Vzc29yIGlzXG4vLyBlaXRoZXIgZ2l2ZW4gYnkgdGhlIGxlZnRtb3N0IGNoaWxkIG9mIHYgb3IgYnkgdGhlIHRocmVhZCBvZiB2LiBUaGUgZnVuY3Rpb25cbi8vIHJldHVybnMgbnVsbCBpZiBhbmQgb25seSBpZiB2IGlzIG9uIHRoZSBoaWdoZXN0IGxldmVsIG9mIGl0cyBzdWJ0cmVlLlxuZnVuY3Rpb24gbmV4dExlZnQodikge1xuICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICByZXR1cm4gY2hpbGRyZW4gPyBjaGlsZHJlblswXSA6IHYudDtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiB3b3JrcyBhbmFsb2dvdXNseSB0byBuZXh0TGVmdC5cbmZ1bmN0aW9uIG5leHRSaWdodCh2KSB7XG4gIHZhciBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIHJldHVybiBjaGlsZHJlbiA/IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdIDogdi50O1xufVxuXG4vLyBTaGlmdHMgdGhlIGN1cnJlbnQgc3VidHJlZSByb290ZWQgYXQgdysuIFRoaXMgaXMgZG9uZSBieSBpbmNyZWFzaW5nXG4vLyBwcmVsaW0odyspIGFuZCBtb2QodyspIGJ5IHNoaWZ0LlxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICB2YXIgY2hhbmdlID0gc2hpZnQgLyAod3AuaSAtIHdtLmkpO1xuICB3cC5jIC09IGNoYW5nZTtcbiAgd3AucyArPSBzaGlmdDtcbiAgd20uYyArPSBjaGFuZ2U7XG4gIHdwLnogKz0gc2hpZnQ7XG4gIHdwLm0gKz0gc2hpZnQ7XG59XG5cbi8vIEFsbCBvdGhlciBzaGlmdHMsIGFwcGxpZWQgdG8gdGhlIHNtYWxsZXIgc3VidHJlZXMgYmV0d2VlbiB3LSBhbmQgdyssIGFyZVxuLy8gcGVyZm9ybWVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIHByZXBhcmUgdGhlIHNoaWZ0cywgd2UgaGF2ZSB0byBhZGp1c3Rcbi8vIGNoYW5nZSh3KyksIHNoaWZ0KHcrKSwgYW5kIGNoYW5nZSh3LSkuXG5mdW5jdGlvbiBleGVjdXRlU2hpZnRzKHYpIHtcbiAgdmFyIHNoaWZ0ID0gMCxcbiAgICAgIGNoYW5nZSA9IDAsXG4gICAgICBjaGlsZHJlbiA9IHYuY2hpbGRyZW4sXG4gICAgICBpID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgdztcbiAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgdyA9IGNoaWxkcmVuW2ldO1xuICAgIHcueiArPSBzaGlmdDtcbiAgICB3Lm0gKz0gc2hpZnQ7XG4gICAgc2hpZnQgKz0gdy5zICsgKGNoYW5nZSArPSB3LmMpO1xuICB9XG59XG5cbi8vIElmIHZpLeKAmXMgYW5jZXN0b3IgaXMgYSBzaWJsaW5nIG9mIHYsIHJldHVybnMgdmkt4oCZcyBhbmNlc3Rvci4gT3RoZXJ3aXNlLFxuLy8gcmV0dXJucyB0aGUgc3BlY2lmaWVkIChkZWZhdWx0KSBhbmNlc3Rvci5cbmZ1bmN0aW9uIG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSB7XG4gIHJldHVybiB2aW0uYS5wYXJlbnQgPT09IHYucGFyZW50ID8gdmltLmEgOiBhbmNlc3Rvcjtcbn1cblxuZnVuY3Rpb24gVHJlZU5vZGUobm9kZSwgaSkge1xuICB0aGlzLl8gPSBub2RlO1xuICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xuICB0aGlzLkEgPSBudWxsOyAvLyBkZWZhdWx0IGFuY2VzdG9yXG4gIHRoaXMuYSA9IHRoaXM7IC8vIGFuY2VzdG9yXG4gIHRoaXMueiA9IDA7IC8vIHByZWxpbVxuICB0aGlzLm0gPSAwOyAvLyBtb2RcbiAgdGhpcy5jID0gMDsgLy8gY2hhbmdlXG4gIHRoaXMucyA9IDA7IC8vIHNoaWZ0XG4gIHRoaXMudCA9IG51bGw7IC8vIHRocmVhZFxuICB0aGlzLmkgPSBpOyAvLyBudW1iZXJcbn1cblxuVHJlZU5vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5cbmZ1bmN0aW9uIHRyZWVSb290KHJvb3QpIHtcbiAgdmFyIHRyZWUgPSBuZXcgVHJlZU5vZGUocm9vdCwgMCksXG4gICAgICBub2RlLFxuICAgICAgbm9kZXMgPSBbdHJlZV0sXG4gICAgICBjaGlsZCxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgaSxcbiAgICAgIG47XG5cbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGlmIChjaGlsZHJlbiA9IG5vZGUuXy5jaGlsZHJlbikge1xuICAgICAgbm9kZS5jaGlsZHJlbiA9IG5ldyBBcnJheShuID0gY2hpbGRyZW4ubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBub2Rlcy5wdXNoKGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXSA9IG5ldyBUcmVlTm9kZShjaGlsZHJlbltpXSwgaSkpO1xuICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gICh0cmVlLnBhcmVudCA9IG5ldyBUcmVlTm9kZShudWxsLCAwKSkuY2hpbGRyZW4gPSBbdHJlZV07XG4gIHJldHVybiB0cmVlO1xufVxuXG4vLyBOb2RlLWxpbmsgdHJlZSBkaWFncmFtIHVzaW5nIHRoZSBSZWluZ29sZC1UaWxmb3JkIFwidGlkeVwiIGFsZ29yaXRobVxudmFyIHRyZWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlcGFyYXRpb24gPSBkZWZhdWx0U2VwYXJhdGlvbiQxLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgbm9kZVNpemUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHRyZWUocm9vdCkge1xuICAgIHZhciB0ID0gdHJlZVJvb3Qocm9vdCk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBsYXlvdXQgdXNpbmcgQnVjaGhlaW0gZXQgYWwu4oCZcyBhbGdvcml0aG0uXG4gICAgdC5lYWNoQWZ0ZXIoZmlyc3RXYWxrKSwgdC5wYXJlbnQubSA9IC10Lno7XG4gICAgdC5lYWNoQmVmb3JlKHNlY29uZFdhbGspO1xuXG4gICAgLy8gSWYgYSBmaXhlZCBub2RlIHNpemUgaXMgc3BlY2lmaWVkLCBzY2FsZSB4IGFuZCB5LlxuICAgIGlmIChub2RlU2l6ZSkgcm9vdC5lYWNoQmVmb3JlKHNpemVOb2RlKTtcblxuICAgIC8vIElmIGEgZml4ZWQgdHJlZSBzaXplIGlzIHNwZWNpZmllZCwgc2NhbGUgeCBhbmQgeSBiYXNlZCBvbiB0aGUgZXh0ZW50LlxuICAgIC8vIENvbXB1dGUgdGhlIGxlZnQtbW9zdCwgcmlnaHQtbW9zdCwgYW5kIGRlcHRoLW1vc3Qgbm9kZXMgZm9yIGV4dGVudHMuXG4gICAgZWxzZSB7XG4gICAgICB2YXIgbGVmdCA9IHJvb3QsXG4gICAgICAgICAgcmlnaHQgPSByb290LFxuICAgICAgICAgIGJvdHRvbSA9IHJvb3Q7XG4gICAgICByb290LmVhY2hCZWZvcmUoZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAobm9kZS54IDwgbGVmdC54KSBsZWZ0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUueCA+IHJpZ2h0LngpIHJpZ2h0ID0gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUuZGVwdGggPiBib3R0b20uZGVwdGgpIGJvdHRvbSA9IG5vZGU7XG4gICAgICB9KTtcbiAgICAgIHZhciBzID0gbGVmdCA9PT0gcmlnaHQgPyAxIDogc2VwYXJhdGlvbihsZWZ0LCByaWdodCkgLyAyLFxuICAgICAgICAgIHR4ID0gcyAtIGxlZnQueCxcbiAgICAgICAgICBreCA9IGR4IC8gKHJpZ2h0LnggKyBzICsgdHgpLFxuICAgICAgICAgIGt5ID0gZHkgLyAoYm90dG9tLmRlcHRoIHx8IDEpO1xuICAgICAgcm9vdC5lYWNoQmVmb3JlKGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgbm9kZS54ID0gKG5vZGUueCArIHR4KSAqIGt4O1xuICAgICAgICBub2RlLnkgPSBub2RlLmRlcHRoICoga3k7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGEgcHJlbGltaW5hcnkgeC1jb29yZGluYXRlIGZvciB2LiBCZWZvcmUgdGhhdCwgRklSU1QgV0FMSyBpc1xuICAvLyBhcHBsaWVkIHJlY3Vyc2l2ZWx5IHRvIHRoZSBjaGlsZHJlbiBvZiB2LCBhcyB3ZWxsIGFzIHRoZSBmdW5jdGlvblxuICAvLyBBUFBPUlRJT04uIEFmdGVyIHNwYWNpbmcgb3V0IHRoZSBjaGlsZHJlbiBieSBjYWxsaW5nIEVYRUNVVEUgU0hJRlRTLCB0aGVcbiAgLy8gbm9kZSB2IGlzIHBsYWNlZCB0byB0aGUgbWlkcG9pbnQgb2YgaXRzIG91dGVybW9zdCBjaGlsZHJlbi5cbiAgZnVuY3Rpb24gZmlyc3RXYWxrKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2LmNoaWxkcmVuLFxuICAgICAgICBzaWJsaW5ncyA9IHYucGFyZW50LmNoaWxkcmVuLFxuICAgICAgICB3ID0gdi5pID8gc2libGluZ3Nbdi5pIC0gMV0gOiBudWxsO1xuICAgIGlmIChjaGlsZHJlbikge1xuICAgICAgZXhlY3V0ZVNoaWZ0cyh2KTtcbiAgICAgIHZhciBtaWRwb2ludCA9IChjaGlsZHJlblswXS56ICsgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ueikgLyAyO1xuICAgICAgaWYgKHcpIHtcbiAgICAgICAgdi56ID0gdy56ICsgc2VwYXJhdGlvbih2Ll8sIHcuXyk7XG4gICAgICAgIHYubSA9IHYueiAtIG1pZHBvaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdi56ID0gbWlkcG9pbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3KSB7XG4gICAgICB2LnogPSB3LnogKyBzZXBhcmF0aW9uKHYuXywgdy5fKTtcbiAgICB9XG4gICAgdi5wYXJlbnQuQSA9IGFwcG9ydGlvbih2LCB3LCB2LnBhcmVudC5BIHx8IHNpYmxpbmdzWzBdKTtcbiAgfVxuXG4gIC8vIENvbXB1dGVzIGFsbCByZWFsIHgtY29vcmRpbmF0ZXMgYnkgc3VtbWluZyB1cCB0aGUgbW9kaWZpZXJzIHJlY3Vyc2l2ZWx5LlxuICBmdW5jdGlvbiBzZWNvbmRXYWxrKHYpIHtcbiAgICB2Ll8ueCA9IHYueiArIHYucGFyZW50Lm07XG4gICAgdi5tICs9IHYucGFyZW50Lm07XG4gIH1cblxuICAvLyBUaGUgY29yZSBvZiB0aGUgYWxnb3JpdGhtLiBIZXJlLCBhIG5ldyBzdWJ0cmVlIGlzIGNvbWJpbmVkIHdpdGggdGhlXG4gIC8vIHByZXZpb3VzIHN1YnRyZWVzLiBUaHJlYWRzIGFyZSB1c2VkIHRvIHRyYXZlcnNlIHRoZSBpbnNpZGUgYW5kIG91dHNpZGVcbiAgLy8gY29udG91cnMgb2YgdGhlIGxlZnQgYW5kIHJpZ2h0IHN1YnRyZWUgdXAgdG8gdGhlIGhpZ2hlc3QgY29tbW9uIGxldmVsLiBUaGVcbiAgLy8gdmVydGljZXMgdXNlZCBmb3IgdGhlIHRyYXZlcnNhbHMgYXJlIHZpKywgdmktLCB2by0sIGFuZCB2byssIHdoZXJlIHRoZVxuICAvLyBzdXBlcnNjcmlwdCBvIG1lYW5zIG91dHNpZGUgYW5kIGkgbWVhbnMgaW5zaWRlLCB0aGUgc3Vic2NyaXB0IC0gbWVhbnMgbGVmdFxuICAvLyBzdWJ0cmVlIGFuZCArIG1lYW5zIHJpZ2h0IHN1YnRyZWUuIEZvciBzdW1taW5nIHVwIHRoZSBtb2RpZmllcnMgYWxvbmcgdGhlXG4gIC8vIGNvbnRvdXIsIHdlIHVzZSByZXNwZWN0aXZlIHZhcmlhYmxlcyBzaSssIHNpLSwgc28tLCBhbmQgc28rLiBXaGVuZXZlciB0d29cbiAgLy8gbm9kZXMgb2YgdGhlIGluc2lkZSBjb250b3VycyBjb25mbGljdCwgd2UgY29tcHV0ZSB0aGUgbGVmdCBvbmUgb2YgdGhlXG4gIC8vIGdyZWF0ZXN0IHVuY29tbW9uIGFuY2VzdG9ycyB1c2luZyB0aGUgZnVuY3Rpb24gQU5DRVNUT1IgYW5kIGNhbGwgTU9WRVxuICAvLyBTVUJUUkVFIHRvIHNoaWZ0IHRoZSBzdWJ0cmVlIGFuZCBwcmVwYXJlIHRoZSBzaGlmdHMgb2Ygc21hbGxlciBzdWJ0cmVlcy5cbiAgLy8gRmluYWxseSwgd2UgYWRkIGEgbmV3IHRocmVhZCAoaWYgbmVjZXNzYXJ5KS5cbiAgZnVuY3Rpb24gYXBwb3J0aW9uKHYsIHcsIGFuY2VzdG9yKSB7XG4gICAgaWYgKHcpIHtcbiAgICAgIHZhciB2aXAgPSB2LFxuICAgICAgICAgIHZvcCA9IHYsXG4gICAgICAgICAgdmltID0gdyxcbiAgICAgICAgICB2b20gPSB2aXAucGFyZW50LmNoaWxkcmVuWzBdLFxuICAgICAgICAgIHNpcCA9IHZpcC5tLFxuICAgICAgICAgIHNvcCA9IHZvcC5tLFxuICAgICAgICAgIHNpbSA9IHZpbS5tLFxuICAgICAgICAgIHNvbSA9IHZvbS5tLFxuICAgICAgICAgIHNoaWZ0O1xuICAgICAgd2hpbGUgKHZpbSA9IG5leHRSaWdodCh2aW0pLCB2aXAgPSBuZXh0TGVmdCh2aXApLCB2aW0gJiYgdmlwKSB7XG4gICAgICAgIHZvbSA9IG5leHRMZWZ0KHZvbSk7XG4gICAgICAgIHZvcCA9IG5leHRSaWdodCh2b3ApO1xuICAgICAgICB2b3AuYSA9IHY7XG4gICAgICAgIHNoaWZ0ID0gdmltLnogKyBzaW0gLSB2aXAueiAtIHNpcCArIHNlcGFyYXRpb24odmltLl8sIHZpcC5fKTtcbiAgICAgICAgaWYgKHNoaWZ0ID4gMCkge1xuICAgICAgICAgIG1vdmVTdWJ0cmVlKG5leHRBbmNlc3Rvcih2aW0sIHYsIGFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICAgIHNpcCArPSBzaGlmdDtcbiAgICAgICAgICBzb3AgKz0gc2hpZnQ7XG4gICAgICAgIH1cbiAgICAgICAgc2ltICs9IHZpbS5tO1xuICAgICAgICBzaXAgKz0gdmlwLm07XG4gICAgICAgIHNvbSArPSB2b20ubTtcbiAgICAgICAgc29wICs9IHZvcC5tO1xuICAgICAgfVxuICAgICAgaWYgKHZpbSAmJiAhbmV4dFJpZ2h0KHZvcCkpIHtcbiAgICAgICAgdm9wLnQgPSB2aW07XG4gICAgICAgIHZvcC5tICs9IHNpbSAtIHNvcDtcbiAgICAgIH1cbiAgICAgIGlmICh2aXAgJiYgIW5leHRMZWZ0KHZvbSkpIHtcbiAgICAgICAgdm9tLnQgPSB2aXA7XG4gICAgICAgIHZvbS5tICs9IHNpcCAtIHNvbTtcbiAgICAgICAgYW5jZXN0b3IgPSB2O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW5jZXN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBzaXplTm9kZShub2RlKSB7XG4gICAgbm9kZS54ICo9IGR4O1xuICAgIG5vZGUueSA9IG5vZGUuZGVwdGggKiBkeTtcbiAgfVxuXG4gIHRyZWUuc2VwYXJhdGlvbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzZXBhcmF0aW9uID0geCwgdHJlZSkgOiBzZXBhcmF0aW9uO1xuICB9O1xuXG4gIHRyZWUuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IGZhbHNlLCBkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlKSA6IChub2RlU2l6ZSA/IG51bGwgOiBbZHgsIGR5XSk7XG4gIH07XG5cbiAgdHJlZS5ub2RlU2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlU2l6ZSA9IHRydWUsIGR4ID0gK3hbMF0sIGR5ID0gK3hbMV0sIHRyZWUpIDogKG5vZGVTaXplID8gW2R4LCBkeV0gOiBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gdHJlZTtcbn07XG5cbnZhciB0cmVlbWFwU2xpY2UgPSBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIG5vZGUsXG4gICAgICBpID0gLTEsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgayA9IHBhcmVudC52YWx1ZSAmJiAoeTEgLSB5MCkgLyBwYXJlbnQudmFsdWU7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUueDAgPSB4MCwgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTAgPSB5MCwgbm9kZS55MSA9IHkwICs9IG5vZGUudmFsdWUgKiBrO1xuICB9XG59O1xuXG52YXIgcGhpID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcblxuZnVuY3Rpb24gc3F1YXJpZnlSYXRpbyhyYXRpbywgcGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICB2YXIgcm93cyA9IFtdLFxuICAgICAgbm9kZXMgPSBwYXJlbnQuY2hpbGRyZW4sXG4gICAgICByb3csXG4gICAgICBub2RlVmFsdWUsXG4gICAgICBpMCA9IDAsXG4gICAgICBpMSA9IDAsXG4gICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgZHgsIGR5LFxuICAgICAgdmFsdWUgPSBwYXJlbnQudmFsdWUsXG4gICAgICBzdW1WYWx1ZSxcbiAgICAgIG1pblZhbHVlLFxuICAgICAgbWF4VmFsdWUsXG4gICAgICBuZXdSYXRpbyxcbiAgICAgIG1pblJhdGlvLFxuICAgICAgYWxwaGEsXG4gICAgICBiZXRhO1xuXG4gIHdoaWxlIChpMCA8IG4pIHtcbiAgICBkeCA9IHgxIC0geDAsIGR5ID0geTEgLSB5MDtcblxuICAgIC8vIEZpbmQgdGhlIG5leHQgbm9uLWVtcHR5IG5vZGUuXG4gICAgZG8gc3VtVmFsdWUgPSBub2Rlc1tpMSsrXS52YWx1ZTsgd2hpbGUgKCFzdW1WYWx1ZSAmJiBpMSA8IG4pO1xuICAgIG1pblZhbHVlID0gbWF4VmFsdWUgPSBzdW1WYWx1ZTtcbiAgICBhbHBoYSA9IE1hdGgubWF4KGR5IC8gZHgsIGR4IC8gZHkpIC8gKHZhbHVlICogcmF0aW8pO1xuICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XG4gICAgbWluUmF0aW8gPSBNYXRoLm1heChtYXhWYWx1ZSAvIGJldGEsIGJldGEgLyBtaW5WYWx1ZSk7XG5cbiAgICAvLyBLZWVwIGFkZGluZyBub2RlcyB3aGlsZSB0aGUgYXNwZWN0IHJhdGlvIG1haW50YWlucyBvciBpbXByb3Zlcy5cbiAgICBmb3IgKDsgaTEgPCBuOyArK2kxKSB7XG4gICAgICBzdW1WYWx1ZSArPSBub2RlVmFsdWUgPSBub2Rlc1tpMV0udmFsdWU7XG4gICAgICBpZiAobm9kZVZhbHVlIDwgbWluVmFsdWUpIG1pblZhbHVlID0gbm9kZVZhbHVlO1xuICAgICAgaWYgKG5vZGVWYWx1ZSA+IG1heFZhbHVlKSBtYXhWYWx1ZSA9IG5vZGVWYWx1ZTtcbiAgICAgIGJldGEgPSBzdW1WYWx1ZSAqIHN1bVZhbHVlICogYWxwaGE7XG4gICAgICBuZXdSYXRpbyA9IE1hdGgubWF4KG1heFZhbHVlIC8gYmV0YSwgYmV0YSAvIG1pblZhbHVlKTtcbiAgICAgIGlmIChuZXdSYXRpbyA+IG1pblJhdGlvKSB7IHN1bVZhbHVlIC09IG5vZGVWYWx1ZTsgYnJlYWs7IH1cbiAgICAgIG1pblJhdGlvID0gbmV3UmF0aW87XG4gICAgfVxuXG4gICAgLy8gUG9zaXRpb24gYW5kIHJlY29yZCB0aGUgcm93IG9yaWVudGF0aW9uLlxuICAgIHJvd3MucHVzaChyb3cgPSB7dmFsdWU6IHN1bVZhbHVlLCBkaWNlOiBkeCA8IGR5LCBjaGlsZHJlbjogbm9kZXMuc2xpY2UoaTAsIGkxKX0pO1xuICAgIGlmIChyb3cuZGljZSkgdHJlZW1hcERpY2Uocm93LCB4MCwgeTAsIHgxLCB2YWx1ZSA/IHkwICs9IGR5ICogc3VtVmFsdWUgLyB2YWx1ZSA6IHkxKTtcbiAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgdmFsdWUgPyB4MCArPSBkeCAqIHN1bVZhbHVlIC8gdmFsdWUgOiB4MSwgeTEpO1xuICAgIHZhbHVlIC09IHN1bVZhbHVlLCBpMCA9IGkxO1xuICB9XG5cbiAgcmV0dXJuIHJvd3M7XG59XG5cbnZhciBzcXVhcmlmeSA9ICgoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gc3F1YXJpZnkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNxdWFyaWZ5O1xufSkpKHBoaSk7XG5cbnZhciBpbmRleCQxID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aWxlID0gc3F1YXJpZnksXG4gICAgICByb3VuZCA9IGZhbHNlLFxuICAgICAgZHggPSAxLFxuICAgICAgZHkgPSAxLFxuICAgICAgcGFkZGluZ1N0YWNrID0gWzBdLFxuICAgICAgcGFkZGluZ0lubmVyID0gY29uc3RhbnRaZXJvLFxuICAgICAgcGFkZGluZ1RvcCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdSaWdodCA9IGNvbnN0YW50WmVybyxcbiAgICAgIHBhZGRpbmdCb3R0b20gPSBjb25zdGFudFplcm8sXG4gICAgICBwYWRkaW5nTGVmdCA9IGNvbnN0YW50WmVybztcblxuICBmdW5jdGlvbiB0cmVlbWFwKHJvb3QpIHtcbiAgICByb290LngwID1cbiAgICByb290LnkwID0gMDtcbiAgICByb290LngxID0gZHg7XG4gICAgcm9vdC55MSA9IGR5O1xuICAgIHJvb3QuZWFjaEJlZm9yZShwb3NpdGlvbk5vZGUpO1xuICAgIHBhZGRpbmdTdGFjayA9IFswXTtcbiAgICBpZiAocm91bmQpIHJvb3QuZWFjaEJlZm9yZShyb3VuZE5vZGUpO1xuICAgIHJldHVybiByb290O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25Ob2RlKG5vZGUpIHtcbiAgICB2YXIgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoXSxcbiAgICAgICAgeDAgPSBub2RlLngwICsgcCxcbiAgICAgICAgeTAgPSBub2RlLnkwICsgcCxcbiAgICAgICAgeDEgPSBub2RlLngxIC0gcCxcbiAgICAgICAgeTEgPSBub2RlLnkxIC0gcDtcbiAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgaWYgKHkxIDwgeTApIHkwID0geTEgPSAoeTAgKyB5MSkgLyAyO1xuICAgIG5vZGUueDAgPSB4MDtcbiAgICBub2RlLnkwID0geTA7XG4gICAgbm9kZS54MSA9IHgxO1xuICAgIG5vZGUueTEgPSB5MTtcbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgcCA9IHBhZGRpbmdTdGFja1tub2RlLmRlcHRoICsgMV0gPSBwYWRkaW5nSW5uZXIobm9kZSkgLyAyO1xuICAgICAgeDAgKz0gcGFkZGluZ0xlZnQobm9kZSkgLSBwO1xuICAgICAgeTAgKz0gcGFkZGluZ1RvcChub2RlKSAtIHA7XG4gICAgICB4MSAtPSBwYWRkaW5nUmlnaHQobm9kZSkgLSBwO1xuICAgICAgeTEgLT0gcGFkZGluZ0JvdHRvbShub2RlKSAtIHA7XG4gICAgICBpZiAoeDEgPCB4MCkgeDAgPSB4MSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoeTEgPCB5MCkgeTAgPSB5MSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICB0aWxlKG5vZGUsIHgwLCB5MCwgeDEsIHkxKTtcbiAgICB9XG4gIH1cblxuICB0cmVlbWFwLnJvdW5kID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISF4LCB0cmVlbWFwKSA6IHJvdW5kO1xuICB9O1xuXG4gIHRyZWVtYXAuc2l6ZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkeCA9ICt4WzBdLCBkeSA9ICt4WzFdLCB0cmVlbWFwKSA6IFtkeCwgZHldO1xuICB9O1xuXG4gIHRyZWVtYXAudGlsZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aWxlID0gcmVxdWlyZWQoeCksIHRyZWVtYXApIDogdGlsZTtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmcgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0cmVlbWFwLnBhZGRpbmdJbm5lcih4KS5wYWRkaW5nT3V0ZXIoeCkgOiB0cmVlbWFwLnBhZGRpbmdJbm5lcigpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IHR5cGVvZiB4ID09PSBcImZ1bmN0aW9uXCIgPyB4IDogY29uc3RhbnQoK3gpLCB0cmVlbWFwKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRyZWVtYXAucGFkZGluZ1RvcCh4KS5wYWRkaW5nUmlnaHQoeCkucGFkZGluZ0JvdHRvbSh4KS5wYWRkaW5nTGVmdCh4KSA6IHRyZWVtYXAucGFkZGluZ1RvcCgpO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ1RvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nVG9wID0gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHggOiBjb25zdGFudCgreCksIHRyZWVtYXApIDogcGFkZGluZ1RvcDtcbiAgfTtcblxuICB0cmVlbWFwLnBhZGRpbmdSaWdodCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nUmlnaHQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nUmlnaHQ7XG4gIH07XG5cbiAgdHJlZW1hcC5wYWRkaW5nQm90dG9tID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdCb3R0b20gPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nQm90dG9tO1xuICB9O1xuXG4gIHRyZWVtYXAucGFkZGluZ0xlZnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ0xlZnQgPSB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geCA6IGNvbnN0YW50KCt4KSwgdHJlZW1hcCkgOiBwYWRkaW5nTGVmdDtcbiAgfTtcblxuICByZXR1cm4gdHJlZW1hcDtcbn07XG5cbnZhciBiaW5hcnkgPSBmdW5jdGlvbihwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBub2RlcyA9IHBhcmVudC5jaGlsZHJlbixcbiAgICAgIGksIG4gPSBub2Rlcy5sZW5ndGgsXG4gICAgICBzdW0sIHN1bXMgPSBuZXcgQXJyYXkobiArIDEpO1xuXG4gIGZvciAoc3Vtc1swXSA9IHN1bSA9IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc3Vtc1tpICsgMV0gPSBzdW0gKz0gbm9kZXNbaV0udmFsdWU7XG4gIH1cblxuICBwYXJ0aXRpb24oMCwgbiwgcGFyZW50LnZhbHVlLCB4MCwgeTAsIHgxLCB5MSk7XG5cbiAgZnVuY3Rpb24gcGFydGl0aW9uKGksIGosIHZhbHVlLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGlmIChpID49IGogLSAxKSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgbm9kZS54MCA9IHgwLCBub2RlLnkwID0geTA7XG4gICAgICBub2RlLngxID0geDEsIG5vZGUueTEgPSB5MTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVPZmZzZXQgPSBzdW1zW2ldLFxuICAgICAgICB2YWx1ZVRhcmdldCA9ICh2YWx1ZSAvIDIpICsgdmFsdWVPZmZzZXQsXG4gICAgICAgIGsgPSBpICsgMSxcbiAgICAgICAgaGkgPSBqIC0gMTtcblxuICAgIHdoaWxlIChrIDwgaGkpIHtcbiAgICAgIHZhciBtaWQgPSBrICsgaGkgPj4+IDE7XG4gICAgICBpZiAoc3Vtc1ttaWRdIDwgdmFsdWVUYXJnZXQpIGsgPSBtaWQgKyAxO1xuICAgICAgZWxzZSBoaSA9IG1pZDtcbiAgICB9XG5cbiAgICBpZiAoKHZhbHVlVGFyZ2V0IC0gc3Vtc1trIC0gMV0pIDwgKHN1bXNba10gLSB2YWx1ZVRhcmdldCkgJiYgaSArIDEgPCBrKSAtLWs7XG5cbiAgICB2YXIgdmFsdWVMZWZ0ID0gc3Vtc1trXSAtIHZhbHVlT2Zmc2V0LFxuICAgICAgICB2YWx1ZVJpZ2h0ID0gdmFsdWUgLSB2YWx1ZUxlZnQ7XG5cbiAgICBpZiAoKHgxIC0geDApID4gKHkxIC0geTApKSB7XG4gICAgICB2YXIgeGsgPSAoeDAgKiB2YWx1ZVJpZ2h0ICsgeDEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHhrLCB5MSk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeGssIHkwLCB4MSwgeTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeWsgPSAoeTAgKiB2YWx1ZVJpZ2h0ICsgeTEgKiB2YWx1ZUxlZnQpIC8gdmFsdWU7XG4gICAgICBwYXJ0aXRpb24oaSwgaywgdmFsdWVMZWZ0LCB4MCwgeTAsIHgxLCB5ayk7XG4gICAgICBwYXJ0aXRpb24oaywgaiwgdmFsdWVSaWdodCwgeDAsIHlrLCB4MSwgeTEpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHNsaWNlRGljZSA9IGZ1bmN0aW9uKHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgKHBhcmVudC5kZXB0aCAmIDEgPyB0cmVlbWFwU2xpY2UgOiB0cmVlbWFwRGljZSkocGFyZW50LCB4MCwgeTAsIHgxLCB5MSk7XG59O1xuXG52YXIgcmVzcXVhcmlmeSA9ICgoZnVuY3Rpb24gY3VzdG9tKHJhdGlvKSB7XG5cbiAgZnVuY3Rpb24gcmVzcXVhcmlmeShwYXJlbnQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgaWYgKChyb3dzID0gcGFyZW50Ll9zcXVhcmlmeSkgJiYgKHJvd3MucmF0aW8gPT09IHJhdGlvKSkge1xuICAgICAgdmFyIHJvd3MsXG4gICAgICAgICAgcm93LFxuICAgICAgICAgIG5vZGVzLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaiA9IC0xLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgbSA9IHJvd3MubGVuZ3RoLFxuICAgICAgICAgIHZhbHVlID0gcGFyZW50LnZhbHVlO1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICByb3cgPSByb3dzW2pdLCBub2RlcyA9IHJvdy5jaGlsZHJlbjtcbiAgICAgICAgZm9yIChpID0gcm93LnZhbHVlID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkgcm93LnZhbHVlICs9IG5vZGVzW2ldLnZhbHVlO1xuICAgICAgICBpZiAocm93LmRpY2UpIHRyZWVtYXBEaWNlKHJvdywgeDAsIHkwLCB4MSwgeTAgKz0gKHkxIC0geTApICogcm93LnZhbHVlIC8gdmFsdWUpO1xuICAgICAgICBlbHNlIHRyZWVtYXBTbGljZShyb3csIHgwLCB5MCwgeDAgKz0gKHgxIC0geDApICogcm93LnZhbHVlIC8gdmFsdWUsIHkxKTtcbiAgICAgICAgdmFsdWUgLT0gcm93LnZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuX3NxdWFyaWZ5ID0gcm93cyA9IHNxdWFyaWZ5UmF0aW8ocmF0aW8sIHBhcmVudCwgeDAsIHkwLCB4MSwgeTEpO1xuICAgICAgcm93cy5yYXRpbyA9IHJhdGlvO1xuICAgIH1cbiAgfVxuXG4gIHJlc3F1YXJpZnkucmF0aW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIGN1c3RvbSgoeCA9ICt4KSA+IDEgPyB4IDogMSk7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3F1YXJpZnk7XG59KSkocGhpKTtcblxuZXhwb3J0cy5jbHVzdGVyID0gY2x1c3RlcjtcbmV4cG9ydHMuaGllcmFyY2h5ID0gaGllcmFyY2h5O1xuZXhwb3J0cy5wYWNrID0gaW5kZXg7XG5leHBvcnRzLnBhY2tTaWJsaW5ncyA9IHNpYmxpbmdzO1xuZXhwb3J0cy5wYWNrRW5jbG9zZSA9IGVuY2xvc2U7XG5leHBvcnRzLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbmV4cG9ydHMuc3RyYXRpZnkgPSBzdHJhdGlmeTtcbmV4cG9ydHMudHJlZSA9IHRyZWU7XG5leHBvcnRzLnRyZWVtYXAgPSBpbmRleCQxO1xuZXhwb3J0cy50cmVlbWFwQmluYXJ5ID0gYmluYXJ5O1xuZXhwb3J0cy50cmVlbWFwRGljZSA9IHRyZWVtYXBEaWNlO1xuZXhwb3J0cy50cmVlbWFwU2xpY2UgPSB0cmVlbWFwU2xpY2U7XG5leHBvcnRzLnRyZWVtYXBTbGljZURpY2UgPSBzbGljZURpY2U7XG5leHBvcnRzLnRyZWVtYXBTcXVhcmlmeSA9IHNxdWFyaWZ5O1xuZXhwb3J0cy50cmVlbWFwUmVzcXVhcmlmeSA9IHJlc3F1YXJpZnk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLWludGVycG9sYXRlLyBWZXJzaW9uIDEuMi4wLiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWNvbG9yJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1jb2xvciddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNDb2xvcikgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGJhc2lzKHQxLCB2MCwgdjEsIHYyLCB2Mykge1xuICB2YXIgdDIgPSB0MSAqIHQxLCB0MyA9IHQyICogdDE7XG4gIHJldHVybiAoKDEgLSAzICogdDEgKyAzICogdDIgLSB0MykgKiB2MFxuICAgICAgKyAoNCAtIDYgKiB0MiArIDMgKiB0MykgKiB2MVxuICAgICAgKyAoMSArIDMgKiB0MSArIDMgKiB0MiAtIDMgKiB0MykgKiB2MlxuICAgICAgKyB0MyAqIHYzKSAvIDY7XG59XG5cbnZhciBiYXNpcyQxID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgdmFyIGkgPSB0IDw9IDAgPyAodCA9IDApIDogdCA+PSAxID8gKHQgPSAxLCBuIC0gMSkgOiBNYXRoLmZsb29yKHQgKiBuKSxcbiAgICAgICAgdjEgPSB2YWx1ZXNbaV0sXG4gICAgICAgIHYyID0gdmFsdWVzW2kgKyAxXSxcbiAgICAgICAgdjAgPSBpID4gMCA/IHZhbHVlc1tpIC0gMV0gOiAyICogdjEgLSB2MixcbiAgICAgICAgdjMgPSBpIDwgbiAtIDEgPyB2YWx1ZXNbaSArIDJdIDogMiAqIHYyIC0gdjE7XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufTtcblxudmFyIGJhc2lzQ2xvc2VkID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aDtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoKCh0ICU9IDEpIDwgMCA/ICsrdCA6IHQpICogbiksXG4gICAgICAgIHYwID0gdmFsdWVzWyhpICsgbiAtIDEpICUgbl0sXG4gICAgICAgIHYxID0gdmFsdWVzW2kgJSBuXSxcbiAgICAgICAgdjIgPSB2YWx1ZXNbKGkgKyAxKSAlIG5dLFxuICAgICAgICB2MyA9IHZhbHVlc1soaSArIDIpICUgbl07XG4gICAgcmV0dXJuIGJhc2lzKCh0IC0gaSAvIG4pICogbiwgdjAsIHYxLCB2MiwgdjMpO1xuICB9O1xufTtcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBsaW5lYXIoYSwgZCkge1xuICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBhICsgdCAqIGQ7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cG9uZW50aWFsKGEsIGIsIHkpIHtcbiAgcmV0dXJuIGEgPSBNYXRoLnBvdyhhLCB5KSwgYiA9IE1hdGgucG93KGIsIHkpIC0gYSwgeSA9IDEgLyB5LCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KGEgKyB0ICogYiwgeSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh1ZShhLCBiKSB7XG4gIHZhciBkID0gYiAtIGE7XG4gIHJldHVybiBkID8gbGluZWFyKGEsIGQgPiAxODAgfHwgZCA8IC0xODAgPyBkIC0gMzYwICogTWF0aC5yb3VuZChkIC8gMzYwKSA6IGQpIDogY29uc3RhbnQoaXNOYU4oYSkgPyBiIDogYSk7XG59XG5cbmZ1bmN0aW9uIGdhbW1hKHkpIHtcbiAgcmV0dXJuICh5ID0gK3kpID09PSAxID8gbm9nYW1tYSA6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYiAtIGEgPyBleHBvbmVudGlhbChhLCBiLCB5KSA6IGNvbnN0YW50KGlzTmFOKGEpID8gYiA6IGEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBub2dhbW1hKGEsIGIpIHtcbiAgdmFyIGQgPSBiIC0gYTtcbiAgcmV0dXJuIGQgPyBsaW5lYXIoYSwgZCkgOiBjb25zdGFudChpc05hTihhKSA/IGIgOiBhKTtcbn1cblxudmFyIHJnYiQxID0gKChmdW5jdGlvbiByZ2JHYW1tYSh5KSB7XG4gIHZhciBjb2xvciQkMSA9IGdhbW1hKHkpO1xuXG4gIGZ1bmN0aW9uIHJnYiQkMShzdGFydCwgZW5kKSB7XG4gICAgdmFyIHIgPSBjb2xvciQkMSgoc3RhcnQgPSBkM0NvbG9yLnJnYihzdGFydCkpLnIsIChlbmQgPSBkM0NvbG9yLnJnYihlbmQpKS5yKSxcbiAgICAgICAgZyA9IGNvbG9yJCQxKHN0YXJ0LmcsIGVuZC5nKSxcbiAgICAgICAgYiA9IGNvbG9yJCQxKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgICAgb3BhY2l0eSA9IG5vZ2FtbWEoc3RhcnQub3BhY2l0eSwgZW5kLm9wYWNpdHkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICBzdGFydC5yID0gcih0KTtcbiAgICAgIHN0YXJ0LmcgPSBnKHQpO1xuICAgICAgc3RhcnQuYiA9IGIodCk7XG4gICAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgfTtcbiAgfVxuXG4gIHJnYiQkMS5nYW1tYSA9IHJnYkdhbW1hO1xuXG4gIHJldHVybiByZ2IkJDE7XG59KSkoMSk7XG5cbmZ1bmN0aW9uIHJnYlNwbGluZShzcGxpbmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbG9ycykge1xuICAgIHZhciBuID0gY29sb3JzLmxlbmd0aCxcbiAgICAgICAgciA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgZyA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgaSwgY29sb3IkJDE7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgY29sb3IkJDEgPSBkM0NvbG9yLnJnYihjb2xvcnNbaV0pO1xuICAgICAgcltpXSA9IGNvbG9yJCQxLnIgfHwgMDtcbiAgICAgIGdbaV0gPSBjb2xvciQkMS5nIHx8IDA7XG4gICAgICBiW2ldID0gY29sb3IkJDEuYiB8fCAwO1xuICAgIH1cbiAgICByID0gc3BsaW5lKHIpO1xuICAgIGcgPSBzcGxpbmUoZyk7XG4gICAgYiA9IHNwbGluZShiKTtcbiAgICBjb2xvciQkMS5vcGFjaXR5ID0gMTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgY29sb3IkJDEuciA9IHIodCk7XG4gICAgICBjb2xvciQkMS5nID0gZyh0KTtcbiAgICAgIGNvbG9yJCQxLmIgPSBiKHQpO1xuICAgICAgcmV0dXJuIGNvbG9yJCQxICsgXCJcIjtcbiAgICB9O1xuICB9O1xufVxuXG52YXIgcmdiQmFzaXMgPSByZ2JTcGxpbmUoYmFzaXMkMSk7XG52YXIgcmdiQmFzaXNDbG9zZWQgPSByZ2JTcGxpbmUoYmFzaXNDbG9zZWQpO1xuXG52YXIgYXJyYXkgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBuYiA9IGIgPyBiLmxlbmd0aCA6IDAsXG4gICAgICBuYSA9IGEgPyBNYXRoLm1pbihuYiwgYS5sZW5ndGgpIDogMCxcbiAgICAgIHggPSBuZXcgQXJyYXkobmEpLFxuICAgICAgYyA9IG5ldyBBcnJheShuYiksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB4W2ldID0gdmFsdWUoYVtpXSwgYltpXSk7XG4gIGZvciAoOyBpIDwgbmI7ICsraSkgY1tpXSA9IGJbaV07XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbmE7ICsraSkgY1tpXSA9IHhbaV0odCk7XG4gICAgcmV0dXJuIGM7XG4gIH07XG59O1xuXG52YXIgZGF0ZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZTtcbiAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGQuc2V0VGltZShhICsgYiAqIHQpLCBkO1xuICB9O1xufTtcblxudmFyIG51bWJlciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGEgPSArYSwgYiAtPSBhLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIGEgKyBiICogdDtcbiAgfTtcbn07XG5cbnZhciBvYmplY3QgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBpID0ge30sXG4gICAgICBjID0ge30sXG4gICAgICBrO1xuXG4gIGlmIChhID09PSBudWxsIHx8IHR5cGVvZiBhICE9PSBcIm9iamVjdFwiKSBhID0ge307XG4gIGlmIChiID09PSBudWxsIHx8IHR5cGVvZiBiICE9PSBcIm9iamVjdFwiKSBiID0ge307XG5cbiAgZm9yIChrIGluIGIpIHtcbiAgICBpZiAoayBpbiBhKSB7XG4gICAgICBpW2tdID0gdmFsdWUoYVtrXSwgYltrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNba10gPSBiW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgZm9yIChrIGluIGkpIGNba10gPSBpW2tdKHQpO1xuICAgIHJldHVybiBjO1xuICB9O1xufTtcblxudmFyIHJlQSA9IC9bLStdPyg/OlxcZCtcXC4/XFxkKnxcXC4/XFxkKykoPzpbZUVdWy0rXT9cXGQrKT8vZztcbnZhciByZUIgPSBuZXcgUmVnRXhwKHJlQS5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gemVybyhiKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYjtcbiAgfTtcbn1cblxuZnVuY3Rpb24gb25lKGIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gYih0KSArIFwiXCI7XG4gIH07XG59XG5cbnZhciBzdHJpbmcgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBiaSA9IHJlQS5sYXN0SW5kZXggPSByZUIubGFzdEluZGV4ID0gMCwgLy8gc2NhbiBpbmRleCBmb3IgbmV4dCBudW1iZXIgaW4gYlxuICAgICAgYW0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYVxuICAgICAgYm0sIC8vIGN1cnJlbnQgbWF0Y2ggaW4gYlxuICAgICAgYnMsIC8vIHN0cmluZyBwcmVjZWRpbmcgY3VycmVudCBudW1iZXIgaW4gYiwgaWYgYW55XG4gICAgICBpID0gLTEsIC8vIGluZGV4IGluIHNcbiAgICAgIHMgPSBbXSwgLy8gc3RyaW5nIGNvbnN0YW50cyBhbmQgcGxhY2Vob2xkZXJzXG4gICAgICBxID0gW107IC8vIG51bWJlciBpbnRlcnBvbGF0b3JzXG5cbiAgLy8gQ29lcmNlIGlucHV0cyB0byBzdHJpbmdzLlxuICBhID0gYSArIFwiXCIsIGIgPSBiICsgXCJcIjtcblxuICAvLyBJbnRlcnBvbGF0ZSBwYWlycyBvZiBudW1iZXJzIGluIGEgJiBiLlxuICB3aGlsZSAoKGFtID0gcmVBLmV4ZWMoYSkpXG4gICAgICAmJiAoYm0gPSByZUIuZXhlYyhiKSkpIHtcbiAgICBpZiAoKGJzID0gYm0uaW5kZXgpID4gYmkpIHsgLy8gYSBzdHJpbmcgcHJlY2VkZXMgdGhlIG5leHQgbnVtYmVyIGluIGJcbiAgICAgIGJzID0gYi5zbGljZShiaSwgYnMpO1xuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJzO1xuICAgIH1cbiAgICBpZiAoKGFtID0gYW1bMF0pID09PSAoYm0gPSBibVswXSkpIHsgLy8gbnVtYmVycyBpbiBhICYgYiBtYXRjaFxuICAgICAgaWYgKHNbaV0pIHNbaV0gKz0gYm07IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgICBlbHNlIHNbKytpXSA9IGJtO1xuICAgIH0gZWxzZSB7IC8vIGludGVycG9sYXRlIG5vbi1tYXRjaGluZyBudW1iZXJzXG4gICAgICBzWysraV0gPSBudWxsO1xuICAgICAgcS5wdXNoKHtpOiBpLCB4OiBudW1iZXIoYW0sIGJtKX0pO1xuICAgIH1cbiAgICBiaSA9IHJlQi5sYXN0SW5kZXg7XG4gIH1cblxuICAvLyBBZGQgcmVtYWlucyBvZiBiLlxuICBpZiAoYmkgPCBiLmxlbmd0aCkge1xuICAgIGJzID0gYi5zbGljZShiaSk7XG4gICAgaWYgKHNbaV0pIHNbaV0gKz0gYnM7IC8vIGNvYWxlc2NlIHdpdGggcHJldmlvdXMgc3RyaW5nXG4gICAgZWxzZSBzWysraV0gPSBicztcbiAgfVxuXG4gIC8vIFNwZWNpYWwgb3B0aW1pemF0aW9uIGZvciBvbmx5IGEgc2luZ2xlIG1hdGNoLlxuICAvLyBPdGhlcndpc2UsIGludGVycG9sYXRlIGVhY2ggb2YgdGhlIG51bWJlcnMgYW5kIHJlam9pbiB0aGUgc3RyaW5nLlxuICByZXR1cm4gcy5sZW5ndGggPCAyID8gKHFbMF1cbiAgICAgID8gb25lKHFbMF0ueClcbiAgICAgIDogemVybyhiKSlcbiAgICAgIDogKGIgPSBxLmxlbmd0aCwgZnVuY3Rpb24odCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvOyBpIDwgYjsgKytpKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICAgICAgcmV0dXJuIHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG59O1xuXG52YXIgdmFsdWUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciB0ID0gdHlwZW9mIGIsIGM7XG4gIHJldHVybiBiID09IG51bGwgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBjb25zdGFudChiKVxuICAgICAgOiAodCA9PT0gXCJudW1iZXJcIiA/IG51bWJlclxuICAgICAgOiB0ID09PSBcInN0cmluZ1wiID8gKChjID0gZDNDb2xvci5jb2xvcihiKSkgPyAoYiA9IGMsIHJnYiQxKSA6IHN0cmluZylcbiAgICAgIDogYiBpbnN0YW5jZW9mIGQzQ29sb3IuY29sb3IgPyByZ2IkMVxuICAgICAgOiBiIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGVcbiAgICAgIDogQXJyYXkuaXNBcnJheShiKSA/IGFycmF5XG4gICAgICA6IHR5cGVvZiBiLnZhbHVlT2YgIT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgYi50b1N0cmluZyAhPT0gXCJmdW5jdGlvblwiIHx8IGlzTmFOKGIpID8gb2JqZWN0XG4gICAgICA6IG51bWJlcikoYSwgYik7XG59O1xuXG52YXIgcm91bmQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHJldHVybiBhID0gK2EsIGIgLT0gYSwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKGEgKyBiICogdCk7XG4gIH07XG59O1xuXG52YXIgZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG5cbnZhciBpZGVudGl0eSA9IHtcbiAgdHJhbnNsYXRlWDogMCxcbiAgdHJhbnNsYXRlWTogMCxcbiAgcm90YXRlOiAwLFxuICBza2V3WDogMCxcbiAgc2NhbGVYOiAxLFxuICBzY2FsZVk6IDFcbn07XG5cbnZhciBkZWNvbXBvc2UgPSBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBzY2FsZVgsIHNjYWxlWSwgc2tld1g7XG4gIGlmIChzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYikpIGEgLz0gc2NhbGVYLCBiIC89IHNjYWxlWDtcbiAgaWYgKHNrZXdYID0gYSAqIGMgKyBiICogZCkgYyAtPSBhICogc2tld1gsIGQgLT0gYiAqIHNrZXdYO1xuICBpZiAoc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpKSBjIC89IHNjYWxlWSwgZCAvPSBzY2FsZVksIHNrZXdYIC89IHNjYWxlWTtcbiAgaWYgKGEgKiBkIDwgYiAqIGMpIGEgPSAtYSwgYiA9IC1iLCBza2V3WCA9IC1za2V3WCwgc2NhbGVYID0gLXNjYWxlWDtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2xhdGVYOiBlLFxuICAgIHRyYW5zbGF0ZVk6IGYsXG4gICAgcm90YXRlOiBNYXRoLmF0YW4yKGIsIGEpICogZGVncmVlcyxcbiAgICBza2V3WDogTWF0aC5hdGFuKHNrZXdYKSAqIGRlZ3JlZXMsXG4gICAgc2NhbGVYOiBzY2FsZVgsXG4gICAgc2NhbGVZOiBzY2FsZVlcbiAgfTtcbn07XG5cbnZhciBjc3NOb2RlO1xudmFyIGNzc1Jvb3Q7XG52YXIgY3NzVmlldztcbnZhciBzdmdOb2RlO1xuXG5mdW5jdGlvbiBwYXJzZUNzcyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT09IFwibm9uZVwiKSByZXR1cm4gaWRlbnRpdHk7XG4gIGlmICghY3NzTm9kZSkgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJESVZcIiksIGNzc1Jvb3QgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNzc1ZpZXcgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgY3NzTm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZTtcbiAgdmFsdWUgPSBjc3NWaWV3LmdldENvbXB1dGVkU3R5bGUoY3NzUm9vdC5hcHBlbmRDaGlsZChjc3NOb2RlKSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShcInRyYW5zZm9ybVwiKTtcbiAgY3NzUm9vdC5yZW1vdmVDaGlsZChjc3NOb2RlKTtcbiAgdmFsdWUgPSB2YWx1ZS5zbGljZSg3LCAtMSkuc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gZGVjb21wb3NlKCt2YWx1ZVswXSwgK3ZhbHVlWzFdLCArdmFsdWVbMl0sICt2YWx1ZVszXSwgK3ZhbHVlWzRdLCArdmFsdWVbNV0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN2Zyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGlkZW50aXR5O1xuICBpZiAoIXN2Z05vZGUpIHN2Z05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XG4gIHN2Z05vZGUuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIHZhbHVlKTtcbiAgaWYgKCEodmFsdWUgPSBzdmdOb2RlLnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkpKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhbHVlID0gdmFsdWUubWF0cml4O1xuICByZXR1cm4gZGVjb21wb3NlKHZhbHVlLmEsIHZhbHVlLmIsIHZhbHVlLmMsIHZhbHVlLmQsIHZhbHVlLmUsIHZhbHVlLmYpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVRyYW5zZm9ybShwYXJzZSwgcHhDb21tYSwgcHhQYXJlbiwgZGVnUGFyZW4pIHtcblxuICBmdW5jdGlvbiBwb3Aocykge1xuICAgIHJldHVybiBzLmxlbmd0aCA/IHMucG9wKCkgKyBcIiBcIiA6IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUoeGEsIHlhLCB4YiwgeWIsIHMsIHEpIHtcbiAgICBpZiAoeGEgIT09IHhiIHx8IHlhICE9PSB5Yikge1xuICAgICAgdmFyIGkgPSBzLnB1c2goXCJ0cmFuc2xhdGUoXCIsIG51bGwsIHB4Q29tbWEsIG51bGwsIHB4UGFyZW4pO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiB8fCB5Yikge1xuICAgICAgcy5wdXNoKFwidHJhbnNsYXRlKFwiICsgeGIgKyBweENvbW1hICsgeWIgKyBweFBhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByb3RhdGUoYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBpZiAoYSAtIGIgPiAxODApIGIgKz0gMzYwOyBlbHNlIGlmIChiIC0gYSA+IDE4MCkgYSArPSAzNjA7IC8vIHNob3J0ZXN0IHBhdGhcbiAgICAgIHEucHVzaCh7aTogcy5wdXNoKHBvcChzKSArIFwicm90YXRlKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInJvdGF0ZShcIiArIGIgKyBkZWdQYXJlbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2tld1goYSwgYiwgcywgcSkge1xuICAgIGlmIChhICE9PSBiKSB7XG4gICAgICBxLnB1c2goe2k6IHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiLCBudWxsLCBkZWdQYXJlbikgLSAyLCB4OiBudW1iZXIoYSwgYil9KTtcbiAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgIHMucHVzaChwb3AocykgKyBcInNrZXdYKFwiICsgYiArIGRlZ1BhcmVuKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2FsZSh4YSwgeWEsIHhiLCB5YiwgcywgcSkge1xuICAgIGlmICh4YSAhPT0geGIgfHwgeWEgIT09IHliKSB7XG4gICAgICB2YXIgaSA9IHMucHVzaChwb3AocykgKyBcInNjYWxlKFwiLCBudWxsLCBcIixcIiwgbnVsbCwgXCIpXCIpO1xuICAgICAgcS5wdXNoKHtpOiBpIC0gNCwgeDogbnVtYmVyKHhhLCB4Yil9LCB7aTogaSAtIDIsIHg6IG51bWJlcih5YSwgeWIpfSk7XG4gICAgfSBlbHNlIGlmICh4YiAhPT0gMSB8fCB5YiAhPT0gMSkge1xuICAgICAgcy5wdXNoKHBvcChzKSArIFwic2NhbGUoXCIgKyB4YiArIFwiLFwiICsgeWIgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcyA9IFtdLCAvLyBzdHJpbmcgY29uc3RhbnRzIGFuZCBwbGFjZWhvbGRlcnNcbiAgICAgICAgcSA9IFtdOyAvLyBudW1iZXIgaW50ZXJwb2xhdG9yc1xuICAgIGEgPSBwYXJzZShhKSwgYiA9IHBhcnNlKGIpO1xuICAgIHRyYW5zbGF0ZShhLnRyYW5zbGF0ZVgsIGEudHJhbnNsYXRlWSwgYi50cmFuc2xhdGVYLCBiLnRyYW5zbGF0ZVksIHMsIHEpO1xuICAgIHJvdGF0ZShhLnJvdGF0ZSwgYi5yb3RhdGUsIHMsIHEpO1xuICAgIHNrZXdYKGEuc2tld1gsIGIuc2tld1gsIHMsIHEpO1xuICAgIHNjYWxlKGEuc2NhbGVYLCBhLnNjYWxlWSwgYi5zY2FsZVgsIGIuc2NhbGVZLCBzLCBxKTtcbiAgICBhID0gYiA9IG51bGw7IC8vIGdjXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHZhciBpID0gLTEsIG4gPSBxLmxlbmd0aCwgbztcbiAgICAgIHdoaWxlICgrK2kgPCBuKSBzWyhvID0gcVtpXSkuaV0gPSBvLngodCk7XG4gICAgICByZXR1cm4gcy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH07XG59XG5cbnZhciBpbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA9IGludGVycG9sYXRlVHJhbnNmb3JtKHBhcnNlQ3NzLCBcInB4LCBcIiwgXCJweClcIiwgXCJkZWcpXCIpO1xudmFyIGludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm0ocGFyc2VTdmcsIFwiLCBcIiwgXCIpXCIsIFwiKVwiKTtcblxudmFyIHJobyA9IE1hdGguU1FSVDI7XG52YXIgcmhvMiA9IDI7XG52YXIgcmhvNCA9IDQ7XG52YXIgZXBzaWxvbjIgPSAxZS0xMjtcblxuZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoKHggPSBNYXRoLmV4cCh4KSkgKyAxIC8geCkgLyAyO1xufVxuXG5mdW5jdGlvbiBzaW5oKHgpIHtcbiAgcmV0dXJuICgoeCA9IE1hdGguZXhwKHgpKSAtIDEgLyB4KSAvIDI7XG59XG5cbmZ1bmN0aW9uIHRhbmgoeCkge1xuICByZXR1cm4gKCh4ID0gTWF0aC5leHAoMiAqIHgpKSAtIDEpIC8gKHggKyAxKTtcbn1cblxuLy8gcDAgPSBbdXgwLCB1eTAsIHcwXVxuLy8gcDEgPSBbdXgxLCB1eTEsIHcxXVxudmFyIHpvb20gPSBmdW5jdGlvbihwMCwgcDEpIHtcbiAgdmFyIHV4MCA9IHAwWzBdLCB1eTAgPSBwMFsxXSwgdzAgPSBwMFsyXSxcbiAgICAgIHV4MSA9IHAxWzBdLCB1eTEgPSBwMVsxXSwgdzEgPSBwMVsyXSxcbiAgICAgIGR4ID0gdXgxIC0gdXgwLFxuICAgICAgZHkgPSB1eTEgLSB1eTAsXG4gICAgICBkMiA9IGR4ICogZHggKyBkeSAqIGR5LFxuICAgICAgaSxcbiAgICAgIFM7XG5cbiAgLy8gU3BlY2lhbCBjYXNlIGZvciB1MCDiiYUgdTEuXG4gIGlmIChkMiA8IGVwc2lsb24yKSB7XG4gICAgUyA9IE1hdGgubG9nKHcxIC8gdzApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB1eDAgKyB0ICogZHgsXG4gICAgICAgIHV5MCArIHQgKiBkeSxcbiAgICAgICAgdzAgKiBNYXRoLmV4cChyaG8gKiB0ICogUylcbiAgICAgIF07XG4gICAgfTtcbiAgfVxuXG4gIC8vIEdlbmVyYWwgY2FzZS5cbiAgZWxzZSB7XG4gICAgdmFyIGQxID0gTWF0aC5zcXJ0KGQyKSxcbiAgICAgICAgYjAgPSAodzEgKiB3MSAtIHcwICogdzAgKyByaG80ICogZDIpIC8gKDIgKiB3MCAqIHJobzIgKiBkMSksXG4gICAgICAgIGIxID0gKHcxICogdzEgLSB3MCAqIHcwIC0gcmhvNCAqIGQyKSAvICgyICogdzEgKiByaG8yICogZDEpLFxuICAgICAgICByMCA9IE1hdGgubG9nKE1hdGguc3FydChiMCAqIGIwICsgMSkgLSBiMCksXG4gICAgICAgIHIxID0gTWF0aC5sb2coTWF0aC5zcXJ0KGIxICogYjEgKyAxKSAtIGIxKTtcbiAgICBTID0gKHIxIC0gcjApIC8gcmhvO1xuICAgIGkgPSBmdW5jdGlvbih0KSB7XG4gICAgICB2YXIgcyA9IHQgKiBTLFxuICAgICAgICAgIGNvc2hyMCA9IGNvc2gocjApLFxuICAgICAgICAgIHUgPSB3MCAvIChyaG8yICogZDEpICogKGNvc2hyMCAqIHRhbmgocmhvICogcyArIHIwKSAtIHNpbmgocjApKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHV4MCArIHUgKiBkeCxcbiAgICAgICAgdXkwICsgdSAqIGR5LFxuICAgICAgICB3MCAqIGNvc2hyMCAvIGNvc2gocmhvICogcyArIHIwKVxuICAgICAgXTtcbiAgICB9O1xuICB9XG5cbiAgaS5kdXJhdGlvbiA9IFMgKiAxMDAwO1xuXG4gIHJldHVybiBpO1xufTtcblxuZnVuY3Rpb24gaHNsJDEoaHVlJCQxKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gZDNDb2xvci5oc2woc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5oc2woZW5kKSkuaCksXG4gICAgICAgIHMgPSBub2dhbW1hKHN0YXJ0LnMsIGVuZC5zKSxcbiAgICAgICAgbCA9IG5vZ2FtbWEoc3RhcnQubCwgZW5kLmwpLFxuICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIHN0YXJ0LmggPSBoKHQpO1xuICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICBzdGFydC5sID0gbCh0KTtcbiAgICAgIHN0YXJ0Lm9wYWNpdHkgPSBvcGFjaXR5KHQpO1xuICAgICAgcmV0dXJuIHN0YXJ0ICsgXCJcIjtcbiAgICB9O1xuICB9XG59XG5cbnZhciBoc2wkMiA9IGhzbCQxKGh1ZSk7XG52YXIgaHNsTG9uZyA9IGhzbCQxKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBsYWIkMShzdGFydCwgZW5kKSB7XG4gIHZhciBsID0gbm9nYW1tYSgoc3RhcnQgPSBkM0NvbG9yLmxhYihzdGFydCkpLmwsIChlbmQgPSBkM0NvbG9yLmxhYihlbmQpKS5sKSxcbiAgICAgIGEgPSBub2dhbW1hKHN0YXJ0LmEsIGVuZC5hKSxcbiAgICAgIGIgPSBub2dhbW1hKHN0YXJ0LmIsIGVuZC5iKSxcbiAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICBzdGFydC5sID0gbCh0KTtcbiAgICBzdGFydC5hID0gYSh0KTtcbiAgICBzdGFydC5iID0gYih0KTtcbiAgICBzdGFydC5vcGFjaXR5ID0gb3BhY2l0eSh0KTtcbiAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBoY2wkMShodWUkJDEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaCA9IGh1ZSQkMSgoc3RhcnQgPSBkM0NvbG9yLmhjbChzdGFydCkpLmgsIChlbmQgPSBkM0NvbG9yLmhjbChlbmQpKS5oKSxcbiAgICAgICAgYyA9IG5vZ2FtbWEoc3RhcnQuYywgZW5kLmMpLFxuICAgICAgICBsID0gbm9nYW1tYShzdGFydC5sLCBlbmQubCksXG4gICAgICAgIG9wYWNpdHkgPSBub2dhbW1hKHN0YXJ0Lm9wYWNpdHksIGVuZC5vcGFjaXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgc3RhcnQuaCA9IGgodCk7XG4gICAgICBzdGFydC5jID0gYyh0KTtcbiAgICAgIHN0YXJ0LmwgPSBsKHQpO1xuICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICByZXR1cm4gc3RhcnQgKyBcIlwiO1xuICAgIH07XG4gIH1cbn1cblxudmFyIGhjbCQyID0gaGNsJDEoaHVlKTtcbnZhciBoY2xMb25nID0gaGNsJDEobm9nYW1tYSk7XG5cbmZ1bmN0aW9uIGN1YmVoZWxpeCQxKGh1ZSQkMSkge1xuICByZXR1cm4gKGZ1bmN0aW9uIGN1YmVoZWxpeEdhbW1hKHkpIHtcbiAgICB5ID0gK3k7XG5cbiAgICBmdW5jdGlvbiBjdWJlaGVsaXgkJDEoc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGggPSBodWUkJDEoKHN0YXJ0ID0gZDNDb2xvci5jdWJlaGVsaXgoc3RhcnQpKS5oLCAoZW5kID0gZDNDb2xvci5jdWJlaGVsaXgoZW5kKSkuaCksXG4gICAgICAgICAgcyA9IG5vZ2FtbWEoc3RhcnQucywgZW5kLnMpLFxuICAgICAgICAgIGwgPSBub2dhbW1hKHN0YXJ0LmwsIGVuZC5sKSxcbiAgICAgICAgICBvcGFjaXR5ID0gbm9nYW1tYShzdGFydC5vcGFjaXR5LCBlbmQub3BhY2l0eSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odCkge1xuICAgICAgICBzdGFydC5oID0gaCh0KTtcbiAgICAgICAgc3RhcnQucyA9IHModCk7XG4gICAgICAgIHN0YXJ0LmwgPSBsKE1hdGgucG93KHQsIHkpKTtcbiAgICAgICAgc3RhcnQub3BhY2l0eSA9IG9wYWNpdHkodCk7XG4gICAgICAgIHJldHVybiBzdGFydCArIFwiXCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGN1YmVoZWxpeCQkMS5nYW1tYSA9IGN1YmVoZWxpeEdhbW1hO1xuXG4gICAgcmV0dXJuIGN1YmVoZWxpeCQkMTtcbiAgfSkoMSk7XG59XG5cbnZhciBjdWJlaGVsaXgkMiA9IGN1YmVoZWxpeCQxKGh1ZSk7XG52YXIgY3ViZWhlbGl4TG9uZyA9IGN1YmVoZWxpeCQxKG5vZ2FtbWEpO1xuXG5mdW5jdGlvbiBwaWVjZXdpc2UoaW50ZXJwb2xhdGUsIHZhbHVlcykge1xuICB2YXIgaSA9IDAsIG4gPSB2YWx1ZXMubGVuZ3RoIC0gMSwgdiA9IHZhbHVlc1swXSwgSSA9IG5ldyBBcnJheShuIDwgMCA/IDAgOiBuKTtcbiAgd2hpbGUgKGkgPCBuKSBJW2ldID0gaW50ZXJwb2xhdGUodiwgdiA9IHZhbHVlc1srK2ldKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgaSA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKj0gbikpKTtcbiAgICByZXR1cm4gSVtpXSh0IC0gaSk7XG4gIH07XG59XG5cbnZhciBxdWFudGl6ZSA9IGZ1bmN0aW9uKGludGVycG9sYXRvciwgbikge1xuICB2YXIgc2FtcGxlcyA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHNhbXBsZXNbaV0gPSBpbnRlcnBvbGF0b3IoaSAvIChuIC0gMSkpO1xuICByZXR1cm4gc2FtcGxlcztcbn07XG5cbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSB2YWx1ZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVBcnJheSA9IGFycmF5O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUJhc2lzID0gYmFzaXMkMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCYXNpc0Nsb3NlZCA9IGJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZURhdGUgPSBkYXRlO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZU51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPYmplY3QgPSBvYmplY3Q7XG5leHBvcnRzLmludGVycG9sYXRlUm91bmQgPSByb3VuZDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVTdHJpbmcgPSBzdHJpbmc7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtQ3NzID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Dc3M7XG5leHBvcnRzLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnID0gaW50ZXJwb2xhdGVUcmFuc2Zvcm1Tdmc7XG5leHBvcnRzLmludGVycG9sYXRlWm9vbSA9IHpvb207XG5leHBvcnRzLmludGVycG9sYXRlUmdiID0gcmdiJDE7XG5leHBvcnRzLmludGVycG9sYXRlUmdiQmFzaXMgPSByZ2JCYXNpcztcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZ2JCYXNpc0Nsb3NlZCA9IHJnYkJhc2lzQ2xvc2VkO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbCA9IGhzbCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhzbExvbmcgPSBoc2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUxhYiA9IGxhYiQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbCA9IGhjbCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUhjbExvbmcgPSBoY2xMb25nO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeCA9IGN1YmVoZWxpeCQyO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcgPSBjdWJlaGVsaXhMb25nO1xuZXhwb3J0cy5waWVjZXdpc2UgPSBwaWVjZXdpc2U7XG5leHBvcnRzLnF1YW50aXplID0gcXVhbnRpemU7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXBhdGgvIFZlcnNpb24gMS4wLjUuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIHBpID0gTWF0aC5QSTtcbnZhciB0YXUgPSAyICogcGk7XG52YXIgZXBzaWxvbiA9IDFlLTY7XG52YXIgdGF1RXBzaWxvbiA9IHRhdSAtIGVwc2lsb247XG5cbmZ1bmN0aW9uIFBhdGgoKSB7XG4gIHRoaXMuX3gwID0gdGhpcy5feTAgPSAvLyBzdGFydCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5feDEgPSB0aGlzLl95MSA9IG51bGw7IC8vIGVuZCBvZiBjdXJyZW50IHN1YnBhdGhcbiAgdGhpcy5fID0gXCJcIjtcbn1cblxuZnVuY3Rpb24gcGF0aCgpIHtcbiAgcmV0dXJuIG5ldyBQYXRoO1xufVxuXG5QYXRoLnByb3RvdHlwZSA9IHBhdGgucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUGF0aCxcbiAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gwID0gdGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MCA9IHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBjbG9zZVBhdGg6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl94MSAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5feDEgPSB0aGlzLl94MCwgdGhpcy5feTEgPSB0aGlzLl95MDtcbiAgICAgIHRoaXMuXyArPSBcIlpcIjtcbiAgICB9XG4gIH0sXG4gIGxpbmVUbzogZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkxcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLl8gKz0gXCJRXCIgKyAoK3gxKSArIFwiLFwiICsgKCt5MSkgKyBcIixcIiArICh0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kxID0gK3kpO1xuICB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuXyArPSBcIkNcIiArICgreDEpICsgXCIsXCIgKyAoK3kxKSArIFwiLFwiICsgKCt4MikgKyBcIixcIiArICgreTIpICsgXCIsXCIgKyAodGhpcy5feDEgPSAreCkgKyBcIixcIiArICh0aGlzLl95MSA9ICt5KTtcbiAgfSxcbiAgYXJjVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCByKSB7XG4gICAgeDEgPSAreDEsIHkxID0gK3kxLCB4MiA9ICt4MiwgeTIgPSAreTIsIHIgPSArcjtcbiAgICB2YXIgeDAgPSB0aGlzLl94MSxcbiAgICAgICAgeTAgPSB0aGlzLl95MSxcbiAgICAgICAgeDIxID0geDIgLSB4MSxcbiAgICAgICAgeTIxID0geTIgLSB5MSxcbiAgICAgICAgeDAxID0geDAgLSB4MSxcbiAgICAgICAgeTAxID0geTAgLSB5MSxcbiAgICAgICAgbDAxXzIgPSB4MDEgKiB4MDEgKyB5MDEgKiB5MDE7XG5cbiAgICAvLyBJcyB0aGUgcmFkaXVzIG5lZ2F0aXZlPyBFcnJvci5cbiAgICBpZiAociA8IDApIHRocm93IG5ldyBFcnJvcihcIm5lZ2F0aXZlIHJhZGl1czogXCIgKyByKTtcblxuICAgIC8vIElzIHRoaXMgcGF0aCBlbXB0eT8gTW92ZSB0byAoeDEseTEpLlxuICAgIGlmICh0aGlzLl94MSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fICs9IFwiTVwiICsgKHRoaXMuX3gxID0geDEpICsgXCIsXCIgKyAodGhpcy5feTEgPSB5MSk7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4MCx5MCk/IERvIG5vdGhpbmcuXG4gICAgZWxzZSBpZiAoIShsMDFfMiA+IGVwc2lsb24pKSB7fVxuXG4gICAgLy8gT3IsIGFyZSAoeDAseTApLCAoeDEseTEpIGFuZCAoeDIseTIpIGNvbGxpbmVhcj9cbiAgICAvLyBFcXVpdmFsZW50bHksIGlzICh4MSx5MSkgY29pbmNpZGVudCB3aXRoICh4Mix5Mik/XG4gICAgLy8gT3IsIGlzIHRoZSByYWRpdXMgemVybz8gTGluZSB0byAoeDEseTEpLlxuICAgIGVsc2UgaWYgKCEoTWF0aC5hYnMoeTAxICogeDIxIC0geTIxICogeDAxKSA+IGVwc2lsb24pIHx8ICFyKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyAodGhpcy5feDEgPSB4MSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkxKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGRyYXcgYW4gYXJjIVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHgyMCA9IHgyIC0geDAsXG4gICAgICAgICAgeTIwID0geTIgLSB5MCxcbiAgICAgICAgICBsMjFfMiA9IHgyMSAqIHgyMSArIHkyMSAqIHkyMSxcbiAgICAgICAgICBsMjBfMiA9IHgyMCAqIHgyMCArIHkyMCAqIHkyMCxcbiAgICAgICAgICBsMjEgPSBNYXRoLnNxcnQobDIxXzIpLFxuICAgICAgICAgIGwwMSA9IE1hdGguc3FydChsMDFfMiksXG4gICAgICAgICAgbCA9IHIgKiBNYXRoLnRhbigocGkgLSBNYXRoLmFjb3MoKGwyMV8yICsgbDAxXzIgLSBsMjBfMikgLyAoMiAqIGwyMSAqIGwwMSkpKSAvIDIpLFxuICAgICAgICAgIHQwMSA9IGwgLyBsMDEsXG4gICAgICAgICAgdDIxID0gbCAvIGwyMTtcblxuICAgICAgLy8gSWYgdGhlIHN0YXJ0IHRhbmdlbnQgaXMgbm90IGNvaW5jaWRlbnQgd2l0aCAoeDAseTApLCBsaW5lIHRvLlxuICAgICAgaWYgKE1hdGguYWJzKHQwMSAtIDEpID4gZXBzaWxvbikge1xuICAgICAgICB0aGlzLl8gKz0gXCJMXCIgKyAoeDEgKyB0MDEgKiB4MDEpICsgXCIsXCIgKyAoeTEgKyB0MDEgKiB5MDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwwLFwiICsgKCsoeTAxICogeDIwID4geDAxICogeTIwKSkgKyBcIixcIiArICh0aGlzLl94MSA9IHgxICsgdDIxICogeDIxKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTEgKyB0MjEgKiB5MjEpO1xuICAgIH1cbiAgfSxcbiAgYXJjOiBmdW5jdGlvbih4LCB5LCByLCBhMCwgYTEsIGNjdykge1xuICAgIHggPSAreCwgeSA9ICt5LCByID0gK3I7XG4gICAgdmFyIGR4ID0gciAqIE1hdGguY29zKGEwKSxcbiAgICAgICAgZHkgPSByICogTWF0aC5zaW4oYTApLFxuICAgICAgICB4MCA9IHggKyBkeCxcbiAgICAgICAgeTAgPSB5ICsgZHksXG4gICAgICAgIGN3ID0gMSBeIGNjdyxcbiAgICAgICAgZGEgPSBjY3cgPyBhMCAtIGExIDogYTEgLSBhMDtcblxuICAgIC8vIElzIHRoZSByYWRpdXMgbmVnYXRpdmU/IEVycm9yLlxuICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IEVycm9yKFwibmVnYXRpdmUgcmFkaXVzOiBcIiArIHIpO1xuXG4gICAgLy8gSXMgdGhpcyBwYXRoIGVtcHR5PyBNb3ZlIHRvICh4MCx5MCkuXG4gICAgaWYgKHRoaXMuX3gxID09PSBudWxsKSB7XG4gICAgICB0aGlzLl8gKz0gXCJNXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgfVxuXG4gICAgLy8gT3IsIGlzICh4MCx5MCkgbm90IGNvaW5jaWRlbnQgd2l0aCB0aGUgcHJldmlvdXMgcG9pbnQ/IExpbmUgdG8gKHgwLHkwKS5cbiAgICBlbHNlIGlmIChNYXRoLmFicyh0aGlzLl94MSAtIHgwKSA+IGVwc2lsb24gfHwgTWF0aC5hYnModGhpcy5feTEgLSB5MCkgPiBlcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJMXCIgKyB4MCArIFwiLFwiICsgeTA7XG4gICAgfVxuXG4gICAgLy8gSXMgdGhpcyBhcmMgZW1wdHk/IFdl4oCZcmUgZG9uZS5cbiAgICBpZiAoIXIpIHJldHVybjtcblxuICAgIC8vIERvZXMgdGhlIGFuZ2xlIGdvIHRoZSB3cm9uZyB3YXk/IEZsaXAgdGhlIGRpcmVjdGlvbi5cbiAgICBpZiAoZGEgPCAwKSBkYSA9IGRhICUgdGF1ICsgdGF1O1xuXG4gICAgLy8gSXMgdGhpcyBhIGNvbXBsZXRlIGNpcmNsZT8gRHJhdyB0d28gYXJjcyB0byBjb21wbGV0ZSB0aGUgY2lyY2xlLlxuICAgIGlmIChkYSA+IHRhdUVwc2lsb24pIHtcbiAgICAgIHRoaXMuXyArPSBcIkFcIiArIHIgKyBcIixcIiArIHIgKyBcIiwwLDEsXCIgKyBjdyArIFwiLFwiICsgKHggLSBkeCkgKyBcIixcIiArICh5IC0gZHkpICsgXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCwxLFwiICsgY3cgKyBcIixcIiArICh0aGlzLl94MSA9IHgwKSArIFwiLFwiICsgKHRoaXMuX3kxID0geTApO1xuICAgIH1cblxuICAgIC8vIElzIHRoaXMgYXJjIG5vbi1lbXB0eT8gRHJhdyBhbiBhcmMhXG4gICAgZWxzZSBpZiAoZGEgPiBlcHNpbG9uKSB7XG4gICAgICB0aGlzLl8gKz0gXCJBXCIgKyByICsgXCIsXCIgKyByICsgXCIsMCxcIiArICgrKGRhID49IHBpKSkgKyBcIixcIiArIGN3ICsgXCIsXCIgKyAodGhpcy5feDEgPSB4ICsgciAqIE1hdGguY29zKGExKSkgKyBcIixcIiArICh0aGlzLl95MSA9IHkgKyByICogTWF0aC5zaW4oYTEpKTtcbiAgICB9XG4gIH0sXG4gIHJlY3Q6IGZ1bmN0aW9uKHgsIHksIHcsIGgpIHtcbiAgICB0aGlzLl8gKz0gXCJNXCIgKyAodGhpcy5feDAgPSB0aGlzLl94MSA9ICt4KSArIFwiLFwiICsgKHRoaXMuX3kwID0gdGhpcy5feTEgPSAreSkgKyBcImhcIiArICgrdykgKyBcInZcIiArICgraCkgKyBcImhcIiArICgtdykgKyBcIlpcIjtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbmV4cG9ydHMucGF0aCA9IHBhdGg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXBvbHlnb24vIFZlcnNpb24gMS4wLjMuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGFyZWEgPSBmdW5jdGlvbihwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICBhLFxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgYXJlYSA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICBhID0gYjtcbiAgICBiID0gcG9seWdvbltpXTtcbiAgICBhcmVhICs9IGFbMV0gKiBiWzBdIC0gYVswXSAqIGJbMV07XG4gIH1cblxuICByZXR1cm4gYXJlYSAvIDI7XG59O1xuXG52YXIgY2VudHJvaWQgPSBmdW5jdGlvbihwb2x5Z29uKSB7XG4gIHZhciBpID0gLTEsXG4gICAgICBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICB4ID0gMCxcbiAgICAgIHkgPSAwLFxuICAgICAgYSxcbiAgICAgIGIgPSBwb2x5Z29uW24gLSAxXSxcbiAgICAgIGMsXG4gICAgICBrID0gMDtcblxuICB3aGlsZSAoKytpIDwgbikge1xuICAgIGEgPSBiO1xuICAgIGIgPSBwb2x5Z29uW2ldO1xuICAgIGsgKz0gYyA9IGFbMF0gKiBiWzFdIC0gYlswXSAqIGFbMV07XG4gICAgeCArPSAoYVswXSArIGJbMF0pICogYztcbiAgICB5ICs9IChhWzFdICsgYlsxXSkgKiBjO1xuICB9XG5cbiAgcmV0dXJuIGsgKj0gMywgW3ggLyBrLCB5IC8ga107XG59O1xuXG4vLyBSZXR1cm5zIHRoZSAyRCBjcm9zcyBwcm9kdWN0IG9mIEFCIGFuZCBBQyB2ZWN0b3JzLCBpLmUuLCB0aGUgei1jb21wb25lbnQgb2Zcbi8vIHRoZSAzRCBjcm9zcyBwcm9kdWN0IGluIGEgcXVhZHJhbnQgSSBDYXJ0ZXNpYW4gY29vcmRpbmF0ZSBzeXN0ZW0gKCt4IGlzXG4vLyByaWdodCwgK3kgaXMgdXApLiBSZXR1cm5zIGEgcG9zaXRpdmUgdmFsdWUgaWYgQUJDIGlzIGNvdW50ZXItY2xvY2t3aXNlLFxuLy8gbmVnYXRpdmUgaWYgY2xvY2t3aXNlLCBhbmQgemVybyBpZiB0aGUgcG9pbnRzIGFyZSBjb2xsaW5lYXIuXG52YXIgY3Jvc3MgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIHJldHVybiAoYlswXSAtIGFbMF0pICogKGNbMV0gLSBhWzFdKSAtIChiWzFdIC0gYVsxXSkgKiAoY1swXSAtIGFbMF0pO1xufTtcblxuZnVuY3Rpb24gbGV4aWNvZ3JhcGhpY09yZGVyKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdIHx8IGFbMV0gLSBiWzFdO1xufVxuXG4vLyBDb21wdXRlcyB0aGUgdXBwZXIgY29udmV4IGh1bGwgcGVyIHRoZSBtb25vdG9uZSBjaGFpbiBhbGdvcml0aG0uXG4vLyBBc3N1bWVzIHBvaW50cy5sZW5ndGggPj0gMywgaXMgc29ydGVkIGJ5IHgsIHVuaXF1ZSBpbiB5LlxuLy8gUmV0dXJucyBhbiBhcnJheSBvZiBpbmRpY2VzIGludG8gcG9pbnRzIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG5mdW5jdGlvbiBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhwb2ludHMpIHtcbiAgdmFyIG4gPSBwb2ludHMubGVuZ3RoLFxuICAgICAgaW5kZXhlcyA9IFswLCAxXSxcbiAgICAgIHNpemUgPSAyO1xuXG4gIGZvciAodmFyIGkgPSAyOyBpIDwgbjsgKytpKSB7XG4gICAgd2hpbGUgKHNpemUgPiAxICYmIGNyb3NzKHBvaW50c1tpbmRleGVzW3NpemUgLSAyXV0sIHBvaW50c1tpbmRleGVzW3NpemUgLSAxXV0sIHBvaW50c1tpXSkgPD0gMCkgLS1zaXplO1xuICAgIGluZGV4ZXNbc2l6ZSsrXSA9IGk7XG4gIH1cblxuICByZXR1cm4gaW5kZXhlcy5zbGljZSgwLCBzaXplKTsgLy8gcmVtb3ZlIHBvcHBlZCBwb2ludHNcbn1cblxudmFyIGh1bGwgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgaWYgKChuID0gcG9pbnRzLmxlbmd0aCkgPCAzKSByZXR1cm4gbnVsbDtcblxuICB2YXIgaSxcbiAgICAgIG4sXG4gICAgICBzb3J0ZWRQb2ludHMgPSBuZXcgQXJyYXkobiksXG4gICAgICBmbGlwcGVkUG9pbnRzID0gbmV3IEFycmF5KG4pO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHNvcnRlZFBvaW50c1tpXSA9IFsrcG9pbnRzW2ldWzBdLCArcG9pbnRzW2ldWzFdLCBpXTtcbiAgc29ydGVkUG9pbnRzLnNvcnQobGV4aWNvZ3JhcGhpY09yZGVyKTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgZmxpcHBlZFBvaW50c1tpXSA9IFtzb3J0ZWRQb2ludHNbaV1bMF0sIC1zb3J0ZWRQb2ludHNbaV1bMV1dO1xuXG4gIHZhciB1cHBlckluZGV4ZXMgPSBjb21wdXRlVXBwZXJIdWxsSW5kZXhlcyhzb3J0ZWRQb2ludHMpLFxuICAgICAgbG93ZXJJbmRleGVzID0gY29tcHV0ZVVwcGVySHVsbEluZGV4ZXMoZmxpcHBlZFBvaW50cyk7XG5cbiAgLy8gQ29uc3RydWN0IHRoZSBodWxsIHBvbHlnb24sIHJlbW92aW5nIHBvc3NpYmxlIGR1cGxpY2F0ZSBlbmRwb2ludHMuXG4gIHZhciBza2lwTGVmdCA9IGxvd2VySW5kZXhlc1swXSA9PT0gdXBwZXJJbmRleGVzWzBdLFxuICAgICAgc2tpcFJpZ2h0ID0gbG93ZXJJbmRleGVzW2xvd2VySW5kZXhlcy5sZW5ndGggLSAxXSA9PT0gdXBwZXJJbmRleGVzW3VwcGVySW5kZXhlcy5sZW5ndGggLSAxXSxcbiAgICAgIGh1bGwgPSBbXTtcblxuICAvLyBBZGQgdXBwZXIgaHVsbCBpbiByaWdodC10by1sIG9yZGVyLlxuICAvLyBUaGVuIGFkZCBsb3dlciBodWxsIGluIGxlZnQtdG8tcmlnaHQgb3JkZXIuXG4gIGZvciAoaSA9IHVwcGVySW5kZXhlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgaHVsbC5wdXNoKHBvaW50c1tzb3J0ZWRQb2ludHNbdXBwZXJJbmRleGVzW2ldXVsyXV0pO1xuICBmb3IgKGkgPSArc2tpcExlZnQ7IGkgPCBsb3dlckluZGV4ZXMubGVuZ3RoIC0gc2tpcFJpZ2h0OyArK2kpIGh1bGwucHVzaChwb2ludHNbc29ydGVkUG9pbnRzW2xvd2VySW5kZXhlc1tpXV1bMl1dKTtcblxuICByZXR1cm4gaHVsbDtcbn07XG5cbnZhciBjb250YWlucyA9IGZ1bmN0aW9uKHBvbHlnb24sIHBvaW50KSB7XG4gIHZhciBuID0gcG9seWdvbi5sZW5ndGgsXG4gICAgICBwID0gcG9seWdvbltuIC0gMV0sXG4gICAgICB4ID0gcG9pbnRbMF0sIHkgPSBwb2ludFsxXSxcbiAgICAgIHgwID0gcFswXSwgeTAgPSBwWzFdLFxuICAgICAgeDEsIHkxLFxuICAgICAgaW5zaWRlID0gZmFsc2U7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBwID0gcG9seWdvbltpXSwgeDEgPSBwWzBdLCB5MSA9IHBbMV07XG4gICAgaWYgKCgoeTEgPiB5KSAhPT0gKHkwID4geSkpICYmICh4IDwgKHgwIC0geDEpICogKHkgLSB5MSkgLyAoeTAgLSB5MSkgKyB4MSkpIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgeDAgPSB4MSwgeTAgPSB5MTtcbiAgfVxuXG4gIHJldHVybiBpbnNpZGU7XG59O1xuXG52YXIgbGVuZ3RoID0gZnVuY3Rpb24ocG9seWdvbikge1xuICB2YXIgaSA9IC0xLFxuICAgICAgbiA9IHBvbHlnb24ubGVuZ3RoLFxuICAgICAgYiA9IHBvbHlnb25bbiAtIDFdLFxuICAgICAgeGEsXG4gICAgICB5YSxcbiAgICAgIHhiID0gYlswXSxcbiAgICAgIHliID0gYlsxXSxcbiAgICAgIHBlcmltZXRlciA9IDA7XG5cbiAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICB4YSA9IHhiO1xuICAgIHlhID0geWI7XG4gICAgYiA9IHBvbHlnb25baV07XG4gICAgeGIgPSBiWzBdO1xuICAgIHliID0gYlsxXTtcbiAgICB4YSAtPSB4YjtcbiAgICB5YSAtPSB5YjtcbiAgICBwZXJpbWV0ZXIgKz0gTWF0aC5zcXJ0KHhhICogeGEgKyB5YSAqIHlhKTtcbiAgfVxuXG4gIHJldHVybiBwZXJpbWV0ZXI7XG59O1xuXG5leHBvcnRzLnBvbHlnb25BcmVhID0gYXJlYTtcbmV4cG9ydHMucG9seWdvbkNlbnRyb2lkID0gY2VudHJvaWQ7XG5leHBvcnRzLnBvbHlnb25IdWxsID0gaHVsbDtcbmV4cG9ydHMucG9seWdvbkNvbnRhaW5zID0gY29udGFpbnM7XG5leHBvcnRzLnBvbHlnb25MZW5ndGggPSBsZW5ndGg7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXF1YWR0cmVlLyBWZXJzaW9uIDEuMC4zLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB0cmVlX2FkZCA9IGZ1bmN0aW9uKGQpIHtcbiAgdmFyIHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCk7XG4gIHJldHVybiBhZGQodGhpcy5jb3Zlcih4LCB5KSwgeCwgeSwgZCk7XG59O1xuXG5mdW5jdGlvbiBhZGQodHJlZSwgeCwgeSwgZCkge1xuICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHJldHVybiB0cmVlOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgcGFyZW50LFxuICAgICAgbm9kZSA9IHRyZWUuX3Jvb3QsXG4gICAgICBsZWFmID0ge2RhdGE6IGR9LFxuICAgICAgeDAgPSB0cmVlLl94MCxcbiAgICAgIHkwID0gdHJlZS5feTAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeTEgPSB0cmVlLl95MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB4cCxcbiAgICAgIHlwLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIEZpbmQgdGhlIGV4aXN0aW5nIGxlYWYgZm9yIHRoZSBuZXcgcG9pbnQsIG9yIGFkZCBpdC5cbiAgd2hpbGUgKG5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gICAgaWYgKHBhcmVudCA9IG5vZGUsICEobm9kZSA9IG5vZGVbaSA9IGJvdHRvbSA8PCAxIHwgcmlnaHRdKSkgcmV0dXJuIHBhcmVudFtpXSA9IGxlYWYsIHRyZWU7XG4gIH1cblxuICAvLyBJcyB0aGUgbmV3IHBvaW50IGlzIGV4YWN0bHkgY29pbmNpZGVudCB3aXRoIHRoZSBleGlzdGluZyBwb2ludD9cbiAgeHAgPSArdHJlZS5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHlwID0gK3RyZWUuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDQpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg0KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgfSB3aGlsZSAoKGkgPSBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5mdW5jdGlvbiBhZGRBbGwoZGF0YSkge1xuICB2YXIgZCwgaSwgbiA9IGRhdGEubGVuZ3RoLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4eiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHl6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB4MSA9IC1JbmZpbml0eSxcbiAgICAgIHkxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaWYgKGlzTmFOKHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQgPSBkYXRhW2ldKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSBjb250aW51ZTtcbiAgICB4eltpXSA9IHg7XG4gICAgeXpbaV0gPSB5O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgfVxuXG4gIC8vIElmIHRoZXJlIHdlcmUgbm8gKHZhbGlkKSBwb2ludHMsIGluaGVyaXQgdGhlIGV4aXN0aW5nIGV4dGVudC5cbiAgaWYgKHgxIDwgeDApIHgwID0gdGhpcy5feDAsIHgxID0gdGhpcy5feDE7XG4gIGlmICh5MSA8IHkwKSB5MCA9IHRoaXMuX3kwLCB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHRyZWVfY292ZXIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIGlmIChpc05hTih4ID0gK3gpIHx8IGlzTmFOKHkgPSAreSkpIHJldHVybiB0aGlzOyAvLyBpZ25vcmUgaW52YWxpZCBwb2ludHNcblxuICB2YXIgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MTtcblxuICAvLyBJZiB0aGUgcXVhZHRyZWUgaGFzIG5vIGV4dGVudCwgaW5pdGlhbGl6ZSB0aGVtLlxuICAvLyBJbnRlZ2VyIGV4dGVudCBhcmUgbmVjZXNzYXJ5IHNvIHRoYXQgaWYgd2UgbGF0ZXIgZG91YmxlIHRoZSBleHRlbnQsXG4gIC8vIHRoZSBleGlzdGluZyBxdWFkcmFudCBib3VuZGFyaWVzIGRvbuKAmXQgY2hhbmdlIGR1ZSB0byBmbG9hdGluZyBwb2ludCBlcnJvciFcbiAgaWYgKGlzTmFOKHgwKSkge1xuICAgIHgxID0gKHgwID0gTWF0aC5mbG9vcih4KSkgKyAxO1xuICAgIHkxID0gKHkwID0gTWF0aC5mbG9vcih5KSkgKyAxO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkb3VibGUgcmVwZWF0ZWRseSB0byBjb3Zlci5cbiAgZWxzZSBpZiAoeDAgPiB4IHx8IHggPiB4MSB8fCB5MCA+IHkgfHwgeSA+IHkxKSB7XG4gICAgdmFyIHogPSB4MSAtIHgwLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgc3dpdGNoIChpID0gKHkgPCAoeTAgKyB5MSkgLyAyKSA8PCAxIHwgKHggPCAoeDAgKyB4MSkgLyAyKSkge1xuICAgICAgY2FzZSAwOiB7XG4gICAgICAgIGRvIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDEgPSB4MCArIHosIHkxID0geTAgKyB6LCB4ID4geDEgfHwgeSA+IHkxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgZG8gcGFyZW50ID0gbmV3IEFycmF5KDQpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50O1xuICAgICAgICB3aGlsZSAoeiAqPSAyLCB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHosIHgwID4geCB8fCB5ID4geTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICBkbyBwYXJlbnQgPSBuZXcgQXJyYXkoNCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIHdoaWxlICh6ICo9IDIsIHgxID0geDAgKyB6LCB5MCA9IHkxIC0geiwgeCA+IHgxIHx8IHkwID4geSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIGRvIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgd2hpbGUgKHogKj0gMiwgeDAgPSB4MSAtIHosIHkwID0geTEgLSB6LCB4MCA+IHggfHwgeTAgPiB5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3Jvb3QgJiYgdGhpcy5fcm9vdC5sZW5ndGgpIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgLy8gSWYgdGhlIHF1YWR0cmVlIGNvdmVycyB0aGUgcG9pbnQgYWxyZWFkeSwganVzdCByZXR1cm4uXG4gIGVsc2UgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5feDAgPSB4MDtcbiAgdGhpcy5feTAgPSB5MDtcbiAgdGhpcy5feDEgPSB4MTtcbiAgdGhpcy5feTEgPSB5MTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG52YXIgdHJlZV9kYXRhID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufTtcblxudmFyIHRyZWVfZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSkuY292ZXIoK19bMV1bMF0sICtfWzFdWzFdKVxuICAgICAgOiBpc05hTih0aGlzLl94MCkgPyB1bmRlZmluZWQgOiBbW3RoaXMuX3gwLCB0aGlzLl95MF0sIFt0aGlzLl94MSwgdGhpcy5feTFdXTtcbn07XG5cbnZhciBRdWFkID0gZnVuY3Rpb24obm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufTtcblxudmFyIHRyZWVfZmluZCA9IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufTtcblxudmFyIHRyZWVfcmVtb3ZlID0gZnVuY3Rpb24oZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB4MSA9IHRoaXMuX3gxLFxuICAgICAgeTEgPSB0aGlzLl95MSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAzXSB8fCBwYXJlbnRbKGkgKyAyKSAmIDNdIHx8IHBhcmVudFsoaSArIDMpICYgM10pIHJldGFpbmVyID0gcGFyZW50LCBqID0gaTtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHBvaW50IHRvIHJlbW92ZS5cbiAgd2hpbGUgKG5vZGUuZGF0YSAhPT0gZCkgaWYgKCEocHJldmlvdXMgPSBub2RlLCBub2RlID0gbm9kZS5uZXh0KSkgcmV0dXJuIHRoaXM7XG4gIGlmIChuZXh0ID0gbm9kZS5uZXh0KSBkZWxldGUgbm9kZS5uZXh0O1xuXG4gIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjb2luY2lkZW50IHBvaW50cywgcmVtb3ZlIGp1c3QgdGhlIHBvaW50LlxuICBpZiAocHJldmlvdXMpIHJldHVybiAobmV4dCA/IHByZXZpb3VzLm5leHQgPSBuZXh0IDogZGVsZXRlIHByZXZpb3VzLm5leHQpLCB0aGlzO1xuXG4gIC8vIElmIHRoaXMgaXMgdGhlIHJvb3QgcG9pbnQsIHJlbW92ZSBpdC5cbiAgaWYgKCFwYXJlbnQpIHJldHVybiB0aGlzLl9yb290ID0gbmV4dCwgdGhpcztcblxuICAvLyBSZW1vdmUgdGhpcyBsZWFmLlxuICBuZXh0ID8gcGFyZW50W2ldID0gbmV4dCA6IGRlbGV0ZSBwYXJlbnRbaV07XG5cbiAgLy8gSWYgdGhlIHBhcmVudCBub3cgY29udGFpbnMgZXhhY3RseSBvbmUgbGVhZiwgY29sbGFwc2Ugc3VwZXJmbHVvdXMgcGFyZW50cy5cbiAgaWYgKChub2RlID0gcGFyZW50WzBdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzNdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFszXSB8fCBwYXJlbnRbMl0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFswXSlcbiAgICAgICYmICFub2RlLmxlbmd0aCkge1xuICAgIGlmIChyZXRhaW5lcikgcmV0YWluZXJbal0gPSBub2RlO1xuICAgIGVsc2UgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZUFsbChkYXRhKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gZGF0YS5sZW5ndGg7IGkgPCBuOyArK2kpIHRoaXMucmVtb3ZlKGRhdGFbaV0pO1xuICByZXR1cm4gdGhpcztcbn1cblxudmFyIHRyZWVfcm9vdCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fcm9vdDtcbn07XG5cbnZhciB0cmVlX3NpemUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59O1xuXG52YXIgdHJlZV92aXNpdCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgeDEsIHkxO1xuICBpZiAobm9kZSkgcXVhZHMucHVzaChuZXcgUXVhZChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgaWYgKCFjYWxsYmFjayhub2RlID0gcS5ub2RlLCB4MCA9IHEueDAsIHkwID0gcS55MCwgeDEgPSBxLngxLCB5MSA9IHEueTEpICYmIG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5MCwgeDEsIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnZhciB0cmVlX3Zpc2l0QWZ0ZXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgcXVhZHMucHVzaChuZXcgUXVhZCh0aGlzLl9yb290LCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3gxLCB0aGlzLl95MSkpO1xuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeTAgPSBxLnkwLCB4MSA9IHEueDEsIHkxID0gcS55MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4MCwgeTAsIHhtLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHkwLCB4MSwgeW0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzNdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeW0sIHgxLCB5MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLngxLCBxLnkxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbnZhciB0cmVlX3ggPSBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59O1xuXG5mdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG52YXIgdHJlZV95ID0gZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufTtcblxuZnVuY3Rpb24gcXVhZHRyZWUobm9kZXMsIHgsIHkpIHtcbiAgdmFyIHRyZWUgPSBuZXcgUXVhZHRyZWUoeCA9PSBudWxsID8gZGVmYXVsdFggOiB4LCB5ID09IG51bGwgPyBkZWZhdWx0WSA6IHksIE5hTiwgTmFOLCBOYU4sIE5hTik7XG4gIHJldHVybiBub2RlcyA9PSBudWxsID8gdHJlZSA6IHRyZWUuYWRkQWxsKG5vZGVzKTtcbn1cblxuZnVuY3Rpb24gUXVhZHRyZWUoeCwgeSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5feCA9IHg7XG4gIHRoaXMuX3kgPSB5O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBxdWFkdHJlZS5wcm90b3R5cGUgPSBRdWFkdHJlZS5wcm90b3R5cGU7XG5cbnRyZWVQcm90by5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb3B5ID0gbmV3IFF1YWR0cmVlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgbm9kZXMsXG4gICAgICBjaGlsZDtcblxuICBpZiAoIW5vZGUpIHJldHVybiBjb3B5O1xuXG4gIGlmICghbm9kZS5sZW5ndGgpIHJldHVybiBjb3B5Ll9yb290ID0gbGVhZl9jb3B5KG5vZGUpLCBjb3B5O1xuXG4gIG5vZGVzID0gW3tzb3VyY2U6IG5vZGUsIHRhcmdldDogY29weS5fcm9vdCA9IG5ldyBBcnJheSg0KX1dO1xuICB3aGlsZSAobm9kZSA9IG5vZGVzLnBvcCgpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyArK2kpIHtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGUuc291cmNlW2ldKSB7XG4gICAgICAgIGlmIChjaGlsZC5sZW5ndGgpIG5vZGVzLnB1c2goe3NvdXJjZTogY2hpbGQsIHRhcmdldDogbm9kZS50YXJnZXRbaV0gPSBuZXcgQXJyYXkoNCl9KTtcbiAgICAgICAgZWxzZSBub2RlLnRhcmdldFtpXSA9IGxlYWZfY29weShjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59O1xuXG50cmVlUHJvdG8uYWRkID0gdHJlZV9hZGQ7XG50cmVlUHJvdG8uYWRkQWxsID0gYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG5cbmV4cG9ydHMucXVhZHRyZWUgPSBxdWFkdHJlZTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtcmFuZG9tLyBWZXJzaW9uIDEuMS4wLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBkZWZhdWx0U291cmNlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpO1xufTtcblxudmFyIHVuaWZvcm0gPSAoKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbVVuaWZvcm0oc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbVVuaWZvcm0obWluLCBtYXgpIHtcbiAgICBtaW4gPSBtaW4gPT0gbnVsbCA/IDAgOiArbWluO1xuICAgIG1heCA9IG1heCA9PSBudWxsID8gMSA6ICttYXg7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIG1heCA9IG1pbiwgbWluID0gMDtcbiAgICBlbHNlIG1heCAtPSBtaW47XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHNvdXJjZSgpICogbWF4ICsgbWluO1xuICAgIH07XG4gIH1cblxuICByYW5kb21Vbmlmb3JtLnNvdXJjZSA9IHNvdXJjZVJhbmRvbVVuaWZvcm07XG5cbiAgcmV0dXJuIHJhbmRvbVVuaWZvcm07XG59KSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBub3JtYWwgPSAoKGZ1bmN0aW9uIHNvdXJjZVJhbmRvbU5vcm1hbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tTm9ybWFsKG11LCBzaWdtYSkge1xuICAgIHZhciB4LCByO1xuICAgIG11ID0gbXUgPT0gbnVsbCA/IDAgOiArbXU7XG4gICAgc2lnbWEgPSBzaWdtYSA9PSBudWxsID8gMSA6ICtzaWdtYTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeTtcblxuICAgICAgLy8gSWYgYXZhaWxhYmxlLCB1c2UgdGhlIHNlY29uZCBwcmV2aW91c2x5LWdlbmVyYXRlZCB1bmlmb3JtIHJhbmRvbS5cbiAgICAgIGlmICh4ICE9IG51bGwpIHkgPSB4LCB4ID0gbnVsbDtcblxuICAgICAgLy8gT3RoZXJ3aXNlLCBnZW5lcmF0ZSBhIG5ldyB4IGFuZCB5LlxuICAgICAgZWxzZSBkbyB7XG4gICAgICAgIHggPSBzb3VyY2UoKSAqIDIgLSAxO1xuICAgICAgICB5ID0gc291cmNlKCkgKiAyIC0gMTtcbiAgICAgICAgciA9IHggKiB4ICsgeSAqIHk7XG4gICAgICB9IHdoaWxlICghciB8fCByID4gMSk7XG5cbiAgICAgIHJldHVybiBtdSArIHNpZ21hICogeSAqIE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHIpIC8gcik7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbU5vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Ob3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbU5vcm1hbDtcbn0pKShkZWZhdWx0U291cmNlKTtcblxudmFyIGxvZ05vcm1hbCA9ICgoZnVuY3Rpb24gc291cmNlUmFuZG9tTG9nTm9ybWFsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21Mb2dOb3JtYWwoKSB7XG4gICAgdmFyIHJhbmRvbU5vcm1hbCA9IG5vcm1hbC5zb3VyY2Uoc291cmNlKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLmV4cChyYW5kb21Ob3JtYWwoKSk7XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUxvZ05vcm1hbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21Mb2dOb3JtYWw7XG5cbiAgcmV0dXJuIHJhbmRvbUxvZ05vcm1hbDtcbn0pKShkZWZhdWx0U291cmNlKTtcblxudmFyIGlyd2luSGFsbCA9ICgoZnVuY3Rpb24gc291cmNlUmFuZG9tSXJ3aW5IYWxsKHNvdXJjZSkge1xuICBmdW5jdGlvbiByYW5kb21JcndpbkhhbGwobikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIHN1bSA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSBzdW0gKz0gc291cmNlKCk7XG4gICAgICByZXR1cm4gc3VtO1xuICAgIH07XG4gIH1cblxuICByYW5kb21JcndpbkhhbGwuc291cmNlID0gc291cmNlUmFuZG9tSXJ3aW5IYWxsO1xuXG4gIHJldHVybiByYW5kb21JcndpbkhhbGw7XG59KSkoZGVmYXVsdFNvdXJjZSk7XG5cbnZhciBiYXRlcyA9ICgoZnVuY3Rpb24gc291cmNlUmFuZG9tQmF0ZXMoc291cmNlKSB7XG4gIGZ1bmN0aW9uIHJhbmRvbUJhdGVzKG4pIHtcbiAgICB2YXIgcmFuZG9tSXJ3aW5IYWxsID0gaXJ3aW5IYWxsLnNvdXJjZShzb3VyY2UpKG4pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb21JcndpbkhhbGwoKSAvIG47XG4gICAgfTtcbiAgfVxuXG4gIHJhbmRvbUJhdGVzLnNvdXJjZSA9IHNvdXJjZVJhbmRvbUJhdGVzO1xuXG4gIHJldHVybiByYW5kb21CYXRlcztcbn0pKShkZWZhdWx0U291cmNlKTtcblxudmFyIGV4cG9uZW50aWFsID0gKChmdW5jdGlvbiBzb3VyY2VSYW5kb21FeHBvbmVudGlhbChzb3VyY2UpIHtcbiAgZnVuY3Rpb24gcmFuZG9tRXhwb25lbnRpYWwobGFtYmRhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIC1NYXRoLmxvZygxIC0gc291cmNlKCkpIC8gbGFtYmRhO1xuICAgIH07XG4gIH1cblxuICByYW5kb21FeHBvbmVudGlhbC5zb3VyY2UgPSBzb3VyY2VSYW5kb21FeHBvbmVudGlhbDtcblxuICByZXR1cm4gcmFuZG9tRXhwb25lbnRpYWw7XG59KSkoZGVmYXVsdFNvdXJjZSk7XG5cbmV4cG9ydHMucmFuZG9tVW5pZm9ybSA9IHVuaWZvcm07XG5leHBvcnRzLnJhbmRvbU5vcm1hbCA9IG5vcm1hbDtcbmV4cG9ydHMucmFuZG9tTG9nTm9ybWFsID0gbG9nTm9ybWFsO1xuZXhwb3J0cy5yYW5kb21CYXRlcyA9IGJhdGVzO1xuZXhwb3J0cy5yYW5kb21JcndpbkhhbGwgPSBpcndpbkhhbGw7XG5leHBvcnRzLnJhbmRvbUV4cG9uZW50aWFsID0gZXhwb25lbnRpYWw7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNjYWxlLWNocm9tYXRpYy8gVmVyc2lvbiAxLjMuMC4gQ29weXJpZ2h0IDIwMTggTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1jb2xvcicpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtY29sb3InXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM0ludGVycG9sYXRlLGQzQ29sb3IpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb2xvcnMoc3BlY2lmaWVyKSB7XG4gIHZhciBuID0gc3BlY2lmaWVyLmxlbmd0aCAvIDYgfCAwLCBjb2xvcnMgPSBuZXcgQXJyYXkobiksIGkgPSAwO1xuICB3aGlsZSAoaSA8IG4pIGNvbG9yc1tpXSA9IFwiI1wiICsgc3BlY2lmaWVyLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcbiAgcmV0dXJuIGNvbG9ycztcbn1cblxudmFyIGNhdGVnb3J5MTAgPSBjb2xvcnMoXCIxZjc3YjRmZjdmMGUyY2EwMmNkNjI3Mjg5NDY3YmQ4YzU2NGJlMzc3YzI3ZjdmN2ZiY2JkMjIxN2JlY2ZcIik7XG5cbnZhciBBY2NlbnQgPSBjb2xvcnMoXCI3ZmM5N2ZiZWFlZDRmZGMwODZmZmZmOTkzODZjYjBmMDAyN2ZiZjViMTc2NjY2NjZcIik7XG5cbnZhciBEYXJrMiA9IGNvbG9ycyhcIjFiOWU3N2Q5NWYwMjc1NzBiM2U3Mjk4YTY2YTYxZWU2YWIwMmE2NzYxZDY2NjY2NlwiKTtcblxudmFyIFBhaXJlZCA9IGNvbG9ycyhcImE2Y2VlMzFmNzhiNGIyZGY4YTMzYTAyY2ZiOWE5OWUzMWExY2ZkYmY2ZmZmN2YwMGNhYjJkNjZhM2Q5YWZmZmY5OWIxNTkyOFwiKTtcblxudmFyIFBhc3RlbDEgPSBjb2xvcnMoXCJmYmI0YWViM2NkZTNjY2ViYzVkZWNiZTRmZWQ5YTZmZmZmY2NlNWQ4YmRmZGRhZWNmMmYyZjJcIik7XG5cbnZhciBQYXN0ZWwyID0gY29sb3JzKFwiYjNlMmNkZmRjZGFjY2JkNWU4ZjRjYWU0ZTZmNWM5ZmZmMmFlZjFlMmNjY2NjY2NjXCIpO1xuXG52YXIgU2V0MSA9IGNvbG9ycyhcImU0MWExYzM3N2ViODRkYWY0YTk4NGVhM2ZmN2YwMGZmZmYzM2E2NTYyOGY3ODFiZjk5OTk5OVwiKTtcblxudmFyIFNldDIgPSBjb2xvcnMoXCI2NmMyYTVmYzhkNjI4ZGEwY2JlNzhhYzNhNmQ4NTRmZmQ5MmZlNWM0OTRiM2IzYjNcIik7XG5cbnZhciBTZXQzID0gY29sb3JzKFwiOGRkM2M3ZmZmZmIzYmViYWRhZmI4MDcyODBiMWQzZmRiNDYyYjNkZTY5ZmNjZGU1ZDlkOWQ5YmM4MGJkY2NlYmM1ZmZlZDZmXCIpO1xuXG5mdW5jdGlvbiByYW1wKHNjaGVtZSkge1xuICByZXR1cm4gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVJnYkJhc2lzKHNjaGVtZVtzY2hlbWUubGVuZ3RoIC0gMV0pO1xufVxuXG52YXIgc2NoZW1lID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJkOGIzNjVmNWY1ZjU1YWI0YWNcIixcbiAgXCJhNjYxMWFkZmMyN2Q4MGNkYzEwMTg1NzFcIixcbiAgXCJhNjYxMWFkZmMyN2RmNWY1ZjU4MGNkYzEwMTg1NzFcIixcbiAgXCI4YzUxMGFkOGIzNjVmNmU4YzNjN2VhZTU1YWI0YWMwMTY2NWVcIixcbiAgXCI4YzUxMGFkOGIzNjVmNmU4YzNmNWY1ZjVjN2VhZTU1YWI0YWMwMTY2NWVcIixcbiAgXCI4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWVcIixcbiAgXCI4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNmNWY1ZjVjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWVcIixcbiAgXCI1NDMwMDU4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWUwMDNjMzBcIixcbiAgXCI1NDMwMDU4YzUxMGFiZjgxMmRkZmMyN2RmNmU4YzNmNWY1ZjVjN2VhZTU4MGNkYzEzNTk3OGYwMTY2NWUwMDNjMzBcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIEJyQkcgPSByYW1wKHNjaGVtZSk7XG5cbnZhciBzY2hlbWUkMSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiYWY4ZGMzZjdmN2Y3N2ZiZjdiXCIsXG4gIFwiN2IzMjk0YzJhNWNmYTZkYmEwMDA4ODM3XCIsXG4gIFwiN2IzMjk0YzJhNWNmZjdmN2Y3YTZkYmEwMDA4ODM3XCIsXG4gIFwiNzYyYTgzYWY4ZGMzZTdkNGU4ZDlmMGQzN2ZiZjdiMWI3ODM3XCIsXG4gIFwiNzYyYTgzYWY4ZGMzZTdkNGU4ZjdmN2Y3ZDlmMGQzN2ZiZjdiMWI3ODM3XCIsXG4gIFwiNzYyYTgzOTk3MGFiYzJhNWNmZTdkNGU4ZDlmMGQzYTZkYmEwNWFhZTYxMWI3ODM3XCIsXG4gIFwiNzYyYTgzOTk3MGFiYzJhNWNmZTdkNGU4ZjdmN2Y3ZDlmMGQzYTZkYmEwNWFhZTYxMWI3ODM3XCIsXG4gIFwiNDAwMDRiNzYyYTgzOTk3MGFiYzJhNWNmZTdkNGU4ZDlmMGQzYTZkYmEwNWFhZTYxMWI3ODM3MDA0NDFiXCIsXG4gIFwiNDAwMDRiNzYyYTgzOTk3MGFiYzJhNWNmZTdkNGU4ZjdmN2Y3ZDlmMGQzYTZkYmEwNWFhZTYxMWI3ODM3MDA0NDFiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQUkduID0gcmFtcChzY2hlbWUkMSk7XG5cbnZhciBzY2hlbWUkMiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTlhM2M5ZjdmN2Y3YTFkNzZhXCIsXG4gIFwiZDAxYzhiZjFiNmRhYjhlMTg2NGRhYzI2XCIsXG4gIFwiZDAxYzhiZjFiNmRhZjdmN2Y3YjhlMTg2NGRhYzI2XCIsXG4gIFwiYzUxYjdkZTlhM2M5ZmRlMGVmZTZmNWQwYTFkNzZhNGQ5MjIxXCIsXG4gIFwiYzUxYjdkZTlhM2M5ZmRlMGVmZjdmN2Y3ZTZmNWQwYTFkNzZhNGQ5MjIxXCIsXG4gIFwiYzUxYjdkZGU3N2FlZjFiNmRhZmRlMGVmZTZmNWQwYjhlMTg2N2ZiYzQxNGQ5MjIxXCIsXG4gIFwiYzUxYjdkZGU3N2FlZjFiNmRhZmRlMGVmZjdmN2Y3ZTZmNWQwYjhlMTg2N2ZiYzQxNGQ5MjIxXCIsXG4gIFwiOGUwMTUyYzUxYjdkZGU3N2FlZjFiNmRhZmRlMGVmZTZmNWQwYjhlMTg2N2ZiYzQxNGQ5MjIxMjc2NDE5XCIsXG4gIFwiOGUwMTUyYzUxYjdkZGU3N2FlZjFiNmRhZmRlMGVmZjdmN2Y3ZTZmNWQwYjhlMTg2N2ZiYzQxNGQ5MjIxMjc2NDE5XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQaVlHID0gcmFtcChzY2hlbWUkMik7XG5cbnZhciBzY2hlbWUkMyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiOTk4ZWMzZjdmN2Y3ZjFhMzQwXCIsXG4gIFwiNWUzYzk5YjJhYmQyZmRiODYzZTY2MTAxXCIsXG4gIFwiNWUzYzk5YjJhYmQyZjdmN2Y3ZmRiODYzZTY2MTAxXCIsXG4gIFwiNTQyNzg4OTk4ZWMzZDhkYWViZmVlMGI2ZjFhMzQwYjM1ODA2XCIsXG4gIFwiNTQyNzg4OTk4ZWMzZDhkYWViZjdmN2Y3ZmVlMGI2ZjFhMzQwYjM1ODA2XCIsXG4gIFwiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2XCIsXG4gIFwiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZjdmN2Y3ZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2XCIsXG4gIFwiMmQwMDRiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2N2YzYjA4XCIsXG4gIFwiMmQwMDRiNTQyNzg4ODA3M2FjYjJhYmQyZDhkYWViZjdmN2Y3ZmVlMGI2ZmRiODYzZTA4MjE0YjM1ODA2N2YzYjA4XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdU9yID0gcmFtcChzY2hlbWUkMyk7XG5cbnZhciBzY2hlbWUkNCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWY4YTYyZjdmN2Y3NjdhOWNmXCIsXG4gIFwiY2EwMDIwZjRhNTgyOTJjNWRlMDU3MWIwXCIsXG4gIFwiY2EwMDIwZjRhNTgyZjdmN2Y3OTJjNWRlMDU3MWIwXCIsXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZDFlNWYwNjdhOWNmMjE2NmFjXCIsXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZjdmN2Y3ZDFlNWYwNjdhOWNmMjE2NmFjXCIsXG4gIFwiYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZDFlNWYwOTJjNWRlNDM5M2MzMjE2NmFjXCIsXG4gIFwiYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZjdmN2Y3ZDFlNWYwOTJjNWRlNDM5M2MzMjE2NmFjXCIsXG4gIFwiNjcwMDFmYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZDFlNWYwOTJjNWRlNDM5M2MzMjE2NmFjMDUzMDYxXCIsXG4gIFwiNjcwMDFmYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZjdmN2Y3ZDFlNWYwOTJjNWRlNDM5M2MzMjE2NmFjMDUzMDYxXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZEJ1ID0gcmFtcChzY2hlbWUkNCk7XG5cbnZhciBzY2hlbWUkNSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWY4YTYyZmZmZmZmOTk5OTk5XCIsXG4gIFwiY2EwMDIwZjRhNTgyYmFiYWJhNDA0MDQwXCIsXG4gIFwiY2EwMDIwZjRhNTgyZmZmZmZmYmFiYWJhNDA0MDQwXCIsXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZTBlMGUwOTk5OTk5NGQ0ZDRkXCIsXG4gIFwiYjIxODJiZWY4YTYyZmRkYmM3ZmZmZmZmZTBlMGUwOTk5OTk5NGQ0ZDRkXCIsXG4gIFwiYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZTBlMGUwYmFiYWJhODc4Nzg3NGQ0ZDRkXCIsXG4gIFwiYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZmZmZmZmZTBlMGUwYmFiYWJhODc4Nzg3NGQ0ZDRkXCIsXG4gIFwiNjcwMDFmYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZTBlMGUwYmFiYWJhODc4Nzg3NGQ0ZDRkMWExYTFhXCIsXG4gIFwiNjcwMDFmYjIxODJiZDY2MDRkZjRhNTgyZmRkYmM3ZmZmZmZmZTBlMGUwYmFiYWJhODc4Nzg3NGQ0ZDRkMWExYTFhXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZEd5ID0gcmFtcChzY2hlbWUkNSk7XG5cbnZhciBzY2hlbWUkNiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmM4ZDU5ZmZmZmJmOTFiZmRiXCIsXG4gIFwiZDcxOTFjZmRhZTYxYWJkOWU5MmM3YmI2XCIsXG4gIFwiZDcxOTFjZmRhZTYxZmZmZmJmYWJkOWU5MmM3YmI2XCIsXG4gIFwiZDczMDI3ZmM4ZDU5ZmVlMDkwZTBmM2Y4OTFiZmRiNDU3NWI0XCIsXG4gIFwiZDczMDI3ZmM4ZDU5ZmVlMDkwZmZmZmJmZTBmM2Y4OTFiZmRiNDU3NWI0XCIsXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0XCIsXG4gIFwiZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZmZmZmJmZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0XCIsXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0MzEzNjk1XCIsXG4gIFwiYTUwMDI2ZDczMDI3ZjQ2ZDQzZmRhZTYxZmVlMDkwZmZmZmJmZTBmM2Y4YWJkOWU5NzRhZGQxNDU3NWI0MzEzNjk1XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZFlsQnUgPSByYW1wKHNjaGVtZSQ2KTtcblxudmFyIHNjaGVtZSQ3ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmYzhkNTlmZmZmYmY5MWNmNjBcIixcbiAgXCJkNzE5MWNmZGFlNjFhNmQ5NmExYTk2NDFcIixcbiAgXCJkNzE5MWNmZGFlNjFmZmZmYmZhNmQ5NmExYTk2NDFcIixcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOGJkOWVmOGI5MWNmNjAxYTk4NTBcIixcbiAgXCJkNzMwMjdmYzhkNTlmZWUwOGJmZmZmYmZkOWVmOGI5MWNmNjAxYTk4NTBcIixcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOGJkOWVmOGJhNmQ5NmE2NmJkNjMxYTk4NTBcIixcbiAgXCJkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZkOWVmOGJhNmQ5NmE2NmJkNjMxYTk4NTBcIixcbiAgXCJhNTAwMjZkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOGJkOWVmOGJhNmQ5NmE2NmJkNjMxYTk4NTAwMDY4MzdcIixcbiAgXCJhNTAwMjZkNzMwMjdmNDZkNDNmZGFlNjFmZWUwOGJmZmZmYmZkOWVmOGJhNmQ5NmE2NmJkNjMxYTk4NTAwMDY4MzdcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkWWxHbiA9IHJhbXAoc2NoZW1lJDcpO1xuXG52YXIgc2NoZW1lJDggPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZjOGQ1OWZmZmZiZjk5ZDU5NFwiLFxuICBcImQ3MTkxY2ZkYWU2MWFiZGRhNDJiODNiYVwiLFxuICBcImQ3MTkxY2ZkYWU2MWZmZmZiZmFiZGRhNDJiODNiYVwiLFxuICBcImQ1M2U0ZmZjOGQ1OWZlZTA4YmU2ZjU5ODk5ZDU5NDMyODhiZFwiLFxuICBcImQ1M2U0ZmZjOGQ1OWZlZTA4YmZmZmZiZmU2ZjU5ODk5ZDU5NDMyODhiZFwiLFxuICBcImQ1M2U0ZmY0NmQ0M2ZkYWU2MWZlZTA4YmU2ZjU5OGFiZGRhNDY2YzJhNTMyODhiZFwiLFxuICBcImQ1M2U0ZmY0NmQ0M2ZkYWU2MWZlZTA4YmZmZmZiZmU2ZjU5OGFiZGRhNDY2YzJhNTMyODhiZFwiLFxuICBcIjllMDE0MmQ1M2U0ZmY0NmQ0M2ZkYWU2MWZlZTA4YmU2ZjU5OGFiZGRhNDY2YzJhNTMyODhiZDVlNGZhMlwiLFxuICBcIjllMDE0MmQ1M2U0ZmY0NmQ0M2ZkYWU2MWZlZTA4YmZmZmZiZmU2ZjU5OGFiZGRhNDY2YzJhNTMyODhiZDVlNGZhMlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgU3BlY3RyYWwgPSByYW1wKHNjaGVtZSQ4KTtcblxudmFyIHNjaGVtZSQ5ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlNWY1Zjk5OWQ4YzkyY2EyNWZcIixcbiAgXCJlZGY4ZmJiMmUyZTI2NmMyYTQyMzhiNDVcIixcbiAgXCJlZGY4ZmJiMmUyZTI2NmMyYTQyY2EyNWYwMDZkMmNcIixcbiAgXCJlZGY4ZmJjY2VjZTY5OWQ4Yzk2NmMyYTQyY2EyNWYwMDZkMmNcIixcbiAgXCJlZGY4ZmJjY2VjZTY5OWQ4Yzk2NmMyYTQ0MWFlNzYyMzhiNDUwMDU4MjRcIixcbiAgXCJmN2ZjZmRlNWY1ZjljY2VjZTY5OWQ4Yzk2NmMyYTQ0MWFlNzYyMzhiNDUwMDU4MjRcIixcbiAgXCJmN2ZjZmRlNWY1ZjljY2VjZTY5OWQ4Yzk2NmMyYTQ0MWFlNzYyMzhiNDUwMDZkMmMwMDQ0MWJcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIEJ1R24gPSByYW1wKHNjaGVtZSQ5KTtcblxudmFyIHNjaGVtZSQxMCA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTBlY2Y0OWViY2RhODg1NmE3XCIsXG4gIFwiZWRmOGZiYjNjZGUzOGM5NmM2ODg0MTlkXCIsXG4gIFwiZWRmOGZiYjNjZGUzOGM5NmM2ODg1NmE3ODEwZjdjXCIsXG4gIFwiZWRmOGZiYmZkM2U2OWViY2RhOGM5NmM2ODg1NmE3ODEwZjdjXCIsXG4gIFwiZWRmOGZiYmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkNmUwMTZiXCIsXG4gIFwiZjdmY2ZkZTBlY2Y0YmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkNmUwMTZiXCIsXG4gIFwiZjdmY2ZkZTBlY2Y0YmZkM2U2OWViY2RhOGM5NmM2OGM2YmIxODg0MTlkODEwZjdjNGQwMDRiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCdVB1ID0gcmFtcChzY2hlbWUkMTApO1xuXG52YXIgc2NoZW1lJDExID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJlMGYzZGJhOGRkYjU0M2EyY2FcIixcbiAgXCJmMGY5ZThiYWU0YmM3YmNjYzQyYjhjYmVcIixcbiAgXCJmMGY5ZThiYWU0YmM3YmNjYzQ0M2EyY2EwODY4YWNcIixcbiAgXCJmMGY5ZThjY2ViYzVhOGRkYjU3YmNjYzQ0M2EyY2EwODY4YWNcIixcbiAgXCJmMGY5ZThjY2ViYzVhOGRkYjU3YmNjYzQ0ZWIzZDMyYjhjYmUwODU4OWVcIixcbiAgXCJmN2ZjZjBlMGYzZGJjY2ViYzVhOGRkYjU3YmNjYzQ0ZWIzZDMyYjhjYmUwODU4OWVcIixcbiAgXCJmN2ZjZjBlMGYzZGJjY2ViYzVhOGRkYjU3YmNjYzQ0ZWIzZDMyYjhjYmUwODY4YWMwODQwODFcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIEduQnUgPSByYW1wKHNjaGVtZSQxMSk7XG5cbnZhciBzY2hlbWUkMTIgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZlZThjOGZkYmI4NGUzNGEzM1wiLFxuICBcImZlZjBkOWZkY2M4YWZjOGQ1OWQ3MzAxZlwiLFxuICBcImZlZjBkOWZkY2M4YWZjOGQ1OWUzNGEzM2IzMDAwMFwiLFxuICBcImZlZjBkOWZkZDQ5ZWZkYmI4NGZjOGQ1OWUzNGEzM2IzMDAwMFwiLFxuICBcImZlZjBkOWZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZjk5MDAwMFwiLFxuICBcImZmZjdlY2ZlZThjOGZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZjk5MDAwMFwiLFxuICBcImZmZjdlY2ZlZThjOGZkZDQ5ZWZkYmI4NGZjOGQ1OWVmNjU0OGQ3MzAxZmIzMDAwMDdmMDAwMFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgT3JSZCA9IHJhbXAoc2NoZW1lJDEyKTtcblxudmFyIHNjaGVtZSQxMyA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZWNlMmYwYTZiZGRiMWM5MDk5XCIsXG4gIFwiZjZlZmY3YmRjOWUxNjdhOWNmMDI4MThhXCIsXG4gIFwiZjZlZmY3YmRjOWUxNjdhOWNmMWM5MDk5MDE2YzU5XCIsXG4gIFwiZjZlZmY3ZDBkMWU2YTZiZGRiNjdhOWNmMWM5MDk5MDE2YzU5XCIsXG4gIFwiZjZlZmY3ZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2NDUwXCIsXG4gIFwiZmZmN2ZiZWNlMmYwZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2NDUwXCIsXG4gIFwiZmZmN2ZiZWNlMmYwZDBkMWU2YTZiZGRiNjdhOWNmMzY5MGMwMDI4MThhMDE2YzU5MDE0NjM2XCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdUJ1R24gPSByYW1wKHNjaGVtZSQxMyk7XG5cbnZhciBzY2hlbWUkMTQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVjZTdmMmE2YmRkYjJiOGNiZVwiLFxuICBcImYxZWVmNmJkYzllMTc0YTljZjA1NzBiMFwiLFxuICBcImYxZWVmNmJkYzllMTc0YTljZjJiOGNiZTA0NWE4ZFwiLFxuICBcImYxZWVmNmQwZDFlNmE2YmRkYjc0YTljZjJiOGNiZTA0NWE4ZFwiLFxuICBcImYxZWVmNmQwZDFlNmE2YmRkYjc0YTljZjM2OTBjMDA1NzBiMDAzNGU3YlwiLFxuICBcImZmZjdmYmVjZTdmMmQwZDFlNmE2YmRkYjc0YTljZjM2OTBjMDA1NzBiMDAzNGU3YlwiLFxuICBcImZmZjdmYmVjZTdmMmQwZDFlNmE2YmRkYjc0YTljZjM2OTBjMDA1NzBiMDA0NWE4ZDAyMzg1OFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUHVCdSA9IHJhbXAoc2NoZW1lJDE0KTtcblxudmFyIHNjaGVtZSQxNSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTdlMWVmYzk5NGM3ZGQxYzc3XCIsXG4gIFwiZjFlZWY2ZDdiNWQ4ZGY2NWIwY2UxMjU2XCIsXG4gIFwiZjFlZWY2ZDdiNWQ4ZGY2NWIwZGQxYzc3OTgwMDQzXCIsXG4gIFwiZjFlZWY2ZDRiOWRhYzk5NGM3ZGY2NWIwZGQxYzc3OTgwMDQzXCIsXG4gIFwiZjFlZWY2ZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTEwMDNmXCIsXG4gIFwiZjdmNGY5ZTdlMWVmZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTEwMDNmXCIsXG4gIFwiZjdmNGY5ZTdlMWVmZDRiOWRhYzk5NGM3ZGY2NWIwZTcyOThhY2UxMjU2OTgwMDQzNjcwMDFmXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBQdVJkID0gcmFtcChzY2hlbWUkMTUpO1xuXG52YXIgc2NoZW1lJDE2ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZGUwZGRmYTlmYjVjNTFiOGFcIixcbiAgXCJmZWViZTJmYmI0YjlmNzY4YTFhZTAxN2VcIixcbiAgXCJmZWViZTJmYmI0YjlmNzY4YTFjNTFiOGE3YTAxNzdcIixcbiAgXCJmZWViZTJmY2M1YzBmYTlmYjVmNzY4YTFjNTFiOGE3YTAxNzdcIixcbiAgXCJmZWViZTJmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzdcIixcbiAgXCJmZmY3ZjNmZGUwZGRmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzdcIixcbiAgXCJmZmY3ZjNmZGUwZGRmY2M1YzBmYTlmYjVmNzY4YTFkZDM0OTdhZTAxN2U3YTAxNzc0OTAwNmFcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFJkUHUgPSByYW1wKHNjaGVtZSQxNik7XG5cbnZhciBzY2hlbWUkMTcgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVkZjhiMTdmY2RiYjJjN2ZiOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDIyNWVhOFwiLFxuICBcImZmZmZjY2ExZGFiNDQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDJjN2ZiODI1MzQ5NFwiLFxuICBcImZmZmZjY2M3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODBjMmM4NFwiLFxuICBcImZmZmZkOWVkZjhiMWM3ZTliNDdmY2RiYjQxYjZjNDFkOTFjMDIyNWVhODI1MzQ5NDA4MWQ1OFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgWWxHbkJ1ID0gcmFtcChzY2hlbWUkMTcpO1xuXG52YXIgc2NoZW1lJDE4ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmN2ZjYjlhZGRkOGUzMWEzNTRcIixcbiAgXCJmZmZmY2NjMmU2OTk3OGM2NzkyMzg0NDNcIixcbiAgXCJmZmZmY2NjMmU2OTk3OGM2NzkzMWEzNTQwMDY4MzdcIixcbiAgXCJmZmZmY2NkOWYwYTNhZGRkOGU3OGM2NzkzMWEzNTQwMDY4MzdcIixcbiAgXCJmZmZmY2NkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDVhMzJcIixcbiAgXCJmZmZmZTVmN2ZjYjlkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDVhMzJcIixcbiAgXCJmZmZmZTVmN2ZjYjlkOWYwYTNhZGRkOGU3OGM2Nzk0MWFiNWQyMzg0NDMwMDY4MzcwMDQ1MjlcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFlsR24gPSByYW1wKHNjaGVtZSQxOCk7XG5cbnZhciBzY2hlbWUkMTkgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImZmZjdiY2ZlYzQ0ZmQ5NWYwZVwiLFxuICBcImZmZmZkNGZlZDk4ZWZlOTkyOWNjNGMwMlwiLFxuICBcImZmZmZkNGZlZDk4ZWZlOTkyOWQ5NWYwZTk5MzQwNFwiLFxuICBcImZmZmZkNGZlZTM5MWZlYzQ0ZmZlOTkyOWQ5NWYwZTk5MzQwNFwiLFxuICBcImZmZmZkNGZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjhjMmQwNFwiLFxuICBcImZmZmZlNWZmZjdiY2ZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjhjMmQwNFwiLFxuICBcImZmZmZlNWZmZjdiY2ZlZTM5MWZlYzQ0ZmZlOTkyOWVjNzAxNGNjNGMwMjk5MzQwNDY2MjUwNlwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgWWxPckJyID0gcmFtcChzY2hlbWUkMTkpO1xuXG52YXIgc2NoZW1lJDIwID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZmVkYTBmZWIyNGNmMDNiMjBcIixcbiAgXCJmZmZmYjJmZWNjNWNmZDhkM2NlMzFhMWNcIixcbiAgXCJmZmZmYjJmZWNjNWNmZDhkM2NmMDNiMjBiZDAwMjZcIixcbiAgXCJmZmZmYjJmZWQ5NzZmZWIyNGNmZDhkM2NmMDNiMjBiZDAwMjZcIixcbiAgXCJmZmZmYjJmZWQ5NzZmZWIyNGNmZDhkM2NmYzRlMmFlMzFhMWNiMTAwMjZcIixcbiAgXCJmZmZmY2NmZmVkYTBmZWQ5NzZmZWIyNGNmZDhkM2NmYzRlMmFlMzFhMWNiMTAwMjZcIixcbiAgXCJmZmZmY2NmZmVkYTBmZWQ5NzZmZWIyNGNmZDhkM2NmYzRlMmFlMzFhMWNiZDAwMjY4MDAwMjZcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIFlsT3JSZCA9IHJhbXAoc2NoZW1lJDIwKTtcblxudmFyIHNjaGVtZSQyMSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZGVlYmY3OWVjYWUxMzE4MmJkXCIsXG4gIFwiZWZmM2ZmYmRkN2U3NmJhZWQ2MjE3MWI1XCIsXG4gIFwiZWZmM2ZmYmRkN2U3NmJhZWQ2MzE4MmJkMDg1MTljXCIsXG4gIFwiZWZmM2ZmYzZkYmVmOWVjYWUxNmJhZWQ2MzE4MmJkMDg1MTljXCIsXG4gIFwiZWZmM2ZmYzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg0NTk0XCIsXG4gIFwiZjdmYmZmZGVlYmY3YzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg0NTk0XCIsXG4gIFwiZjdmYmZmZGVlYmY3YzZkYmVmOWVjYWUxNmJhZWQ2NDI5MmM2MjE3MWI1MDg1MTljMDgzMDZiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBCbHVlcyA9IHJhbXAoc2NoZW1lJDIxKTtcblxudmFyIHNjaGVtZSQyMiA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZTVmNWUwYTFkOTliMzFhMzU0XCIsXG4gIFwiZWRmOGU5YmFlNGIzNzRjNDc2MjM4YjQ1XCIsXG4gIFwiZWRmOGU5YmFlNGIzNzRjNDc2MzFhMzU0MDA2ZDJjXCIsXG4gIFwiZWRmOGU5YzdlOWMwYTFkOTliNzRjNDc2MzFhMzU0MDA2ZDJjXCIsXG4gIFwiZWRmOGU5YzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA1YTMyXCIsXG4gIFwiZjdmY2Y1ZTVmNWUwYzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA1YTMyXCIsXG4gIFwiZjdmY2Y1ZTVmNWUwYzdlOWMwYTFkOTliNzRjNDc2NDFhYjVkMjM4YjQ1MDA2ZDJjMDA0NDFiXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBHcmVlbnMgPSByYW1wKHNjaGVtZSQyMik7XG5cbnZhciBzY2hlbWUkMjMgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImYwZjBmMGJkYmRiZDYzNjM2M1wiLFxuICBcImY3ZjdmN2NjY2NjYzk2OTY5NjUyNTI1MlwiLFxuICBcImY3ZjdmN2NjY2NjYzk2OTY5NjYzNjM2MzI1MjUyNVwiLFxuICBcImY3ZjdmN2Q5ZDlkOWJkYmRiZDk2OTY5NjYzNjM2MzI1MjUyNVwiLFxuICBcImY3ZjdmN2Q5ZDlkOWJkYmRiZDk2OTY5NjczNzM3MzUyNTI1MjI1MjUyNVwiLFxuICBcImZmZmZmZmYwZjBmMGQ5ZDlkOWJkYmRiZDk2OTY5NjczNzM3MzUyNTI1MjI1MjUyNVwiLFxuICBcImZmZmZmZmYwZjBmMGQ5ZDlkOWJkYmRiZDk2OTY5NjczNzM3MzUyNTI1MjI1MjUyNTAwMDAwMFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgR3JleXMgPSByYW1wKHNjaGVtZSQyMyk7XG5cbnZhciBzY2hlbWUkMjQgPSBuZXcgQXJyYXkoMykuY29uY2F0KFxuICBcImVmZWRmNWJjYmRkYzc1NmJiMVwiLFxuICBcImYyZjBmN2NiYzllMjllOWFjODZhNTFhM1wiLFxuICBcImYyZjBmN2NiYzllMjllOWFjODc1NmJiMTU0Mjc4ZlwiLFxuICBcImYyZjBmN2RhZGFlYmJjYmRkYzllOWFjODc1NmJiMTU0Mjc4ZlwiLFxuICBcImYyZjBmN2RhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzRhMTQ4NlwiLFxuICBcImZjZmJmZGVmZWRmNWRhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzRhMTQ4NlwiLFxuICBcImZjZmJmZGVmZWRmNWRhZGFlYmJjYmRkYzllOWFjODgwN2RiYTZhNTFhMzU0Mjc4ZjNmMDA3ZFwiXG4pLm1hcChjb2xvcnMpO1xuXG52YXIgUHVycGxlcyA9IHJhbXAoc2NoZW1lJDI0KTtcblxudmFyIHNjaGVtZSQyNSA9IG5ldyBBcnJheSgzKS5jb25jYXQoXG4gIFwiZmVlMGQyZmM5MjcyZGUyZDI2XCIsXG4gIFwiZmVlNWQ5ZmNhZTkxZmI2YTRhY2IxODFkXCIsXG4gIFwiZmVlNWQ5ZmNhZTkxZmI2YTRhZGUyZDI2YTUwZjE1XCIsXG4gIFwiZmVlNWQ5ZmNiYmExZmM5MjcyZmI2YTRhZGUyZDI2YTUwZjE1XCIsXG4gIFwiZmVlNWQ5ZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkOTkwMDBkXCIsXG4gIFwiZmZmNWYwZmVlMGQyZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkOTkwMDBkXCIsXG4gIFwiZmZmNWYwZmVlMGQyZmNiYmExZmM5MjcyZmI2YTRhZWYzYjJjY2IxODFkYTUwZjE1NjcwMDBkXCJcbikubWFwKGNvbG9ycyk7XG5cbnZhciBSZWRzID0gcmFtcChzY2hlbWUkMjUpO1xuXG52YXIgc2NoZW1lJDI2ID0gbmV3IEFycmF5KDMpLmNvbmNhdChcbiAgXCJmZWU2Y2VmZGFlNmJlNjU1MGRcIixcbiAgXCJmZWVkZGVmZGJlODVmZDhkM2NkOTQ3MDFcIixcbiAgXCJmZWVkZGVmZGJlODVmZDhkM2NlNjU1MGRhNjM2MDNcIixcbiAgXCJmZWVkZGVmZGQwYTJmZGFlNmJmZDhkM2NlNjU1MGRhNjM2MDNcIixcbiAgXCJmZWVkZGVmZGQwYTJmZGFlNmJmZDhkM2NmMTY5MTNkOTQ4MDE4YzJkMDRcIixcbiAgXCJmZmY1ZWJmZWU2Y2VmZGQwYTJmZGFlNmJmZDhkM2NmMTY5MTNkOTQ4MDE4YzJkMDRcIixcbiAgXCJmZmY1ZWJmZWU2Y2VmZGQwYTJmZGFlNmJmZDhkM2NmMTY5MTNkOTQ4MDFhNjM2MDM3ZjI3MDRcIlxuKS5tYXAoY29sb3JzKTtcblxudmFyIE9yYW5nZXMgPSByYW1wKHNjaGVtZSQyNik7XG5cbnZhciBjdWJlaGVsaXgkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KDMwMCwgMC41LCAwLjApLCBkM0NvbG9yLmN1YmVoZWxpeCgtMjQwLCAwLjUsIDEuMCkpO1xuXG52YXIgd2FybSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVDdWJlaGVsaXhMb25nKGQzQ29sb3IuY3ViZWhlbGl4KC0xMDAsIDAuNzUsIDAuMzUpLCBkM0NvbG9yLmN1YmVoZWxpeCg4MCwgMS41MCwgMC44KSk7XG5cbnZhciBjb29sID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZUN1YmVoZWxpeExvbmcoZDNDb2xvci5jdWJlaGVsaXgoMjYwLCAwLjc1LCAwLjM1KSwgZDNDb2xvci5jdWJlaGVsaXgoODAsIDEuNTAsIDAuOCkpO1xuXG52YXIgYyA9IGQzQ29sb3IuY3ViZWhlbGl4KCk7XG5cbmZ1bmN0aW9uIHJhaW5ib3codCkge1xuICBpZiAodCA8IDAgfHwgdCA+IDEpIHQgLT0gTWF0aC5mbG9vcih0KTtcbiAgdmFyIHRzID0gTWF0aC5hYnModCAtIDAuNSk7XG4gIGMuaCA9IDM2MCAqIHQgLSAxMDA7XG4gIGMucyA9IDEuNSAtIDEuNSAqIHRzO1xuICBjLmwgPSAwLjggLSAwLjkgKiB0cztcbiAgcmV0dXJuIGMgKyBcIlwiO1xufVxuXG52YXIgYyQxID0gZDNDb2xvci5yZ2IoKTtcbnZhciBwaV8xXzMgPSBNYXRoLlBJIC8gMztcbnZhciBwaV8yXzMgPSBNYXRoLlBJICogMiAvIDM7XG5cbmZ1bmN0aW9uIHNpbmVib3codCkge1xuICB2YXIgeDtcbiAgdCA9ICgwLjUgLSB0KSAqIE1hdGguUEk7XG4gIGMkMS5yID0gMjU1ICogKHggPSBNYXRoLnNpbih0KSkgKiB4O1xuICBjJDEuZyA9IDI1NSAqICh4ID0gTWF0aC5zaW4odCArIHBpXzFfMykpICogeDtcbiAgYyQxLmIgPSAyNTUgKiAoeCA9IE1hdGguc2luKHQgKyBwaV8yXzMpKSAqIHg7XG4gIHJldHVybiBjJDEgKyBcIlwiO1xufVxuXG5mdW5jdGlvbiByYW1wJDEocmFuZ2UpIHtcbiAgdmFyIG4gPSByYW5nZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHJhbmdlW01hdGgubWF4KDAsIE1hdGgubWluKG4gLSAxLCBNYXRoLmZsb29yKHQgKiBuKSkpXTtcbiAgfTtcbn1cblxudmFyIHZpcmlkaXMgPSByYW1wJDEoY29sb3JzKFwiNDQwMTU0NDQwMjU2NDUwNDU3NDUwNTU5NDYwNzVhNDYwODVjNDYwYTVkNDYwYjVlNDcwZDYwNDcwZTYxNDcxMDYzNDcxMTY0NDcxMzY1NDgxNDY3NDgxNjY4NDgxNzY5NDgxODZhNDgxYTZjNDgxYjZkNDgxYzZlNDgxZDZmNDgxZjcwNDgyMDcxNDgyMTczNDgyMzc0NDgyNDc1NDgyNTc2NDgyNjc3NDgyODc4NDgyOTc5NDcyYTdhNDcyYzdhNDcyZDdiNDcyZTdjNDcyZjdkNDYzMDdlNDYzMjdlNDYzMzdmNDYzNDgwNDUzNTgxNDUzNzgxNDUzODgyNDQzOTgzNDQzYTgzNDQzYjg0NDMzZDg0NDMzZTg1NDIzZjg1NDI0MDg2NDI0MTg2NDE0Mjg3NDE0NDg3NDA0NTg4NDA0Njg4M2Y0Nzg4M2Y0ODg5M2U0OTg5M2U0YTg5M2U0YzhhM2Q0ZDhhM2Q0ZThhM2M0ZjhhM2M1MDhiM2I1MThiM2I1MjhiM2E1MzhiM2E1NDhjMzk1NThjMzk1NjhjMzg1ODhjMzg1OThjMzc1YThjMzc1YjhkMzY1YzhkMzY1ZDhkMzU1ZThkMzU1ZjhkMzQ2MDhkMzQ2MThkMzM2MjhkMzM2MzhkMzI2NDhlMzI2NThlMzE2NjhlMzE2NzhlMzE2ODhlMzA2OThlMzA2YThlMmY2YjhlMmY2YzhlMmU2ZDhlMmU2ZThlMmU2ZjhlMmQ3MDhlMmQ3MThlMmM3MThlMmM3MjhlMmM3MzhlMmI3NDhlMmI3NThlMmE3NjhlMmE3NzhlMmE3ODhlMjk3OThlMjk3YThlMjk3YjhlMjg3YzhlMjg3ZDhlMjc3ZThlMjc3ZjhlMjc4MDhlMjY4MThlMjY4MjhlMjY4MjhlMjU4MzhlMjU4NDhlMjU4NThlMjQ4NjhlMjQ4NzhlMjM4ODhlMjM4OThlMjM4YThkMjI4YjhkMjI4YzhkMjI4ZDhkMjE4ZThkMjE4ZjhkMjE5MDhkMjE5MThjMjA5MjhjMjA5MjhjMjA5MzhjMWY5NDhjMWY5NThiMWY5NjhiMWY5NzhiMWY5ODhiMWY5OThhMWY5YThhMWU5YjhhMWU5Yzg5MWU5ZDg5MWY5ZTg5MWY5Zjg4MWZhMDg4MWZhMTg4MWZhMTg3MWZhMjg3MjBhMzg2MjBhNDg2MjFhNTg1MjFhNjg1MjJhNzg1MjJhODg0MjNhOTgzMjRhYTgzMjVhYjgyMjVhYzgyMjZhZDgxMjdhZDgxMjhhZTgwMjlhZjdmMmFiMDdmMmNiMTdlMmRiMjdkMmViMzdjMmZiNDdjMzFiNTdiMzJiNjdhMzRiNjc5MzViNzc5MzdiODc4MzhiOTc3M2FiYTc2M2JiYjc1M2RiYzc0M2ZiYzczNDBiZDcyNDJiZTcxNDRiZjcwNDZjMDZmNDhjMTZlNGFjMTZkNGNjMjZjNGVjMzZiNTBjNDZhNTJjNTY5NTRjNTY4NTZjNjY3NThjNzY1NWFjODY0NWNjODYzNWVjOTYyNjBjYTYwNjNjYjVmNjVjYjVlNjdjYzVjNjljZDViNmNjZDVhNmVjZTU4NzBjZjU3NzNkMDU2NzVkMDU0NzdkMTUzN2FkMTUxN2NkMjUwN2ZkMzRlODFkMzRkODRkNDRiODZkNTQ5ODlkNTQ4OGJkNjQ2OGVkNjQ1OTBkNzQzOTNkNzQxOTVkODQwOThkODNlOWJkOTNjOWRkOTNiYTBkYTM5YTJkYTM3YTVkYjM2YThkYjM0YWFkYzMyYWRkYzMwYjBkZDJmYjJkZDJkYjVkZTJiYjhkZTI5YmFkZTI4YmRkZjI2YzBkZjI1YzJkZjIzYzVlMDIxYzhlMDIwY2FlMTFmY2RlMTFkZDBlMTFjZDJlMjFiZDVlMjFhZDhlMjE5ZGFlMzE5ZGRlMzE4ZGZlMzE4ZTJlNDE4ZTVlNDE5ZTdlNDE5ZWFlNTFhZWNlNTFiZWZlNTFjZjFlNTFkZjRlNjFlZjZlNjIwZjhlNjIxZmJlNzIzZmRlNzI1XCIpKTtcblxudmFyIG1hZ21hID0gcmFtcCQxKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwOTAyMDIwYjAyMDIwZDAzMDMwZjAzMDMxMjA0MDQxNDA1MDQxNjA2MDUxODA2MDUxYTA3MDYxYzA4MDcxZTA5MDcyMDBhMDgyMjBiMDkyNDBjMDkyNjBkMGEyOTBlMGIyYjEwMGIyZDExMGMyZjEyMGQzMTEzMGQzNDE0MGUzNjE1MGUzODE2MGYzYjE4MGYzZDE5MTAzZjFhMTA0MjFjMTA0NDFkMTE0NzFlMTE0OTIwMTE0YjIxMTE0ZTIyMTE1MDI0MTI1MzI1MTI1NTI3MTI1ODI5MTE1YTJhMTE1YzJjMTE1ZjJkMTE2MTJmMTE2MzMxMTE2NTMzMTA2NzM0MTA2OTM2MTA2YjM4MTA2YzM5MGY2ZTNiMGY3MDNkMGY3MTNmMGY3MjQwMGY3NDQyMGY3NTQ0MGY3NjQ1MTA3NzQ3MTA3ODQ5MTA3ODRhMTA3OTRjMTE3YTRlMTE3YjRmMTI3YjUxMTI3YzUyMTM3YzU0MTM3ZDU2MTQ3ZDU3MTU3ZTU5MTU3ZTVhMTY3ZTVjMTY3ZjVkMTc3ZjVmMTg3ZjYwMTg4MDYyMTk4MDY0MWE4MDY1MWE4MDY3MWI4MDY4MWM4MTZhMWM4MTZiMWQ4MTZkMWQ4MTZlMWU4MTcwMWY4MTcyMWY4MTczMjA4MTc1MjE4MTc2MjE4MTc4MjI4MTc5MjI4MjdiMjM4MjdjMjM4MjdlMjQ4MjgwMjU4MjgxMjU4MTgzMjY4MTg0MjY4MTg2Mjc4MTg4Mjc4MTg5Mjg4MThiMjk4MThjMjk4MThlMmE4MTkwMmE4MTkxMmI4MTkzMmI4MDk0MmM4MDk2MmM4MDk4MmQ4MDk5MmQ4MDliMmU3ZjljMmU3ZjllMmY3ZmEwMmY3ZmExMzA3ZWEzMzA3ZWE1MzE3ZWE2MzE3ZGE4MzI3ZGFhMzM3ZGFiMzM3Y2FkMzQ3Y2FlMzQ3YmIwMzU3YmIyMzU3YmIzMzY3YWI1MzY3YWI3Mzc3OWI4Mzc3OWJhMzg3OGJjMzk3OGJkMzk3N2JmM2E3N2MwM2E3NmMyM2I3NWM0M2M3NWM1M2M3NGM3M2Q3M2M4M2U3M2NhM2U3MmNjM2Y3MWNkNDA3MWNmNDA3MGQwNDE2ZmQyNDI2ZmQzNDM2ZWQ1NDQ2ZGQ2NDU2Y2Q4NDU2Y2Q5NDY2YmRiNDc2YWRjNDg2OWRlNDk2OGRmNGE2OGUwNGM2N2UyNGQ2NmUzNGU2NWU0NGY2NGU1NTA2NGU3NTI2M2U4NTM2MmU5NTQ2MmVhNTY2MWViNTc2MGVjNTg2MGVkNWE1ZmVlNWI1ZWVmNWQ1ZWYwNWY1ZWYxNjA1ZGYyNjI1ZGYyNjQ1Y2YzNjU1Y2Y0Njc1Y2Y0Njk1Y2Y1NmI1Y2Y2NmM1Y2Y2NmU1Y2Y3NzA1Y2Y3NzI1Y2Y4NzQ1Y2Y4NzY1Y2Y5Nzg1ZGY5Nzk1ZGY5N2I1ZGZhN2Q1ZWZhN2Y1ZWZhODE1ZmZiODM1ZmZiODU2MGZiODc2MWZjODk2MWZjOGE2MmZjOGM2M2ZjOGU2NGZjOTA2NWZkOTI2NmZkOTQ2N2ZkOTY2OGZkOTg2OWZkOWE2YWZkOWI2YmZlOWQ2Y2ZlOWY2ZGZlYTE2ZWZlYTM2ZmZlYTU3MWZlYTc3MmZlYTk3M2ZlYWE3NGZlYWM3NmZlYWU3N2ZlYjA3OGZlYjI3YWZlYjQ3YmZlYjY3Y2ZlYjc3ZWZlYjk3ZmZlYmI4MWZlYmQ4MmZlYmY4NGZlYzE4NWZlYzI4N2ZlYzQ4OGZlYzY4YWZlYzg4Y2ZlY2E4ZGZlY2M4ZmZlY2Q5MGZlY2Y5MmZlZDE5NGZlZDM5NWZlZDU5N2ZlZDc5OWZlZDg5YWZkZGE5Y2ZkZGM5ZWZkZGVhMGZkZTBhMWZkZTJhM2ZkZTNhNWZkZTVhN2ZkZTdhOWZkZTlhYWZkZWJhY2ZjZWNhZWZjZWViMGZjZjBiMmZjZjJiNGZjZjRiNmZjZjZiOGZjZjdiOWZjZjliYmZjZmJiZGZjZmRiZlwiKSk7XG5cbnZhciBpbmZlcm5vID0gcmFtcCQxKGNvbG9ycyhcIjAwMDAwNDAxMDAwNTAxMDEwNjAxMDEwODAyMDEwYTAyMDIwYzAyMDIwZTAzMDIxMDA0MDMxMjA0MDMxNDA1MDQxNzA2MDQxOTA3MDUxYjA4MDUxZDA5MDYxZjBhMDcyMjBiMDcyNDBjMDgyNjBkMDgyOTBlMDkyYjEwMDkyZDExMGEzMDEyMGEzMjE0MGIzNDE1MGIzNzE2MGIzOTE4MGMzYzE5MGMzZTFiMGM0MTFjMGM0MzFlMGM0NTFmMGM0ODIxMGM0YTIzMGM0YzI0MGM0ZjI2MGM1MTI4MGI1MzI5MGI1NTJiMGI1NzJkMGI1OTJmMGE1YjMxMGE1YzMyMGE1ZTM0MGE1ZjM2MDk2MTM4MDk2MjM5MDk2MzNiMDk2NDNkMDk2NTNlMDk2NjQwMGE2NzQyMGE2ODQ0MGE2ODQ1MGE2OTQ3MGI2YTQ5MGI2YTRhMGM2YjRjMGM2YjRkMGQ2YzRmMGQ2YzUxMGU2YzUyMGU2ZDU0MGY2ZDU1MGY2ZDU3MTA2ZTU5MTA2ZTVhMTE2ZTVjMTI2ZTVkMTI2ZTVmMTM2ZTYxMTM2ZTYyMTQ2ZTY0MTU2ZTY1MTU2ZTY3MTY2ZTY5MTY2ZTZhMTc2ZTZjMTg2ZTZkMTg2ZTZmMTk2ZTcxMTk2ZTcyMWE2ZTc0MWE2ZTc1MWI2ZTc3MWM2ZDc4MWM2ZDdhMWQ2ZDdjMWQ2ZDdkMWU2ZDdmMWU2YzgwMWY2YzgyMjA2Yzg0MjA2Yjg1MjE2Yjg3MjE2Yjg4MjI2YThhMjI2YThjMjM2OThkMjM2OThmMjQ2OTkwMjU2ODkyMjU2ODkzMjY2Nzk1MjY2Nzk3Mjc2Njk4Mjc2NjlhMjg2NTliMjk2NDlkMjk2NDlmMmE2M2EwMmE2M2EyMmI2MmEzMmM2MWE1MmM2MGE2MmQ2MGE4MmU1ZmE5MmU1ZWFiMmY1ZWFkMzA1ZGFlMzA1Y2IwMzE1YmIxMzI1YWIzMzI1YWI0MzM1OWI2MzQ1OGI3MzU1N2I5MzU1NmJhMzY1NWJjMzc1NGJkMzg1M2JmMzk1MmMwM2E1MWMxM2E1MGMzM2I0ZmM0M2M0ZWM2M2Q0ZGM3M2U0Y2M4M2Y0YmNhNDA0YWNiNDE0OWNjNDI0OGNlNDM0N2NmNDQ0NmQwNDU0NWQyNDY0NGQzNDc0M2Q0NDg0MmQ1NGE0MWQ3NGIzZmQ4NGMzZWQ5NGQzZGRhNGUzY2RiNTAzYmRkNTEzYWRlNTIzOGRmNTMzN2UwNTUzNmUxNTYzNWUyNTczNGUzNTkzM2U0NWEzMWU1NWMzMGU2NWQyZmU3NWUyZWU4NjAyZGU5NjEyYmVhNjMyYWViNjQyOWViNjYyOGVjNjcyNmVkNjkyNWVlNmEyNGVmNmMyM2VmNmUyMWYwNmYyMGYxNzExZmYxNzMxZGYyNzQxY2YzNzYxYmYzNzgxOWY0NzkxOGY1N2IxN2Y1N2QxNWY2N2UxNGY2ODAxM2Y3ODIxMmY3ODQxMGY4ODUwZmY4ODcwZWY4ODkwY2Y5OGIwYmY5OGMwYWY5OGUwOWZhOTAwOGZhOTIwN2ZhOTQwN2ZiOTYwNmZiOTcwNmZiOTkwNmZiOWIwNmZiOWQwN2ZjOWYwN2ZjYTEwOGZjYTMwOWZjYTUwYWZjYTYwY2ZjYTgwZGZjYWEwZmZjYWMxMWZjYWUxMmZjYjAxNGZjYjIxNmZjYjQxOGZiYjYxYWZiYjgxZGZiYmExZmZiYmMyMWZiYmUyM2ZhYzAyNmZhYzIyOGZhYzQyYWZhYzYyZGY5YzcyZmY5YzkzMmY5Y2IzNWY4Y2QzN2Y4Y2YzYWY3ZDEzZGY3ZDM0MGY2ZDU0M2Y2ZDc0NmY1ZDk0OWY1ZGI0Y2Y0ZGQ0ZmY0ZGY1M2Y0ZTE1NmYzZTM1YWYzZTU1ZGYyZTY2MWYyZTg2NWYyZWE2OWYxZWM2ZGYxZWQ3MWYxZWY3NWYxZjE3OWYyZjI3ZGYyZjQ4MmYzZjU4NmYzZjY4YWY0Zjg4ZWY1Zjk5MmY2ZmE5NmY4ZmI5YWY5ZmM5ZGZhZmRhMWZjZmZhNFwiKSk7XG5cbnZhciBwbGFzbWEgPSByYW1wJDEoY29sb3JzKFwiMGQwODg3MTAwNzg4MTMwNzg5MTYwNzhhMTkwNjhjMWIwNjhkMWQwNjhlMjAwNjhmMjIwNjkwMjQwNjkxMjYwNTkxMjgwNTkyMmEwNTkzMmMwNTk0MmUwNTk1MmYwNTk2MzEwNTk3MzMwNTk3MzUwNDk4MzcwNDk5MzgwNDlhM2EwNDlhM2MwNDliM2UwNDljM2YwNDljNDEwNDlkNDMwMzllNDQwMzllNDYwMzlmNDgwMzlmNDkwM2EwNGIwM2ExNGMwMmExNGUwMmEyNTAwMmEyNTEwMmEzNTMwMmEzNTUwMmE0NTYwMWE0NTgwMWE0NTkwMWE1NWIwMWE1NWMwMWE2NWUwMWE2NjAwMWE2NjEwMGE3NjMwMGE3NjQwMGE3NjYwMGE3NjcwMGE4NjkwMGE4NmEwMGE4NmMwMGE4NmUwMGE4NmYwMGE4NzEwMGE4NzIwMWE4NzQwMWE4NzUwMWE4NzcwMWE4NzgwMWE4N2EwMmE4N2IwMmE4N2QwM2E4N2UwM2E4ODAwNGE4ODEwNGE3ODMwNWE3ODQwNWE3ODYwNmE2ODcwN2E2ODgwOGE2OGEwOWE1OGIwYWE1OGQwYmE1OGUwY2E0OGYwZGE0OTEwZWEzOTIwZmEzOTQxMGEyOTUxMWExOTYxM2ExOTgxNGEwOTkxNTlmOWExNjlmOWMxNzllOWQxODlkOWUxOTlkYTAxYTljYTExYjliYTIxZDlhYTMxZTlhYTUxZjk5YTYyMDk4YTcyMTk3YTgyMjk2YWEyMzk1YWIyNDk0YWMyNjk0YWQyNzkzYWUyODkyYjAyOTkxYjEyYTkwYjIyYjhmYjMyYzhlYjQyZThkYjUyZjhjYjYzMDhiYjczMThhYjgzMjg5YmEzMzg4YmIzNDg4YmMzNTg3YmQzNzg2YmUzODg1YmYzOTg0YzAzYTgzYzEzYjgyYzIzYzgxYzMzZDgwYzQzZTdmYzU0MDdlYzY0MTdkYzc0MjdjYzg0MzdiYzk0NDdhY2E0NTdhY2I0Njc5Y2M0Nzc4Y2M0OTc3Y2Q0YTc2Y2U0Yjc1Y2Y0Yzc0ZDA0ZDczZDE0ZTcyZDI0ZjcxZDM1MTcxZDQ1MjcwZDU1MzZmZDU1NDZlZDY1NTZkZDc1NjZjZDg1NzZiZDk1ODZhZGE1YTZhZGE1YjY5ZGI1YzY4ZGM1ZDY3ZGQ1ZTY2ZGU1ZjY1ZGU2MTY0ZGY2MjYzZTA2MzYzZTE2NDYyZTI2NTYxZTI2NjYwZTM2ODVmZTQ2OTVlZTU2YTVkZTU2YjVkZTY2YzVjZTc2ZTViZTc2ZjVhZTg3MDU5ZTk3MTU4ZTk3MjU3ZWE3NDU3ZWI3NTU2ZWI3NjU1ZWM3NzU0ZWQ3OTUzZWQ3YTUyZWU3YjUxZWY3YzUxZWY3ZTUwZjA3ZjRmZjA4MDRlZjE4MTRkZjE4MzRjZjI4NDRiZjM4NTRiZjM4NzRhZjQ4ODQ5ZjQ4OTQ4ZjU4YjQ3ZjU4YzQ2ZjY4ZDQ1ZjY4ZjQ0Zjc5MDQ0Zjc5MTQzZjc5MzQyZjg5NDQxZjg5NTQwZjk5NzNmZjk5ODNlZjk5YTNlZmE5YjNkZmE5YzNjZmE5ZTNiZmI5ZjNhZmJhMTM5ZmJhMjM4ZmNhMzM4ZmNhNTM3ZmNhNjM2ZmNhODM1ZmNhOTM0ZmRhYjMzZmRhYzMzZmRhZTMyZmRhZjMxZmRiMTMwZmRiMjJmZmRiNDJmZmRiNTJlZmViNzJkZmViODJjZmViYTJjZmViYjJiZmViZDJhZmViZTJhZmVjMDI5ZmRjMjI5ZmRjMzI4ZmRjNTI3ZmRjNjI3ZmRjODI3ZmRjYTI2ZmRjYjI2ZmNjZDI1ZmNjZTI1ZmNkMDI1ZmNkMjI1ZmJkMzI0ZmJkNTI0ZmJkNzI0ZmFkODI0ZmFkYTI0ZjlkYzI0ZjlkZDI1ZjhkZjI1ZjhlMTI1ZjdlMjI1ZjdlNDI1ZjZlNjI2ZjZlODI2ZjVlOTI2ZjVlYjI3ZjRlZDI3ZjNlZTI3ZjNmMDI3ZjJmMjI3ZjFmNDI2ZjFmNTI1ZjBmNzI0ZjBmOTIxXCIpKTtcblxuZXhwb3J0cy5zY2hlbWVDYXRlZ29yeTEwID0gY2F0ZWdvcnkxMDtcbmV4cG9ydHMuc2NoZW1lQWNjZW50ID0gQWNjZW50O1xuZXhwb3J0cy5zY2hlbWVEYXJrMiA9IERhcmsyO1xuZXhwb3J0cy5zY2hlbWVQYWlyZWQgPSBQYWlyZWQ7XG5leHBvcnRzLnNjaGVtZVBhc3RlbDEgPSBQYXN0ZWwxO1xuZXhwb3J0cy5zY2hlbWVQYXN0ZWwyID0gUGFzdGVsMjtcbmV4cG9ydHMuc2NoZW1lU2V0MSA9IFNldDE7XG5leHBvcnRzLnNjaGVtZVNldDIgPSBTZXQyO1xuZXhwb3J0cy5zY2hlbWVTZXQzID0gU2V0MztcbmV4cG9ydHMuaW50ZXJwb2xhdGVCckJHID0gQnJCRztcbmV4cG9ydHMuc2NoZW1lQnJCRyA9IHNjaGVtZTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQUkduID0gUFJHbjtcbmV4cG9ydHMuc2NoZW1lUFJHbiA9IHNjaGVtZSQxO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVBpWUcgPSBQaVlHO1xuZXhwb3J0cy5zY2hlbWVQaVlHID0gc2NoZW1lJDI7XG5leHBvcnRzLmludGVycG9sYXRlUHVPciA9IFB1T3I7XG5leHBvcnRzLnNjaGVtZVB1T3IgPSBzY2hlbWUkMztcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZEJ1ID0gUmRCdTtcbmV4cG9ydHMuc2NoZW1lUmRCdSA9IHNjaGVtZSQ0O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVJkR3kgPSBSZEd5O1xuZXhwb3J0cy5zY2hlbWVSZEd5ID0gc2NoZW1lJDU7XG5leHBvcnRzLmludGVycG9sYXRlUmRZbEJ1ID0gUmRZbEJ1O1xuZXhwb3J0cy5zY2hlbWVSZFlsQnUgPSBzY2hlbWUkNjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZFlsR24gPSBSZFlsR247XG5leHBvcnRzLnNjaGVtZVJkWWxHbiA9IHNjaGVtZSQ3O1xuZXhwb3J0cy5pbnRlcnBvbGF0ZVNwZWN0cmFsID0gU3BlY3RyYWw7XG5leHBvcnRzLnNjaGVtZVNwZWN0cmFsID0gc2NoZW1lJDg7XG5leHBvcnRzLmludGVycG9sYXRlQnVHbiA9IEJ1R247XG5leHBvcnRzLnNjaGVtZUJ1R24gPSBzY2hlbWUkOTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCdVB1ID0gQnVQdTtcbmV4cG9ydHMuc2NoZW1lQnVQdSA9IHNjaGVtZSQxMDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVHbkJ1ID0gR25CdTtcbmV4cG9ydHMuc2NoZW1lR25CdSA9IHNjaGVtZSQxMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPclJkID0gT3JSZDtcbmV4cG9ydHMuc2NoZW1lT3JSZCA9IHNjaGVtZSQxMjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdUJ1R24gPSBQdUJ1R247XG5leHBvcnRzLnNjaGVtZVB1QnVHbiA9IHNjaGVtZSQxMztcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdUJ1ID0gUHVCdTtcbmV4cG9ydHMuc2NoZW1lUHVCdSA9IHNjaGVtZSQxNDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdVJkID0gUHVSZDtcbmV4cG9ydHMuc2NoZW1lUHVSZCA9IHNjaGVtZSQxNTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZFB1ID0gUmRQdTtcbmV4cG9ydHMuc2NoZW1lUmRQdSA9IHNjaGVtZSQxNjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbEduQnUgPSBZbEduQnU7XG5leHBvcnRzLnNjaGVtZVlsR25CdSA9IHNjaGVtZSQxNztcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbEduID0gWWxHbjtcbmV4cG9ydHMuc2NoZW1lWWxHbiA9IHNjaGVtZSQxODtcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbE9yQnIgPSBZbE9yQnI7XG5leHBvcnRzLnNjaGVtZVlsT3JCciA9IHNjaGVtZSQxOTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVZbE9yUmQgPSBZbE9yUmQ7XG5leHBvcnRzLnNjaGVtZVlsT3JSZCA9IHNjaGVtZSQyMDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVCbHVlcyA9IEJsdWVzO1xuZXhwb3J0cy5zY2hlbWVCbHVlcyA9IHNjaGVtZSQyMTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVHcmVlbnMgPSBHcmVlbnM7XG5leHBvcnRzLnNjaGVtZUdyZWVucyA9IHNjaGVtZSQyMjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVHcmV5cyA9IEdyZXlzO1xuZXhwb3J0cy5zY2hlbWVHcmV5cyA9IHNjaGVtZSQyMztcbmV4cG9ydHMuaW50ZXJwb2xhdGVQdXJwbGVzID0gUHVycGxlcztcbmV4cG9ydHMuc2NoZW1lUHVycGxlcyA9IHNjaGVtZSQyNDtcbmV4cG9ydHMuaW50ZXJwb2xhdGVSZWRzID0gUmVkcztcbmV4cG9ydHMuc2NoZW1lUmVkcyA9IHNjaGVtZSQyNTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVPcmFuZ2VzID0gT3JhbmdlcztcbmV4cG9ydHMuc2NoZW1lT3JhbmdlcyA9IHNjaGVtZSQyNjtcbmV4cG9ydHMuaW50ZXJwb2xhdGVDdWJlaGVsaXhEZWZhdWx0ID0gY3ViZWhlbGl4JDE7XG5leHBvcnRzLmludGVycG9sYXRlUmFpbmJvdyA9IHJhaW5ib3c7XG5leHBvcnRzLmludGVycG9sYXRlV2FybSA9IHdhcm07XG5leHBvcnRzLmludGVycG9sYXRlQ29vbCA9IGNvb2w7XG5leHBvcnRzLmludGVycG9sYXRlU2luZWJvdyA9IHNpbmVib3c7XG5leHBvcnRzLmludGVycG9sYXRlVmlyaWRpcyA9IHZpcmlkaXM7XG5leHBvcnRzLmludGVycG9sYXRlTWFnbWEgPSBtYWdtYTtcbmV4cG9ydHMuaW50ZXJwb2xhdGVJbmZlcm5vID0gaW5mZXJubztcbmV4cG9ydHMuaW50ZXJwb2xhdGVQbGFzbWEgPSBwbGFzbWE7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXNjYWxlLyBWZXJzaW9uIDIuMC4wLiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLWFycmF5JyksIHJlcXVpcmUoJ2QzLWNvbGxlY3Rpb24nKSwgcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKSwgcmVxdWlyZSgnZDMtZm9ybWF0JyksIHJlcXVpcmUoJ2QzLXRpbWUnKSwgcmVxdWlyZSgnZDMtdGltZS1mb3JtYXQnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLWFycmF5JywgJ2QzLWNvbGxlY3Rpb24nLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtZm9ybWF0JywgJ2QzLXRpbWUnLCAnZDMtdGltZS1mb3JtYXQnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNBcnJheSxkM0NvbGxlY3Rpb24sZDNJbnRlcnBvbGF0ZSxkM0Zvcm1hdCxkM1RpbWUsZDNUaW1lRm9ybWF0KSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlO1xuXG52YXIgbWFwJDEgPSBhcnJheS5tYXA7XG52YXIgc2xpY2UgPSBhcnJheS5zbGljZTtcblxudmFyIGltcGxpY2l0ID0ge25hbWU6IFwiaW1wbGljaXRcIn07XG5cbmZ1bmN0aW9uIG9yZGluYWwocmFuZ2UkJDEpIHtcbiAgdmFyIGluZGV4ID0gZDNDb2xsZWN0aW9uLm1hcCgpLFxuICAgICAgZG9tYWluID0gW10sXG4gICAgICB1bmtub3duID0gaW1wbGljaXQ7XG5cbiAgcmFuZ2UkJDEgPSByYW5nZSQkMSA9PSBudWxsID8gW10gOiBzbGljZS5jYWxsKHJhbmdlJCQxKTtcblxuICBmdW5jdGlvbiBzY2FsZShkKSB7XG4gICAgdmFyIGtleSA9IGQgKyBcIlwiLCBpID0gaW5kZXguZ2V0KGtleSk7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAodW5rbm93biAhPT0gaW1wbGljaXQpIHJldHVybiB1bmtub3duO1xuICAgICAgaW5kZXguc2V0KGtleSwgaSA9IGRvbWFpbi5wdXNoKGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlJCQxWyhpIC0gMSkgJSByYW5nZSQkMS5sZW5ndGhdO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdLCBpbmRleCA9IGQzQ29sbGVjdGlvbi5tYXAoKTtcbiAgICB2YXIgaSA9IC0xLCBuID0gXy5sZW5ndGgsIGQsIGtleTtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFpbmRleC5oYXMoa2V5ID0gKGQgPSBfW2ldKSArIFwiXCIpKSBpbmRleC5zZXQoa2V5LCBkb21haW4ucHVzaChkKSk7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSwgc2NhbGUpIDogcmFuZ2UkJDEuc2xpY2UoKTtcbiAgfTtcblxuICBzY2FsZS51bmtub3duID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHVua25vd24gPSBfLCBzY2FsZSkgOiB1bmtub3duO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gb3JkaW5hbCgpXG4gICAgICAgIC5kb21haW4oZG9tYWluKVxuICAgICAgICAucmFuZ2UocmFuZ2UkJDEpXG4gICAgICAgIC51bmtub3duKHVua25vd24pO1xuICB9O1xuXG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gYmFuZCgpIHtcbiAgdmFyIHNjYWxlID0gb3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbixcbiAgICAgIG9yZGluYWxSYW5nZSA9IHNjYWxlLnJhbmdlLFxuICAgICAgcmFuZ2UkJDEgPSBbMCwgMV0sXG4gICAgICBzdGVwLFxuICAgICAgYmFuZHdpZHRoLFxuICAgICAgcm91bmQgPSBmYWxzZSxcbiAgICAgIHBhZGRpbmdJbm5lciA9IDAsXG4gICAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgICAgYWxpZ24gPSAwLjU7XG5cbiAgZGVsZXRlIHNjYWxlLnVua25vd247XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgbiA9IGRvbWFpbigpLmxlbmd0aCxcbiAgICAgICAgcmV2ZXJzZSA9IHJhbmdlJCQxWzFdIDwgcmFuZ2UkJDFbMF0sXG4gICAgICAgIHN0YXJ0ID0gcmFuZ2UkJDFbcmV2ZXJzZSAtIDBdLFxuICAgICAgICBzdG9wID0gcmFuZ2UkJDFbMSAtIHJldmVyc2VdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KDEsIG4gLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyKTtcbiAgICBpZiAocm91bmQpIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIHN0YXJ0ICs9IChzdG9wIC0gc3RhcnQgLSBzdGVwICogKG4gLSBwYWRkaW5nSW5uZXIpKSAqIGFsaWduO1xuICAgIGJhbmR3aWR0aCA9IHN0ZXAgKiAoMSAtIHBhZGRpbmdJbm5lcik7XG4gICAgaWYgKHJvdW5kKSBzdGFydCA9IE1hdGgucm91bmQoc3RhcnQpLCBiYW5kd2lkdGggPSBNYXRoLnJvdW5kKGJhbmR3aWR0aCk7XG4gICAgdmFyIHZhbHVlcyA9IGQzQXJyYXkucmFuZ2UobikubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIHN0YXJ0ICsgc3RlcCAqIGk7IH0pO1xuICAgIHJldHVybiBvcmRpbmFsUmFuZ2UocmV2ZXJzZSA/IHZhbHVlcy5yZXZlcnNlKCkgOiB2YWx1ZXMpO1xuICB9XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbihfKSwgcmVzY2FsZSgpKSA6IGRvbWFpbigpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gWytfWzBdLCArX1sxXV0sIHJlc2NhbGUoKSkgOiByYW5nZSQkMS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlUm91bmQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIHJhbmdlJCQxID0gWytfWzBdLCArX1sxXV0sIHJvdW5kID0gdHJ1ZSwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmJhbmR3aWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kd2lkdGg7XG4gIH07XG5cbiAgc2NhbGUuc3RlcCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzdGVwO1xuICB9O1xuXG4gIHNjYWxlLnJvdW5kID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJvdW5kID0gISFfLCByZXNjYWxlKCkpIDogcm91bmQ7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nSW5uZXIgPSBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSksIHJlc2NhbGUoKSkgOiBwYWRkaW5nSW5uZXI7XG4gIH07XG5cbiAgc2NhbGUucGFkZGluZ0lubmVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZGRpbmdJbm5lciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKSwgcmVzY2FsZSgpKSA6IHBhZGRpbmdJbm5lcjtcbiAgfTtcblxuICBzY2FsZS5wYWRkaW5nT3V0ZXIgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkZGluZ091dGVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogcGFkZGluZ091dGVyO1xuICB9O1xuXG4gIHNjYWxlLmFsaWduID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpLCByZXNjYWxlKCkpIDogYWxpZ247XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBiYW5kKClcbiAgICAgICAgLmRvbWFpbihkb21haW4oKSlcbiAgICAgICAgLnJhbmdlKHJhbmdlJCQxKVxuICAgICAgICAucm91bmQocm91bmQpXG4gICAgICAgIC5wYWRkaW5nSW5uZXIocGFkZGluZ0lubmVyKVxuICAgICAgICAucGFkZGluZ091dGVyKHBhZGRpbmdPdXRlcilcbiAgICAgICAgLmFsaWduKGFsaWduKTtcbiAgfTtcblxuICByZXR1cm4gcmVzY2FsZSgpO1xufVxuXG5mdW5jdGlvbiBwb2ludGlzaChzY2FsZSkge1xuICB2YXIgY29weSA9IHNjYWxlLmNvcHk7XG5cbiAgc2NhbGUucGFkZGluZyA9IHNjYWxlLnBhZGRpbmdPdXRlcjtcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdJbm5lcjtcbiAgZGVsZXRlIHNjYWxlLnBhZGRpbmdPdXRlcjtcblxuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHBvaW50aXNoKGNvcHkoKSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudCh4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbnVtYmVyKHgpIHtcbiAgcmV0dXJuICt4O1xufVxuXG52YXIgdW5pdCA9IFswLCAxXTtcblxuZnVuY3Rpb24gZGVpbnRlcnBvbGF0ZUxpbmVhcihhLCBiKSB7XG4gIHJldHVybiAoYiAtPSAoYSA9ICthKSlcbiAgICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gKHggLSBhKSAvIGI7IH1cbiAgICAgIDogY29uc3RhbnQoYik7XG59XG5cbmZ1bmN0aW9uIGRlaW50ZXJwb2xhdGVDbGFtcChkZWludGVycG9sYXRlKSB7XG4gIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIGQgPSBkZWludGVycG9sYXRlKGEgPSArYSwgYiA9ICtiKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeCkgeyByZXR1cm4geCA8PSBhID8gMCA6IHggPj0gYiA/IDEgOiBkKHgpOyB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiByZWludGVycG9sYXRlQ2xhbXAocmVpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByID0gcmVpbnRlcnBvbGF0ZShhID0gK2EsIGIgPSArYik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHsgcmV0dXJuIHQgPD0gMCA/IGEgOiB0ID49IDEgPyBiIDogcih0KTsgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYmltYXAoZG9tYWluLCByYW5nZSQkMSwgZGVpbnRlcnBvbGF0ZSwgcmVpbnRlcnBvbGF0ZSkge1xuICB2YXIgZDAgPSBkb21haW5bMF0sIGQxID0gZG9tYWluWzFdLCByMCA9IHJhbmdlJCQxWzBdLCByMSA9IHJhbmdlJCQxWzFdO1xuICBpZiAoZDEgPCBkMCkgZDAgPSBkZWludGVycG9sYXRlKGQxLCBkMCksIHIwID0gcmVpbnRlcnBvbGF0ZShyMSwgcjApO1xuICBlbHNlIGQwID0gZGVpbnRlcnBvbGF0ZShkMCwgZDEpLCByMCA9IHJlaW50ZXJwb2xhdGUocjAsIHIxKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHIwKGQwKHgpKTsgfTtcbn1cblxuZnVuY3Rpb24gcG9seW1hcChkb21haW4sIHJhbmdlJCQxLCBkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBqID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoKSAtIDEsXG4gICAgICBkID0gbmV3IEFycmF5KGopLFxuICAgICAgciA9IG5ldyBBcnJheShqKSxcbiAgICAgIGkgPSAtMTtcblxuICAvLyBSZXZlcnNlIGRlc2NlbmRpbmcgZG9tYWlucy5cbiAgaWYgKGRvbWFpbltqXSA8IGRvbWFpblswXSkge1xuICAgIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpLnJldmVyc2UoKTtcbiAgICByYW5nZSQkMSA9IHJhbmdlJCQxLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB9XG5cbiAgd2hpbGUgKCsraSA8IGopIHtcbiAgICBkW2ldID0gZGVpbnRlcnBvbGF0ZShkb21haW5baV0sIGRvbWFpbltpICsgMV0pO1xuICAgIHJbaV0gPSByZWludGVycG9sYXRlKHJhbmdlJCQxW2ldLCByYW5nZSQkMVtpICsgMV0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaSA9IGQzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMSwgaikgLSAxO1xuICAgIHJldHVybiByW2ldKGRbaV0oeCkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjb3B5KHNvdXJjZSwgdGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXRcbiAgICAgIC5kb21haW4oc291cmNlLmRvbWFpbigpKVxuICAgICAgLnJhbmdlKHNvdXJjZS5yYW5nZSgpKVxuICAgICAgLmludGVycG9sYXRlKHNvdXJjZS5pbnRlcnBvbGF0ZSgpKVxuICAgICAgLmNsYW1wKHNvdXJjZS5jbGFtcCgpKTtcbn1cblxuLy8gZGVpbnRlcnBvbGF0ZShhLCBiKSh4KSB0YWtlcyBhIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlciB0IGluIFswLDFdLlxuLy8gcmVpbnRlcnBvbGF0ZShhLCBiKSh0KSB0YWtlcyBhIHBhcmFtZXRlciB0IGluIFswLDFdIGFuZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGRvbWFpbiB2YWx1ZSB4IGluIFthLGJdLlxuZnVuY3Rpb24gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKSB7XG4gIHZhciBkb21haW4gPSB1bml0LFxuICAgICAgcmFuZ2UkJDEgPSB1bml0LFxuICAgICAgaW50ZXJwb2xhdGUkJDEgPSBkM0ludGVycG9sYXRlLmludGVycG9sYXRlLFxuICAgICAgY2xhbXAgPSBmYWxzZSxcbiAgICAgIHBpZWNld2lzZSxcbiAgICAgIG91dHB1dCxcbiAgICAgIGlucHV0O1xuXG4gIGZ1bmN0aW9uIHJlc2NhbGUoKSB7XG4gICAgcGllY2V3aXNlID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoKSA+IDIgPyBwb2x5bWFwIDogYmltYXA7XG4gICAgb3V0cHV0ID0gaW5wdXQgPSBudWxsO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gKG91dHB1dCB8fCAob3V0cHV0ID0gcGllY2V3aXNlKGRvbWFpbiwgcmFuZ2UkJDEsIGNsYW1wID8gZGVpbnRlcnBvbGF0ZUNsYW1wKGRlaW50ZXJwb2xhdGUpIDogZGVpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGUkJDEpKSkoK3gpO1xuICB9XG5cbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiAoaW5wdXQgfHwgKGlucHV0ID0gcGllY2V3aXNlKHJhbmdlJCQxLCBkb21haW4sIGRlaW50ZXJwb2xhdGVMaW5lYXIsIGNsYW1wID8gcmVpbnRlcnBvbGF0ZUNsYW1wKHJlaW50ZXJwb2xhdGUpIDogcmVpbnRlcnBvbGF0ZSkpKSgreSk7XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRvbWFpbiA9IG1hcCQxLmNhbGwoXywgbnVtYmVyKSwgcmVzY2FsZSgpKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSwgcmVzY2FsZSgpKSA6IHJhbmdlJCQxLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gcmFuZ2UkJDEgPSBzbGljZS5jYWxsKF8pLCBpbnRlcnBvbGF0ZSQkMSA9IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSb3VuZCwgcmVzY2FsZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNsYW1wID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsYW1wID0gISFfLCByZXNjYWxlKCkpIDogY2xhbXA7XG4gIH07XG5cbiAgc2NhbGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW50ZXJwb2xhdGUkJDEgPSBfLCByZXNjYWxlKCkpIDogaW50ZXJwb2xhdGUkJDE7XG4gIH07XG5cbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cblxuZnVuY3Rpb24gdGlja0Zvcm1hdChkb21haW4sIGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgdmFyIHN0YXJ0ID0gZG9tYWluWzBdLFxuICAgICAgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV0sXG4gICAgICBzdGVwID0gZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQgPT0gbnVsbCA/IDEwIDogY291bnQpLFxuICAgICAgcHJlY2lzaW9uO1xuICBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyBcIixmXCIgOiBzcGVjaWZpZXIpO1xuICBzd2l0Y2ggKHNwZWNpZmllci50eXBlKSB7XG4gICAgY2FzZSBcInNcIjoge1xuICAgICAgdmFyIHZhbHVlID0gTWF0aC5tYXgoTWF0aC5hYnMoc3RhcnQpLCBNYXRoLmFicyhzdG9wKSk7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25QcmVmaXgoc3RlcCwgdmFsdWUpKSkgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgIHJldHVybiBkM0Zvcm1hdC5mb3JtYXRQcmVmaXgoc3BlY2lmaWVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIGNhc2UgXCJcIjpcbiAgICBjYXNlIFwiZVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwiclwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25Sb3VuZChzdGVwLCBNYXRoLm1heChNYXRoLmFicyhzdGFydCksIE1hdGguYWJzKHN0b3ApKSkpKSBzcGVjaWZpZXIucHJlY2lzaW9uID0gcHJlY2lzaW9uIC0gKHNwZWNpZmllci50eXBlID09PSBcImVcIik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImZcIjpcbiAgICBjYXNlIFwiJVwiOiB7XG4gICAgICBpZiAoc3BlY2lmaWVyLnByZWNpc2lvbiA9PSBudWxsICYmICFpc05hTihwcmVjaXNpb24gPSBkM0Zvcm1hdC5wcmVjaXNpb25GaXhlZChzdGVwKSkpIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09IFwiJVwiKSAqIDI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGQzRm9ybWF0LmZvcm1hdChzcGVjaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBsaW5lYXJpc2goc2NhbGUpIHtcbiAgdmFyIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICBzY2FsZS50aWNrcyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGQgPSBkb21haW4oKTtcbiAgICByZXR1cm4gZDNBcnJheS50aWNrcyhkWzBdLCBkW2QubGVuZ3RoIC0gMV0sIGNvdW50ID09IG51bGwgPyAxMCA6IGNvdW50KTtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiB0aWNrRm9ybWF0KGRvbWFpbigpLCBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gbnVsbCkgY291bnQgPSAxMDtcblxuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIGkwID0gMCxcbiAgICAgICAgaTEgPSBkLmxlbmd0aCAtIDEsXG4gICAgICAgIHN0YXJ0ID0gZFtpMF0sXG4gICAgICAgIHN0b3AgPSBkW2kxXSxcbiAgICAgICAgc3RlcDtcblxuICAgIGlmIChzdG9wIDwgc3RhcnQpIHtcbiAgICAgIHN0ZXAgPSBzdGFydCwgc3RhcnQgPSBzdG9wLCBzdG9wID0gc3RlcDtcbiAgICAgIHN0ZXAgPSBpMCwgaTAgPSBpMSwgaTEgPSBzdGVwO1xuICAgIH1cblxuICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcblxuICAgIGlmIChzdGVwID4gMCkge1xuICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKHN0YXJ0IC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguY2VpbChzdG9wIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgc3RlcCA9IGQzQXJyYXkudGlja0luY3JlbWVudChzdGFydCwgc3RvcCwgY291bnQpO1xuICAgIH0gZWxzZSBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5jZWlsKHN0YXJ0ICogc3RlcCkgLyBzdGVwO1xuICAgICAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIHN0ZXAgPSBkM0FycmF5LnRpY2tJbmNyZW1lbnQoc3RhcnQsIHN0b3AsIGNvdW50KTtcbiAgICB9XG5cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgIGRbaTBdID0gTWF0aC5mbG9vcihzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgICAgIGRbaTFdID0gTWF0aC5jZWlsKHN0b3AgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICBkb21haW4oZCk7XG4gICAgfSBlbHNlIGlmIChzdGVwIDwgMCkge1xuICAgICAgZFtpMF0gPSBNYXRoLmNlaWwoc3RhcnQgKiBzdGVwKSAvIHN0ZXA7XG4gICAgICBkW2kxXSA9IE1hdGguZmxvb3Ioc3RvcCAqIHN0ZXApIC8gc3RlcDtcbiAgICAgIGRvbWFpbihkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBsaW5lYXIoKSB7XG4gIHZhciBzY2FsZSA9IGNvbnRpbnVvdXMoZGVpbnRlcnBvbGF0ZUxpbmVhciwgZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZU51bWJlcik7XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBjb3B5KHNjYWxlLCBsaW5lYXIoKSk7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICB2YXIgZG9tYWluID0gWzAsIDFdO1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHgpIHtcbiAgICByZXR1cm4gK3g7XG4gIH1cblxuICBzY2FsZS5pbnZlcnQgPSBzY2FsZTtcblxuICBzY2FsZS5kb21haW4gPSBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBtYXAkMS5jYWxsKF8sIG51bWJlciksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRlbnRpdHkoKS5kb21haW4oZG9tYWluKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gbmljZShkb21haW4sIGludGVydmFsKSB7XG4gIGRvbWFpbiA9IGRvbWFpbi5zbGljZSgpO1xuXG4gIHZhciBpMCA9IDAsXG4gICAgICBpMSA9IGRvbWFpbi5sZW5ndGggLSAxLFxuICAgICAgeDAgPSBkb21haW5baTBdLFxuICAgICAgeDEgPSBkb21haW5baTFdLFxuICAgICAgdDtcblxuICBpZiAoeDEgPCB4MCkge1xuICAgIHQgPSBpMCwgaTAgPSBpMSwgaTEgPSB0O1xuICAgIHQgPSB4MCwgeDAgPSB4MSwgeDEgPSB0O1xuICB9XG5cbiAgZG9tYWluW2kwXSA9IGludGVydmFsLmZsb29yKHgwKTtcbiAgZG9tYWluW2kxXSA9IGludGVydmFsLmNlaWwoeDEpO1xuICByZXR1cm4gZG9tYWluO1xufVxuXG5mdW5jdGlvbiBkZWludGVycG9sYXRlKGEsIGIpIHtcbiAgcmV0dXJuIChiID0gTWF0aC5sb2coYiAvIGEpKVxuICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiBNYXRoLmxvZyh4IC8gYSkgLyBiOyB9XG4gICAgICA6IGNvbnN0YW50KGIpO1xufVxuXG5mdW5jdGlvbiByZWludGVycG9sYXRlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCAwXG4gICAgICA/IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIC1NYXRoLnBvdygtYiwgdCkgKiBNYXRoLnBvdygtYSwgMSAtIHQpOyB9XG4gICAgICA6IGZ1bmN0aW9uKHQpIHsgcmV0dXJuIE1hdGgucG93KGIsIHQpICogTWF0aC5wb3coYSwgMSAtIHQpOyB9O1xufVxuXG5mdW5jdGlvbiBwb3cxMCh4KSB7XG4gIHJldHVybiBpc0Zpbml0ZSh4KSA/ICsoXCIxZVwiICsgeCkgOiB4IDwgMCA/IDAgOiB4O1xufVxuXG5mdW5jdGlvbiBwb3dwKGJhc2UpIHtcbiAgcmV0dXJuIGJhc2UgPT09IDEwID8gcG93MTBcbiAgICAgIDogYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5leHBcbiAgICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5wb3coYmFzZSwgeCk7IH07XG59XG5cbmZ1bmN0aW9uIGxvZ3AoYmFzZSkge1xuICByZXR1cm4gYmFzZSA9PT0gTWF0aC5FID8gTWF0aC5sb2dcbiAgICAgIDogYmFzZSA9PT0gMTAgJiYgTWF0aC5sb2cxMFxuICAgICAgfHwgYmFzZSA9PT0gMiAmJiBNYXRoLmxvZzJcbiAgICAgIHx8IChiYXNlID0gTWF0aC5sb2coYmFzZSksIGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpIC8gYmFzZTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJlZmxlY3QoZikge1xuICByZXR1cm4gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAtZigteCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlLCByZWludGVycG9sYXRlKS5kb21haW4oWzEsIDEwXSksXG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgICBiYXNlID0gMTAsXG4gICAgICBsb2dzID0gbG9ncCgxMCksXG4gICAgICBwb3dzID0gcG93cCgxMCk7XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBsb2dzID0gbG9ncChiYXNlKSwgcG93cyA9IHBvd3AoYmFzZSk7XG4gICAgaWYgKGRvbWFpbigpWzBdIDwgMCkgbG9ncyA9IHJlZmxlY3QobG9ncyksIHBvd3MgPSByZWZsZWN0KHBvd3MpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmJhc2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYmFzZSA9ICtfLCByZXNjYWxlKCkpIDogYmFzZTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZG9tYWluKF8pLCByZXNjYWxlKCkpIDogZG9tYWluKCk7XG4gIH07XG5cbiAgc2NhbGUudGlja3MgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBkID0gZG9tYWluKCksXG4gICAgICAgIHUgPSBkWzBdLFxuICAgICAgICB2ID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByO1xuXG4gICAgaWYgKHIgPSB2IDwgdSkgaSA9IHUsIHUgPSB2LCB2ID0gaTtcblxuICAgIHZhciBpID0gbG9ncyh1KSxcbiAgICAgICAgaiA9IGxvZ3ModiksXG4gICAgICAgIHAsXG4gICAgICAgIGssXG4gICAgICAgIHQsXG4gICAgICAgIG4gPSBjb3VudCA9PSBudWxsID8gMTAgOiArY291bnQsXG4gICAgICAgIHogPSBbXTtcblxuICAgIGlmICghKGJhc2UgJSAxKSAmJiBqIC0gaSA8IG4pIHtcbiAgICAgIGkgPSBNYXRoLnJvdW5kKGkpIC0gMSwgaiA9IE1hdGgucm91bmQoaikgKyAxO1xuICAgICAgaWYgKHUgPiAwKSBmb3IgKDsgaSA8IGo7ICsraSkge1xuICAgICAgICBmb3IgKGsgPSAxLCBwID0gcG93cyhpKTsgayA8IGJhc2U7ICsraykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgZm9yICg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgZm9yIChrID0gYmFzZSAtIDEsIHAgPSBwb3dzKGkpOyBrID49IDE7IC0taykge1xuICAgICAgICAgIHQgPSBwICogaztcbiAgICAgICAgICBpZiAodCA8IHUpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmICh0ID4gdikgYnJlYWs7XG4gICAgICAgICAgei5wdXNoKHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHogPSBkM0FycmF5LnRpY2tzKGksIGosIE1hdGgubWluKGogLSBpLCBuKSkubWFwKHBvd3MpO1xuICAgIH1cblxuICAgIHJldHVybiByID8gei5yZXZlcnNlKCkgOiB6O1xuICB9O1xuXG4gIHNjYWxlLnRpY2tGb3JtYXQgPSBmdW5jdGlvbihjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgaWYgKHNwZWNpZmllciA9PSBudWxsKSBzcGVjaWZpZXIgPSBiYXNlID09PSAxMCA/IFwiLjBlXCIgOiBcIixcIjtcbiAgICBpZiAodHlwZW9mIHNwZWNpZmllciAhPT0gXCJmdW5jdGlvblwiKSBzcGVjaWZpZXIgPSBkM0Zvcm1hdC5mb3JtYXQoc3BlY2lmaWVyKTtcbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gc3BlY2lmaWVyO1xuICAgIGlmIChjb3VudCA9PSBudWxsKSBjb3VudCA9IDEwO1xuICAgIHZhciBrID0gTWF0aC5tYXgoMSwgYmFzZSAqIGNvdW50IC8gc2NhbGUudGlja3MoKS5sZW5ndGgpOyAvLyBUT0RPIGZhc3QgZXN0aW1hdGU/XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGQpIHtcbiAgICAgIHZhciBpID0gZCAvIHBvd3MoTWF0aC5yb3VuZChsb2dzKGQpKSk7XG4gICAgICBpZiAoaSAqIGJhc2UgPCBiYXNlIC0gMC41KSBpICo9IGJhc2U7XG4gICAgICByZXR1cm4gaSA8PSBrID8gc3BlY2lmaWVyKGQpIDogXCJcIjtcbiAgICB9O1xuICB9O1xuXG4gIHNjYWxlLm5pY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZG9tYWluKG5pY2UoZG9tYWluKCksIHtcbiAgICAgIGZsb29yOiBmdW5jdGlvbih4KSB7IHJldHVybiBwb3dzKE1hdGguZmxvb3IobG9ncyh4KSkpOyB9LFxuICAgICAgY2VpbDogZnVuY3Rpb24oeCkgeyByZXR1cm4gcG93cyhNYXRoLmNlaWwobG9ncyh4KSkpOyB9XG4gICAgfSkpO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgbG9nKCkuYmFzZShiYXNlKSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiByYWlzZSh4LCBleHBvbmVudCkge1xuICByZXR1cm4geCA8IDAgPyAtTWF0aC5wb3coLXgsIGV4cG9uZW50KSA6IE1hdGgucG93KHgsIGV4cG9uZW50KTtcbn1cblxuZnVuY3Rpb24gcG93KCkge1xuICB2YXIgZXhwb25lbnQgPSAxLFxuICAgICAgc2NhbGUgPSBjb250aW51b3VzKGRlaW50ZXJwb2xhdGUsIHJlaW50ZXJwb2xhdGUpLFxuICAgICAgZG9tYWluID0gc2NhbGUuZG9tYWluO1xuXG4gIGZ1bmN0aW9uIGRlaW50ZXJwb2xhdGUoYSwgYikge1xuICAgIHJldHVybiAoYiA9IHJhaXNlKGIsIGV4cG9uZW50KSAtIChhID0gcmFpc2UoYSwgZXhwb25lbnQpKSlcbiAgICAgICAgPyBmdW5jdGlvbih4KSB7IHJldHVybiAocmFpc2UoeCwgZXhwb25lbnQpIC0gYSkgLyBiOyB9XG4gICAgICAgIDogY29uc3RhbnQoYik7XG4gIH1cblxuICBmdW5jdGlvbiByZWludGVycG9sYXRlKGEsIGIpIHtcbiAgICBiID0gcmFpc2UoYiwgZXhwb25lbnQpIC0gKGEgPSByYWlzZShhLCBleHBvbmVudCkpO1xuICAgIHJldHVybiBmdW5jdGlvbih0KSB7IHJldHVybiByYWlzZShhICsgYiAqIHQsIDEgLyBleHBvbmVudCk7IH07XG4gIH1cblxuICBzY2FsZS5leHBvbmVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHBvbmVudCA9ICtfLCBkb21haW4oZG9tYWluKCkpKSA6IGV4cG9uZW50O1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgcG93KCkuZXhwb25lbnQoZXhwb25lbnQpKTtcbiAgfTtcblxuICByZXR1cm4gbGluZWFyaXNoKHNjYWxlKTtcbn1cblxuZnVuY3Rpb24gc3FydCgpIHtcbiAgcmV0dXJuIHBvdygpLmV4cG9uZW50KDAuNSk7XG59XG5cbmZ1bmN0aW9uIHF1YW50aWxlJDEoKSB7XG4gIHZhciBkb21haW4gPSBbXSxcbiAgICAgIHJhbmdlJCQxID0gW10sXG4gICAgICB0aHJlc2hvbGRzID0gW107XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IDAsIG4gPSBNYXRoLm1heCgxLCByYW5nZSQkMS5sZW5ndGgpO1xuICAgIHRocmVzaG9sZHMgPSBuZXcgQXJyYXkobiAtIDEpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB0aHJlc2hvbGRzW2kgLSAxXSA9IGQzQXJyYXkucXVhbnRpbGUoZG9tYWluLCBpIC8gbik7XG4gICAgcmV0dXJuIHNjYWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICghaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHJhbmdlJCQxW2QzQXJyYXkuYmlzZWN0KHRocmVzaG9sZHMsIHgpXTtcbiAgfVxuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlJCQxLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXSA6IFtcbiAgICAgIGkgPiAwID8gdGhyZXNob2xkc1tpIC0gMV0gOiBkb21haW5bMF0sXG4gICAgICBpIDwgdGhyZXNob2xkcy5sZW5ndGggPyB0aHJlc2hvbGRzW2ldIDogZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXVxuICAgIF07XG4gIH07XG5cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oXykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGRvbWFpbi5zbGljZSgpO1xuICAgIGRvbWFpbiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gXy5sZW5ndGgsIGQ7IGkgPCBuOyArK2kpIGlmIChkID0gX1tpXSwgZCAhPSBudWxsICYmICFpc05hTihkID0gK2QpKSBkb21haW4ucHVzaChkKTtcbiAgICBkb21haW4uc29ydChkM0FycmF5LmFzY2VuZGluZyk7XG4gICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgfTtcblxuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5nZSQkMSA9IHNsaWNlLmNhbGwoXyksIHJlc2NhbGUoKSkgOiByYW5nZSQkMS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnF1YW50aWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aHJlc2hvbGRzLnNsaWNlKCk7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxdWFudGlsZSQxKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBxdWFudGl6ZSgpIHtcbiAgdmFyIHgwID0gMCxcbiAgICAgIHgxID0gMSxcbiAgICAgIG4gPSAxLFxuICAgICAgZG9tYWluID0gWzAuNV0sXG4gICAgICByYW5nZSQkMSA9IFswLCAxXTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgaWYgKHggPD0geCkgcmV0dXJuIHJhbmdlJCQxW2QzQXJyYXkuYmlzZWN0KGRvbWFpbiwgeCwgMCwgbildO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIGRvbWFpbiA9IG5ldyBBcnJheShuKTtcbiAgICB3aGlsZSAoKytpIDwgbikgZG9tYWluW2ldID0gKChpICsgMSkgKiB4MSAtIChpIC0gbikgKiB4MCkgLyAobiArIDEpO1xuICAgIHJldHVybiBzY2FsZTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MCA9ICtfWzBdLCB4MSA9ICtfWzFdLCByZXNjYWxlKCkpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAobiA9IChyYW5nZSQkMSA9IHNsaWNlLmNhbGwoXykpLmxlbmd0aCAtIDEsIHJlc2NhbGUoKSkgOiByYW5nZSQkMS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlJCQxLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIGkgPCAwID8gW05hTiwgTmFOXVxuICAgICAgICA6IGkgPCAxID8gW3gwLCBkb21haW5bMF1dXG4gICAgICAgIDogaSA+PSBuID8gW2RvbWFpbltuIC0gMV0sIHgxXVxuICAgICAgICA6IFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhbnRpemUoKVxuICAgICAgICAuZG9tYWluKFt4MCwgeDFdKVxuICAgICAgICAucmFuZ2UocmFuZ2UkJDEpO1xuICB9O1xuXG4gIHJldHVybiBsaW5lYXJpc2goc2NhbGUpO1xufVxuXG5mdW5jdGlvbiB0aHJlc2hvbGQoKSB7XG4gIHZhciBkb21haW4gPSBbMC41XSxcbiAgICAgIHJhbmdlJCQxID0gWzAsIDFdLFxuICAgICAgbiA9IDE7XG5cbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIGlmICh4IDw9IHgpIHJldHVybiByYW5nZSQkMVtkM0FycmF5LmJpc2VjdChkb21haW4sIHgsIDAsIG4pXTtcbiAgfVxuXG4gIHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkb21haW4gPSBzbGljZS5jYWxsKF8pLCBuID0gTWF0aC5taW4oZG9tYWluLmxlbmd0aCwgcmFuZ2UkJDEubGVuZ3RoIC0gMSksIHNjYWxlKSA6IGRvbWFpbi5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLnJhbmdlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmdlJCQxID0gc2xpY2UuY2FsbChfKSwgbiA9IE1hdGgubWluKGRvbWFpbi5sZW5ndGgsIHJhbmdlJCQxLmxlbmd0aCAtIDEpLCBzY2FsZSkgOiByYW5nZSQkMS5zbGljZSgpO1xuICB9O1xuXG4gIHNjYWxlLmludmVydEV4dGVudCA9IGZ1bmN0aW9uKHkpIHtcbiAgICB2YXIgaSA9IHJhbmdlJCQxLmluZGV4T2YoeSk7XG4gICAgcmV0dXJuIFtkb21haW5baSAtIDFdLCBkb21haW5baV1dO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhyZXNob2xkKClcbiAgICAgICAgLmRvbWFpbihkb21haW4pXG4gICAgICAgIC5yYW5nZShyYW5nZSQkMSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjYWxlO1xufVxuXG52YXIgZHVyYXRpb25TZWNvbmQgPSAxMDAwO1xudmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbnZhciBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xudmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG52YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xudmFyIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xudmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG5mdW5jdGlvbiBkYXRlKHQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKHQpO1xufVxuXG5mdW5jdGlvbiBudW1iZXIkMSh0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgRGF0ZSA/ICt0IDogK25ldyBEYXRlKCt0KTtcbn1cblxuZnVuY3Rpb24gY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQkJDEpIHtcbiAgdmFyIHNjYWxlID0gY29udGludW91cyhkZWludGVycG9sYXRlTGluZWFyLCBkM0ludGVycG9sYXRlLmludGVycG9sYXRlTnVtYmVyKSxcbiAgICAgIGludmVydCA9IHNjYWxlLmludmVydCxcbiAgICAgIGRvbWFpbiA9IHNjYWxlLmRvbWFpbjtcblxuICB2YXIgZm9ybWF0TWlsbGlzZWNvbmQgPSBmb3JtYXQkJDEoXCIuJUxcIiksXG4gICAgICBmb3JtYXRTZWNvbmQgPSBmb3JtYXQkJDEoXCI6JVNcIiksXG4gICAgICBmb3JtYXRNaW51dGUgPSBmb3JtYXQkJDEoXCIlSTolTVwiKSxcbiAgICAgIGZvcm1hdEhvdXIgPSBmb3JtYXQkJDEoXCIlSSAlcFwiKSxcbiAgICAgIGZvcm1hdERheSA9IGZvcm1hdCQkMShcIiVhICVkXCIpLFxuICAgICAgZm9ybWF0V2VlayA9IGZvcm1hdCQkMShcIiViICVkXCIpLFxuICAgICAgZm9ybWF0TW9udGggPSBmb3JtYXQkJDEoXCIlQlwiKSxcbiAgICAgIGZvcm1hdFllYXIgPSBmb3JtYXQkJDEoXCIlWVwiKTtcblxuICB2YXIgdGlja0ludGVydmFscyA9IFtcbiAgICBbc2Vjb25kLCAgMSwgICAgICBkdXJhdGlvblNlY29uZF0sXG4gICAgW3NlY29uZCwgIDUsICA1ICogZHVyYXRpb25TZWNvbmRdLFxuICAgIFtzZWNvbmQsIDE1LCAxNSAqIGR1cmF0aW9uU2Vjb25kXSxcbiAgICBbc2Vjb25kLCAzMCwgMzAgKiBkdXJhdGlvblNlY29uZF0sXG4gICAgW21pbnV0ZSwgIDEsICAgICAgZHVyYXRpb25NaW51dGVdLFxuICAgIFttaW51dGUsICA1LCAgNSAqIGR1cmF0aW9uTWludXRlXSxcbiAgICBbbWludXRlLCAxNSwgMTUgKiBkdXJhdGlvbk1pbnV0ZV0sXG4gICAgW21pbnV0ZSwgMzAsIDMwICogZHVyYXRpb25NaW51dGVdLFxuICAgIFsgIGhvdXIsICAxLCAgICAgIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICBob3VyLCAgMywgIDMgKiBkdXJhdGlvbkhvdXIgIF0sXG4gICAgWyAgaG91ciwgIDYsICA2ICogZHVyYXRpb25Ib3VyICBdLFxuICAgIFsgIGhvdXIsIDEyLCAxMiAqIGR1cmF0aW9uSG91ciAgXSxcbiAgICBbICAgZGF5LCAgMSwgICAgICBkdXJhdGlvbkRheSAgIF0sXG4gICAgWyAgIGRheSwgIDIsICAyICogZHVyYXRpb25EYXkgICBdLFxuICAgIFsgIHdlZWssICAxLCAgICAgIGR1cmF0aW9uV2VlayAgXSxcbiAgICBbIG1vbnRoLCAgMSwgICAgICBkdXJhdGlvbk1vbnRoIF0sXG4gICAgWyBtb250aCwgIDMsICAzICogZHVyYXRpb25Nb250aCBdLFxuICAgIFsgIHllYXIsICAxLCAgICAgIGR1cmF0aW9uWWVhciAgXVxuICBdO1xuXG4gIGZ1bmN0aW9uIHRpY2tGb3JtYXQoZGF0ZSkge1xuICAgIHJldHVybiAoc2Vjb25kKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdE1pbGxpc2Vjb25kXG4gICAgICAgIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IGZvcm1hdFNlY29uZFxuICAgICAgICA6IGhvdXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TWludXRlXG4gICAgICAgIDogZGF5KGRhdGUpIDwgZGF0ZSA/IGZvcm1hdEhvdXJcbiAgICAgICAgOiBtb250aChkYXRlKSA8IGRhdGUgPyAod2VlayhkYXRlKSA8IGRhdGUgPyBmb3JtYXREYXkgOiBmb3JtYXRXZWVrKVxuICAgICAgICA6IHllYXIoZGF0ZSkgPCBkYXRlID8gZm9ybWF0TW9udGhcbiAgICAgICAgOiBmb3JtYXRZZWFyKShkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbCkgaW50ZXJ2YWwgPSAxMDtcblxuICAgIC8vIElmIGEgZGVzaXJlZCB0aWNrIGNvdW50IGlzIHNwZWNpZmllZCwgcGljayBhIHJlYXNvbmFibGUgdGljayBpbnRlcnZhbFxuICAgIC8vIGJhc2VkIG9uIHRoZSBleHRlbnQgb2YgdGhlIGRvbWFpbiBhbmQgYSByb3VnaCBlc3RpbWF0ZSBvZiB0aWNrIHNpemUuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3N1bWUgaW50ZXJ2YWwgaXMgYWxyZWFkeSBhIHRpbWUgaW50ZXJ2YWwgYW5kIHVzZSBpdC5cbiAgICBpZiAodHlwZW9mIGludGVydmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIGludGVydmFsLFxuICAgICAgICAgIGkgPSBkM0FycmF5LmJpc2VjdG9yKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGlbMl07IH0pLnJpZ2h0KHRpY2tJbnRlcnZhbHMsIHRhcmdldCk7XG4gICAgICBpZiAoaSA9PT0gdGlja0ludGVydmFscy5sZW5ndGgpIHtcbiAgICAgICAgc3RlcCA9IGQzQXJyYXkudGlja1N0ZXAoc3RhcnQgLyBkdXJhdGlvblllYXIsIHN0b3AgLyBkdXJhdGlvblllYXIsIGludGVydmFsKTtcbiAgICAgICAgaW50ZXJ2YWwgPSB5ZWFyO1xuICAgICAgfSBlbHNlIGlmIChpKSB7XG4gICAgICAgIGkgPSB0aWNrSW50ZXJ2YWxzW3RhcmdldCAvIHRpY2tJbnRlcnZhbHNbaSAtIDFdWzJdIDwgdGlja0ludGVydmFsc1tpXVsyXSAvIHRhcmdldCA/IGkgLSAxIDogaV07XG4gICAgICAgIHN0ZXAgPSBpWzFdO1xuICAgICAgICBpbnRlcnZhbCA9IGlbMF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGVwID0gTWF0aC5tYXgoZDNBcnJheS50aWNrU3RlcChzdGFydCwgc3RvcCwgaW50ZXJ2YWwpLCAxKTtcbiAgICAgICAgaW50ZXJ2YWwgPSBtaWxsaXNlY29uZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RlcCA9PSBudWxsID8gaW50ZXJ2YWwgOiBpbnRlcnZhbC5ldmVyeShzdGVwKTtcbiAgfVxuXG4gIHNjYWxlLmludmVydCA9IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoaW52ZXJ0KHkpKTtcbiAgfTtcblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkb21haW4obWFwJDEuY2FsbChfLCBudW1iZXIkMSkpIDogZG9tYWluKCkubWFwKGRhdGUpO1xuICB9O1xuXG4gIHNjYWxlLnRpY2tzID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpLFxuICAgICAgICB0MCA9IGRbMF0sXG4gICAgICAgIHQxID0gZFtkLmxlbmd0aCAtIDFdLFxuICAgICAgICByID0gdDEgPCB0MCxcbiAgICAgICAgdDtcbiAgICBpZiAocikgdCA9IHQwLCB0MCA9IHQxLCB0MSA9IHQ7XG4gICAgdCA9IHRpY2tJbnRlcnZhbChpbnRlcnZhbCwgdDAsIHQxLCBzdGVwKTtcbiAgICB0ID0gdCA/IHQucmFuZ2UodDAsIHQxICsgMSkgOiBbXTsgLy8gaW5jbHVzaXZlIHN0b3BcbiAgICByZXR1cm4gciA/IHQucmV2ZXJzZSgpIDogdDtcbiAgfTtcblxuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24oY291bnQsIHNwZWNpZmllcikge1xuICAgIHJldHVybiBzcGVjaWZpZXIgPT0gbnVsbCA/IHRpY2tGb3JtYXQgOiBmb3JtYXQkJDEoc3BlY2lmaWVyKTtcbiAgfTtcblxuICBzY2FsZS5uaWNlID0gZnVuY3Rpb24oaW50ZXJ2YWwsIHN0ZXApIHtcbiAgICB2YXIgZCA9IGRvbWFpbigpO1xuICAgIHJldHVybiAoaW50ZXJ2YWwgPSB0aWNrSW50ZXJ2YWwoaW50ZXJ2YWwsIGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgc3RlcCkpXG4gICAgICAgID8gZG9tYWluKG5pY2UoZCwgaW50ZXJ2YWwpKVxuICAgICAgICA6IHNjYWxlO1xuICB9O1xuXG4gIHNjYWxlLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gY29weShzY2FsZSwgY2FsZW5kYXIoeWVhciwgbW9udGgsIHdlZWssIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kLCBmb3JtYXQkJDEpKTtcbiAgfTtcblxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHRpbWUoKSB7XG4gIHJldHVybiBjYWxlbmRhcihkM1RpbWUudGltZVllYXIsIGQzVGltZS50aW1lTW9udGgsIGQzVGltZS50aW1lV2VlaywgZDNUaW1lLnRpbWVEYXksIGQzVGltZS50aW1lSG91ciwgZDNUaW1lLnRpbWVNaW51dGUsIGQzVGltZS50aW1lU2Vjb25kLCBkM1RpbWUudGltZU1pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudGltZUZvcm1hdCkuZG9tYWluKFtuZXcgRGF0ZSgyMDAwLCAwLCAxKSwgbmV3IERhdGUoMjAwMCwgMCwgMildKTtcbn1cblxuZnVuY3Rpb24gdXRjVGltZSgpIHtcbiAgcmV0dXJuIGNhbGVuZGFyKGQzVGltZS51dGNZZWFyLCBkM1RpbWUudXRjTW9udGgsIGQzVGltZS51dGNXZWVrLCBkM1RpbWUudXRjRGF5LCBkM1RpbWUudXRjSG91ciwgZDNUaW1lLnV0Y01pbnV0ZSwgZDNUaW1lLnV0Y1NlY29uZCwgZDNUaW1lLnV0Y01pbGxpc2Vjb25kLCBkM1RpbWVGb3JtYXQudXRjRm9ybWF0KS5kb21haW4oW0RhdGUuVVRDKDIwMDAsIDAsIDEpLCBEYXRlLlVUQygyMDAwLCAwLCAyKV0pO1xufVxuXG5mdW5jdGlvbiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikge1xuICB2YXIgeDAgPSAwLFxuICAgICAgeDEgPSAxLFxuICAgICAgY2xhbXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzY2FsZSh4KSB7XG4gICAgdmFyIHQgPSAoeCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICByZXR1cm4gaW50ZXJwb2xhdG9yKGNsYW1wID8gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgdCkpIDogdCk7XG4gIH1cblxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeDAgPSArX1swXSwgeDEgPSArX1sxXSwgc2NhbGUpIDogW3gwLCB4MV07XG4gIH07XG5cbiAgc2NhbGUuY2xhbXAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoY2xhbXAgPSAhIV8sIHNjYWxlKSA6IGNsYW1wO1xuICB9O1xuXG4gIHNjYWxlLmludGVycG9sYXRvciA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0b3IgPSBfLCBzY2FsZSkgOiBpbnRlcnBvbGF0b3I7XG4gIH07XG5cbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZXF1ZW50aWFsKGludGVycG9sYXRvcikuZG9tYWluKFt4MCwgeDFdKS5jbGFtcChjbGFtcCk7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmVhcmlzaChzY2FsZSk7XG59XG5cbmV4cG9ydHMuc2NhbGVCYW5kID0gYmFuZDtcbmV4cG9ydHMuc2NhbGVQb2ludCA9IHBvaW50O1xuZXhwb3J0cy5zY2FsZUlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLnNjYWxlTGluZWFyID0gbGluZWFyO1xuZXhwb3J0cy5zY2FsZUxvZyA9IGxvZztcbmV4cG9ydHMuc2NhbGVPcmRpbmFsID0gb3JkaW5hbDtcbmV4cG9ydHMuc2NhbGVJbXBsaWNpdCA9IGltcGxpY2l0O1xuZXhwb3J0cy5zY2FsZVBvdyA9IHBvdztcbmV4cG9ydHMuc2NhbGVTcXJ0ID0gc3FydDtcbmV4cG9ydHMuc2NhbGVRdWFudGlsZSA9IHF1YW50aWxlJDE7XG5leHBvcnRzLnNjYWxlUXVhbnRpemUgPSBxdWFudGl6ZTtcbmV4cG9ydHMuc2NhbGVUaHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG5leHBvcnRzLnNjYWxlVGltZSA9IHRpbWU7XG5leHBvcnRzLnNjYWxlVXRjID0gdXRjVGltZTtcbmV4cG9ydHMuc2NhbGVTZXF1ZW50aWFsID0gc2VxdWVudGlhbDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2VsZWN0aW9uLyBWZXJzaW9uIDEuMy4wLiBDb3B5cmlnaHQgMjAxOCBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciB4aHRtbCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG52YXIgbmFtZXNwYWNlcyA9IHtcbiAgc3ZnOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIHhodG1sOiB4aHRtbCxcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvXCJcbn07XG5cbmZ1bmN0aW9uIG5hbWVzcGFjZShuYW1lKSB7XG4gIHZhciBwcmVmaXggPSBuYW1lICs9IFwiXCIsIGkgPSBwcmVmaXguaW5kZXhPZihcIjpcIik7XG4gIGlmIChpID49IDAgJiYgKHByZWZpeCA9IG5hbWUuc2xpY2UoMCwgaSkpICE9PSBcInhtbG5zXCIpIG5hbWUgPSBuYW1lLnNsaWNlKGkgKyAxKTtcbiAgcmV0dXJuIG5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJlZml4KSA/IHtzcGFjZTogbmFtZXNwYWNlc1twcmVmaXhdLCBsb2NhbDogbmFtZX0gOiBuYW1lO1xufVxuXG5mdW5jdGlvbiBjcmVhdG9ySW5oZXJpdChuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlVVJJO1xuICAgIHJldHVybiB1cmkgPT09IHhodG1sICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5uYW1lc3BhY2VVUkkgPT09IHhodG1sXG4gICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKVxuICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh1cmksIG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdG9yRml4ZWQoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0b3IobmFtZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG4gIHJldHVybiAoZnVsbG5hbWUubG9jYWxcbiAgICAgID8gY3JlYXRvckZpeGVkXG4gICAgICA6IGNyZWF0b3JJbmhlcml0KShmdWxsbmFtZSk7XG59XG5cbmZ1bmN0aW9uIG5vbmUoKSB7fVxuXG5mdW5jdGlvbiBzZWxlY3RvcihzZWxlY3Rvcikge1xuICByZXR1cm4gc2VsZWN0b3IgPT0gbnVsbCA/IG5vbmUgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX3NlbGVjdChzZWxlY3QpIHtcbiAgaWYgKHR5cGVvZiBzZWxlY3QgIT09IFwiZnVuY3Rpb25cIikgc2VsZWN0ID0gc2VsZWN0b3Ioc2VsZWN0KTtcblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBzdWJncm91cHMgPSBuZXcgQXJyYXkobSksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIHN1Ymdyb3VwID0gc3ViZ3JvdXBzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBzdWJub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIChzdWJub2RlID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSkge1xuICAgICAgICBpZiAoXCJfX2RhdGFfX1wiIGluIG5vZGUpIHN1Ym5vZGUuX19kYXRhX18gPSBub2RlLl9fZGF0YV9fO1xuICAgICAgICBzdWJncm91cFtpXSA9IHN1Ym5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JBbGwoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHNlbGVjdG9yID09IG51bGwgPyBlbXB0eSA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2VsZWN0QWxsKHNlbGVjdCkge1xuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBzZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIHN1Ymdyb3Vwcy5wdXNoKHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSk7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdWJncm91cHMsIHBhcmVudHMpO1xufVxuXG52YXIgbWF0Y2hlciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgfTtcbn07XG5cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudC5tYXRjaGVzKSB7XG4gICAgdmFyIHZlbmRvck1hdGNoZXMgPSBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgICAgICB8fCBlbGVtZW50Lm1zTWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yXG4gICAgICAgIHx8IGVsZW1lbnQub01hdGNoZXNTZWxlY3RvcjtcbiAgICBtYXRjaGVyID0gZnVuY3Rpb24oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHZlbmRvck1hdGNoZXMuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgICB9O1xuICAgIH07XG4gIH1cbn1cblxudmFyIG1hdGNoZXIkMSA9IG1hdGNoZXI7XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9maWx0ZXIobWF0Y2gpIHtcbiAgaWYgKHR5cGVvZiBtYXRjaCAhPT0gXCJmdW5jdGlvblwiKSBtYXRjaCA9IG1hdGNoZXIkMShtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc3BhcnNlKHVwZGF0ZSkge1xuICByZXR1cm4gbmV3IEFycmF5KHVwZGF0ZS5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZW50ZXIoKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2VudGVyIHx8IHRoaXMuX2dyb3Vwcy5tYXAoc3BhcnNlKSwgdGhpcy5fcGFyZW50cyk7XG59XG5cbmZ1bmN0aW9uIEVudGVyTm9kZShwYXJlbnQsIGRhdHVtKSB7XG4gIHRoaXMub3duZXJEb2N1bWVudCA9IHBhcmVudC5vd25lckRvY3VtZW50O1xuICB0aGlzLm5hbWVzcGFjZVVSSSA9IHBhcmVudC5uYW1lc3BhY2VVUkk7XG4gIHRoaXMuX25leHQgPSBudWxsO1xuICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gIHRoaXMuX19kYXRhX18gPSBkYXR1bTtcbn1cblxuRW50ZXJOb2RlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEVudGVyTm9kZSxcbiAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7IHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0QmVmb3JlKGNoaWxkLCB0aGlzLl9uZXh0KTsgfSxcbiAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihjaGlsZCwgbmV4dCkgeyByZXR1cm4gdGhpcy5fcGFyZW50Lmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7IH0sXG4gIHF1ZXJ5U2VsZWN0b3I6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7IH0sXG4gIHF1ZXJ5U2VsZWN0b3JBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7IHJldHVybiB0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7IH1cbn07XG5cbmZ1bmN0aW9uIGNvbnN0YW50KHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuXG52YXIga2V5UHJlZml4ID0gXCIkXCI7IC8vIFByb3RlY3QgYWdhaW5zdCBrZXlzIGxpa2Ug4oCcX19wcm90b19f4oCdLlxuXG5mdW5jdGlvbiBiaW5kSW5kZXgocGFyZW50LCBncm91cCwgZW50ZXIsIHVwZGF0ZSwgZXhpdCwgZGF0YSkge1xuICB2YXIgaSA9IDAsXG4gICAgICBub2RlLFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgLy8gUHV0IGFueSBub24tbnVsbCBub2RlcyB0aGF0IGZpdCBpbnRvIHVwZGF0ZS5cbiAgLy8gUHV0IGFueSBudWxsIG5vZGVzIGludG8gZW50ZXIuXG4gIC8vIFB1dCBhbnkgcmVtYWluaW5nIGRhdGEgaW50byBlbnRlci5cbiAgZm9yICg7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFB1dCBhbnkgbm9uLW51bGwgbm9kZXMgdGhhdCBkb27igJl0IGZpdCBpbnRvIGV4aXQuXG4gIGZvciAoOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBiaW5kS2V5KHBhcmVudCwgZ3JvdXAsIGVudGVyLCB1cGRhdGUsIGV4aXQsIGRhdGEsIGtleSkge1xuICB2YXIgaSxcbiAgICAgIG5vZGUsXG4gICAgICBub2RlQnlLZXlWYWx1ZSA9IHt9LFxuICAgICAgZ3JvdXBMZW5ndGggPSBncm91cC5sZW5ndGgsXG4gICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICBrZXlWYWx1ZXMgPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpLFxuICAgICAga2V5VmFsdWU7XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIG5vZGUuXG4gIC8vIElmIG11bHRpcGxlIG5vZGVzIGhhdmUgdGhlIHNhbWUga2V5LCB0aGUgZHVwbGljYXRlcyBhcmUgYWRkZWQgdG8gZXhpdC5cbiAgZm9yIChpID0gMDsgaSA8IGdyb3VwTGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICBrZXlWYWx1ZXNbaV0gPSBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKTtcbiAgICAgIGlmIChrZXlWYWx1ZSBpbiBub2RlQnlLZXlWYWx1ZSkge1xuICAgICAgICBleGl0W2ldID0gbm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUga2V5IGZvciBlYWNoIGRhdHVtLlxuICAvLyBJZiB0aGVyZSBhIG5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMga2V5LCBqb2luIGFuZCBhZGQgaXQgdG8gdXBkYXRlLlxuICAvLyBJZiB0aGVyZSBpcyBub3QgKG9yIHRoZSBrZXkgaXMgYSBkdXBsaWNhdGUpLCBhZGQgaXQgdG8gZW50ZXIuXG4gIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyArK2kpIHtcbiAgICBrZXlWYWx1ZSA9IGtleVByZWZpeCArIGtleS5jYWxsKHBhcmVudCwgZGF0YVtpXSwgaSwgZGF0YSk7XG4gICAgaWYgKG5vZGUgPSBub2RlQnlLZXlWYWx1ZVtrZXlWYWx1ZV0pIHtcbiAgICAgIHVwZGF0ZVtpXSA9IG5vZGU7XG4gICAgICBub2RlLl9fZGF0YV9fID0gZGF0YVtpXTtcbiAgICAgIG5vZGVCeUtleVZhbHVlW2tleVZhbHVlXSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVudGVyW2ldID0gbmV3IEVudGVyTm9kZShwYXJlbnQsIGRhdGFbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBhbnkgcmVtYWluaW5nIG5vZGVzIHRoYXQgd2VyZSBub3QgYm91bmQgdG8gZGF0YSB0byBleGl0LlxuICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBMZW5ndGg7ICsraSkge1xuICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAobm9kZUJ5S2V5VmFsdWVba2V5VmFsdWVzW2ldXSA9PT0gbm9kZSkpIHtcbiAgICAgIGV4aXRbaV0gPSBub2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGF0YSh2YWx1ZSwga2V5KSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBkYXRhID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKSwgaiA9IC0xO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihkKSB7IGRhdGFbKytqXSA9IGQ7IH0pO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJpbmQgPSBrZXkgPyBiaW5kS2V5IDogYmluZEluZGV4LFxuICAgICAgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMsXG4gICAgICBncm91cHMgPSB0aGlzLl9ncm91cHM7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB2YWx1ZSA9IGNvbnN0YW50KHZhbHVlKTtcblxuICBmb3IgKHZhciBtID0gZ3JvdXBzLmxlbmd0aCwgdXBkYXRlID0gbmV3IEFycmF5KG0pLCBlbnRlciA9IG5ldyBBcnJheShtKSwgZXhpdCA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tqXSxcbiAgICAgICAgZ3JvdXAgPSBncm91cHNbal0sXG4gICAgICAgIGdyb3VwTGVuZ3RoID0gZ3JvdXAubGVuZ3RoLFxuICAgICAgICBkYXRhID0gdmFsdWUuY2FsbChwYXJlbnQsIHBhcmVudCAmJiBwYXJlbnQuX19kYXRhX18sIGosIHBhcmVudHMpLFxuICAgICAgICBkYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGVudGVyR3JvdXAgPSBlbnRlcltqXSA9IG5ldyBBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgdXBkYXRlR3JvdXAgPSB1cGRhdGVbal0gPSBuZXcgQXJyYXkoZGF0YUxlbmd0aCksXG4gICAgICAgIGV4aXRHcm91cCA9IGV4aXRbal0gPSBuZXcgQXJyYXkoZ3JvdXBMZW5ndGgpO1xuXG4gICAgYmluZChwYXJlbnQsIGdyb3VwLCBlbnRlckdyb3VwLCB1cGRhdGVHcm91cCwgZXhpdEdyb3VwLCBkYXRhLCBrZXkpO1xuXG4gICAgLy8gTm93IGNvbm5lY3QgdGhlIGVudGVyIG5vZGVzIHRvIHRoZWlyIGZvbGxvd2luZyB1cGRhdGUgbm9kZSwgc3VjaCB0aGF0XG4gICAgLy8gYXBwZW5kQ2hpbGQgY2FuIGluc2VydCB0aGUgbWF0ZXJpYWxpemVkIGVudGVyIG5vZGUgYmVmb3JlIHRoaXMgbm9kZSxcbiAgICAvLyByYXRoZXIgdGhhbiBhdCB0aGUgZW5kIG9mIHRoZSBwYXJlbnQgbm9kZS5cbiAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMCwgcHJldmlvdXMsIG5leHQ7IGkwIDwgZGF0YUxlbmd0aDsgKytpMCkge1xuICAgICAgaWYgKHByZXZpb3VzID0gZW50ZXJHcm91cFtpMF0pIHtcbiAgICAgICAgaWYgKGkwID49IGkxKSBpMSA9IGkwICsgMTtcbiAgICAgICAgd2hpbGUgKCEobmV4dCA9IHVwZGF0ZUdyb3VwW2kxXSkgJiYgKytpMSA8IGRhdGFMZW5ndGgpO1xuICAgICAgICBwcmV2aW91cy5fbmV4dCA9IG5leHQgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1cGRhdGUgPSBuZXcgU2VsZWN0aW9uKHVwZGF0ZSwgcGFyZW50cyk7XG4gIHVwZGF0ZS5fZW50ZXIgPSBlbnRlcjtcbiAgdXBkYXRlLl9leGl0ID0gZXhpdDtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2V4aXQoKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2V4aXQgfHwgdGhpcy5fZ3JvdXBzLm1hcChzcGFyc2UpLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX21lcmdlKHNlbGVjdGlvbiQkMSkge1xuXG4gIGZvciAodmFyIGdyb3VwczAgPSB0aGlzLl9ncm91cHMsIGdyb3VwczEgPSBzZWxlY3Rpb24kJDEuX2dyb3VwcywgbTAgPSBncm91cHMwLmxlbmd0aCwgbTEgPSBncm91cHMxLmxlbmd0aCwgbSA9IE1hdGgubWluKG0wLCBtMSksIG1lcmdlcyA9IG5ldyBBcnJheShtMCksIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAwID0gZ3JvdXBzMFtqXSwgZ3JvdXAxID0gZ3JvdXBzMVtqXSwgbiA9IGdyb3VwMC5sZW5ndGgsIG1lcmdlID0gbWVyZ2VzW2pdID0gbmV3IEFycmF5KG4pLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cDBbaV0gfHwgZ3JvdXAxW2ldKSB7XG4gICAgICAgIG1lcmdlW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKDsgaiA8IG0wOyArK2opIHtcbiAgICBtZXJnZXNbal0gPSBncm91cHMwW2pdO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX29yZGVyKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IC0xLCBtID0gZ3JvdXBzLmxlbmd0aDsgKytqIDwgbTspIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IGdyb3VwLmxlbmd0aCAtIDEsIG5leHQgPSBncm91cFtpXSwgbm9kZTsgLS1pID49IDA7KSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09IG5vZGUubmV4dFNpYmxpbmcpIG5leHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dCk7XG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc29ydChjb21wYXJlKSB7XG4gIGlmICghY29tcGFyZSkgY29tcGFyZSA9IGFzY2VuZGluZztcblxuICBmdW5jdGlvbiBjb21wYXJlTm9kZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgJiYgYiA/IGNvbXBhcmUoYS5fX2RhdGFfXywgYi5fX2RhdGFfXykgOiAhYSAtICFiO1xuICB9XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc29ydGdyb3VwcyA9IG5ldyBBcnJheShtKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgc29ydGdyb3VwID0gc29ydGdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgc29ydGdyb3VwW2ldID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc29ydGdyb3VwLnNvcnQoY29tcGFyZU5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc29ydGdyb3VwcywgdGhpcy5fcGFyZW50cykub3JkZXIoKTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiBhID49IGIgPyAwIDogTmFOO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2FsbCgpIHtcbiAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzWzBdO1xuICBhcmd1bWVudHNbMF0gPSB0aGlzO1xuICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX25vZGVzKCkge1xuICB2YXIgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5zaXplKCkpLCBpID0gLTE7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpIHsgbm9kZXNbKytpXSA9IHRoaXM7IH0pO1xuICByZXR1cm4gbm9kZXM7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9ub2RlKCkge1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgaiA9IDAsIG0gPSBncm91cHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIGkgPSAwLCBuID0gZ3JvdXAubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2YXIgbm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG5vZGUpIHJldHVybiBub2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fc2l6ZSgpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLmVhY2goZnVuY3Rpb24oKSB7ICsrc2l6ZTsgfSk7XG4gIHJldHVybiBzaXplO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZW1wdHkoKSB7XG4gIHJldHVybiAhdGhpcy5ub2RlKCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9lYWNoKGNhbGxiYWNrKSB7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBqID0gMCwgbSA9IGdyb3Vwcy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgaSA9IDAsIG4gPSBncm91cC5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIGNhbGxiYWNrLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyUmVtb3ZlTlMoZnVsbG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckNvbnN0YW50KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudE5TKGZ1bGxuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHZhbHVlKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCB2KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0ckZ1bmN0aW9uTlMoZnVsbG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKHYgPT0gbnVsbCkgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIGVsc2UgdGhpcy5zZXRBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwsIHYpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fYXR0cihuYW1lLCB2YWx1ZSkge1xuICB2YXIgZnVsbG5hbWUgPSBuYW1lc3BhY2UobmFtZSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGUoKTtcbiAgICByZXR1cm4gZnVsbG5hbWUubG9jYWxcbiAgICAgICAgPyBub2RlLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbClcbiAgICAgICAgOiBub2RlLmdldEF0dHJpYnV0ZShmdWxsbmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJSZW1vdmVOUyA6IGF0dHJSZW1vdmUpIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJGdW5jdGlvbk5TIDogYXR0ckZ1bmN0aW9uKVxuICAgICAgOiAoZnVsbG5hbWUubG9jYWwgPyBhdHRyQ29uc3RhbnROUyA6IGF0dHJDb25zdGFudCkpKShmdWxsbmFtZSwgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFZpZXcobm9kZSkge1xuICByZXR1cm4gKG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIC8vIG5vZGUgaXMgYSBOb2RlXG4gICAgICB8fCAobm9kZS5kb2N1bWVudCAmJiBub2RlKSAvLyBub2RlIGlzIGEgV2luZG93XG4gICAgICB8fCBub2RlLmRlZmF1bHRWaWV3OyAvLyBub2RlIGlzIGEgRG9jdW1lbnRcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsIHByaW9yaXR5KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVGdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAodiA9PSBudWxsKSB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIGVsc2UgdGhpcy5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2LCBwcmlvcml0eSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9zdHlsZShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxXG4gICAgICA/IHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbFxuICAgICAgICAgICAgPyBzdHlsZVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHN0eWxlRnVuY3Rpb25cbiAgICAgICAgICAgIDogc3R5bGVDb25zdGFudCkobmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKVxuICAgICAgOiBzdHlsZVZhbHVlKHRoaXMubm9kZSgpLCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gc3R5bGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gIHJldHVybiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSlcbiAgICAgIHx8IGRlZmF1bHRWaWV3KG5vZGUpLmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlSZW1vdmUobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Q29uc3RhbnQobmFtZSwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmICh2ID09IG51bGwpIGRlbGV0ZSB0aGlzW25hbWVdO1xuICAgIGVsc2UgdGhpc1tuYW1lXSA9IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9wcm9wZXJ0eShuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDFcbiAgICAgID8gdGhpcy5lYWNoKCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBwcm9wZXJ0eVJlbW92ZSA6IHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBwcm9wZXJ0eUZ1bmN0aW9uXG4gICAgICAgICAgOiBwcm9wZXJ0eUNvbnN0YW50KShuYW1lLCB2YWx1ZSkpXG4gICAgICA6IHRoaXMubm9kZSgpW25hbWVdO1xufVxuXG5mdW5jdGlvbiBjbGFzc0FycmF5KHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nLnRyaW0oKS5zcGxpdCgvXnxcXHMrLyk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzTGlzdChub2RlKSB7XG4gIHJldHVybiBub2RlLmNsYXNzTGlzdCB8fCBuZXcgQ2xhc3NMaXN0KG5vZGUpO1xufVxuXG5mdW5jdGlvbiBDbGFzc0xpc3Qobm9kZSkge1xuICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgdGhpcy5fbmFtZXMgPSBjbGFzc0FycmF5KG5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIik7XG59XG5cbkNsYXNzTGlzdC5wcm90b3R5cGUgPSB7XG4gIGFkZDogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRoaXMuX25hbWVzLnB1c2gobmFtZSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBpID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9uYW1lcy5zcGxpY2UoaSwgMSk7XG4gICAgICB0aGlzLl9ub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIHRoaXMuX25hbWVzLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gIH0sXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzLmluZGV4T2YobmFtZSkgPj0gMDtcbiAgfVxufTtcblxuZnVuY3Rpb24gY2xhc3NlZEFkZChub2RlLCBuYW1lcykge1xuICB2YXIgbGlzdCA9IGNsYXNzTGlzdChub2RlKSwgaSA9IC0xLCBuID0gbmFtZXMubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbikgbGlzdC5hZGQobmFtZXNbaV0pO1xufVxuXG5mdW5jdGlvbiBjbGFzc2VkUmVtb3ZlKG5vZGUsIG5hbWVzKSB7XG4gIHZhciBsaXN0ID0gY2xhc3NMaXN0KG5vZGUpLCBpID0gLTEsIG4gPSBuYW1lcy5sZW5ndGg7XG4gIHdoaWxlICgrK2kgPCBuKSBsaXN0LnJlbW92ZShuYW1lc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZWRUcnVlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkQWRkKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZhbHNlKG5hbWVzKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGFzc2VkUmVtb3ZlKHRoaXMsIG5hbWVzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2xhc3NlZEZ1bmN0aW9uKG5hbWVzLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgKHZhbHVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPyBjbGFzc2VkQWRkIDogY2xhc3NlZFJlbW92ZSkodGhpcywgbmFtZXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fY2xhc3NlZChuYW1lLCB2YWx1ZSkge1xuICB2YXIgbmFtZXMgPSBjbGFzc0FycmF5KG5hbWUgKyBcIlwiKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgbGlzdCA9IGNsYXNzTGlzdCh0aGlzLm5vZGUoKSksIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbikgaWYgKCFsaXN0LmNvbnRhaW5zKG5hbWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgID8gY2xhc3NlZEZ1bmN0aW9uIDogdmFsdWVcbiAgICAgID8gY2xhc3NlZFRydWVcbiAgICAgIDogY2xhc3NlZEZhbHNlKShuYW1lcywgdmFsdWUpKTtcbn1cblxuZnVuY3Rpb24gdGV4dFJlbW92ZSgpIHtcbiAgdGhpcy50ZXh0Q29udGVudCA9IFwiXCI7XG59XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl90ZXh0KHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyB0ZXh0UmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyB0ZXh0RnVuY3Rpb25cbiAgICAgICAgICA6IHRleHRDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS50ZXh0Q29udGVudDtcbn1cblxuZnVuY3Rpb24gaHRtbFJlbW92ZSgpIHtcbiAgdGhpcy5pbm5lckhUTUwgPSBcIlwiO1xufVxuXG5mdW5jdGlvbiBodG1sQ29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdmFsdWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGh0bWxGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB2YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHRoaXMuaW5uZXJIVE1MID0gdiA9PSBudWxsID8gXCJcIiA6IHY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9odG1sKHZhbHVlKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCh2YWx1ZSA9PSBudWxsXG4gICAgICAgICAgPyBodG1sUmVtb3ZlIDogKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBodG1sRnVuY3Rpb25cbiAgICAgICAgICA6IGh0bWxDb25zdGFudCkodmFsdWUpKVxuICAgICAgOiB0aGlzLm5vZGUoKS5pbm5lckhUTUw7XG59XG5cbmZ1bmN0aW9uIHJhaXNlKCkge1xuICBpZiAodGhpcy5uZXh0U2libGluZykgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fcmFpc2UoKSB7XG4gIHJldHVybiB0aGlzLmVhY2gocmFpc2UpO1xufVxuXG5mdW5jdGlvbiBsb3dlcigpIHtcbiAgaWYgKHRoaXMucHJldmlvdXNTaWJsaW5nKSB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMsIHRoaXMucGFyZW50Tm9kZS5maXJzdENoaWxkKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2xvd2VyKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKGxvd2VyKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2FwcGVuZChuYW1lKSB7XG4gIHZhciBjcmVhdGUgPSB0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiID8gbmFtZSA6IGNyZWF0b3IobmFtZSk7XG4gIHJldHVybiB0aGlzLnNlbGVjdChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDaGlsZChjcmVhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjb25zdGFudE51bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25faW5zZXJ0KG5hbWUsIGJlZm9yZSkge1xuICB2YXIgY3JlYXRlID0gdHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiA/IG5hbWUgOiBjcmVhdG9yKG5hbWUpLFxuICAgICAgc2VsZWN0ID0gYmVmb3JlID09IG51bGwgPyBjb25zdGFudE51bGwgOiB0eXBlb2YgYmVmb3JlID09PSBcImZ1bmN0aW9uXCIgPyBiZWZvcmUgOiBzZWxlY3RvcihiZWZvcmUpO1xuICByZXR1cm4gdGhpcy5zZWxlY3QoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zZXJ0QmVmb3JlKGNyZWF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBzZWxlY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCBudWxsKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fcmVtb3ZlKCkge1xuICByZXR1cm4gdGhpcy5lYWNoKHJlbW92ZSk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZVNoYWxsb3coKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKGZhbHNlKSwgdGhpcy5uZXh0U2libGluZyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9jbG9uZURlZXAoKSB7XG4gIHJldHVybiB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY2xvbmVOb2RlKHRydWUpLCB0aGlzLm5leHRTaWJsaW5nKTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX2Nsb25lKGRlZXApIHtcbiAgcmV0dXJuIHRoaXMuc2VsZWN0KGRlZXAgPyBzZWxlY3Rpb25fY2xvbmVEZWVwIDogc2VsZWN0aW9uX2Nsb25lU2hhbGxvdyk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdGlvbl9kYXR1bSh2YWx1ZSkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLnByb3BlcnR5KFwiX19kYXRhX19cIiwgdmFsdWUpXG4gICAgICA6IHRoaXMubm9kZSgpLl9fZGF0YV9fO1xufVxuXG52YXIgZmlsdGVyRXZlbnRzID0ge307XG5cbmV4cG9ydHMuZXZlbnQgPSBudWxsO1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIHZhciBlbGVtZW50JDEgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGlmICghKFwib25tb3VzZWVudGVyXCIgaW4gZWxlbWVudCQxKSkge1xuICAgIGZpbHRlckV2ZW50cyA9IHttb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLCBtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCJ9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbHRlckNvbnRleHRMaXN0ZW5lcihsaXN0ZW5lciwgaW5kZXgsIGdyb3VwKSB7XG4gIGxpc3RlbmVyID0gY29udGV4dExpc3RlbmVyKGxpc3RlbmVyLCBpbmRleCwgZ3JvdXApO1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgcmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEocmVsYXRlZC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzKSAmIDgpKSkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb250ZXh0TGlzdGVuZXIobGlzdGVuZXIsIGluZGV4LCBncm91cCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZlbnQxKSB7XG4gICAgdmFyIGV2ZW50MCA9IGV4cG9ydHMuZXZlbnQ7IC8vIEV2ZW50cyBjYW4gYmUgcmVlbnRyYW50IChlLmcuLCBmb2N1cykuXG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgICB0cnkge1xuICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB0aGlzLl9fZGF0YV9fLCBpbmRleCwgZ3JvdXApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBvcnRzLmV2ZW50ID0gZXZlbnQwO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzKSB7XG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxccysvKS5tYXAoZnVuY3Rpb24odCkge1xuICAgIHZhciBuYW1lID0gXCJcIiwgaSA9IHQuaW5kZXhPZihcIi5cIik7XG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25SZW1vdmUodHlwZW5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbiA9IHRoaXMuX19vbjtcbiAgICBpZiAoIW9uKSByZXR1cm47XG4gICAgZm9yICh2YXIgaiA9IDAsIGkgPSAtMSwgbSA9IG9uLmxlbmd0aCwgbzsgaiA8IG07ICsraikge1xuICAgICAgaWYgKG8gPSBvbltqXSwgKCF0eXBlbmFtZS50eXBlIHx8IG8udHlwZSA9PT0gdHlwZW5hbWUudHlwZSkgJiYgby5uYW1lID09PSB0eXBlbmFtZS5uYW1lKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihvLnR5cGUsIG8ubGlzdGVuZXIsIG8uY2FwdHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvblsrK2ldID0gbztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCsraSkgb24ubGVuZ3RoID0gaTtcbiAgICBlbHNlIGRlbGV0ZSB0aGlzLl9fb247XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9uQWRkKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgd3JhcCA9IGZpbHRlckV2ZW50cy5oYXNPd25Qcm9wZXJ0eSh0eXBlbmFtZS50eXBlKSA/IGZpbHRlckNvbnRleHRMaXN0ZW5lciA6IGNvbnRleHRMaXN0ZW5lcjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGQsIGksIGdyb3VwKSB7XG4gICAgdmFyIG9uID0gdGhpcy5fX29uLCBvLCBsaXN0ZW5lciA9IHdyYXAodmFsdWUsIGksIGdyb3VwKTtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoKG8gPSBvbltqXSkudHlwZSA9PT0gdHlwZW5hbWUudHlwZSAmJiBvLm5hbWUgPT09IHR5cGVuYW1lLm5hbWUpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciwgby5jYXB0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG8udHlwZSwgby5saXN0ZW5lciA9IGxpc3RlbmVyLCBvLmNhcHR1cmUgPSBjYXB0dXJlKTtcbiAgICAgICAgby52YWx1ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcih0eXBlbmFtZS50eXBlLCBsaXN0ZW5lciwgY2FwdHVyZSk7XG4gICAgbyA9IHt0eXBlOiB0eXBlbmFtZS50eXBlLCBuYW1lOiB0eXBlbmFtZS5uYW1lLCB2YWx1ZTogdmFsdWUsIGxpc3RlbmVyOiBsaXN0ZW5lciwgY2FwdHVyZTogY2FwdHVyZX07XG4gICAgaWYgKCFvbikgdGhpcy5fX29uID0gW29dO1xuICAgIGVsc2Ugb24ucHVzaChvKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uX29uKHR5cGVuYW1lLCB2YWx1ZSwgY2FwdHVyZSkge1xuICB2YXIgdHlwZW5hbWVzID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcIlwiKSwgaSwgbiA9IHR5cGVuYW1lcy5sZW5ndGgsIHQ7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgdmFyIG9uID0gdGhpcy5ub2RlKCkuX19vbjtcbiAgICBpZiAob24pIGZvciAodmFyIGogPSAwLCBtID0gb24ubGVuZ3RoLCBvOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKGkgPSAwLCBvID0gb25bal07IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCh0ID0gdHlwZW5hbWVzW2ldKS50eXBlID09PSBvLnR5cGUgJiYgdC5uYW1lID09PSBvLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gby52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBvbiA9IHZhbHVlID8gb25BZGQgOiBvblJlbW92ZTtcbiAgaWYgKGNhcHR1cmUgPT0gbnVsbCkgY2FwdHVyZSA9IGZhbHNlO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB0aGlzLmVhY2gob24odHlwZW5hbWVzW2ldLCB2YWx1ZSwgY2FwdHVyZSkpO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gY3VzdG9tRXZlbnQoZXZlbnQxLCBsaXN0ZW5lciwgdGhhdCwgYXJncykge1xuICB2YXIgZXZlbnQwID0gZXhwb3J0cy5ldmVudDtcbiAgZXZlbnQxLnNvdXJjZUV2ZW50ID0gZXhwb3J0cy5ldmVudDtcbiAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbGlzdGVuZXIuYXBwbHkodGhhdCwgYXJncyk7XG4gIH0gZmluYWxseSB7XG4gICAgZXhwb3J0cy5ldmVudCA9IGV2ZW50MDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KG5vZGUsIHR5cGUsIHBhcmFtcykge1xuICB2YXIgd2luZG93ID0gZGVmYXVsdFZpZXcobm9kZSksXG4gICAgICBldmVudCA9IHdpbmRvdy5DdXN0b21FdmVudDtcblxuICBpZiAodHlwZW9mIGV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBldmVudCA9IG5ldyBldmVudCh0eXBlLCBwYXJhbXMpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50ID0gd2luZG93LmRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgaWYgKHBhcmFtcykgZXZlbnQuaW5pdEV2ZW50KHR5cGUsIHBhcmFtcy5idWJibGVzLCBwYXJhbXMuY2FuY2VsYWJsZSksIGV2ZW50LmRldGFpbCA9IHBhcmFtcy5kZXRhaWw7XG4gICAgZWxzZSBldmVudC5pbml0RXZlbnQodHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgfVxuXG4gIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQ29uc3RhbnQodHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCB0eXBlLCBwYXJhbXMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEZ1bmN0aW9uKHR5cGUsIHBhcmFtcykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoRXZlbnQodGhpcywgdHlwZSwgcGFyYW1zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb25fZGlzcGF0Y2godHlwZSwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLmVhY2goKHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyBkaXNwYXRjaEZ1bmN0aW9uXG4gICAgICA6IGRpc3BhdGNoQ29uc3RhbnQpKHR5cGUsIHBhcmFtcykpO1xufVxuXG52YXIgcm9vdCA9IFtudWxsXTtcblxuZnVuY3Rpb24gU2VsZWN0aW9uKGdyb3VwcywgcGFyZW50cykge1xuICB0aGlzLl9ncm91cHMgPSBncm91cHM7XG4gIHRoaXMuX3BhcmVudHMgPSBwYXJlbnRzO1xufVxuXG5mdW5jdGlvbiBzZWxlY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XV0sIHJvb3QpO1xufVxuXG5TZWxlY3Rpb24ucHJvdG90eXBlID0gc2VsZWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFNlbGVjdGlvbixcbiAgc2VsZWN0OiBzZWxlY3Rpb25fc2VsZWN0LFxuICBzZWxlY3RBbGw6IHNlbGVjdGlvbl9zZWxlY3RBbGwsXG4gIGZpbHRlcjogc2VsZWN0aW9uX2ZpbHRlcixcbiAgZGF0YTogc2VsZWN0aW9uX2RhdGEsXG4gIGVudGVyOiBzZWxlY3Rpb25fZW50ZXIsXG4gIGV4aXQ6IHNlbGVjdGlvbl9leGl0LFxuICBtZXJnZTogc2VsZWN0aW9uX21lcmdlLFxuICBvcmRlcjogc2VsZWN0aW9uX29yZGVyLFxuICBzb3J0OiBzZWxlY3Rpb25fc29ydCxcbiAgY2FsbDogc2VsZWN0aW9uX2NhbGwsXG4gIG5vZGVzOiBzZWxlY3Rpb25fbm9kZXMsXG4gIG5vZGU6IHNlbGVjdGlvbl9ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fc2l6ZSxcbiAgZW1wdHk6IHNlbGVjdGlvbl9lbXB0eSxcbiAgZWFjaDogc2VsZWN0aW9uX2VhY2gsXG4gIGF0dHI6IHNlbGVjdGlvbl9hdHRyLFxuICBzdHlsZTogc2VsZWN0aW9uX3N0eWxlLFxuICBwcm9wZXJ0eTogc2VsZWN0aW9uX3Byb3BlcnR5LFxuICBjbGFzc2VkOiBzZWxlY3Rpb25fY2xhc3NlZCxcbiAgdGV4dDogc2VsZWN0aW9uX3RleHQsXG4gIGh0bWw6IHNlbGVjdGlvbl9odG1sLFxuICByYWlzZTogc2VsZWN0aW9uX3JhaXNlLFxuICBsb3dlcjogc2VsZWN0aW9uX2xvd2VyLFxuICBhcHBlbmQ6IHNlbGVjdGlvbl9hcHBlbmQsXG4gIGluc2VydDogc2VsZWN0aW9uX2luc2VydCxcbiAgcmVtb3ZlOiBzZWxlY3Rpb25fcmVtb3ZlLFxuICBjbG9uZTogc2VsZWN0aW9uX2Nsb25lLFxuICBkYXR1bTogc2VsZWN0aW9uX2RhdHVtLFxuICBvbjogc2VsZWN0aW9uX29uLFxuICBkaXNwYXRjaDogc2VsZWN0aW9uX2Rpc3BhdGNoXG59O1xuXG5mdW5jdGlvbiBzZWxlY3Qoc2VsZWN0b3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIlxuICAgICAgPyBuZXcgU2VsZWN0aW9uKFtbZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcildXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW1tzZWxlY3Rvcl1dLCByb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5hbWUpIHtcbiAgcmV0dXJuIHNlbGVjdChjcmVhdG9yKG5hbWUpLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSk7XG59XG5cbnZhciBuZXh0SWQgPSAwO1xuXG5mdW5jdGlvbiBsb2NhbCgpIHtcbiAgcmV0dXJuIG5ldyBMb2NhbDtcbn1cblxuZnVuY3Rpb24gTG9jYWwoKSB7XG4gIHRoaXMuXyA9IFwiQFwiICsgKCsrbmV4dElkKS50b1N0cmluZygzNik7XG59XG5cbkxvY2FsLnByb3RvdHlwZSA9IGxvY2FsLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExvY2FsLFxuICBnZXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgaWQgPSB0aGlzLl87XG4gICAgd2hpbGUgKCEoaWQgaW4gbm9kZSkpIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIG5vZGVbaWRdO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG5vZGVbdGhpcy5fXSA9IHZhbHVlO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fIGluIG5vZGUgJiYgZGVsZXRlIG5vZGVbdGhpcy5fXTtcbiAgfSxcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl87XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNvdXJjZUV2ZW50KCkge1xuICB2YXIgY3VycmVudCA9IGV4cG9ydHMuZXZlbnQsIHNvdXJjZTtcbiAgd2hpbGUgKHNvdXJjZSA9IGN1cnJlbnQuc291cmNlRXZlbnQpIGN1cnJlbnQgPSBzb3VyY2U7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBwb2ludChub2RlLCBldmVudCkge1xuICB2YXIgc3ZnID0gbm9kZS5vd25lclNWR0VsZW1lbnQgfHwgbm9kZTtcblxuICBpZiAoc3ZnLmNyZWF0ZVNWR1BvaW50KSB7XG4gICAgdmFyIHBvaW50ID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFgsIHBvaW50LnkgPSBldmVudC5jbGllbnRZO1xuICAgIHBvaW50ID0gcG9pbnQubWF0cml4VHJhbnNmb3JtKG5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKTtcbiAgICByZXR1cm4gW3BvaW50LngsIHBvaW50LnldO1xuICB9XG5cbiAgdmFyIHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gW2V2ZW50LmNsaWVudFggLSByZWN0LmxlZnQgLSBub2RlLmNsaWVudExlZnQsIGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcCAtIG5vZGUuY2xpZW50VG9wXTtcbn1cblxuZnVuY3Rpb24gbW91c2Uobm9kZSkge1xuICB2YXIgZXZlbnQgPSBzb3VyY2VFdmVudCgpO1xuICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMpIGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XG4gIHJldHVybiBwb2ludChub2RlLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdEFsbChzZWxlY3Rvcikge1xuICByZXR1cm4gdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiXG4gICAgICA/IG5ldyBTZWxlY3Rpb24oW2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXSwgW2RvY3VtZW50LmRvY3VtZW50RWxlbWVudF0pXG4gICAgICA6IG5ldyBTZWxlY3Rpb24oW3NlbGVjdG9yID09IG51bGwgPyBbXSA6IHNlbGVjdG9yXSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIHRvdWNoKG5vZGUsIHRvdWNoZXMsIGlkZW50aWZpZXIpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSBpZGVudGlmaWVyID0gdG91Y2hlcywgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkuY2hhbmdlZFRvdWNoZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3VjaGVzID8gdG91Y2hlcy5sZW5ndGggOiAwLCB0b3VjaDsgaSA8IG47ICsraSkge1xuICAgIGlmICgodG91Y2ggPSB0b3VjaGVzW2ldKS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXR1cm4gcG9pbnQobm9kZSwgdG91Y2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB0b3VjaGVzKG5vZGUsIHRvdWNoZXMpIHtcbiAgaWYgKHRvdWNoZXMgPT0gbnVsbCkgdG91Y2hlcyA9IHNvdXJjZUV2ZW50KCkudG91Y2hlcztcblxuICBmb3IgKHZhciBpID0gMCwgbiA9IHRvdWNoZXMgPyB0b3VjaGVzLmxlbmd0aCA6IDAsIHBvaW50cyA9IG5ldyBBcnJheShuKTsgaSA8IG47ICsraSkge1xuICAgIHBvaW50c1tpXSA9IHBvaW50KG5vZGUsIHRvdWNoZXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyZWF0b3IgPSBjcmVhdG9yO1xuZXhwb3J0cy5sb2NhbCA9IGxvY2FsO1xuZXhwb3J0cy5tYXRjaGVyID0gbWF0Y2hlciQxO1xuZXhwb3J0cy5tb3VzZSA9IG1vdXNlO1xuZXhwb3J0cy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5leHBvcnRzLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuZXhwb3J0cy5jbGllbnRQb2ludCA9IHBvaW50O1xuZXhwb3J0cy5zZWxlY3QgPSBzZWxlY3Q7XG5leHBvcnRzLnNlbGVjdEFsbCA9IHNlbGVjdEFsbDtcbmV4cG9ydHMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuZXhwb3J0cy5zZWxlY3RvciA9IHNlbGVjdG9yO1xuZXhwb3J0cy5zZWxlY3RvckFsbCA9IHNlbGVjdG9yQWxsO1xuZXhwb3J0cy5zdHlsZSA9IHN0eWxlVmFsdWU7XG5leHBvcnRzLnRvdWNoID0gdG91Y2g7XG5leHBvcnRzLnRvdWNoZXMgPSB0b3VjaGVzO1xuZXhwb3J0cy53aW5kb3cgPSBkZWZhdWx0VmlldztcbmV4cG9ydHMuY3VzdG9tRXZlbnQgPSBjdXN0b21FdmVudDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtc2hhcGUvIFZlcnNpb24gMS4yLjAuIENvcHlyaWdodCAyMDE3IE1pa2UgQm9zdG9jay5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnZDMtcGF0aCcpKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnLCAnZDMtcGF0aCddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNQYXRoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gZnVuY3Rpb24gY29uc3RhbnQoKSB7XG4gICAgcmV0dXJuIHg7XG4gIH07XG59O1xuXG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xudmFyIGNvcyA9IE1hdGguY29zO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHNpbiA9IE1hdGguc2luO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbnZhciBlcHNpbG9uID0gMWUtMTI7XG52YXIgcGkgPSBNYXRoLlBJO1xudmFyIGhhbGZQaSA9IHBpIC8gMjtcbnZhciB0YXUgPSAyICogcGk7XG5cbmZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmZ1bmN0aW9uIGFzaW4oeCkge1xuICByZXR1cm4geCA+PSAxID8gaGFsZlBpIDogeCA8PSAtMSA/IC1oYWxmUGkgOiBNYXRoLmFzaW4oeCk7XG59XG5cbmZ1bmN0aW9uIGFyY0lubmVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQuaW5uZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY091dGVyUmFkaXVzKGQpIHtcbiAgcmV0dXJuIGQub3V0ZXJSYWRpdXM7XG59XG5cbmZ1bmN0aW9uIGFyY1N0YXJ0QW5nbGUoZCkge1xuICByZXR1cm4gZC5zdGFydEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNFbmRBbmdsZShkKSB7XG4gIHJldHVybiBkLmVuZEFuZ2xlO1xufVxuXG5mdW5jdGlvbiBhcmNQYWRBbmdsZShkKSB7XG4gIHJldHVybiBkICYmIGQucGFkQW5nbGU7IC8vIE5vdGU6IG9wdGlvbmFsIVxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gIHZhciB4MTAgPSB4MSAtIHgwLCB5MTAgPSB5MSAtIHkwLFxuICAgICAgeDMyID0geDMgLSB4MiwgeTMyID0geTMgLSB5MixcbiAgICAgIHQgPSAoeDMyICogKHkwIC0geTIpIC0geTMyICogKHgwIC0geDIpKSAvICh5MzIgKiB4MTAgLSB4MzIgKiB5MTApO1xuICByZXR1cm4gW3gwICsgdCAqIHgxMCwgeTAgKyB0ICogeTEwXTtcbn1cblxuLy8gQ29tcHV0ZSBwZXJwZW5kaWN1bGFyIG9mZnNldCBsaW5lIG9mIGxlbmd0aCByYy5cbi8vIGh0dHA6Ly9tYXRod29ybGQud29sZnJhbS5jb20vQ2lyY2xlLUxpbmVJbnRlcnNlY3Rpb24uaHRtbFxuZnVuY3Rpb24gY29ybmVyVGFuZ2VudHMoeDAsIHkwLCB4MSwgeTEsIHIxLCByYywgY3cpIHtcbiAgdmFyIHgwMSA9IHgwIC0geDEsXG4gICAgICB5MDEgPSB5MCAtIHkxLFxuICAgICAgbG8gPSAoY3cgPyByYyA6IC1yYykgLyBzcXJ0KHgwMSAqIHgwMSArIHkwMSAqIHkwMSksXG4gICAgICBveCA9IGxvICogeTAxLFxuICAgICAgb3kgPSAtbG8gKiB4MDEsXG4gICAgICB4MTEgPSB4MCArIG94LFxuICAgICAgeTExID0geTAgKyBveSxcbiAgICAgIHgxMCA9IHgxICsgb3gsXG4gICAgICB5MTAgPSB5MSArIG95LFxuICAgICAgeDAwID0gKHgxMSArIHgxMCkgLyAyLFxuICAgICAgeTAwID0gKHkxMSArIHkxMCkgLyAyLFxuICAgICAgZHggPSB4MTAgLSB4MTEsXG4gICAgICBkeSA9IHkxMCAtIHkxMSxcbiAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHksXG4gICAgICByID0gcjEgLSByYyxcbiAgICAgIEQgPSB4MTEgKiB5MTAgLSB4MTAgKiB5MTEsXG4gICAgICBkID0gKGR5IDwgMCA/IC0xIDogMSkgKiBzcXJ0KG1heCgwLCByICogciAqIGQyIC0gRCAqIEQpKSxcbiAgICAgIGN4MCA9IChEICogZHkgLSBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTAgPSAoLUQgKiBkeCAtIGR5ICogZCkgLyBkMixcbiAgICAgIGN4MSA9IChEICogZHkgKyBkeCAqIGQpIC8gZDIsXG4gICAgICBjeTEgPSAoLUQgKiBkeCArIGR5ICogZCkgLyBkMixcbiAgICAgIGR4MCA9IGN4MCAtIHgwMCxcbiAgICAgIGR5MCA9IGN5MCAtIHkwMCxcbiAgICAgIGR4MSA9IGN4MSAtIHgwMCxcbiAgICAgIGR5MSA9IGN5MSAtIHkwMDtcblxuICAvLyBQaWNrIHRoZSBjbG9zZXIgb2YgdGhlIHR3byBpbnRlcnNlY3Rpb24gcG9pbnRzLlxuICAvLyBUT0RPIElzIHRoZXJlIGEgZmFzdGVyIHdheSB0byBkZXRlcm1pbmUgd2hpY2ggaW50ZXJzZWN0aW9uIHRvIHVzZT9cbiAgaWYgKGR4MCAqIGR4MCArIGR5MCAqIGR5MCA+IGR4MSAqIGR4MSArIGR5MSAqIGR5MSkgY3gwID0gY3gxLCBjeTAgPSBjeTE7XG5cbiAgcmV0dXJuIHtcbiAgICBjeDogY3gwLFxuICAgIGN5OiBjeTAsXG4gICAgeDAxOiAtb3gsXG4gICAgeTAxOiAtb3ksXG4gICAgeDExOiBjeDAgKiAocjEgLyByIC0gMSksXG4gICAgeTExOiBjeTAgKiAocjEgLyByIC0gMSlcbiAgfTtcbn1cblxudmFyIGFyYyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5uZXJSYWRpdXMgPSBhcmNJbm5lclJhZGl1cyxcbiAgICAgIG91dGVyUmFkaXVzID0gYXJjT3V0ZXJSYWRpdXMsXG4gICAgICBjb3JuZXJSYWRpdXMgPSBjb25zdGFudCgwKSxcbiAgICAgIHBhZFJhZGl1cyA9IG51bGwsXG4gICAgICBzdGFydEFuZ2xlID0gYXJjU3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlID0gYXJjRW5kQW5nbGUsXG4gICAgICBwYWRBbmdsZSA9IGFyY1BhZEFuZ2xlLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJjKCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICAgIHIsXG4gICAgICAgIHIwID0gK2lubmVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHIxID0gK291dGVyUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGEwID0gc3RhcnRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gaGFsZlBpLFxuICAgICAgICBhMSA9IGVuZEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLSBoYWxmUGksXG4gICAgICAgIGRhID0gYWJzKGExIC0gYTApLFxuICAgICAgICBjdyA9IGExID4gYTA7XG5cbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIG91dGVyIHJhZGl1cyBpcyBhbHdheXMgbGFyZ2VyIHRoYW4gdGhlIGlubmVyIHJhZGl1cy5cbiAgICBpZiAocjEgPCByMCkgciA9IHIxLCByMSA9IHIwLCByMCA9IHI7XG5cbiAgICAvLyBJcyBpdCBhIHBvaW50P1xuICAgIGlmICghKHIxID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKDAsIDApO1xuXG4gICAgLy8gT3IgaXMgaXQgYSBjaXJjbGUgb3IgYW5udWx1cz9cbiAgICBlbHNlIGlmIChkYSA+IHRhdSAtIGVwc2lsb24pIHtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIxICogY29zKGEwKSwgcjEgKiBzaW4oYTApKTtcbiAgICAgIGNvbnRleHQuYXJjKDAsIDAsIHIxLCBhMCwgYTEsICFjdyk7XG4gICAgICBpZiAocjAgPiBlcHNpbG9uKSB7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHIwICogY29zKGExKSwgcjAgKiBzaW4oYTEpKTtcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjAsIGExLCBhMCwgY3cpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9yIGlzIGl0IGEgY2lyY3VsYXIgb3IgYW5udWxhciBzZWN0b3I/XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYTAxID0gYTAsXG4gICAgICAgICAgYTExID0gYTEsXG4gICAgICAgICAgYTAwID0gYTAsXG4gICAgICAgICAgYTEwID0gYTEsXG4gICAgICAgICAgZGEwID0gZGEsXG4gICAgICAgICAgZGExID0gZGEsXG4gICAgICAgICAgYXAgPSBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC8gMixcbiAgICAgICAgICBycCA9IChhcCA+IGVwc2lsb24pICYmIChwYWRSYWRpdXMgPyArcGFkUmFkaXVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBzcXJ0KHIwICogcjAgKyByMSAqIHIxKSksXG4gICAgICAgICAgcmMgPSBtaW4oYWJzKHIxIC0gcjApIC8gMiwgK2Nvcm5lclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgICByYzAgPSByYyxcbiAgICAgICAgICByYzEgPSByYyxcbiAgICAgICAgICB0MCxcbiAgICAgICAgICB0MTtcblxuICAgICAgLy8gQXBwbHkgcGFkZGluZz8gTm90ZSB0aGF0IHNpbmNlIHIxIOKJpSByMCwgZGExIOKJpSBkYTAuXG4gICAgICBpZiAocnAgPiBlcHNpbG9uKSB7XG4gICAgICAgIHZhciBwMCA9IGFzaW4ocnAgLyByMCAqIHNpbihhcCkpLFxuICAgICAgICAgICAgcDEgPSBhc2luKHJwIC8gcjEgKiBzaW4oYXApKTtcbiAgICAgICAgaWYgKChkYTAgLT0gcDAgKiAyKSA+IGVwc2lsb24pIHAwICo9IChjdyA/IDEgOiAtMSksIGEwMCArPSBwMCwgYTEwIC09IHAwO1xuICAgICAgICBlbHNlIGRhMCA9IDAsIGEwMCA9IGExMCA9IChhMCArIGExKSAvIDI7XG4gICAgICAgIGlmICgoZGExIC09IHAxICogMikgPiBlcHNpbG9uKSBwMSAqPSAoY3cgPyAxIDogLTEpLCBhMDEgKz0gcDEsIGExMSAtPSBwMTtcbiAgICAgICAgZWxzZSBkYTEgPSAwLCBhMDEgPSBhMTEgPSAoYTAgKyBhMSkgLyAyO1xuICAgICAgfVxuXG4gICAgICB2YXIgeDAxID0gcjEgKiBjb3MoYTAxKSxcbiAgICAgICAgICB5MDEgPSByMSAqIHNpbihhMDEpLFxuICAgICAgICAgIHgxMCA9IHIwICogY29zKGExMCksXG4gICAgICAgICAgeTEwID0gcjAgKiBzaW4oYTEwKTtcblxuICAgICAgLy8gQXBwbHkgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgaWYgKHJjID4gZXBzaWxvbikge1xuICAgICAgICB2YXIgeDExID0gcjEgKiBjb3MoYTExKSxcbiAgICAgICAgICAgIHkxMSA9IHIxICogc2luKGExMSksXG4gICAgICAgICAgICB4MDAgPSByMCAqIGNvcyhhMDApLFxuICAgICAgICAgICAgeTAwID0gcjAgKiBzaW4oYTAwKTtcblxuICAgICAgICAvLyBSZXN0cmljdCB0aGUgY29ybmVyIHJhZGl1cyBhY2NvcmRpbmcgdG8gdGhlIHNlY3RvciBhbmdsZS5cbiAgICAgICAgaWYgKGRhIDwgcGkpIHtcbiAgICAgICAgICB2YXIgb2MgPSBkYTAgPiBlcHNpbG9uID8gaW50ZXJzZWN0KHgwMSwgeTAxLCB4MDAsIHkwMCwgeDExLCB5MTEsIHgxMCwgeTEwKSA6IFt4MTAsIHkxMF0sXG4gICAgICAgICAgICAgIGF4ID0geDAxIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGF5ID0geTAxIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGJ4ID0geDExIC0gb2NbMF0sXG4gICAgICAgICAgICAgIGJ5ID0geTExIC0gb2NbMV0sXG4gICAgICAgICAgICAgIGtjID0gMSAvIHNpbihhY29zKChheCAqIGJ4ICsgYXkgKiBieSkgLyAoc3FydChheCAqIGF4ICsgYXkgKiBheSkgKiBzcXJ0KGJ4ICogYnggKyBieSAqIGJ5KSkpIC8gMiksXG4gICAgICAgICAgICAgIGxjID0gc3FydChvY1swXSAqIG9jWzBdICsgb2NbMV0gKiBvY1sxXSk7XG4gICAgICAgICAgcmMwID0gbWluKHJjLCAocjAgLSBsYykgLyAoa2MgLSAxKSk7XG4gICAgICAgICAgcmMxID0gbWluKHJjLCAocjEgLSBsYykgLyAoa2MgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSXMgdGhlIHNlY3RvciBjb2xsYXBzZWQgdG8gYSBsaW5lP1xuICAgICAgaWYgKCEoZGExID4gZXBzaWxvbikpIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKTtcblxuICAgICAgLy8gRG9lcyB0aGUgc2VjdG9y4oCZcyBvdXRlciByaW5nIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMxID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgwMCwgeTAwLCB4MDEsIHkwMSwgcjEsIHJjMSwgY3cpO1xuICAgICAgICB0MSA9IGNvcm5lclRhbmdlbnRzKHgxMSwgeTExLCB4MTAsIHkxMCwgcjEsIHJjMSwgY3cpO1xuXG4gICAgICAgIGNvbnRleHQubW92ZVRvKHQwLmN4ICsgdDAueDAxLCB0MC5jeSArIHQwLnkwMSk7XG5cbiAgICAgICAgLy8gSGF2ZSB0aGUgY29ybmVycyBtZXJnZWQ/XG4gICAgICAgIGlmIChyYzEgPCByYykgY29udGV4dC5hcmModDAuY3gsIHQwLmN5LCByYzEsIGF0YW4yKHQwLnkwMSwgdDAueDAxKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgZHJhdyB0aGUgdHdvIGNvcm5lcnMgYW5kIHRoZSByaW5nLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMSwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MC55MTEsIHQwLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgcjEsIGF0YW4yKHQwLmN5ICsgdDAueTExLCB0MC5jeCArIHQwLngxMSksIGF0YW4yKHQxLmN5ICsgdDEueTExLCB0MS5jeCArIHQxLngxMSksICFjdyk7XG4gICAgICAgICAgY29udGV4dC5hcmModDEuY3gsIHQxLmN5LCByYzEsIGF0YW4yKHQxLnkxMSwgdDEueDExKSwgYXRhbjIodDEueTAxLCB0MS54MDEpLCAhY3cpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE9yIGlzIHRoZSBvdXRlciByaW5nIGp1c3QgYSBjaXJjdWxhciBhcmM/XG4gICAgICBlbHNlIGNvbnRleHQubW92ZVRvKHgwMSwgeTAxKSwgY29udGV4dC5hcmMoMCwgMCwgcjEsIGEwMSwgYTExLCAhY3cpO1xuXG4gICAgICAvLyBJcyB0aGVyZSBubyBpbm5lciByaW5nLCBhbmQgaXTigJlzIGEgY2lyY3VsYXIgc2VjdG9yP1xuICAgICAgLy8gT3IgcGVyaGFwcyBpdOKAmXMgYW4gYW5udWxhciBzZWN0b3IgY29sbGFwc2VkIGR1ZSB0byBwYWRkaW5nP1xuICAgICAgaWYgKCEocjAgPiBlcHNpbG9uKSB8fCAhKGRhMCA+IGVwc2lsb24pKSBjb250ZXh0LmxpbmVUbyh4MTAsIHkxMCk7XG5cbiAgICAgIC8vIERvZXMgdGhlIHNlY3RvcuKAmXMgaW5uZXIgcmluZyAob3IgcG9pbnQpIGhhdmUgcm91bmRlZCBjb3JuZXJzP1xuICAgICAgZWxzZSBpZiAocmMwID4gZXBzaWxvbikge1xuICAgICAgICB0MCA9IGNvcm5lclRhbmdlbnRzKHgxMCwgeTEwLCB4MTEsIHkxMSwgcjAsIC1yYzAsIGN3KTtcbiAgICAgICAgdDEgPSBjb3JuZXJUYW5nZW50cyh4MDEsIHkwMSwgeDAwLCB5MDAsIHIwLCAtcmMwLCBjdyk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8odDAuY3ggKyB0MC54MDEsIHQwLmN5ICsgdDAueTAxKTtcblxuICAgICAgICAvLyBIYXZlIHRoZSBjb3JuZXJzIG1lcmdlZD9cbiAgICAgICAgaWYgKHJjMCA8IHJjKSBjb250ZXh0LmFyYyh0MC5jeCwgdDAuY3ksIHJjMCwgYXRhbjIodDAueTAxLCB0MC54MDEpLCBhdGFuMih0MS55MDEsIHQxLngwMSksICFjdyk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBkcmF3IHRoZSB0d28gY29ybmVycyBhbmQgdGhlIHJpbmcuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQwLmN4LCB0MC5jeSwgcmMwLCBhdGFuMih0MC55MDEsIHQwLngwMSksIGF0YW4yKHQwLnkxMSwgdDAueDExKSwgIWN3KTtcbiAgICAgICAgICBjb250ZXh0LmFyYygwLCAwLCByMCwgYXRhbjIodDAuY3kgKyB0MC55MTEsIHQwLmN4ICsgdDAueDExKSwgYXRhbjIodDEuY3kgKyB0MS55MTEsIHQxLmN4ICsgdDEueDExKSwgY3cpO1xuICAgICAgICAgIGNvbnRleHQuYXJjKHQxLmN4LCB0MS5jeSwgcmMwLCBhdGFuMih0MS55MTEsIHQxLngxMSksIGF0YW4yKHQxLnkwMSwgdDEueDAxKSwgIWN3KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBPciBpcyB0aGUgaW5uZXIgcmluZyBqdXN0IGEgY2lyY3VsYXIgYXJjP1xuICAgICAgZWxzZSBjb250ZXh0LmFyYygwLCAwLCByMCwgYTEwLCBhMDAsIGN3KTtcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIGNvbnRleHQgPSBudWxsLCBidWZmZXIgKyBcIlwiIHx8IG51bGw7XG4gIH1cblxuICBhcmMuY2VudHJvaWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9ICgraW5uZXJSYWRpdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtvdXRlclJhZGl1cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIsXG4gICAgICAgIGEgPSAoK3N0YXJ0QW5nbGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSArICtlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSAvIDIgLSBwaSAvIDI7XG4gICAgcmV0dXJuIFtjb3MoYSkgKiByLCBzaW4oYSkgKiByXTtcbiAgfTtcblxuICBhcmMuaW5uZXJSYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaW5uZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGlubmVyUmFkaXVzO1xuICB9O1xuXG4gIGFyYy5vdXRlclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChvdXRlclJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogb3V0ZXJSYWRpdXM7XG4gIH07XG5cbiAgYXJjLmNvcm5lclJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb3JuZXJSYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IGNvcm5lclJhZGl1cztcbiAgfTtcblxuICBhcmMucGFkUmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZFJhZGl1cyA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJjKSA6IHBhZFJhZGl1cztcbiAgfTtcblxuICBhcmMuc3RhcnRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdGFydEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBzdGFydEFuZ2xlO1xuICB9O1xuXG4gIGFyYy5lbmRBbmdsZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChlbmRBbmdsZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmMpIDogZW5kQW5nbGU7XG4gIH07XG5cbiAgYXJjLnBhZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHBhZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyYykgOiBwYWRBbmdsZTtcbiAgfTtcblxuICBhcmMuY29udGV4dCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICgoY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfKSwgYXJjKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyYztcbn07XG5cbmZ1bmN0aW9uIExpbmVhcihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5MaW5lYXIucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpOyBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjdXJ2ZUxpbmVhciA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBMaW5lYXIoY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiB4KHApIHtcbiAgcmV0dXJuIHBbMF07XG59XG5cbmZ1bmN0aW9uIHkocCkge1xuICByZXR1cm4gcFsxXTtcbn1cblxudmFyIGxpbmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHgkJDEgPSB4LFxuICAgICAgeSQkMSA9IHksXG4gICAgICBkZWZpbmVkID0gY29uc3RhbnQodHJ1ZSksXG4gICAgICBjb250ZXh0ID0gbnVsbCxcbiAgICAgIGN1cnZlID0gY3VydmVMaW5lYXIsXG4gICAgICBvdXRwdXQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGQsXG4gICAgICAgIGRlZmluZWQwID0gZmFsc2UsXG4gICAgICAgIGJ1ZmZlcjtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSBvdXRwdXQubGluZVN0YXJ0KCk7XG4gICAgICAgIGVsc2Ugb3V0cHV0LmxpbmVFbmQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgb3V0cHV0LnBvaW50KCt4JCQxKGQsIGksIGRhdGEpLCAreSQkMShkLCBpLCBkYXRhKSk7XG4gICAgfVxuXG4gICAgaWYgKGJ1ZmZlcikgcmV0dXJuIG91dHB1dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmUueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmUpIDogeCQkMTtcbiAgfTtcblxuICBsaW5lLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5lKSA6IHkkJDE7XG4gIH07XG5cbiAgbGluZS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGxpbmUpIDogZGVmaW5lZDtcbiAgfTtcblxuICBsaW5lLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGxpbmUpIDogY3VydmU7XG4gIH07XG5cbiAgbGluZS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBsaW5lKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbmU7XG59O1xuXG52YXIgYXJlYSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeDAgPSB4LFxuICAgICAgeDEgPSBudWxsLFxuICAgICAgeTAgPSBjb25zdGFudCgwKSxcbiAgICAgIHkxID0geSxcbiAgICAgIGRlZmluZWQgPSBjb25zdGFudCh0cnVlKSxcbiAgICAgIGNvbnRleHQgPSBudWxsLFxuICAgICAgY3VydmUgPSBjdXJ2ZUxpbmVhcixcbiAgICAgIG91dHB1dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gYXJlYShkYXRhKSB7XG4gICAgdmFyIGksXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgZCxcbiAgICAgICAgZGVmaW5lZDAgPSBmYWxzZSxcbiAgICAgICAgYnVmZmVyLFxuICAgICAgICB4MHogPSBuZXcgQXJyYXkobiksXG4gICAgICAgIHkweiA9IG5ldyBBcnJheShuKTtcblxuICAgIGlmIChjb250ZXh0ID09IG51bGwpIG91dHB1dCA9IGN1cnZlKGJ1ZmZlciA9IGQzUGF0aC5wYXRoKCkpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8PSBuOyArK2kpIHtcbiAgICAgIGlmICghKGkgPCBuICYmIGRlZmluZWQoZCA9IGRhdGFbaV0sIGksIGRhdGEpKSA9PT0gZGVmaW5lZDApIHtcbiAgICAgICAgaWYgKGRlZmluZWQwID0gIWRlZmluZWQwKSB7XG4gICAgICAgICAgaiA9IGk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFTdGFydCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdXRwdXQubGluZUVuZCgpO1xuICAgICAgICAgIG91dHB1dC5saW5lU3RhcnQoKTtcbiAgICAgICAgICBmb3IgKGsgPSBpIC0gMTsgayA+PSBqOyAtLWspIHtcbiAgICAgICAgICAgIG91dHB1dC5wb2ludCh4MHpba10sIHkweltrXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dC5saW5lRW5kKCk7XG4gICAgICAgICAgb3V0cHV0LmFyZWFFbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRlZmluZWQwKSB7XG4gICAgICAgIHgweltpXSA9ICt4MChkLCBpLCBkYXRhKSwgeTB6W2ldID0gK3kwKGQsIGksIGRhdGEpO1xuICAgICAgICBvdXRwdXQucG9pbnQoeDEgPyAreDEoZCwgaSwgZGF0YSkgOiB4MHpbaV0sIHkxID8gK3kxKGQsIGksIGRhdGEpIDogeTB6W2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gb3V0cHV0ID0gbnVsbCwgYnVmZmVyICsgXCJcIiB8fCBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gYXJlYWxpbmUoKSB7XG4gICAgcmV0dXJuIGxpbmUoKS5kZWZpbmVkKGRlZmluZWQpLmN1cnZlKGN1cnZlKS5jb250ZXh0KGNvbnRleHQpO1xuICB9XG5cbiAgYXJlYS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHgxID0gbnVsbCwgYXJlYSkgOiB4MDtcbiAgfTtcblxuICBhcmVhLngwID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHgwID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGFyZWEpIDogeDA7XG4gIH07XG5cbiAgYXJlYS54MSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4MSA9IF8gPT0gbnVsbCA/IG51bGwgOiB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB4MTtcbiAgfTtcblxuICBhcmVhLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgeTEgPSBudWxsLCBhcmVhKSA6IHkwO1xuICB9O1xuXG4gIGFyZWEueTAgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeTAgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgYXJlYSkgOiB5MDtcbiAgfTtcblxuICBhcmVhLnkxID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkxID0gXyA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBhcmVhKSA6IHkxO1xuICB9O1xuXG4gIGFyZWEubGluZVgwID1cbiAgYXJlYS5saW5lWTAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXJlYWxpbmUoKS54KHgwKS55KHkwKTtcbiAgfTtcblxuICBhcmVhLmxpbmVZMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcmVhbGluZSgpLngoeDApLnkoeTEpO1xuICB9O1xuXG4gIGFyZWEubGluZVgxID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGFyZWFsaW5lKCkueCh4MSkueSh5MCk7XG4gIH07XG5cbiAgYXJlYS5kZWZpbmVkID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRlZmluZWQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCEhXyksIGFyZWEpIDogZGVmaW5lZDtcbiAgfTtcblxuICBhcmVhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGN1cnZlID0gXywgY29udGV4dCAhPSBudWxsICYmIChvdXRwdXQgPSBjdXJ2ZShjb250ZXh0KSksIGFyZWEpIDogY3VydmU7XG4gIH07XG5cbiAgYXJlYS5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKF8gPT0gbnVsbCA/IGNvbnRleHQgPSBvdXRwdXQgPSBudWxsIDogb3V0cHV0ID0gY3VydmUoY29udGV4dCA9IF8pLCBhcmVhKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGFyZWE7XG59O1xuXG52YXIgZGVzY2VuZGluZyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgcmV0dXJuIGIgPCBhID8gLTEgOiBiID4gYSA/IDEgOiBiID49IGEgPyAwIDogTmFOO1xufTtcblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24oZCkge1xuICByZXR1cm4gZDtcbn07XG5cbnZhciBwaWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZhbHVlID0gaWRlbnRpdHksXG4gICAgICBzb3J0VmFsdWVzID0gZGVzY2VuZGluZyxcbiAgICAgIHNvcnQgPSBudWxsLFxuICAgICAgc3RhcnRBbmdsZSA9IGNvbnN0YW50KDApLFxuICAgICAgZW5kQW5nbGUgPSBjb25zdGFudCh0YXUpLFxuICAgICAgcGFkQW5nbGUgPSBjb25zdGFudCgwKTtcblxuICBmdW5jdGlvbiBwaWUoZGF0YSkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGosXG4gICAgICAgIGssXG4gICAgICAgIHN1bSA9IDAsXG4gICAgICAgIGluZGV4ID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhcmNzID0gbmV3IEFycmF5KG4pLFxuICAgICAgICBhMCA9ICtzdGFydEFuZ2xlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIGRhID0gTWF0aC5taW4odGF1LCBNYXRoLm1heCgtdGF1LCBlbmRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIC0gYTApKSxcbiAgICAgICAgYTEsXG4gICAgICAgIHAgPSBNYXRoLm1pbihNYXRoLmFicyhkYSkgLyBuLCBwYWRBbmdsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSxcbiAgICAgICAgcGEgPSBwICogKGRhIDwgMCA/IC0xIDogMSksXG4gICAgICAgIHY7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoKHYgPSBhcmNzW2luZGV4W2ldID0gaV0gPSArdmFsdWUoZGF0YVtpXSwgaSwgZGF0YSkpID4gMCkge1xuICAgICAgICBzdW0gKz0gdjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNvcnQgdGhlIGFyY3MgYnkgcHJldmlvdXNseS1jb21wdXRlZCB2YWx1ZXMgb3IgYnkgZGF0YS5cbiAgICBpZiAoc29ydFZhbHVlcyAhPSBudWxsKSBpbmRleC5zb3J0KGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIHNvcnRWYWx1ZXMoYXJjc1tpXSwgYXJjc1tqXSk7IH0pO1xuICAgIGVsc2UgaWYgKHNvcnQgIT0gbnVsbCkgaW5kZXguc29ydChmdW5jdGlvbihpLCBqKSB7IHJldHVybiBzb3J0KGRhdGFbaV0sIGRhdGFbal0pOyB9KTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGFyY3MhIFRoZXkgYXJlIHN0b3JlZCBpbiB0aGUgb3JpZ2luYWwgZGF0YSdzIG9yZGVyLlxuICAgIGZvciAoaSA9IDAsIGsgPSBzdW0gPyAoZGEgLSBuICogcGEpIC8gc3VtIDogMDsgaSA8IG47ICsraSwgYTAgPSBhMSkge1xuICAgICAgaiA9IGluZGV4W2ldLCB2ID0gYXJjc1tqXSwgYTEgPSBhMCArICh2ID4gMCA/IHYgKiBrIDogMCkgKyBwYSwgYXJjc1tqXSA9IHtcbiAgICAgICAgZGF0YTogZGF0YVtqXSxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiB2LFxuICAgICAgICBzdGFydEFuZ2xlOiBhMCxcbiAgICAgICAgZW5kQW5nbGU6IGExLFxuICAgICAgICBwYWRBbmdsZTogcFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJjcztcbiAgfVxuXG4gIHBpZS52YWx1ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh2YWx1ZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBwaWUpIDogdmFsdWU7XG4gIH07XG5cbiAgcGllLnNvcnRWYWx1ZXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc29ydFZhbHVlcyA9IF8sIHNvcnQgPSBudWxsLCBwaWUpIDogc29ydFZhbHVlcztcbiAgfTtcblxuICBwaWUuc29ydCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzb3J0ID0gXywgc29ydFZhbHVlcyA9IG51bGwsIHBpZSkgOiBzb3J0O1xuICB9O1xuXG4gIHBpZS5zdGFydEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0YXJ0QW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHN0YXJ0QW5nbGU7XG4gIH07XG5cbiAgcGllLmVuZEFuZ2xlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGVuZEFuZ2xlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHBpZSkgOiBlbmRBbmdsZTtcbiAgfTtcblxuICBwaWUucGFkQW5nbGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocGFkQW5nbGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgcGllKSA6IHBhZEFuZ2xlO1xuICB9O1xuXG4gIHJldHVybiBwaWU7XG59O1xuXG52YXIgY3VydmVSYWRpYWxMaW5lYXIgPSBjdXJ2ZVJhZGlhbChjdXJ2ZUxpbmVhcik7XG5cbmZ1bmN0aW9uIFJhZGlhbChjdXJ2ZSkge1xuICB0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xufVxuXG5SYWRpYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmFyZWFTdGFydCgpO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jdXJ2ZS5hcmVhRW5kKCk7XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fY3VydmUubGluZVN0YXJ0KCk7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2N1cnZlLmxpbmVFbmQoKTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKGEsIHIpIHtcbiAgICB0aGlzLl9jdXJ2ZS5wb2ludChyICogTWF0aC5zaW4oYSksIHIgKiAtTWF0aC5jb3MoYSkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBjdXJ2ZVJhZGlhbChjdXJ2ZSkge1xuXG4gIGZ1bmN0aW9uIHJhZGlhbChjb250ZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBSYWRpYWwoY3VydmUoY29udGV4dCkpO1xuICB9XG5cbiAgcmFkaWFsLl9jdXJ2ZSA9IGN1cnZlO1xuXG4gIHJldHVybiByYWRpYWw7XG59XG5cbmZ1bmN0aW9uIGxpbmVSYWRpYWwobCkge1xuICB2YXIgYyA9IGwuY3VydmU7XG5cbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG5cbiAgbC5jdXJ2ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IGMoY3VydmVSYWRpYWwoXykpIDogYygpLl9jdXJ2ZTtcbiAgfTtcblxuICByZXR1cm4gbDtcbn1cblxudmFyIGxpbmVSYWRpYWwkMSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbGluZVJhZGlhbChsaW5lKCkuY3VydmUoY3VydmVSYWRpYWxMaW5lYXIpKTtcbn07XG5cbnZhciBhcmVhUmFkaWFsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhID0gYXJlYSgpLmN1cnZlKGN1cnZlUmFkaWFsTGluZWFyKSxcbiAgICAgIGMgPSBhLmN1cnZlLFxuICAgICAgeDAgPSBhLmxpbmVYMCxcbiAgICAgIHgxID0gYS5saW5lWDEsXG4gICAgICB5MCA9IGEubGluZVkwLFxuICAgICAgeTEgPSBhLmxpbmVZMTtcblxuICBhLmFuZ2xlID0gYS54LCBkZWxldGUgYS54O1xuICBhLnN0YXJ0QW5nbGUgPSBhLngwLCBkZWxldGUgYS54MDtcbiAgYS5lbmRBbmdsZSA9IGEueDEsIGRlbGV0ZSBhLngxO1xuICBhLnJhZGl1cyA9IGEueSwgZGVsZXRlIGEueTtcbiAgYS5pbm5lclJhZGl1cyA9IGEueTAsIGRlbGV0ZSBhLnkwO1xuICBhLm91dGVyUmFkaXVzID0gYS55MSwgZGVsZXRlIGEueTE7XG4gIGEubGluZVN0YXJ0QW5nbGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeDAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVYMDtcbiAgYS5saW5lRW5kQW5nbGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeDEoKSk7IH0sIGRlbGV0ZSBhLmxpbmVYMTtcbiAgYS5saW5lSW5uZXJSYWRpdXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTAoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMDtcbiAgYS5saW5lT3V0ZXJSYWRpdXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGxpbmVSYWRpYWwoeTEoKSk7IH0sIGRlbGV0ZSBhLmxpbmVZMTtcblxuICBhLmN1cnZlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gYyhjdXJ2ZVJhZGlhbChfKSkgOiBjKCkuX2N1cnZlO1xuICB9O1xuXG4gIHJldHVybiBhO1xufTtcblxudmFyIHBvaW50UmFkaWFsID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4gWyh5ID0gK3kpICogTWF0aC5jb3MoeCAtPSBNYXRoLlBJIC8gMiksIHkgKiBNYXRoLnNpbih4KV07XG59O1xuXG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGxpbmtTb3VyY2UoZCkge1xuICByZXR1cm4gZC5zb3VyY2U7XG59XG5cbmZ1bmN0aW9uIGxpbmtUYXJnZXQoZCkge1xuICByZXR1cm4gZC50YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGxpbmsoY3VydmUpIHtcbiAgdmFyIHNvdXJjZSA9IGxpbmtTb3VyY2UsXG4gICAgICB0YXJnZXQgPSBsaW5rVGFyZ2V0LFxuICAgICAgeCQkMSA9IHgsXG4gICAgICB5JCQxID0geSxcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGxpbmsoKSB7XG4gICAgdmFyIGJ1ZmZlciwgYXJndiA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKSwgcyA9IHNvdXJjZS5hcHBseSh0aGlzLCBhcmd2KSwgdCA9IHRhcmdldC5hcHBseSh0aGlzLCBhcmd2KTtcbiAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBidWZmZXIgPSBkM1BhdGgucGF0aCgpO1xuICAgIGN1cnZlKGNvbnRleHQsICt4JCQxLmFwcGx5KHRoaXMsIChhcmd2WzBdID0gcywgYXJndikpLCAreSQkMS5hcHBseSh0aGlzLCBhcmd2KSwgK3gkJDEuYXBwbHkodGhpcywgKGFyZ3ZbMF0gPSB0LCBhcmd2KSksICt5JCQxLmFwcGx5KHRoaXMsIGFyZ3YpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIGxpbmsuc291cmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHNvdXJjZSA9IF8sIGxpbmspIDogc291cmNlO1xuICB9O1xuXG4gIGxpbmsudGFyZ2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRhcmdldCA9IF8sIGxpbmspIDogdGFyZ2V0O1xuICB9O1xuXG4gIGxpbmsueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4JCQxID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGxpbmspIDogeCQkMTtcbiAgfTtcblxuICBsaW5rLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBsaW5rKSA6IHkkJDE7XG4gIH07XG5cbiAgbGluay5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKChjb250ZXh0ID0gXyA9PSBudWxsID8gbnVsbCA6IF8pLCBsaW5rKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGN1cnZlSG9yaXpvbnRhbChjb250ZXh0LCB4MCwgeTAsIHgxLCB5MSkge1xuICBjb250ZXh0Lm1vdmVUbyh4MCwgeTApO1xuICBjb250ZXh0LmJlemllckN1cnZlVG8oeDAgPSAoeDAgKyB4MSkgLyAyLCB5MCwgeDAsIHkxLCB4MSwgeTEpO1xufVxuXG5mdW5jdGlvbiBjdXJ2ZVZlcnRpY2FsKGNvbnRleHQsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIGNvbnRleHQubW92ZVRvKHgwLCB5MCk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCwgeTAgPSAoeTAgKyB5MSkgLyAyLCB4MSwgeTAsIHgxLCB5MSk7XG59XG5cbmZ1bmN0aW9uIGN1cnZlUmFkaWFsJDEoY29udGV4dCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIHAwID0gcG9pbnRSYWRpYWwoeDAsIHkwKSxcbiAgICAgIHAxID0gcG9pbnRSYWRpYWwoeDAsIHkwID0gKHkwICsgeTEpIC8gMiksXG4gICAgICBwMiA9IHBvaW50UmFkaWFsKHgxLCB5MCksXG4gICAgICBwMyA9IHBvaW50UmFkaWFsKHgxLCB5MSk7XG4gIGNvbnRleHQubW92ZVRvKHAwWzBdLCBwMFsxXSk7XG4gIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhwMVswXSwgcDFbMV0sIHAyWzBdLCBwMlsxXSwgcDNbMF0sIHAzWzFdKTtcbn1cblxuZnVuY3Rpb24gbGlua0hvcml6b250YWwoKSB7XG4gIHJldHVybiBsaW5rKGN1cnZlSG9yaXpvbnRhbCk7XG59XG5cbmZ1bmN0aW9uIGxpbmtWZXJ0aWNhbCgpIHtcbiAgcmV0dXJuIGxpbmsoY3VydmVWZXJ0aWNhbCk7XG59XG5cbmZ1bmN0aW9uIGxpbmtSYWRpYWwoKSB7XG4gIHZhciBsID0gbGluayhjdXJ2ZVJhZGlhbCQxKTtcbiAgbC5hbmdsZSA9IGwueCwgZGVsZXRlIGwueDtcbiAgbC5yYWRpdXMgPSBsLnksIGRlbGV0ZSBsLnk7XG4gIHJldHVybiBsO1xufVxuXG52YXIgY2lyY2xlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIHBpKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhyLCAwKTtcbiAgICBjb250ZXh0LmFyYygwLCAwLCByLCAwLCB0YXUpO1xuICB9XG59O1xuXG52YXIgY3Jvc3MgPSB7XG4gIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUpIHtcbiAgICB2YXIgciA9IE1hdGguc3FydChzaXplIC8gNSkgLyAyO1xuICAgIGNvbnRleHQubW92ZVRvKC0zICogciwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIC0zICogcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgLTMgKiByKTtcbiAgICBjb250ZXh0LmxpbmVUbyhyLCAtcik7XG4gICAgY29udGV4dC5saW5lVG8oMyAqIHIsIC1yKTtcbiAgICBjb250ZXh0LmxpbmVUbygzICogciwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgcik7XG4gICAgY29udGV4dC5saW5lVG8ociwgMyAqIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC1yLCAzICogcik7XG4gICAgY29udGV4dC5saW5lVG8oLXIsIHIpO1xuICAgIGNvbnRleHQubGluZVRvKC0zICogciwgcik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIHRhbjMwID0gTWF0aC5zcXJ0KDEgLyAzKTtcbnZhciB0YW4zMF8yID0gdGFuMzAgKiAyO1xuXG52YXIgZGlhbW9uZCA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gTWF0aC5zcXJ0KHNpemUgLyB0YW4zMF8yKSxcbiAgICAgICAgeCA9IHkgKiB0YW4zMDtcbiAgICBjb250ZXh0Lm1vdmVUbygwLCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oeCwgMCk7XG4gICAgY29udGV4dC5saW5lVG8oMCwgeSk7XG4gICAgY29udGV4dC5saW5lVG8oLXgsIDApO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBrYSA9IDAuODkwODEzMDkxNTI5Mjg1MjI4MTA7XG52YXIga3IgPSBNYXRoLnNpbihwaSAvIDEwKSAvIE1hdGguc2luKDcgKiBwaSAvIDEwKTtcbnZhciBreCA9IE1hdGguc2luKHRhdSAvIDEwKSAqIGtyO1xudmFyIGt5ID0gLU1hdGguY29zKHRhdSAvIDEwKSAqIGtyO1xuXG52YXIgc3RhciA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciByID0gTWF0aC5zcXJ0KHNpemUgKiBrYSksXG4gICAgICAgIHggPSBreCAqIHIsXG4gICAgICAgIHkgPSBreSAqIHI7XG4gICAgY29udGV4dC5tb3ZlVG8oMCwgLXIpO1xuICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgNTsgKytpKSB7XG4gICAgICB2YXIgYSA9IHRhdSAqIGkgLyA1LFxuICAgICAgICAgIGMgPSBNYXRoLmNvcyhhKSxcbiAgICAgICAgICBzID0gTWF0aC5zaW4oYSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzICogciwgLWMgKiByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGMgKiB4IC0gcyAqIHksIHMgKiB4ICsgYyAqIHkpO1xuICAgIH1cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9XG59O1xuXG52YXIgc3F1YXJlID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHcgPSBNYXRoLnNxcnQoc2l6ZSksXG4gICAgICAgIHggPSAtdyAvIDI7XG4gICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICB9XG59O1xuXG52YXIgc3FydDMgPSBNYXRoLnNxcnQoMyk7XG5cbnZhciB0cmlhbmdsZSA9IHtcbiAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSkge1xuICAgIHZhciB5ID0gLU1hdGguc3FydChzaXplIC8gKHNxcnQzICogMykpO1xuICAgIGNvbnRleHQubW92ZVRvKDAsIHkgKiAyKTtcbiAgICBjb250ZXh0LmxpbmVUbygtc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5saW5lVG8oc3FydDMgKiB5LCAteSk7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIGMgPSAtMC41O1xudmFyIHMgPSBNYXRoLnNxcnQoMykgLyAyO1xudmFyIGsgPSAxIC8gTWF0aC5zcXJ0KDEyKTtcbnZhciBhID0gKGsgLyAyICsgMSkgKiAzO1xuXG52YXIgd3llID0ge1xuICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplKSB7XG4gICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIGEpLFxuICAgICAgICB4MCA9IHIgLyAyLFxuICAgICAgICB5MCA9IHIgKiBrLFxuICAgICAgICB4MSA9IHgwLFxuICAgICAgICB5MSA9IHIgKiBrICsgcixcbiAgICAgICAgeDIgPSAteDEsXG4gICAgICAgIHkyID0geTE7XG4gICAgY29udGV4dC5tb3ZlVG8oeDAsIHkwKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwIC0gcyAqIHkwLCBzICogeDAgKyBjICogeTApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSAtIHMgKiB5MSwgcyAqIHgxICsgYyAqIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgLSBzICogeTIsIHMgKiB4MiArIGMgKiB5Mik7XG4gICAgY29udGV4dC5saW5lVG8oYyAqIHgwICsgcyAqIHkwLCBjICogeTAgLSBzICogeDApO1xuICAgIGNvbnRleHQubGluZVRvKGMgKiB4MSArIHMgKiB5MSwgYyAqIHkxIC0gcyAqIHgxKTtcbiAgICBjb250ZXh0LmxpbmVUbyhjICogeDIgKyBzICogeTIsIGMgKiB5MiAtIHMgKiB4Mik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblxudmFyIHN5bWJvbHMgPSBbXG4gIGNpcmNsZSxcbiAgY3Jvc3MsXG4gIGRpYW1vbmQsXG4gIHNxdWFyZSxcbiAgc3RhcixcbiAgdHJpYW5nbGUsXG4gIHd5ZVxuXTtcblxudmFyIHN5bWJvbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGNvbnN0YW50KGNpcmNsZSksXG4gICAgICBzaXplID0gY29uc3RhbnQoNjQpLFxuICAgICAgY29udGV4dCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gc3ltYm9sKCkge1xuICAgIHZhciBidWZmZXI7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gZDNQYXRoLnBhdGgoKTtcbiAgICB0eXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZHJhdyhjb250ZXh0LCArc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICBpZiAoYnVmZmVyKSByZXR1cm4gY29udGV4dCA9IG51bGwsIGJ1ZmZlciArIFwiXCIgfHwgbnVsbDtcbiAgfVxuXG4gIHN5bWJvbC50eXBlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHR5cGUgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KF8pLCBzeW1ib2wpIDogdHlwZTtcbiAgfTtcblxuICBzeW1ib2wuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN5bWJvbCkgOiBzaXplO1xuICB9O1xuXG4gIHN5bWJvbC5jb250ZXh0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNvbnRleHQgPSBfID09IG51bGwgPyBudWxsIDogXywgc3ltYm9sKSA6IGNvbnRleHQ7XG4gIH07XG5cbiAgcmV0dXJuIHN5bWJvbDtcbn07XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuZnVuY3Rpb24gcG9pbnQodGhhdCwgeCwgeSkge1xuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oXG4gICAgKDIgKiB0aGF0Ll94MCArIHRoYXQuX3gxKSAvIDMsXG4gICAgKDIgKiB0aGF0Ll95MCArIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgMiAqIHRoYXQuX3gxKSAvIDMsXG4gICAgKHRoYXQuX3kwICsgMiAqIHRoYXQuX3kxKSAvIDMsXG4gICAgKHRoYXQuX3gwICsgNCAqIHRoYXQuX3gxICsgeCkgLyA2LFxuICAgICh0aGF0Ll95MCArIDQgKiB0aGF0Ll95MSArIHkpIC8gNlxuICApO1xufVxuXG5mdW5jdGlvbiBCYXNpcyhjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpcy5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMzogcG9pbnQodGhpcywgdGhpcy5feDEsIHRoaXMuX3kxKTsgLy8gcHJvY2VlZFxuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX2NvbnRleHQubGluZVRvKCg1ICogdGhpcy5feDAgKyB0aGlzLl94MSkgLyA2LCAoNSAqIHRoaXMuX3kwICsgdGhpcy5feTEpIC8gNik7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxudmFyIGJhc2lzID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IEJhc2lzKGNvbnRleHQpO1xufTtcblxuZnVuY3Rpb24gQmFzaXNDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuQmFzaXNDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gdGhpcy5feTMgPSB0aGlzLl95NCA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMToge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94MiwgdGhpcy5feTIpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMjoge1xuICAgICAgICB0aGlzLl9jb250ZXh0Lm1vdmVUbygodGhpcy5feDIgKyAyICogdGhpcy5feDMpIC8gMywgKHRoaXMuX3kyICsgMiAqIHRoaXMuX3kzKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbygodGhpcy5feDMgKyAyICogdGhpcy5feDIpIC8gMywgKHRoaXMuX3kzICsgMiAqIHRoaXMuX3kyKSAvIDMpO1xuICAgICAgICB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMzoge1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3gyLCB0aGlzLl95Mik7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gyID0geCwgdGhpcy5feTIgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgdGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHk7IHRoaXMuX2NvbnRleHQubW92ZVRvKCh0aGlzLl94MCArIDQgKiB0aGlzLl94MSArIHgpIC8gNiwgKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2KTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCh0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX3gwID0gdGhpcy5feDEsIHRoaXMuX3gxID0geDtcbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxLCB0aGlzLl95MSA9IHk7XG4gIH1cbn07XG5cbnZhciBiYXNpc0Nsb3NlZCA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc0Nsb3NlZChjb250ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIEJhc2lzT3Blbihjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5CYXNpc09wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPVxuICAgIHRoaXMuX3kwID0gdGhpcy5feTEgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB2YXIgeDAgPSAodGhpcy5feDAgKyA0ICogdGhpcy5feDEgKyB4KSAvIDYsIHkwID0gKHRoaXMuX3kwICsgNCAqIHRoaXMuX3kxICsgeSkgLyA2OyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeDAsIHkwKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHgwLCB5MCk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50KHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgfVxufTtcblxudmFyIGJhc2lzT3BlbiA9IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBCYXNpc09wZW4oY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBCdW5kbGUoY29udGV4dCwgYmV0YSkge1xuICB0aGlzLl9iYXNpcyA9IG5ldyBCYXNpcyhjb250ZXh0KTtcbiAgdGhpcy5fYmV0YSA9IGJldGE7XG59XG5cbkJ1bmRsZS5wcm90b3R5cGUgPSB7XG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgICB0aGlzLl9iYXNpcy5saW5lU3RhcnQoKTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgaiA9IHgubGVuZ3RoIC0gMTtcblxuICAgIGlmIChqID4gMCkge1xuICAgICAgdmFyIHgwID0geFswXSxcbiAgICAgICAgICB5MCA9IHlbMF0sXG4gICAgICAgICAgZHggPSB4W2pdIC0geDAsXG4gICAgICAgICAgZHkgPSB5W2pdIC0geTAsXG4gICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgIHQ7XG5cbiAgICAgIHdoaWxlICgrK2kgPD0gaikge1xuICAgICAgICB0ID0gaSAvIGo7XG4gICAgICAgIHRoaXMuX2Jhc2lzLnBvaW50KFxuICAgICAgICAgIHRoaXMuX2JldGEgKiB4W2ldICsgKDEgLSB0aGlzLl9iZXRhKSAqICh4MCArIHQgKiBkeCksXG4gICAgICAgICAgdGhpcy5fYmV0YSAqIHlbaV0gKyAoMSAtIHRoaXMuX2JldGEpICogKHkwICsgdCAqIGR5KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3ggPSB0aGlzLl95ID0gbnVsbDtcbiAgICB0aGlzLl9iYXNpcy5saW5lRW5kKCk7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG52YXIgYnVuZGxlID0gKChmdW5jdGlvbiBjdXN0b20oYmV0YSkge1xuXG4gIGZ1bmN0aW9uIGJ1bmRsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGJldGEgPT09IDEgPyBuZXcgQmFzaXMoY29udGV4dCkgOiBuZXcgQnVuZGxlKGNvbnRleHQsIGJldGEpO1xuICB9XG5cbiAgYnVuZGxlLmJldGEgPSBmdW5jdGlvbihiZXRhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYmV0YSk7XG4gIH07XG5cbiAgcmV0dXJuIGJ1bmRsZTtcbn0pKSgwLjg1KTtcblxuZnVuY3Rpb24gcG9pbnQkMSh0aGF0LCB4LCB5KSB7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyhcbiAgICB0aGF0Ll94MSArIHRoYXQuX2sgKiAodGhhdC5feDIgLSB0aGF0Ll94MCksXG4gICAgdGhhdC5feTEgKyB0aGF0Ll9rICogKHRoYXQuX3kyIC0gdGhhdC5feTApLFxuICAgIHRoYXQuX3gyICsgdGhhdC5fayAqICh0aGF0Ll94MSAtIHgpLFxuICAgIHRoYXQuX3kyICsgdGhhdC5fayAqICh0aGF0Ll95MSAtIHkpLFxuICAgIHRoYXQuX3gyLFxuICAgIHRoYXQuX3kyXG4gICk7XG59XG5cbmZ1bmN0aW9uIENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWwucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAyOiB0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94MiwgdGhpcy5feTIpOyBicmVhaztcbiAgICAgIGNhc2UgMzogcG9pbnQkMSh0aGlzLCB0aGlzLl94MSwgdGhpcy5feTEpOyBicmVhaztcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IHRoaXMuX3gxID0geCwgdGhpcy5feTEgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyAvLyBwcm9jZWVkXG4gICAgICBkZWZhdWx0OiBwb2ludCQxKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsID0gKChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSkoMCk7XG5cbmZ1bmN0aW9uIENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2sgPSAoMSAtIHRlbnNpb24pIC8gNjtcbn1cblxuQ2FyZGluYWxDbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDE6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDI6IHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94MywgdGhpcy5feTMpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g0LCB0aGlzLl95NCk7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDUsIHRoaXMuX3k1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl94MyA9IHgsIHRoaXMuX3kzID0geTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgdGhpcy5fY29udGV4dC5tb3ZlVG8odGhpcy5feDQgPSB4LCB0aGlzLl95NCA9IHkpOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl94NSA9IHgsIHRoaXMuX3k1ID0geTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBwb2ludCQxKHRoaXMsIHgsIHkpOyBicmVhaztcbiAgICB9XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhcmRpbmFsQ2xvc2VkID0gKChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsQ2xvc2VkKGNvbnRleHQsIHRlbnNpb24pO1xuICB9XG5cbiAgY2FyZGluYWwudGVuc2lvbiA9IGZ1bmN0aW9uKHRlbnNpb24pIHtcbiAgICByZXR1cm4gY3VzdG9tKCt0ZW5zaW9uKTtcbiAgfTtcblxuICByZXR1cm4gY2FyZGluYWw7XG59KSkoMCk7XG5cbmZ1bmN0aW9uIENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLl9rID0gKDEgLSB0ZW5zaW9uKSAvIDY7XG59XG5cbkNhcmRpbmFsT3Blbi5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fbGluZSB8fCAodGhpcy5fbGluZSAhPT0gMCAmJiB0aGlzLl9wb2ludCA9PT0gMykpIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDEodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2FyZGluYWxPcGVuID0gKChmdW5jdGlvbiBjdXN0b20odGVuc2lvbikge1xuXG4gIGZ1bmN0aW9uIGNhcmRpbmFsKGNvbnRleHQpIHtcbiAgICByZXR1cm4gbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCB0ZW5zaW9uKTtcbiAgfVxuXG4gIGNhcmRpbmFsLnRlbnNpb24gPSBmdW5jdGlvbih0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrdGVuc2lvbik7XG4gIH07XG5cbiAgcmV0dXJuIGNhcmRpbmFsO1xufSkpKDApO1xuXG5mdW5jdGlvbiBwb2ludCQyKHRoYXQsIHgsIHkpIHtcbiAgdmFyIHgxID0gdGhhdC5feDEsXG4gICAgICB5MSA9IHRoYXQuX3kxLFxuICAgICAgeDIgPSB0aGF0Ll94MixcbiAgICAgIHkyID0gdGhhdC5feTI7XG5cbiAgaWYgKHRoYXQuX2wwMV9hID4gZXBzaWxvbikge1xuICAgIHZhciBhID0gMiAqIHRoYXQuX2wwMV8yYSArIDMgKiB0aGF0Ll9sMDFfYSAqIHRoYXQuX2wxMl9hICsgdGhhdC5fbDEyXzJhLFxuICAgICAgICBuID0gMyAqIHRoYXQuX2wwMV9hICogKHRoYXQuX2wwMV9hICsgdGhhdC5fbDEyX2EpO1xuICAgIHgxID0gKHgxICogYSAtIHRoYXQuX3gwICogdGhhdC5fbDEyXzJhICsgdGhhdC5feDIgKiB0aGF0Ll9sMDFfMmEpIC8gbjtcbiAgICB5MSA9ICh5MSAqIGEgLSB0aGF0Ll95MCAqIHRoYXQuX2wxMl8yYSArIHRoYXQuX3kyICogdGhhdC5fbDAxXzJhKSAvIG47XG4gIH1cblxuICBpZiAodGhhdC5fbDIzX2EgPiBlcHNpbG9uKSB7XG4gICAgdmFyIGIgPSAyICogdGhhdC5fbDIzXzJhICsgMyAqIHRoYXQuX2wyM19hICogdGhhdC5fbDEyX2EgKyB0aGF0Ll9sMTJfMmEsXG4gICAgICAgIG0gPSAzICogdGhhdC5fbDIzX2EgKiAodGhhdC5fbDIzX2EgKyB0aGF0Ll9sMTJfYSk7XG4gICAgeDIgPSAoeDIgKiBiICsgdGhhdC5feDEgKiB0aGF0Ll9sMjNfMmEgLSB4ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gICAgeTIgPSAoeTIgKiBiICsgdGhhdC5feTEgKiB0aGF0Ll9sMjNfMmEgLSB5ICogdGhhdC5fbDEyXzJhKSAvIG07XG4gIH1cblxuICB0aGF0Ll9jb250ZXh0LmJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHRoYXQuX3gyLCB0aGF0Ll95Mik7XG59XG5cbmZ1bmN0aW9uIENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb20ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMjogdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgICBjYXNlIDM6IHRoaXMucG9pbnQodGhpcy5feDIsIHRoaXMuX3kyKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgYnJlYWs7XG4gICAgICBjYXNlIDI6IHRoaXMuX3BvaW50ID0gMzsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDogcG9pbnQkMih0aGlzLCB4LCB5KTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSwgdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYTtcbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEsIHRoaXMuX2wxMl8yYSA9IHRoaXMuX2wyM18yYTtcbiAgICB0aGlzLl94MCA9IHRoaXMuX3gxLCB0aGlzLl94MSA9IHRoaXMuX3gyLCB0aGlzLl94MiA9IHg7XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSwgdGhpcy5feTEgPSB0aGlzLl95MiwgdGhpcy5feTIgPSB5O1xuICB9XG59O1xuXG52YXIgY2F0bXVsbFJvbSA9ICgoZnVuY3Rpb24gY3VzdG9tKGFscGhhKSB7XG5cbiAgZnVuY3Rpb24gY2F0bXVsbFJvbShjb250ZXh0KSB7XG4gICAgcmV0dXJuIGFscGhhID8gbmV3IENhdG11bGxSb20oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsKGNvbnRleHQsIDApO1xuICB9XG5cbiAgY2F0bXVsbFJvbS5hbHBoYSA9IGZ1bmN0aW9uKGFscGhhKSB7XG4gICAgcmV0dXJuIGN1c3RvbSgrYWxwaGEpO1xuICB9O1xuXG4gIHJldHVybiBjYXRtdWxsUm9tO1xufSkpKDAuNSk7XG5cbmZ1bmN0aW9uIENhdG11bGxSb21DbG9zZWQoY29udGV4dCwgYWxwaGEpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX2FscGhhID0gYWxwaGE7XG59XG5cbkNhdG11bGxSb21DbG9zZWQucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IG5vb3AsXG4gIGFyZWFFbmQ6IG5vb3AsXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9IHRoaXMuX3gyID0gdGhpcy5feDMgPSB0aGlzLl94NCA9IHRoaXMuX3g1ID1cbiAgICB0aGlzLl95MCA9IHRoaXMuX3kxID0gdGhpcy5feTIgPSB0aGlzLl95MyA9IHRoaXMuX3k0ID0gdGhpcy5feTUgPSBOYU47XG4gICAgdGhpcy5fbDAxX2EgPSB0aGlzLl9sMTJfYSA9IHRoaXMuX2wyM19hID1cbiAgICB0aGlzLl9sMDFfMmEgPSB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmEgPVxuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAxOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAyOiB7XG4gICAgICAgIHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gzLCB0aGlzLl95Myk7XG4gICAgICAgIHRoaXMuX2NvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAzOiB7XG4gICAgICAgIHRoaXMucG9pbnQodGhpcy5feDMsIHRoaXMuX3kzKTtcbiAgICAgICAgdGhpcy5wb2ludCh0aGlzLl94NCwgdGhpcy5feTQpO1xuICAgICAgICB0aGlzLnBvaW50KHRoaXMuX3g1LCB0aGlzLl95NSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gK3gsIHkgPSAreTtcblxuICAgIGlmICh0aGlzLl9wb2ludCkge1xuICAgICAgdmFyIHgyMyA9IHRoaXMuX3gyIC0geCxcbiAgICAgICAgICB5MjMgPSB0aGlzLl95MiAtIHk7XG4gICAgICB0aGlzLl9sMjNfYSA9IE1hdGguc3FydCh0aGlzLl9sMjNfMmEgPSBNYXRoLnBvdyh4MjMgKiB4MjMgKyB5MjMgKiB5MjMsIHRoaXMuX2FscGhhKSk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl9wb2ludCkge1xuICAgICAgY2FzZSAwOiB0aGlzLl9wb2ludCA9IDE7IHRoaXMuX3gzID0geCwgdGhpcy5feTMgPSB5OyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh0aGlzLl94NCA9IHgsIHRoaXMuX3k0ID0geSk7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHRoaXMuX3g1ID0geCwgdGhpcy5feTUgPSB5OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDIodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21DbG9zZWQgPSAoKGZ1bmN0aW9uIGN1c3RvbShhbHBoYSkge1xuXG4gIGZ1bmN0aW9uIGNhdG11bGxSb20oY29udGV4dCkge1xuICAgIHJldHVybiBhbHBoYSA/IG5ldyBDYXRtdWxsUm9tQ2xvc2VkKGNvbnRleHQsIGFscGhhKSA6IG5ldyBDYXJkaW5hbENsb3NlZChjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKSgwLjUpO1xuXG5mdW5jdGlvbiBDYXRtdWxsUm9tT3Blbihjb250ZXh0LCBhbHBoYSkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5fYWxwaGEgPSBhbHBoYTtcbn1cblxuQ2F0bXVsbFJvbU9wZW4ucHJvdG90eXBlID0ge1xuICBhcmVhU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSAwO1xuICB9LFxuICBhcmVhRW5kOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gTmFOO1xuICB9LFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3gwID0gdGhpcy5feDEgPSB0aGlzLl94MiA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9IHRoaXMuX3kyID0gTmFOO1xuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EgPSB0aGlzLl9sMjNfYSA9XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhID0gdGhpcy5fbDIzXzJhID1cbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAzKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgeCA9ICt4LCB5ID0gK3k7XG5cbiAgICBpZiAodGhpcy5fcG9pbnQpIHtcbiAgICAgIHZhciB4MjMgPSB0aGlzLl94MiAtIHgsXG4gICAgICAgICAgeTIzID0gdGhpcy5feTIgLSB5O1xuICAgICAgdGhpcy5fbDIzX2EgPSBNYXRoLnNxcnQodGhpcy5fbDIzXzJhID0gTWF0aC5wb3coeDIzICogeDIzICsgeTIzICogeTIzLCB0aGlzLl9hbHBoYSkpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyBicmVhaztcbiAgICAgIGNhc2UgMTogdGhpcy5fcG9pbnQgPSAyOyBicmVhaztcbiAgICAgIGNhc2UgMjogdGhpcy5fcG9pbnQgPSAzOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feDIsIHRoaXMuX3kyKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHRoaXMuX3gyLCB0aGlzLl95Mik7IGJyZWFrO1xuICAgICAgY2FzZSAzOiB0aGlzLl9wb2ludCA9IDQ7IC8vIHByb2NlZWRcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDIodGhpcywgeCwgeSk7IGJyZWFrO1xuICAgIH1cblxuICAgIHRoaXMuX2wwMV9hID0gdGhpcy5fbDEyX2EsIHRoaXMuX2wxMl9hID0gdGhpcy5fbDIzX2E7XG4gICAgdGhpcy5fbDAxXzJhID0gdGhpcy5fbDEyXzJhLCB0aGlzLl9sMTJfMmEgPSB0aGlzLl9sMjNfMmE7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB0aGlzLl94MiwgdGhpcy5feDIgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0gdGhpcy5feTIsIHRoaXMuX3kyID0geTtcbiAgfVxufTtcblxudmFyIGNhdG11bGxSb21PcGVuID0gKChmdW5jdGlvbiBjdXN0b20oYWxwaGEpIHtcblxuICBmdW5jdGlvbiBjYXRtdWxsUm9tKGNvbnRleHQpIHtcbiAgICByZXR1cm4gYWxwaGEgPyBuZXcgQ2F0bXVsbFJvbU9wZW4oY29udGV4dCwgYWxwaGEpIDogbmV3IENhcmRpbmFsT3Blbihjb250ZXh0LCAwKTtcbiAgfVxuXG4gIGNhdG11bGxSb20uYWxwaGEgPSBmdW5jdGlvbihhbHBoYSkge1xuICAgIHJldHVybiBjdXN0b20oK2FscGhhKTtcbiAgfTtcblxuICByZXR1cm4gY2F0bXVsbFJvbTtcbn0pKSgwLjUpO1xuXG5mdW5jdGlvbiBMaW5lYXJDbG9zZWQoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTGluZWFyQ2xvc2VkLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBub29wLFxuICBhcmVhRW5kOiBub29wLFxuICBsaW5lU3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3BvaW50ID0gMDtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BvaW50KSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIGlmICh0aGlzLl9wb2ludCkgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgZWxzZSB0aGlzLl9wb2ludCA9IDEsIHRoaXMuX2NvbnRleHQubW92ZVRvKHgsIHkpO1xuICB9XG59O1xuXG52YXIgbGluZWFyQ2xvc2VkID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IExpbmVhckNsb3NlZChjb250ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIHNpZ24oeCkge1xuICByZXR1cm4geCA8IDAgPyAtMSA6IDE7XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgc2xvcGVzIG9mIHRoZSB0YW5nZW50cyAoSGVybWl0ZS10eXBlIGludGVycG9sYXRpb24pIGJhc2VkIG9uXG4vLyB0aGUgZm9sbG93aW5nIHBhcGVyOiBTdGVmZmVuLCBNLiAxOTkwLiBBIFNpbXBsZSBNZXRob2QgZm9yIE1vbm90b25pY1xuLy8gSW50ZXJwb2xhdGlvbiBpbiBPbmUgRGltZW5zaW9uLiBBc3Ryb25vbXkgYW5kIEFzdHJvcGh5c2ljcywgVm9sLiAyMzksIE5PLlxuLy8gTk9WKElJKSwgUC4gNDQzLCAxOTkwLlxuZnVuY3Rpb24gc2xvcGUzKHRoYXQsIHgyLCB5Mikge1xuICB2YXIgaDAgPSB0aGF0Ll94MSAtIHRoYXQuX3gwLFxuICAgICAgaDEgPSB4MiAtIHRoYXQuX3gxLFxuICAgICAgczAgPSAodGhhdC5feTEgLSB0aGF0Ll95MCkgLyAoaDAgfHwgaDEgPCAwICYmIC0wKSxcbiAgICAgIHMxID0gKHkyIC0gdGhhdC5feTEpIC8gKGgxIHx8IGgwIDwgMCAmJiAtMCksXG4gICAgICBwID0gKHMwICogaDEgKyBzMSAqIGgwKSAvIChoMCArIGgxKTtcbiAgcmV0dXJuIChzaWduKHMwKSArIHNpZ24oczEpKSAqIE1hdGgubWluKE1hdGguYWJzKHMwKSwgTWF0aC5hYnMoczEpLCAwLjUgKiBNYXRoLmFicyhwKSkgfHwgMDtcbn1cblxuLy8gQ2FsY3VsYXRlIGEgb25lLXNpZGVkIHNsb3BlLlxuZnVuY3Rpb24gc2xvcGUyKHRoYXQsIHQpIHtcbiAgdmFyIGggPSB0aGF0Ll94MSAtIHRoYXQuX3gwO1xuICByZXR1cm4gaCA/ICgzICogKHRoYXQuX3kxIC0gdGhhdC5feTApIC8gaCAtIHQpIC8gMiA6IHQ7XG59XG5cbi8vIEFjY29yZGluZyB0byBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DdWJpY19IZXJtaXRlX3NwbGluZSNSZXByZXNlbnRhdGlvbnNcbi8vIFwieW91IGNhbiBleHByZXNzIGN1YmljIEhlcm1pdGUgaW50ZXJwb2xhdGlvbiBpbiB0ZXJtcyBvZiBjdWJpYyBCw6l6aWVyIGN1cnZlc1xuLy8gd2l0aCByZXNwZWN0IHRvIHRoZSBmb3VyIHZhbHVlcyBwMCwgcDAgKyBtMCAvIDMsIHAxIC0gbTEgLyAzLCBwMVwiLlxuZnVuY3Rpb24gcG9pbnQkMyh0aGF0LCB0MCwgdDEpIHtcbiAgdmFyIHgwID0gdGhhdC5feDAsXG4gICAgICB5MCA9IHRoYXQuX3kwLFxuICAgICAgeDEgPSB0aGF0Ll94MSxcbiAgICAgIHkxID0gdGhhdC5feTEsXG4gICAgICBkeCA9ICh4MSAtIHgwKSAvIDM7XG4gIHRoYXQuX2NvbnRleHQuYmV6aWVyQ3VydmVUbyh4MCArIGR4LCB5MCArIGR4ICogdDAsIHgxIC0gZHgsIHkxIC0gZHggKiB0MSwgeDEsIHkxKTtcbn1cblxuZnVuY3Rpb24gTW9ub3RvbmVYKGNvbnRleHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbk1vbm90b25lWC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSA9XG4gICAgdGhpcy5feTAgPSB0aGlzLl95MSA9XG4gICAgdGhpcy5fdDAgPSBOYU47XG4gICAgdGhpcy5fcG9pbnQgPSAwO1xuICB9LFxuICBsaW5lRW5kOiBmdW5jdGlvbigpIHtcbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDI6IHRoaXMuX2NvbnRleHQubGluZVRvKHRoaXMuX3gxLCB0aGlzLl95MSk7IGJyZWFrO1xuICAgICAgY2FzZSAzOiBwb2ludCQzKHRoaXMsIHRoaXMuX3QwLCBzbG9wZTIodGhpcywgdGhpcy5fdDApKTsgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIHRoaXMuX3BvaW50ID09PSAxKSkgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLl9saW5lID0gMSAtIHRoaXMuX2xpbmU7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHQxID0gTmFOO1xuXG4gICAgeCA9ICt4LCB5ID0gK3k7XG4gICAgaWYgKHggPT09IHRoaXMuX3gxICYmIHkgPT09IHRoaXMuX3kxKSByZXR1cm47IC8vIElnbm9yZSBjb2luY2lkZW50IHBvaW50cy5cbiAgICBzd2l0Y2ggKHRoaXMuX3BvaW50KSB7XG4gICAgICBjYXNlIDA6IHRoaXMuX3BvaW50ID0gMTsgdGhpcy5fbGluZSA/IHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkpIDogdGhpcy5fY29udGV4dC5tb3ZlVG8oeCwgeSk7IGJyZWFrO1xuICAgICAgY2FzZSAxOiB0aGlzLl9wb2ludCA9IDI7IGJyZWFrO1xuICAgICAgY2FzZSAyOiB0aGlzLl9wb2ludCA9IDM7IHBvaW50JDModGhpcywgc2xvcGUyKHRoaXMsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKSwgdDEpOyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHBvaW50JDModGhpcywgdGhpcy5fdDAsIHQxID0gc2xvcGUzKHRoaXMsIHgsIHkpKTsgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy5feDAgPSB0aGlzLl94MSwgdGhpcy5feDEgPSB4O1xuICAgIHRoaXMuX3kwID0gdGhpcy5feTEsIHRoaXMuX3kxID0geTtcbiAgICB0aGlzLl90MCA9IHQxO1xuICB9XG59O1xuXG5mdW5jdGlvbiBNb25vdG9uZVkoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gbmV3IFJlZmxlY3RDb250ZXh0KGNvbnRleHQpO1xufVxuXG4oTW9ub3RvbmVZLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTW9ub3RvbmVYLnByb3RvdHlwZSkpLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICBNb25vdG9uZVgucHJvdG90eXBlLnBvaW50LmNhbGwodGhpcywgeSwgeCk7XG59O1xuXG5mdW5jdGlvbiBSZWZsZWN0Q29udGV4dChjb250ZXh0KSB7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufVxuXG5SZWZsZWN0Q29udGV4dC5wcm90b3R5cGUgPSB7XG4gIG1vdmVUbzogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLl9jb250ZXh0Lm1vdmVUbyh5LCB4KTsgfSxcbiAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHsgdGhpcy5fY29udGV4dC5jbG9zZVBhdGgoKTsgfSxcbiAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7IHRoaXMuX2NvbnRleHQubGluZVRvKHksIHgpOyB9LFxuICBiZXppZXJDdXJ2ZVRvOiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkgeyB0aGlzLl9jb250ZXh0LmJlemllckN1cnZlVG8oeTEsIHgxLCB5MiwgeDIsIHksIHgpOyB9XG59O1xuXG5mdW5jdGlvbiBtb25vdG9uZVgoY29udGV4dCkge1xuICByZXR1cm4gbmV3IE1vbm90b25lWChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbW9ub3RvbmVZKGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBNb25vdG9uZVkoY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIE5hdHVyYWwoY29udGV4dCkge1xuICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbn1cblxuTmF0dXJhbC5wcm90b3R5cGUgPSB7XG4gIGFyZWFTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IDA7XG4gIH0sXG4gIGFyZWFFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpbmUgPSBOYU47XG4gIH0sXG4gIGxpbmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5feCA9IFtdO1xuICAgIHRoaXMuX3kgPSBbXTtcbiAgfSxcbiAgbGluZUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHggPSB0aGlzLl94LFxuICAgICAgICB5ID0gdGhpcy5feSxcbiAgICAgICAgbiA9IHgubGVuZ3RoO1xuXG4gICAgaWYgKG4pIHtcbiAgICAgIHRoaXMuX2xpbmUgPyB0aGlzLl9jb250ZXh0LmxpbmVUbyh4WzBdLCB5WzBdKSA6IHRoaXMuX2NvbnRleHQubW92ZVRvKHhbMF0sIHlbMF0pO1xuICAgICAgaWYgKG4gPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeFsxXSwgeVsxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHggPSBjb250cm9sUG9pbnRzKHgpLFxuICAgICAgICAgICAgcHkgPSBjb250cm9sUG9pbnRzKHkpO1xuICAgICAgICBmb3IgKHZhciBpMCA9IDAsIGkxID0gMTsgaTEgPCBuOyArK2kwLCArK2kxKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5iZXppZXJDdXJ2ZVRvKHB4WzBdW2kwXSwgcHlbMF1baTBdLCBweFsxXVtpMF0sIHB5WzFdW2kwXSwgeFtpMV0sIHlbaTFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lIHx8ICh0aGlzLl9saW5lICE9PSAwICYmIG4gPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuX2xpbmUgPSAxIC0gdGhpcy5fbGluZTtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IG51bGw7XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5feC5wdXNoKCt4KTtcbiAgICB0aGlzLl95LnB1c2goK3kpO1xuICB9XG59O1xuXG4vLyBTZWUgaHR0cHM6Ly93d3cucGFydGljbGVpbmNlbGwuY29tLzIwMTIvYmV6aWVyLXNwbGluZXMvIGZvciBkZXJpdmF0aW9uLlxuZnVuY3Rpb24gY29udHJvbFBvaW50cyh4KSB7XG4gIHZhciBpLFxuICAgICAgbiA9IHgubGVuZ3RoIC0gMSxcbiAgICAgIG0sXG4gICAgICBhID0gbmV3IEFycmF5KG4pLFxuICAgICAgYiA9IG5ldyBBcnJheShuKSxcbiAgICAgIHIgPSBuZXcgQXJyYXkobik7XG4gIGFbMF0gPSAwLCBiWzBdID0gMiwgclswXSA9IHhbMF0gKyAyICogeFsxXTtcbiAgZm9yIChpID0gMTsgaSA8IG4gLSAxOyArK2kpIGFbaV0gPSAxLCBiW2ldID0gNCwgcltpXSA9IDQgKiB4W2ldICsgMiAqIHhbaSArIDFdO1xuICBhW24gLSAxXSA9IDIsIGJbbiAtIDFdID0gNywgcltuIC0gMV0gPSA4ICogeFtuIC0gMV0gKyB4W25dO1xuICBmb3IgKGkgPSAxOyBpIDwgbjsgKytpKSBtID0gYVtpXSAvIGJbaSAtIDFdLCBiW2ldIC09IG0sIHJbaV0gLT0gbSAqIHJbaSAtIDFdO1xuICBhW24gLSAxXSA9IHJbbiAtIDFdIC8gYltuIC0gMV07XG4gIGZvciAoaSA9IG4gLSAyOyBpID49IDA7IC0taSkgYVtpXSA9IChyW2ldIC0gYVtpICsgMV0pIC8gYltpXTtcbiAgYltuIC0gMV0gPSAoeFtuXSArIGFbbiAtIDFdKSAvIDI7XG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgKytpKSBiW2ldID0gMiAqIHhbaSArIDFdIC0gYVtpICsgMV07XG4gIHJldHVybiBbYSwgYl07XG59XG5cbnZhciBuYXR1cmFsID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IE5hdHVyYWwoY29udGV4dCk7XG59O1xuXG5mdW5jdGlvbiBTdGVwKGNvbnRleHQsIHQpIHtcbiAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuX3QgPSB0O1xufVxuXG5TdGVwLnByb3RvdHlwZSA9IHtcbiAgYXJlYVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9saW5lID0gMDtcbiAgfSxcbiAgYXJlYUVuZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGluZSA9IE5hTjtcbiAgfSxcbiAgbGluZVN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl94ID0gdGhpcy5feSA9IE5hTjtcbiAgICB0aGlzLl9wb2ludCA9IDA7XG4gIH0sXG4gIGxpbmVFbmQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICgwIDwgdGhpcy5fdCAmJiB0aGlzLl90IDwgMSAmJiB0aGlzLl9wb2ludCA9PT0gMikgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgdGhpcy5feSk7XG4gICAgaWYgKHRoaXMuX2xpbmUgfHwgKHRoaXMuX2xpbmUgIT09IDAgJiYgdGhpcy5fcG9pbnQgPT09IDEpKSB0aGlzLl9jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGlmICh0aGlzLl9saW5lID49IDApIHRoaXMuX3QgPSAxIC0gdGhpcy5fdCwgdGhpcy5fbGluZSA9IDEgLSB0aGlzLl9saW5lO1xuICB9LFxuICBwb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgIHggPSAreCwgeSA9ICt5O1xuICAgIHN3aXRjaCAodGhpcy5fcG9pbnQpIHtcbiAgICAgIGNhc2UgMDogdGhpcy5fcG9pbnQgPSAxOyB0aGlzLl9saW5lID8gdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSkgOiB0aGlzLl9jb250ZXh0Lm1vdmVUbyh4LCB5KTsgYnJlYWs7XG4gICAgICBjYXNlIDE6IHRoaXMuX3BvaW50ID0gMjsgLy8gcHJvY2VlZFxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBpZiAodGhpcy5fdCA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHgxID0gdGhpcy5feCAqICgxIC0gdGhpcy5fdCkgKyB4ICogdGhpcy5fdDtcbiAgICAgICAgICB0aGlzLl9jb250ZXh0LmxpbmVUbyh4MSwgdGhpcy5feSk7XG4gICAgICAgICAgdGhpcy5fY29udGV4dC5saW5lVG8oeDEsIHkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl94ID0geCwgdGhpcy5feSA9IHk7XG4gIH1cbn07XG5cbnZhciBzdGVwID0gZnVuY3Rpb24oY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMC41KTtcbn07XG5cbmZ1bmN0aW9uIHN0ZXBCZWZvcmUoY29udGV4dCkge1xuICByZXR1cm4gbmV3IFN0ZXAoY29udGV4dCwgMCk7XG59XG5cbmZ1bmN0aW9uIHN0ZXBBZnRlcihjb250ZXh0KSB7XG4gIHJldHVybiBuZXcgU3RlcChjb250ZXh0LCAxKTtcbn1cblxudmFyIG5vbmUgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAxKSkgcmV0dXJuO1xuICBmb3IgKHZhciBpID0gMSwgaiwgczAsIHMxID0gc2VyaWVzW29yZGVyWzBdXSwgbiwgbSA9IHMxLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHMwID0gczEsIHMxID0gc2VyaWVzW29yZGVyW2ldXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBzMVtqXVsxXSArPSBzMVtqXVswXSA9IGlzTmFOKHMwW2pdWzFdKSA/IHMwW2pdWzBdIDogczBbal1bMV07XG4gICAgfVxuICB9XG59O1xuXG52YXIgbm9uZSQxID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCwgbyA9IG5ldyBBcnJheShuKTtcbiAgd2hpbGUgKC0tbiA+PSAwKSBvW25dID0gbjtcbiAgcmV0dXJuIG87XG59O1xuXG5mdW5jdGlvbiBzdGFja1ZhbHVlKGQsIGtleSkge1xuICByZXR1cm4gZFtrZXldO1xufVxuXG52YXIgc3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGtleXMgPSBjb25zdGFudChbXSksXG4gICAgICBvcmRlciA9IG5vbmUkMSxcbiAgICAgIG9mZnNldCA9IG5vbmUsXG4gICAgICB2YWx1ZSA9IHN0YWNrVmFsdWU7XG5cbiAgZnVuY3Rpb24gc3RhY2soZGF0YSkge1xuICAgIHZhciBreiA9IGtleXMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgaSxcbiAgICAgICAgbSA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBuID0ga3oubGVuZ3RoLFxuICAgICAgICBzeiA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgb3o7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmb3IgKHZhciBraSA9IGt6W2ldLCBzaSA9IHN6W2ldID0gbmV3IEFycmF5KG0pLCBqID0gMCwgc2lqOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIHNpW2pdID0gc2lqID0gWzAsICt2YWx1ZShkYXRhW2pdLCBraSwgaiwgZGF0YSldO1xuICAgICAgICBzaWouZGF0YSA9IGRhdGFbal07XG4gICAgICB9XG4gICAgICBzaS5rZXkgPSBraTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBveiA9IG9yZGVyKHN6KTsgaSA8IG47ICsraSkge1xuICAgICAgc3pbb3pbaV1dLmluZGV4ID0gaTtcbiAgICB9XG5cbiAgICBvZmZzZXQoc3osIG96KTtcbiAgICByZXR1cm4gc3o7XG4gIH1cblxuICBzdGFjay5rZXlzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGtleXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KHNsaWNlLmNhbGwoXykpLCBzdGFjaykgOiBrZXlzO1xuICB9O1xuXG4gIHN0YWNrLnZhbHVlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZhbHVlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIHN0YWNrKSA6IHZhbHVlO1xuICB9O1xuXG4gIHN0YWNrLm9yZGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9yZGVyID0gXyA9PSBudWxsID8gbm9uZSQxIDogdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudChzbGljZS5jYWxsKF8pKSwgc3RhY2spIDogb3JkZXI7XG4gIH07XG5cbiAgc3RhY2sub2Zmc2V0ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG9mZnNldCA9IF8gPT0gbnVsbCA/IG5vbmUgOiBfLCBzdGFjaykgOiBvZmZzZXQ7XG4gIH07XG5cbiAgcmV0dXJuIHN0YWNrO1xufTtcblxudmFyIGV4cGFuZCA9IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGksIG4sIGogPSAwLCBtID0gc2VyaWVzWzBdLmxlbmd0aCwgeTsgaiA8IG07ICsraikge1xuICAgIGZvciAoeSA9IGkgPSAwOyBpIDwgbjsgKytpKSB5ICs9IHNlcmllc1tpXVtqXVsxXSB8fCAwO1xuICAgIGlmICh5KSBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBzZXJpZXNbaV1bal1bMV0gLz0geTtcbiAgfVxuICBub25lKHNlcmllcywgb3JkZXIpO1xufTtcblxudmFyIGRpdmVyZ2luZyA9IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDEpKSByZXR1cm47XG4gIGZvciAodmFyIGksIGogPSAwLCBkLCBkeSwgeXAsIHluLCBuLCBtID0gc2VyaWVzW29yZGVyWzBdXS5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHlwID0geW4gPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChkeSA9IChkID0gc2VyaWVzW29yZGVyW2ldXVtqXSlbMV0gLSBkWzBdKSA+PSAwKSB7XG4gICAgICAgIGRbMF0gPSB5cCwgZFsxXSA9IHlwICs9IGR5O1xuICAgICAgfSBlbHNlIGlmIChkeSA8IDApIHtcbiAgICAgICAgZFsxXSA9IHluLCBkWzBdID0geW4gKz0gZHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkWzBdID0geXA7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2lsaG91ZXR0ZSA9IGZ1bmN0aW9uKHNlcmllcywgb3JkZXIpIHtcbiAgaWYgKCEoKG4gPSBzZXJpZXMubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIGogPSAwLCBzMCA9IHNlcmllc1tvcmRlclswXV0sIG4sIG0gPSBzMC5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgeSA9IDA7IGkgPCBuOyArK2kpIHkgKz0gc2VyaWVzW2ldW2pdWzFdIHx8IDA7XG4gICAgczBbal1bMV0gKz0gczBbal1bMF0gPSAteSAvIDI7XG4gIH1cbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn07XG5cbnZhciB3aWdnbGUgPSBmdW5jdGlvbihzZXJpZXMsIG9yZGVyKSB7XG4gIGlmICghKChuID0gc2VyaWVzLmxlbmd0aCkgPiAwKSB8fCAhKChtID0gKHMwID0gc2VyaWVzW29yZGVyWzBdXSkubGVuZ3RoKSA+IDApKSByZXR1cm47XG4gIGZvciAodmFyIHkgPSAwLCBqID0gMSwgczAsIG0sIG47IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBpID0gMCwgczEgPSAwLCBzMiA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBzaSA9IHNlcmllc1tvcmRlcltpXV0sXG4gICAgICAgICAgc2lqMCA9IHNpW2pdWzFdIHx8IDAsXG4gICAgICAgICAgc2lqMSA9IHNpW2ogLSAxXVsxXSB8fCAwLFxuICAgICAgICAgIHMzID0gKHNpajAgLSBzaWoxKSAvIDI7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGk7ICsraykge1xuICAgICAgICB2YXIgc2sgPSBzZXJpZXNbb3JkZXJba11dLFxuICAgICAgICAgICAgc2tqMCA9IHNrW2pdWzFdIHx8IDAsXG4gICAgICAgICAgICBza2oxID0gc2tbaiAtIDFdWzFdIHx8IDA7XG4gICAgICAgIHMzICs9IHNrajAgLSBza2oxO1xuICAgICAgfVxuICAgICAgczEgKz0gc2lqMCwgczIgKz0gczMgKiBzaWowO1xuICAgIH1cbiAgICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgICBpZiAoczEpIHkgLT0gczIgLyBzMTtcbiAgfVxuICBzMFtqIC0gMV1bMV0gKz0gczBbaiAtIDFdWzBdID0geTtcbiAgbm9uZShzZXJpZXMsIG9yZGVyKTtcbn07XG5cbnZhciBhc2NlbmRpbmcgPSBmdW5jdGlvbihzZXJpZXMpIHtcbiAgdmFyIHN1bXMgPSBzZXJpZXMubWFwKHN1bSk7XG4gIHJldHVybiBub25lJDEoc2VyaWVzKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIHN1bXNbYV0gLSBzdW1zW2JdOyB9KTtcbn07XG5cbmZ1bmN0aW9uIHN1bShzZXJpZXMpIHtcbiAgdmFyIHMgPSAwLCBpID0gLTEsIG4gPSBzZXJpZXMubGVuZ3RoLCB2O1xuICB3aGlsZSAoKytpIDwgbikgaWYgKHYgPSArc2VyaWVzW2ldWzFdKSBzICs9IHY7XG4gIHJldHVybiBzO1xufVxuXG52YXIgZGVzY2VuZGluZyQxID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHJldHVybiBhc2NlbmRpbmcoc2VyaWVzKS5yZXZlcnNlKCk7XG59O1xuXG52YXIgaW5zaWRlT3V0ID0gZnVuY3Rpb24oc2VyaWVzKSB7XG4gIHZhciBuID0gc2VyaWVzLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgc3VtcyA9IHNlcmllcy5tYXAoc3VtKSxcbiAgICAgIG9yZGVyID0gbm9uZSQxKHNlcmllcykuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBzdW1zW2JdIC0gc3Vtc1thXTsgfSksXG4gICAgICB0b3AgPSAwLFxuICAgICAgYm90dG9tID0gMCxcbiAgICAgIHRvcHMgPSBbXSxcbiAgICAgIGJvdHRvbXMgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgaiA9IG9yZGVyW2ldO1xuICAgIGlmICh0b3AgPCBib3R0b20pIHtcbiAgICAgIHRvcCArPSBzdW1zW2pdO1xuICAgICAgdG9wcy5wdXNoKGopO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3R0b20gKz0gc3Vtc1tqXTtcbiAgICAgIGJvdHRvbXMucHVzaChqKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm90dG9tcy5yZXZlcnNlKCkuY29uY2F0KHRvcHMpO1xufTtcblxudmFyIHJldmVyc2UgPSBmdW5jdGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIG5vbmUkMShzZXJpZXMpLnJldmVyc2UoKTtcbn07XG5cbmV4cG9ydHMuYXJjID0gYXJjO1xuZXhwb3J0cy5hcmVhID0gYXJlYTtcbmV4cG9ydHMubGluZSA9IGxpbmU7XG5leHBvcnRzLnBpZSA9IHBpZTtcbmV4cG9ydHMuYXJlYVJhZGlhbCA9IGFyZWFSYWRpYWw7XG5leHBvcnRzLnJhZGlhbEFyZWEgPSBhcmVhUmFkaWFsO1xuZXhwb3J0cy5saW5lUmFkaWFsID0gbGluZVJhZGlhbCQxO1xuZXhwb3J0cy5yYWRpYWxMaW5lID0gbGluZVJhZGlhbCQxO1xuZXhwb3J0cy5wb2ludFJhZGlhbCA9IHBvaW50UmFkaWFsO1xuZXhwb3J0cy5saW5rSG9yaXpvbnRhbCA9IGxpbmtIb3Jpem9udGFsO1xuZXhwb3J0cy5saW5rVmVydGljYWwgPSBsaW5rVmVydGljYWw7XG5leHBvcnRzLmxpbmtSYWRpYWwgPSBsaW5rUmFkaWFsO1xuZXhwb3J0cy5zeW1ib2wgPSBzeW1ib2w7XG5leHBvcnRzLnN5bWJvbHMgPSBzeW1ib2xzO1xuZXhwb3J0cy5zeW1ib2xDaXJjbGUgPSBjaXJjbGU7XG5leHBvcnRzLnN5bWJvbENyb3NzID0gY3Jvc3M7XG5leHBvcnRzLnN5bWJvbERpYW1vbmQgPSBkaWFtb25kO1xuZXhwb3J0cy5zeW1ib2xTcXVhcmUgPSBzcXVhcmU7XG5leHBvcnRzLnN5bWJvbFN0YXIgPSBzdGFyO1xuZXhwb3J0cy5zeW1ib2xUcmlhbmdsZSA9IHRyaWFuZ2xlO1xuZXhwb3J0cy5zeW1ib2xXeWUgPSB3eWU7XG5leHBvcnRzLmN1cnZlQmFzaXNDbG9zZWQgPSBiYXNpc0Nsb3NlZDtcbmV4cG9ydHMuY3VydmVCYXNpc09wZW4gPSBiYXNpc09wZW47XG5leHBvcnRzLmN1cnZlQmFzaXMgPSBiYXNpcztcbmV4cG9ydHMuY3VydmVCdW5kbGUgPSBidW5kbGU7XG5leHBvcnRzLmN1cnZlQ2FyZGluYWxDbG9zZWQgPSBjYXJkaW5hbENsb3NlZDtcbmV4cG9ydHMuY3VydmVDYXJkaW5hbE9wZW4gPSBjYXJkaW5hbE9wZW47XG5leHBvcnRzLmN1cnZlQ2FyZGluYWwgPSBjYXJkaW5hbDtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkID0gY2F0bXVsbFJvbUNsb3NlZDtcbmV4cG9ydHMuY3VydmVDYXRtdWxsUm9tT3BlbiA9IGNhdG11bGxSb21PcGVuO1xuZXhwb3J0cy5jdXJ2ZUNhdG11bGxSb20gPSBjYXRtdWxsUm9tO1xuZXhwb3J0cy5jdXJ2ZUxpbmVhckNsb3NlZCA9IGxpbmVhckNsb3NlZDtcbmV4cG9ydHMuY3VydmVMaW5lYXIgPSBjdXJ2ZUxpbmVhcjtcbmV4cG9ydHMuY3VydmVNb25vdG9uZVggPSBtb25vdG9uZVg7XG5leHBvcnRzLmN1cnZlTW9ub3RvbmVZID0gbW9ub3RvbmVZO1xuZXhwb3J0cy5jdXJ2ZU5hdHVyYWwgPSBuYXR1cmFsO1xuZXhwb3J0cy5jdXJ2ZVN0ZXAgPSBzdGVwO1xuZXhwb3J0cy5jdXJ2ZVN0ZXBBZnRlciA9IHN0ZXBBZnRlcjtcbmV4cG9ydHMuY3VydmVTdGVwQmVmb3JlID0gc3RlcEJlZm9yZTtcbmV4cG9ydHMuc3RhY2sgPSBzdGFjaztcbmV4cG9ydHMuc3RhY2tPZmZzZXRFeHBhbmQgPSBleHBhbmQ7XG5leHBvcnRzLnN0YWNrT2Zmc2V0RGl2ZXJnaW5nID0gZGl2ZXJnaW5nO1xuZXhwb3J0cy5zdGFja09mZnNldE5vbmUgPSBub25lO1xuZXhwb3J0cy5zdGFja09mZnNldFNpbGhvdWV0dGUgPSBzaWxob3VldHRlO1xuZXhwb3J0cy5zdGFja09mZnNldFdpZ2dsZSA9IHdpZ2dsZTtcbmV4cG9ydHMuc3RhY2tPcmRlckFzY2VuZGluZyA9IGFzY2VuZGluZztcbmV4cG9ydHMuc3RhY2tPcmRlckRlc2NlbmRpbmcgPSBkZXNjZW5kaW5nJDE7XG5leHBvcnRzLnN0YWNrT3JkZXJJbnNpZGVPdXQgPSBpbnNpZGVPdXQ7XG5leHBvcnRzLnN0YWNrT3JkZXJOb25lID0gbm9uZSQxO1xuZXhwb3J0cy5zdGFja09yZGVyUmV2ZXJzZSA9IHJldmVyc2U7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWUtZm9ybWF0LyBWZXJzaW9uIDIuMS4xLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXRpbWUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2QzLXRpbWUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSxnbG9iYWwuZDMpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLGQzVGltZSkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGxvY2FsRGF0ZShkKSB7XG4gIGlmICgwIDw9IGQueSAmJiBkLnkgPCAxMDApIHtcbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKC0xLCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKGQueSk7XG4gICAgcmV0dXJuIGRhdGU7XG4gIH1cbiAgcmV0dXJuIG5ldyBEYXRlKGQueSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCk7XG59XG5cbmZ1bmN0aW9uIHV0Y0RhdGUoZCkge1xuICBpZiAoMCA8PSBkLnkgJiYgZC55IDwgMTAwKSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgZC5tLCBkLmQsIGQuSCwgZC5NLCBkLlMsIGQuTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZC55LCBkLm0sIGQuZCwgZC5ILCBkLk0sIGQuUywgZC5MKSk7XG59XG5cbmZ1bmN0aW9uIG5ld1llYXIoeSkge1xuICByZXR1cm4ge3k6IHksIG06IDAsIGQ6IDEsIEg6IDAsIE06IDAsIFM6IDAsIEw6IDB9O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRMb2NhbGUobG9jYWxlKSB7XG4gIHZhciBsb2NhbGVfZGF0ZVRpbWUgPSBsb2NhbGUuZGF0ZVRpbWUsXG4gICAgICBsb2NhbGVfZGF0ZSA9IGxvY2FsZS5kYXRlLFxuICAgICAgbG9jYWxlX3RpbWUgPSBsb2NhbGUudGltZSxcbiAgICAgIGxvY2FsZV9wZXJpb2RzID0gbG9jYWxlLnBlcmlvZHMsXG4gICAgICBsb2NhbGVfd2Vla2RheXMgPSBsb2NhbGUuZGF5cyxcbiAgICAgIGxvY2FsZV9zaG9ydFdlZWtkYXlzID0gbG9jYWxlLnNob3J0RGF5cyxcbiAgICAgIGxvY2FsZV9tb250aHMgPSBsb2NhbGUubW9udGhzLFxuICAgICAgbG9jYWxlX3Nob3J0TW9udGhzID0gbG9jYWxlLnNob3J0TW9udGhzO1xuXG4gIHZhciBwZXJpb2RSZSA9IGZvcm1hdFJlKGxvY2FsZV9wZXJpb2RzKSxcbiAgICAgIHBlcmlvZExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfcGVyaW9kcyksXG4gICAgICB3ZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgd2Vla2RheUxvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfd2Vla2RheXMpLFxuICAgICAgc2hvcnRXZWVrZGF5UmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRXZWVrZGF5cyksXG4gICAgICBzaG9ydFdlZWtkYXlMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX3Nob3J0V2Vla2RheXMpLFxuICAgICAgbW9udGhSZSA9IGZvcm1hdFJlKGxvY2FsZV9tb250aHMpLFxuICAgICAgbW9udGhMb29rdXAgPSBmb3JtYXRMb29rdXAobG9jYWxlX21vbnRocyksXG4gICAgICBzaG9ydE1vbnRoUmUgPSBmb3JtYXRSZShsb2NhbGVfc2hvcnRNb250aHMpLFxuICAgICAgc2hvcnRNb250aExvb2t1cCA9IGZvcm1hdExvb2t1cChsb2NhbGVfc2hvcnRNb250aHMpO1xuXG4gIHZhciBmb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFdlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFNob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdE1vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXREYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdEhvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0SG91cjEyLFxuICAgIFwialwiOiBmb3JtYXREYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdE1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0TW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdE1pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFBlcmlvZCxcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFNlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFdlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFdlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFdlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFllYXIsXG4gICAgXCJZXCI6IGZvcm1hdEZ1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciB1dGNGb3JtYXRzID0ge1xuICAgIFwiYVwiOiBmb3JtYXRVVENTaG9ydFdlZWtkYXksXG4gICAgXCJBXCI6IGZvcm1hdFVUQ1dlZWtkYXksXG4gICAgXCJiXCI6IGZvcm1hdFVUQ1Nob3J0TW9udGgsXG4gICAgXCJCXCI6IGZvcm1hdFVUQ01vbnRoLFxuICAgIFwiY1wiOiBudWxsLFxuICAgIFwiZFwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBmb3JtYXRVVENEYXlPZk1vbnRoLFxuICAgIFwiZlwiOiBmb3JtYXRVVENNaWNyb3NlY29uZHMsXG4gICAgXCJIXCI6IGZvcm1hdFVUQ0hvdXIyNCxcbiAgICBcIklcIjogZm9ybWF0VVRDSG91cjEyLFxuICAgIFwialwiOiBmb3JtYXRVVENEYXlPZlllYXIsXG4gICAgXCJMXCI6IGZvcm1hdFVUQ01pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogZm9ybWF0VVRDTW9udGhOdW1iZXIsXG4gICAgXCJNXCI6IGZvcm1hdFVUQ01pbnV0ZXMsXG4gICAgXCJwXCI6IGZvcm1hdFVUQ1BlcmlvZCxcbiAgICBcIlFcIjogZm9ybWF0VW5peFRpbWVzdGFtcCxcbiAgICBcInNcIjogZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMsXG4gICAgXCJTXCI6IGZvcm1hdFVUQ1NlY29uZHMsXG4gICAgXCJ1XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJNb25kYXksXG4gICAgXCJVXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJTdW5kYXksXG4gICAgXCJWXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IGZvcm1hdFVUQ1dlZWtkYXlOdW1iZXJTdW5kYXksXG4gICAgXCJXXCI6IGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXksXG4gICAgXCJ4XCI6IG51bGwsXG4gICAgXCJYXCI6IG51bGwsXG4gICAgXCJ5XCI6IGZvcm1hdFVUQ1llYXIsXG4gICAgXCJZXCI6IGZvcm1hdFVUQ0Z1bGxZZWFyLFxuICAgIFwiWlwiOiBmb3JtYXRVVENab25lLFxuICAgIFwiJVwiOiBmb3JtYXRMaXRlcmFsUGVyY2VudFxuICB9O1xuXG4gIHZhciBwYXJzZXMgPSB7XG4gICAgXCJhXCI6IHBhcnNlU2hvcnRXZWVrZGF5LFxuICAgIFwiQVwiOiBwYXJzZVdlZWtkYXksXG4gICAgXCJiXCI6IHBhcnNlU2hvcnRNb250aCxcbiAgICBcIkJcIjogcGFyc2VNb250aCxcbiAgICBcImNcIjogcGFyc2VMb2NhbGVEYXRlVGltZSxcbiAgICBcImRcIjogcGFyc2VEYXlPZk1vbnRoLFxuICAgIFwiZVwiOiBwYXJzZURheU9mTW9udGgsXG4gICAgXCJmXCI6IHBhcnNlTWljcm9zZWNvbmRzLFxuICAgIFwiSFwiOiBwYXJzZUhvdXIyNCxcbiAgICBcIklcIjogcGFyc2VIb3VyMjQsXG4gICAgXCJqXCI6IHBhcnNlRGF5T2ZZZWFyLFxuICAgIFwiTFwiOiBwYXJzZU1pbGxpc2Vjb25kcyxcbiAgICBcIm1cIjogcGFyc2VNb250aE51bWJlcixcbiAgICBcIk1cIjogcGFyc2VNaW51dGVzLFxuICAgIFwicFwiOiBwYXJzZVBlcmlvZCxcbiAgICBcIlFcIjogcGFyc2VVbml4VGltZXN0YW1wLFxuICAgIFwic1wiOiBwYXJzZVVuaXhUaW1lc3RhbXBTZWNvbmRzLFxuICAgIFwiU1wiOiBwYXJzZVNlY29uZHMsXG4gICAgXCJ1XCI6IHBhcnNlV2Vla2RheU51bWJlck1vbmRheSxcbiAgICBcIlVcIjogcGFyc2VXZWVrTnVtYmVyU3VuZGF5LFxuICAgIFwiVlwiOiBwYXJzZVdlZWtOdW1iZXJJU08sXG4gICAgXCJ3XCI6IHBhcnNlV2Vla2RheU51bWJlclN1bmRheSxcbiAgICBcIldcIjogcGFyc2VXZWVrTnVtYmVyTW9uZGF5LFxuICAgIFwieFwiOiBwYXJzZUxvY2FsZURhdGUsXG4gICAgXCJYXCI6IHBhcnNlTG9jYWxlVGltZSxcbiAgICBcInlcIjogcGFyc2VZZWFyLFxuICAgIFwiWVwiOiBwYXJzZUZ1bGxZZWFyLFxuICAgIFwiWlwiOiBwYXJzZVpvbmUsXG4gICAgXCIlXCI6IHBhcnNlTGl0ZXJhbFBlcmNlbnRcbiAgfTtcblxuICAvLyBUaGVzZSByZWN1cnNpdmUgZGlyZWN0aXZlIGRlZmluaXRpb25zIG11c3QgYmUgZGVmZXJyZWQuXG4gIGZvcm1hdHMueCA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuWCA9IG5ld0Zvcm1hdChsb2NhbGVfdGltZSwgZm9ybWF0cyk7XG4gIGZvcm1hdHMuYyA9IG5ld0Zvcm1hdChsb2NhbGVfZGF0ZVRpbWUsIGZvcm1hdHMpO1xuICB1dGNGb3JtYXRzLnggPSBuZXdGb3JtYXQobG9jYWxlX2RhdGUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLlggPSBuZXdGb3JtYXQobG9jYWxlX3RpbWUsIHV0Y0Zvcm1hdHMpO1xuICB1dGNGb3JtYXRzLmMgPSBuZXdGb3JtYXQobG9jYWxlX2RhdGVUaW1lLCB1dGNGb3JtYXRzKTtcblxuICBmdW5jdGlvbiBuZXdGb3JtYXQoc3BlY2lmaWVyLCBmb3JtYXRzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBbXSxcbiAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgaiA9IDAsXG4gICAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgICAgYyxcbiAgICAgICAgICBwYWQsXG4gICAgICAgICAgZm9ybWF0O1xuXG4gICAgICBpZiAoIShkYXRlIGluc3RhbmNlb2YgRGF0ZSkpIGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XG5cbiAgICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICAgIGlmIChzcGVjaWZpZXIuY2hhckNvZGVBdChpKSA9PT0gMzcpIHtcbiAgICAgICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgICAgIGlmICgocGFkID0gcGFkc1tjID0gc3BlY2lmaWVyLmNoYXJBdCgrK2kpXSkgIT0gbnVsbCkgYyA9IHNwZWNpZmllci5jaGFyQXQoKytpKTtcbiAgICAgICAgICBlbHNlIHBhZCA9IGMgPT09IFwiZVwiID8gXCIgXCIgOiBcIjBcIjtcbiAgICAgICAgICBpZiAoZm9ybWF0ID0gZm9ybWF0c1tjXSkgYyA9IGZvcm1hdChkYXRlLCBwYWQpO1xuICAgICAgICAgIHN0cmluZy5wdXNoKGMpO1xuICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzdHJpbmcucHVzaChzcGVjaWZpZXIuc2xpY2UoaiwgaSkpO1xuICAgICAgcmV0dXJuIHN0cmluZy5qb2luKFwiXCIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBuZXdQYXJzZShzcGVjaWZpZXIsIG5ld0RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICB2YXIgZCA9IG5ld1llYXIoMTkwMCksXG4gICAgICAgICAgaSA9IHBhcnNlU3BlY2lmaWVyKGQsIHNwZWNpZmllciwgc3RyaW5nICs9IFwiXCIsIDApLFxuICAgICAgICAgIHdlZWssIGRheTtcbiAgICAgIGlmIChpICE9IHN0cmluZy5sZW5ndGgpIHJldHVybiBudWxsO1xuXG4gICAgICAvLyBJZiBhIFVOSVggdGltZXN0YW1wIGlzIHNwZWNpZmllZCwgcmV0dXJuIGl0LlxuICAgICAgaWYgKFwiUVwiIGluIGQpIHJldHVybiBuZXcgRGF0ZShkLlEpO1xuXG4gICAgICAvLyBUaGUgYW0tcG0gZmxhZyBpcyAwIGZvciBBTSwgYW5kIDEgZm9yIFBNLlxuICAgICAgaWYgKFwicFwiIGluIGQpIGQuSCA9IGQuSCAlIDEyICsgZC5wICogMTI7XG5cbiAgICAgIC8vIENvbnZlcnQgZGF5LW9mLXdlZWsgYW5kIHdlZWstb2YteWVhciB0byBkYXktb2YteWVhci5cbiAgICAgIGlmIChcIlZcIiBpbiBkKSB7XG4gICAgICAgIGlmIChkLlYgPCAxIHx8IGQuViA+IDUzKSByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKCEoXCJ3XCIgaW4gZCkpIGQudyA9IDE7XG4gICAgICAgIGlmIChcIlpcIiBpbiBkKSB7XG4gICAgICAgICAgd2VlayA9IHV0Y0RhdGUobmV3WWVhcihkLnkpKSwgZGF5ID0gd2Vlay5nZXRVVENEYXkoKTtcbiAgICAgICAgICB3ZWVrID0gZGF5ID4gNCB8fCBkYXkgPT09IDAgPyBkM1RpbWUudXRjTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudXRjTW9uZGF5KHdlZWspO1xuICAgICAgICAgIHdlZWsgPSBkM1RpbWUudXRjRGF5Lm9mZnNldCh3ZWVrLCAoZC5WIC0gMSkgKiA3KTtcbiAgICAgICAgICBkLnkgPSB3ZWVrLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgZC5tID0gd2Vlay5nZXRVVENNb250aCgpO1xuICAgICAgICAgIGQuZCA9IHdlZWsuZ2V0VVRDRGF0ZSgpICsgKGQudyArIDYpICUgNztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ZWVrID0gbmV3RGF0ZShuZXdZZWFyKGQueSkpLCBkYXkgPSB3ZWVrLmdldERheSgpO1xuICAgICAgICAgIHdlZWsgPSBkYXkgPiA0IHx8IGRheSA9PT0gMCA/IGQzVGltZS50aW1lTW9uZGF5LmNlaWwod2VlaykgOiBkM1RpbWUudGltZU1vbmRheSh3ZWVrKTtcbiAgICAgICAgICB3ZWVrID0gZDNUaW1lLnRpbWVEYXkub2Zmc2V0KHdlZWssIChkLlYgLSAxKSAqIDcpO1xuICAgICAgICAgIGQueSA9IHdlZWsuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgICBkLm0gPSB3ZWVrLmdldE1vbnRoKCk7XG4gICAgICAgICAgZC5kID0gd2Vlay5nZXREYXRlKCkgKyAoZC53ICsgNikgJSA3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFwiV1wiIGluIGQgfHwgXCJVXCIgaW4gZCkge1xuICAgICAgICBpZiAoIShcIndcIiBpbiBkKSkgZC53ID0gXCJ1XCIgaW4gZCA/IGQudSAlIDcgOiBcIldcIiBpbiBkID8gMSA6IDA7XG4gICAgICAgIGRheSA9IFwiWlwiIGluIGQgPyB1dGNEYXRlKG5ld1llYXIoZC55KSkuZ2V0VVRDRGF5KCkgOiBuZXdEYXRlKG5ld1llYXIoZC55KSkuZ2V0RGF5KCk7XG4gICAgICAgIGQubSA9IDA7XG4gICAgICAgIGQuZCA9IFwiV1wiIGluIGQgPyAoZC53ICsgNikgJSA3ICsgZC5XICogNyAtIChkYXkgKyA1KSAlIDcgOiBkLncgKyBkLlUgKiA3IC0gKGRheSArIDYpICUgNztcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYSB0aW1lIHpvbmUgaXMgc3BlY2lmaWVkLCBhbGwgZmllbGRzIGFyZSBpbnRlcnByZXRlZCBhcyBVVEMgYW5kIHRoZW5cbiAgICAgIC8vIG9mZnNldCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCB0aW1lIHpvbmUuXG4gICAgICBpZiAoXCJaXCIgaW4gZCkge1xuICAgICAgICBkLkggKz0gZC5aIC8gMTAwIHwgMDtcbiAgICAgICAgZC5NICs9IGQuWiAlIDEwMDtcbiAgICAgICAgcmV0dXJuIHV0Y0RhdGUoZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSwgYWxsIGZpZWxkcyBhcmUgaW4gbG9jYWwgdGltZS5cbiAgICAgIHJldHVybiBuZXdEYXRlKGQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVNwZWNpZmllcihkLCBzcGVjaWZpZXIsIHN0cmluZywgaikge1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgbiA9IHNwZWNpZmllci5sZW5ndGgsXG4gICAgICAgIG0gPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICBjLFxuICAgICAgICBwYXJzZTtcblxuICAgIHdoaWxlIChpIDwgbikge1xuICAgICAgaWYgKGogPj0gbSkgcmV0dXJuIC0xO1xuICAgICAgYyA9IHNwZWNpZmllci5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICBpZiAoYyA9PT0gMzcpIHtcbiAgICAgICAgYyA9IHNwZWNpZmllci5jaGFyQXQoaSsrKTtcbiAgICAgICAgcGFyc2UgPSBwYXJzZXNbYyBpbiBwYWRzID8gc3BlY2lmaWVyLmNoYXJBdChpKyspIDogY107XG4gICAgICAgIGlmICghcGFyc2UgfHwgKChqID0gcGFyc2UoZCwgc3RyaW5nLCBqKSkgPCAwKSkgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChjICE9IHN0cmluZy5jaGFyQ29kZUF0KGorKykpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBqO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VQZXJpb2QoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBwZXJpb2RSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gICAgcmV0dXJuIG4gPyAoZC5wID0gcGVyaW9kTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlU2hvcnRXZWVrZGF5KGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRXZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHNob3J0V2Vla2RheUxvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSB3ZWVrZGF5UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSkpO1xuICAgIHJldHVybiBuID8gKGQudyA9IHdlZWtkYXlMb29rdXBbblswXS50b0xvd2VyQ2FzZSgpXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VTaG9ydE1vbnRoKGQsIHN0cmluZywgaSkge1xuICAgIHZhciBuID0gc2hvcnRNb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBzaG9ydE1vbnRoTG9va3VwW25bMF0udG9Mb3dlckNhc2UoKV0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlTW9udGgoZCwgc3RyaW5nLCBpKSB7XG4gICAgdmFyIG4gPSBtb250aFJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgICByZXR1cm4gbiA/IChkLm0gPSBtb250aExvb2t1cFtuWzBdLnRvTG93ZXJDYXNlKCldLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfZGF0ZVRpbWUsIHN0cmluZywgaSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUxvY2FsZURhdGUoZCwgc3RyaW5nLCBpKSB7XG4gICAgcmV0dXJuIHBhcnNlU3BlY2lmaWVyKGQsIGxvY2FsZV9kYXRlLCBzdHJpbmcsIGkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VMb2NhbGVUaW1lKGQsIHN0cmluZywgaSkge1xuICAgIHJldHVybiBwYXJzZVNwZWNpZmllcihkLCBsb2NhbGVfdGltZSwgc3RyaW5nLCBpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0RGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldERheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFNob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdE1vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldE1vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0UGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldEhvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0V2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV9zaG9ydFdlZWtkYXlzW2QuZ2V0VVRDRGF5KCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDV2Vla2RheShkKSB7XG4gICAgcmV0dXJuIGxvY2FsZV93ZWVrZGF5c1tkLmdldFVUQ0RheSgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ1Nob3J0TW9udGgoZCkge1xuICAgIHJldHVybiBsb2NhbGVfc2hvcnRNb250aHNbZC5nZXRVVENNb250aCgpXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcm1hdFVUQ01vbnRoKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX21vbnRoc1tkLmdldFVUQ01vbnRoKCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0VVRDUGVyaW9kKGQpIHtcbiAgICByZXR1cm4gbG9jYWxlX3BlcmlvZHNbKyhkLmdldFVUQ0hvdXJzKCkgPj0gMTIpXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCBmb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIgKz0gXCJcIiwgbG9jYWxEYXRlKTtcbiAgICAgIHAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgdXRjRm9ybWF0OiBmdW5jdGlvbihzcGVjaWZpZXIpIHtcbiAgICAgIHZhciBmID0gbmV3Rm9ybWF0KHNwZWNpZmllciArPSBcIlwiLCB1dGNGb3JtYXRzKTtcbiAgICAgIGYudG9TdHJpbmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHNwZWNpZmllcjsgfTtcbiAgICAgIHJldHVybiBmO1xuICAgIH0sXG4gICAgdXRjUGFyc2U6IGZ1bmN0aW9uKHNwZWNpZmllcikge1xuICAgICAgdmFyIHAgPSBuZXdQYXJzZShzcGVjaWZpZXIsIHV0Y0RhdGUpO1xuICAgICAgcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gc3BlY2lmaWVyOyB9O1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9O1xufVxuXG52YXIgcGFkcyA9IHtcIi1cIjogXCJcIiwgXCJfXCI6IFwiIFwiLCBcIjBcIjogXCIwXCJ9O1xudmFyIG51bWJlclJlID0gL15cXHMqXFxkKy87XG52YXIgcGVyY2VudFJlID0gL14lLztcbnZhciByZXF1b3RlUmUgPSAvW1xcXFxeJCorP3xbXFxdKCkue31dL2c7XG5cbmZ1bmN0aW9uIHBhZCh2YWx1ZSwgZmlsbCwgd2lkdGgpIHtcbiAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyBcIi1cIiA6IFwiXCIsXG4gICAgICBzdHJpbmcgPSAoc2lnbiA/IC12YWx1ZSA6IHZhbHVlKSArIFwiXCIsXG4gICAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICByZXR1cm4gc2lnbiArIChsZW5ndGggPCB3aWR0aCA/IG5ldyBBcnJheSh3aWR0aCAtIGxlbmd0aCArIDEpLmpvaW4oZmlsbCkgKyBzdHJpbmcgOiBzdHJpbmcpO1xufVxuXG5mdW5jdGlvbiByZXF1b3RlKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShyZXF1b3RlUmUsIFwiXFxcXCQmXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRSZShuYW1lcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oPzpcIiArIG5hbWVzLm1hcChyZXF1b3RlKS5qb2luKFwifFwiKSArIFwiKVwiLCBcImlcIik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdExvb2t1cChuYW1lcykge1xuICB2YXIgbWFwID0ge30sIGkgPSAtMSwgbiA9IG5hbWVzLmxlbmd0aDtcbiAgd2hpbGUgKCsraSA8IG4pIG1hcFtuYW1lc1tpXS50b0xvd2VyQ2FzZSgpXSA9IGk7XG4gIHJldHVybiBtYXA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla2RheU51bWJlclN1bmRheShkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMSkpO1xuICByZXR1cm4gbiA/IChkLncgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtkYXlOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyAoZC51ID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VXZWVrTnVtYmVyU3VuZGF5KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuVSA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlV2Vla051bWJlcklTTyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLlYgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVdlZWtOdW1iZXJNb25kYXkoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5XID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdWxsWWVhcihkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNCkpO1xuICByZXR1cm4gbiA/IChkLnkgPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC55ID0gK25bMF0gKyAoK25bMF0gPiA2OCA/IDE5MDAgOiAyMDAwKSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVpvbmUoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gL14oWil8KFsrLV1cXGRcXGQpKD86Oj8oXFxkXFxkKSk/Ly5leGVjKHN0cmluZy5zbGljZShpLCBpICsgNikpO1xuICByZXR1cm4gbiA/IChkLlogPSBuWzFdID8gMCA6IC0oblsyXSArIChuWzNdIHx8IFwiMDBcIikpLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhOdW1iZXIoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5tID0gblswXSAtIDEsIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXlPZk1vbnRoKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF5T2ZZZWFyKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAzKSk7XG4gIHJldHVybiBuID8gKGQubSA9IDAsIGQuZCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSG91cjI0KGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGksIGkgKyAyKSk7XG4gIHJldHVybiBuID8gKGQuSCA9ICtuWzBdLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTWludXRlcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpLCBpICsgMikpO1xuICByZXR1cm4gbiA/IChkLk0gPSArblswXSwgaSArIG5bMF0ubGVuZ3RoKSA6IC0xO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDIpKTtcbiAgcmV0dXJuIG4gPyAoZC5TID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWxsaXNlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDMpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNaWNyb3NlY29uZHMoZCwgc3RyaW5nLCBpKSB7XG4gIHZhciBuID0gbnVtYmVyUmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDYpKTtcbiAgcmV0dXJuIG4gPyAoZC5MID0gTWF0aC5mbG9vcihuWzBdIC8gMTAwMCksIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMaXRlcmFsUGVyY2VudChkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBwZXJjZW50UmUuZXhlYyhzdHJpbmcuc2xpY2UoaSwgaSArIDEpKTtcbiAgcmV0dXJuIG4gPyBpICsgblswXS5sZW5ndGggOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wKGQsIHN0cmluZywgaSkge1xuICB2YXIgbiA9IG51bWJlclJlLmV4ZWMoc3RyaW5nLnNsaWNlKGkpKTtcbiAgcmV0dXJuIG4gPyAoZC5RID0gK25bMF0sIGkgKyBuWzBdLmxlbmd0aCkgOiAtMTtcbn1cblxuZnVuY3Rpb24gcGFyc2VVbml4VGltZXN0YW1wU2Vjb25kcyhkLCBzdHJpbmcsIGkpIHtcbiAgdmFyIG4gPSBudW1iZXJSZS5leGVjKHN0cmluZy5zbGljZShpKSk7XG4gIHJldHVybiBuID8gKGQuUSA9ICgrblswXSkgKiAxMDAwLCBpICsgblswXS5sZW5ndGgpIDogLTE7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERheU9mTW9udGgoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RGF0ZSgpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SG91cjI0KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkLmdldEhvdXJzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRIb3VyMTIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0SG91cnMoKSAlIDEyIHx8IDEyLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF5T2ZZZWFyKGQsIHApIHtcbiAgcmV0dXJuIHBhZCgxICsgZDNUaW1lLnRpbWVEYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0TWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRheSA9IGQuZ2V0RGF5KCk7XG4gIHJldHVybiBkYXkgPT09IDAgPyA3IDogZGF5O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZVN1bmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla051bWJlcklTTyhkLCBwKSB7XG4gIHZhciBkYXkgPSBkLmdldERheSgpO1xuICBkID0gKGRheSA+PSA0IHx8IGRheSA9PT0gMCkgPyBkM1RpbWUudGltZVRodXJzZGF5KGQpIDogZDNUaW1lLnRpbWVUaHVyc2RheS5jZWlsKGQpO1xuICByZXR1cm4gcGFkKGQzVGltZS50aW1lVGh1cnNkYXkuY291bnQoZDNUaW1lLnRpbWVZZWFyKGQpLCBkKSArIChkM1RpbWUudGltZVllYXIoZCkuZ2V0RGF5KCkgPT09IDQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0V2Vla2RheU51bWJlclN1bmRheShkKSB7XG4gIHJldHVybiBkLmdldERheSgpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyTW9uZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudGltZU1vbmRheS5jb3VudChkM1RpbWUudGltZVllYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0WWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0Wm9uZShkKSB7XG4gIHZhciB6ID0gZC5nZXRUaW1lem9uZU9mZnNldCgpO1xuICByZXR1cm4gKHogPiAwID8gXCItXCIgOiAoeiAqPSAtMSwgXCIrXCIpKVxuICAgICAgKyBwYWQoeiAvIDYwIHwgMCwgXCIwXCIsIDIpXG4gICAgICArIHBhZCh6ICUgNjAsIFwiMFwiLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRGF5T2ZNb250aChkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENEYXRlKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENIb3VyMjQoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDSG91cnMoKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ0hvdXIxMihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENIb3VycygpICUgMTIgfHwgMTIsIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENEYXlPZlllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKDEgKyBkM1RpbWUudXRjRGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbGxpc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNaWxsaXNlY29uZHMoKSwgcCwgMyk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pY3Jvc2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBmb3JtYXRVVENNaWxsaXNlY29uZHMoZCwgcCkgKyBcIjAwMFwiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENNb250aE51bWJlcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENNb250aCgpICsgMSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ01pbnV0ZXMoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDTWludXRlcygpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDU2Vjb25kcyhkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENTZWNvbmRzKCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyTW9uZGF5KGQpIHtcbiAgdmFyIGRvdyA9IGQuZ2V0VVRDRGF5KCk7XG4gIHJldHVybiBkb3cgPT09IDAgPyA3IDogZG93O1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrTnVtYmVyU3VuZGF5KGQsIHApIHtcbiAgcmV0dXJuIHBhZChkM1RpbWUudXRjU3VuZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSwgcCwgMik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJJU08oZCwgcCkge1xuICB2YXIgZGF5ID0gZC5nZXRVVENEYXkoKTtcbiAgZCA9IChkYXkgPj0gNCB8fCBkYXkgPT09IDApID8gZDNUaW1lLnV0Y1RodXJzZGF5KGQpIDogZDNUaW1lLnV0Y1RodXJzZGF5LmNlaWwoZCk7XG4gIHJldHVybiBwYWQoZDNUaW1lLnV0Y1RodXJzZGF5LmNvdW50KGQzVGltZS51dGNZZWFyKGQpLCBkKSArIChkM1RpbWUudXRjWWVhcihkKS5nZXRVVENEYXkoKSA9PT0gNCksIHAsIDIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRVVENXZWVrZGF5TnVtYmVyU3VuZGF5KGQpIHtcbiAgcmV0dXJuIGQuZ2V0VVRDRGF5KCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVUQ1dlZWtOdW1iZXJNb25kYXkoZCwgcCkge1xuICByZXR1cm4gcGFkKGQzVGltZS51dGNNb25kYXkuY291bnQoZDNUaW1lLnV0Y1llYXIoZCksIGQpLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWWVhcihkLCBwKSB7XG4gIHJldHVybiBwYWQoZC5nZXRVVENGdWxsWWVhcigpICUgMTAwLCBwLCAyKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDRnVsbFllYXIoZCwgcCkge1xuICByZXR1cm4gcGFkKGQuZ2V0VVRDRnVsbFllYXIoKSAlIDEwMDAwLCBwLCA0KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VVRDWm9uZSgpIHtcbiAgcmV0dXJuIFwiKzAwMDBcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0TGl0ZXJhbFBlcmNlbnQoKSB7XG4gIHJldHVybiBcIiVcIjtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcChkKSB7XG4gIHJldHVybiArZDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VW5peFRpbWVzdGFtcFNlY29uZHMoZCkge1xuICByZXR1cm4gTWF0aC5mbG9vcigrZCAvIDEwMDApO1xufVxuXG52YXIgbG9jYWxlO1xuXG5cblxuXG5cbmRlZmF1bHRMb2NhbGUoe1xuICBkYXRlVGltZTogXCIleCwgJVhcIixcbiAgZGF0ZTogXCIlLW0vJS1kLyVZXCIsXG4gIHRpbWU6IFwiJS1JOiVNOiVTICVwXCIsXG4gIHBlcmlvZHM6IFtcIkFNXCIsIFwiUE1cIl0sXG4gIGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCJdLFxuICBzaG9ydERheXM6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgbW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufSk7XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUoZGVmaW5pdGlvbikge1xuICBsb2NhbGUgPSBmb3JtYXRMb2NhbGUoZGVmaW5pdGlvbik7XG4gIGV4cG9ydHMudGltZUZvcm1hdCA9IGxvY2FsZS5mb3JtYXQ7XG4gIGV4cG9ydHMudGltZVBhcnNlID0gbG9jYWxlLnBhcnNlO1xuICBleHBvcnRzLnV0Y0Zvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQ7XG4gIGV4cG9ydHMudXRjUGFyc2UgPSBsb2NhbGUudXRjUGFyc2U7XG4gIHJldHVybiBsb2NhbGU7XG59XG5cbnZhciBpc29TcGVjaWZpZXIgPSBcIiVZLSVtLSVkVCVIOiVNOiVTLiVMWlwiO1xuXG5mdW5jdGlvbiBmb3JtYXRJc29OYXRpdmUoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS50b0lTT1N0cmluZygpO1xufVxuXG52YXIgZm9ybWF0SXNvID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdcbiAgICA/IGZvcm1hdElzb05hdGl2ZVxuICAgIDogZXhwb3J0cy51dGNGb3JtYXQoaXNvU3BlY2lmaWVyKTtcblxuZnVuY3Rpb24gcGFyc2VJc29OYXRpdmUoc3RyaW5nKSB7XG4gIHZhciBkYXRlID0gbmV3IERhdGUoc3RyaW5nKTtcbiAgcmV0dXJuIGlzTmFOKGRhdGUpID8gbnVsbCA6IGRhdGU7XG59XG5cbnZhciBwYXJzZUlzbyA9ICtuZXcgRGF0ZShcIjIwMDAtMDEtMDFUMDA6MDA6MDAuMDAwWlwiKVxuICAgID8gcGFyc2VJc29OYXRpdmVcbiAgICA6IGV4cG9ydHMudXRjUGFyc2UoaXNvU3BlY2lmaWVyKTtcblxuZXhwb3J0cy50aW1lRm9ybWF0RGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG5leHBvcnRzLnRpbWVGb3JtYXRMb2NhbGUgPSBmb3JtYXRMb2NhbGU7XG5leHBvcnRzLmlzb0Zvcm1hdCA9IGZvcm1hdElzbztcbmV4cG9ydHMuaXNvUGFyc2UgPSBwYXJzZUlzbztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtdGltZS8gVmVyc2lvbiAxLjAuOC4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLmQzID0gZ2xvYmFsLmQzIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgdDAgPSBuZXcgRGF0ZTtcbnZhciB0MSA9IG5ldyBEYXRlO1xuXG5mdW5jdGlvbiBuZXdJbnRlcnZhbChmbG9vcmksIG9mZnNldGksIGNvdW50LCBmaWVsZCkge1xuXG4gIGZ1bmN0aW9uIGludGVydmFsKGRhdGUpIHtcbiAgICByZXR1cm4gZmxvb3JpKGRhdGUgPSBuZXcgRGF0ZSgrZGF0ZSkpLCBkYXRlO1xuICB9XG5cbiAgaW50ZXJ2YWwuZmxvb3IgPSBpbnRlcnZhbDtcblxuICBpbnRlcnZhbC5jZWlsID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiBmbG9vcmkoZGF0ZSA9IG5ldyBEYXRlKGRhdGUgLSAxKSksIG9mZnNldGkoZGF0ZSwgMSksIGZsb29yaShkYXRlKSwgZGF0ZTtcbiAgfTtcblxuICBpbnRlcnZhbC5yb3VuZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICB2YXIgZDAgPSBpbnRlcnZhbChkYXRlKSxcbiAgICAgICAgZDEgPSBpbnRlcnZhbC5jZWlsKGRhdGUpO1xuICAgIHJldHVybiBkYXRlIC0gZDAgPCBkMSAtIGRhdGUgPyBkMCA6IGQxO1xuICB9O1xuXG4gIGludGVydmFsLm9mZnNldCA9IGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICByZXR1cm4gb2Zmc2V0aShkYXRlID0gbmV3IERhdGUoK2RhdGUpLCBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKSksIGRhdGU7XG4gIH07XG5cbiAgaW50ZXJ2YWwucmFuZ2UgPSBmdW5jdGlvbihzdGFydCwgc3RvcCwgc3RlcCkge1xuICAgIHZhciByYW5nZSA9IFtdLCBwcmV2aW91cztcbiAgICBzdGFydCA9IGludGVydmFsLmNlaWwoc3RhcnQpO1xuICAgIHN0ZXAgPSBzdGVwID09IG51bGwgPyAxIDogTWF0aC5mbG9vcihzdGVwKTtcbiAgICBpZiAoIShzdGFydCA8IHN0b3ApIHx8ICEoc3RlcCA+IDApKSByZXR1cm4gcmFuZ2U7IC8vIGFsc28gaGFuZGxlcyBJbnZhbGlkIERhdGVcbiAgICBkbyByYW5nZS5wdXNoKHByZXZpb3VzID0gbmV3IERhdGUoK3N0YXJ0KSksIG9mZnNldGkoc3RhcnQsIHN0ZXApLCBmbG9vcmkoc3RhcnQpO1xuICAgIHdoaWxlIChwcmV2aW91cyA8IHN0YXJ0ICYmIHN0YXJ0IDwgc3RvcCk7XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIGludGVydmFsLmZpbHRlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICByZXR1cm4gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkgd2hpbGUgKGZsb29yaShkYXRlKSwgIXRlc3QoZGF0ZSkpIGRhdGUuc2V0VGltZShkYXRlIC0gMSk7XG4gICAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgICAgaWYgKGRhdGUgPj0gZGF0ZSkge1xuICAgICAgICBpZiAoc3RlcCA8IDApIHdoaWxlICgrK3N0ZXAgPD0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsIC0xKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBlbHNlIHdoaWxlICgtLXN0ZXAgPj0gMCkge1xuICAgICAgICAgIHdoaWxlIChvZmZzZXRpKGRhdGUsICsxKSwgIXRlc3QoZGF0ZSkpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIGlmIChjb3VudCkge1xuICAgIGludGVydmFsLmNvdW50ID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgdDAuc2V0VGltZSgrc3RhcnQpLCB0MS5zZXRUaW1lKCtlbmQpO1xuICAgICAgZmxvb3JpKHQwKSwgZmxvb3JpKHQxKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKGNvdW50KHQwLCB0MSkpO1xuICAgIH07XG5cbiAgICBpbnRlcnZhbC5ldmVyeSA9IGZ1bmN0aW9uKHN0ZXApIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgICAgcmV0dXJuICFpc0Zpbml0ZShzdGVwKSB8fCAhKHN0ZXAgPiAwKSA/IG51bGxcbiAgICAgICAgICA6ICEoc3RlcCA+IDEpID8gaW50ZXJ2YWxcbiAgICAgICAgICA6IGludGVydmFsLmZpbHRlcihmaWVsZFxuICAgICAgICAgICAgICA/IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGZpZWxkKGQpICUgc3RlcCA9PT0gMDsgfVxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGludGVydmFsLmNvdW50KDAsIGQpICUgc3RlcCA9PT0gMDsgfSk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBpbnRlcnZhbDtcbn1cblxudmFyIG1pbGxpc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gIC8vIG5vb3Bcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiBlbmQgLSBzdGFydDtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG5taWxsaXNlY29uZC5ldmVyeSA9IGZ1bmN0aW9uKGspIHtcbiAgayA9IE1hdGguZmxvb3Ioayk7XG4gIGlmICghaXNGaW5pdGUoaykgfHwgIShrID4gMCkpIHJldHVybiBudWxsO1xuICBpZiAoIShrID4gMSkpIHJldHVybiBtaWxsaXNlY29uZDtcbiAgcmV0dXJuIG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gaykgKiBrKTtcbiAgfSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICAgIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBrKTtcbiAgfSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gaztcbiAgfSk7XG59O1xuXG52YXIgbWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmQucmFuZ2U7XG5cbnZhciBkdXJhdGlvblNlY29uZCA9IDFlMztcbnZhciBkdXJhdGlvbk1pbnV0ZSA9IDZlNDtcbnZhciBkdXJhdGlvbkhvdXIgPSAzNmU1O1xudmFyIGR1cmF0aW9uRGF5ID0gODY0ZTU7XG52YXIgZHVyYXRpb25XZWVrID0gNjA0OGU1O1xuXG52YXIgc2Vjb25kID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFRpbWUoTWF0aC5mbG9vcihkYXRlIC8gZHVyYXRpb25TZWNvbmQpICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25TZWNvbmQpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uU2Vjb25kO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENTZWNvbmRzKCk7XG59KTtcblxudmFyIHNlY29uZHMgPSBzZWNvbmQucmFuZ2U7XG5cbnZhciBtaW51dGUgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKGRhdGUgLyBkdXJhdGlvbk1pbnV0ZSkgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbk1pbnV0ZSk7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25NaW51dGU7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1pbnV0ZXMoKTtcbn0pO1xuXG52YXIgbWludXRlcyA9IG1pbnV0ZS5yYW5nZTtcblxudmFyIGhvdXIgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIHZhciBvZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZSAlIGR1cmF0aW9uSG91cjtcbiAgaWYgKG9mZnNldCA8IDApIG9mZnNldCArPSBkdXJhdGlvbkhvdXI7XG4gIGRhdGUuc2V0VGltZShNYXRoLmZsb29yKCgrZGF0ZSAtIG9mZnNldCkgLyBkdXJhdGlvbkhvdXIpICogZHVyYXRpb25Ib3VyICsgb2Zmc2V0KTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRUaW1lKCtkYXRlICsgc3RlcCAqIGR1cmF0aW9uSG91cik7XG59LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiAoZW5kIC0gc3RhcnQpIC8gZHVyYXRpb25Ib3VyO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRIb3VycygpO1xufSk7XG5cbnZhciBob3VycyA9IGhvdXIucmFuZ2U7XG5cbnZhciBkYXkgPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0RGF0ZShkYXRlLmdldERhdGUoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0IC0gKGVuZC5nZXRUaW1lem9uZU9mZnNldCgpIC0gc3RhcnQuZ2V0VGltZXpvbmVPZmZzZXQoKSkgKiBkdXJhdGlvbk1pbnV0ZSkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RGF0ZSgpIC0gMTtcbn0pO1xuXG52YXIgZGF5cyA9IGRheS5yYW5nZTtcblxuZnVuY3Rpb24gd2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpIC0gKGRhdGUuZ2V0RGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCAtIChlbmQuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIHN0YXJ0LmdldFRpbWV6b25lT2Zmc2V0KCkpICogZHVyYXRpb25NaW51dGUpIC8gZHVyYXRpb25XZWVrO1xuICB9KTtcbn1cblxudmFyIHN1bmRheSA9IHdlZWtkYXkoMCk7XG52YXIgbW9uZGF5ID0gd2Vla2RheSgxKTtcbnZhciB0dWVzZGF5ID0gd2Vla2RheSgyKTtcbnZhciB3ZWRuZXNkYXkgPSB3ZWVrZGF5KDMpO1xudmFyIHRodXJzZGF5ID0gd2Vla2RheSg0KTtcbnZhciBmcmlkYXkgPSB3ZWVrZGF5KDUpO1xudmFyIHNhdHVyZGF5ID0gd2Vla2RheSg2KTtcblxudmFyIHN1bmRheXMgPSBzdW5kYXkucmFuZ2U7XG52YXIgbW9uZGF5cyA9IG1vbmRheS5yYW5nZTtcbnZhciB0dWVzZGF5cyA9IHR1ZXNkYXkucmFuZ2U7XG52YXIgd2VkbmVzZGF5cyA9IHdlZG5lc2RheS5yYW5nZTtcbnZhciB0aHVyc2RheXMgPSB0aHVyc2RheS5yYW5nZTtcbnZhciBmcmlkYXlzID0gZnJpZGF5LnJhbmdlO1xudmFyIHNhdHVyZGF5cyA9IHNhdHVyZGF5LnJhbmdlO1xuXG52YXIgbW9udGggPSBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gIGRhdGUuc2V0RGF0ZSgxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRNb250aChkYXRlLmdldE1vbnRoKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRNb250aCgpIC0gc3RhcnQuZ2V0TW9udGgoKSArIChlbmQuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0LmdldEZ1bGxZZWFyKCkpICogMTI7XG59LCBmdW5jdGlvbihkYXRlKSB7XG4gIHJldHVybiBkYXRlLmdldE1vbnRoKCk7XG59KTtcblxudmFyIG1vbnRocyA9IG1vbnRoLnJhbmdlO1xuXG52YXIgeWVhciA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbn0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGVuZC5nZXRGdWxsWWVhcigpIC0gc3RhcnQuZ2V0RnVsbFllYXIoKTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbn0pO1xuXG4vLyBBbiBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZm9yIHRoaXMgc2ltcGxlIGNhc2UuXG55ZWFyLmV2ZXJ5ID0gZnVuY3Rpb24oaykge1xuICByZXR1cm4gIWlzRmluaXRlKGsgPSBNYXRoLmZsb29yKGspKSB8fCAhKGsgPiAwKSA/IG51bGwgOiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmZsb29yKGRhdGUuZ2V0RnVsbFllYXIoKSAvIGspICogayk7XG4gICAgZGF0ZS5zZXRNb250aCgwLCAxKTtcbiAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCkgKyBzdGVwICogayk7XG4gIH0pO1xufTtcblxudmFyIHllYXJzID0geWVhci5yYW5nZTtcblxudmFyIHV0Y01pbnV0ZSA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENTZWNvbmRzKDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFRpbWUoK2RhdGUgKyBzdGVwICogZHVyYXRpb25NaW51dGUpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uTWludXRlO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENNaW51dGVzKCk7XG59KTtcblxudmFyIHV0Y01pbnV0ZXMgPSB1dGNNaW51dGUucmFuZ2U7XG5cbnZhciB1dGNIb3VyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01pbnV0ZXMoMCwgMCwgMCk7XG59LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gIGRhdGUuc2V0VGltZSgrZGF0ZSArIHN0ZXAgKiBkdXJhdGlvbkhvdXIpO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gKGVuZCAtIHN0YXJ0KSAvIGR1cmF0aW9uSG91cjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDSG91cnMoKTtcbn0pO1xuXG52YXIgdXRjSG91cnMgPSB1dGNIb3VyLnJhbmdlO1xuXG52YXIgdXRjRGF5ID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBzdGVwKTtcbn0sIGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbkRheTtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRGF0ZSgpIC0gMTtcbn0pO1xuXG52YXIgdXRjRGF5cyA9IHV0Y0RheS5yYW5nZTtcblxuZnVuY3Rpb24gdXRjV2Vla2RheShpKSB7XG4gIHJldHVybiBuZXdJbnRlcnZhbChmdW5jdGlvbihkYXRlKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpIC0gKGRhdGUuZ2V0VVRDRGF5KCkgKyA3IC0gaSkgJSA3KTtcbiAgICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICB9LCBmdW5jdGlvbihkYXRlLCBzdGVwKSB7XG4gICAgZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgc3RlcCAqIDcpO1xuICB9LCBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXJhdGlvbldlZWs7XG4gIH0pO1xufVxuXG52YXIgdXRjU3VuZGF5ID0gdXRjV2Vla2RheSgwKTtcbnZhciB1dGNNb25kYXkgPSB1dGNXZWVrZGF5KDEpO1xudmFyIHV0Y1R1ZXNkYXkgPSB1dGNXZWVrZGF5KDIpO1xudmFyIHV0Y1dlZG5lc2RheSA9IHV0Y1dlZWtkYXkoMyk7XG52YXIgdXRjVGh1cnNkYXkgPSB1dGNXZWVrZGF5KDQpO1xudmFyIHV0Y0ZyaWRheSA9IHV0Y1dlZWtkYXkoNSk7XG52YXIgdXRjU2F0dXJkYXkgPSB1dGNXZWVrZGF5KDYpO1xuXG52YXIgdXRjU3VuZGF5cyA9IHV0Y1N1bmRheS5yYW5nZTtcbnZhciB1dGNNb25kYXlzID0gdXRjTW9uZGF5LnJhbmdlO1xudmFyIHV0Y1R1ZXNkYXlzID0gdXRjVHVlc2RheS5yYW5nZTtcbnZhciB1dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5LnJhbmdlO1xudmFyIHV0Y1RodXJzZGF5cyA9IHV0Y1RodXJzZGF5LnJhbmdlO1xudmFyIHV0Y0ZyaWRheXMgPSB1dGNGcmlkYXkucmFuZ2U7XG52YXIgdXRjU2F0dXJkYXlzID0gdXRjU2F0dXJkYXkucmFuZ2U7XG5cbnZhciB1dGNNb250aCA9IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgZGF0ZS5zZXRVVENEYXRlKDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ01vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ01vbnRoKCkgLSBzdGFydC5nZXRVVENNb250aCgpICsgKGVuZC5nZXRVVENGdWxsWWVhcigpIC0gc3RhcnQuZ2V0VVRDRnVsbFllYXIoKSkgKiAxMjtcbn0sIGZ1bmN0aW9uKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDTW9udGgoKTtcbn0pO1xuXG52YXIgdXRjTW9udGhzID0gdXRjTW9udGgucmFuZ2U7XG5cbnZhciB1dGNZZWFyID0gbmV3SW50ZXJ2YWwoZnVuY3Rpb24oZGF0ZSkge1xuICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkYXRlLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xufSwgZnVuY3Rpb24oZGF0ZSwgc3RlcCkge1xuICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXApO1xufSwgZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZW5kLmdldFVUQ0Z1bGxZZWFyKCkgLSBzdGFydC5nZXRVVENGdWxsWWVhcigpO1xufSwgZnVuY3Rpb24oZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xufSk7XG5cbi8vIEFuIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbiBmb3IgdGhpcyBzaW1wbGUgY2FzZS5cbnV0Y1llYXIuZXZlcnkgPSBmdW5jdGlvbihrKSB7XG4gIHJldHVybiAhaXNGaW5pdGUoayA9IE1hdGguZmxvb3IoaykpIHx8ICEoayA+IDApID8gbnVsbCA6IG5ld0ludGVydmFsKGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKE1hdGguZmxvb3IoZGF0ZS5nZXRVVENGdWxsWWVhcigpIC8gaykgKiBrKTtcbiAgICBkYXRlLnNldFVUQ01vbnRoKDAsIDEpO1xuICAgIGRhdGUuc2V0VVRDSG91cnMoMCwgMCwgMCwgMCk7XG4gIH0sIGZ1bmN0aW9uKGRhdGUsIHN0ZXApIHtcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSArIHN0ZXAgKiBrKTtcbiAgfSk7XG59O1xuXG52YXIgdXRjWWVhcnMgPSB1dGNZZWFyLnJhbmdlO1xuXG5leHBvcnRzLnRpbWVJbnRlcnZhbCA9IG5ld0ludGVydmFsO1xuZXhwb3J0cy50aW1lTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudGltZU1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbmV4cG9ydHMudXRjTWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuZXhwb3J0cy50aW1lU2Vjb25kID0gc2Vjb25kO1xuZXhwb3J0cy50aW1lU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnV0Y1NlY29uZCA9IHNlY29uZDtcbmV4cG9ydHMudXRjU2Vjb25kcyA9IHNlY29uZHM7XG5leHBvcnRzLnRpbWVNaW51dGUgPSBtaW51dGU7XG5leHBvcnRzLnRpbWVNaW51dGVzID0gbWludXRlcztcbmV4cG9ydHMudGltZUhvdXIgPSBob3VyO1xuZXhwb3J0cy50aW1lSG91cnMgPSBob3VycztcbmV4cG9ydHMudGltZURheSA9IGRheTtcbmV4cG9ydHMudGltZURheXMgPSBkYXlzO1xuZXhwb3J0cy50aW1lV2VlayA9IHN1bmRheTtcbmV4cG9ydHMudGltZVdlZWtzID0gc3VuZGF5cztcbmV4cG9ydHMudGltZVN1bmRheSA9IHN1bmRheTtcbmV4cG9ydHMudGltZVN1bmRheXMgPSBzdW5kYXlzO1xuZXhwb3J0cy50aW1lTW9uZGF5ID0gbW9uZGF5O1xuZXhwb3J0cy50aW1lTW9uZGF5cyA9IG1vbmRheXM7XG5leHBvcnRzLnRpbWVUdWVzZGF5ID0gdHVlc2RheTtcbmV4cG9ydHMudGltZVR1ZXNkYXlzID0gdHVlc2RheXM7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXkgPSB3ZWRuZXNkYXk7XG5leHBvcnRzLnRpbWVXZWRuZXNkYXlzID0gd2VkbmVzZGF5cztcbmV4cG9ydHMudGltZVRodXJzZGF5ID0gdGh1cnNkYXk7XG5leHBvcnRzLnRpbWVUaHVyc2RheXMgPSB0aHVyc2RheXM7XG5leHBvcnRzLnRpbWVGcmlkYXkgPSBmcmlkYXk7XG5leHBvcnRzLnRpbWVGcmlkYXlzID0gZnJpZGF5cztcbmV4cG9ydHMudGltZVNhdHVyZGF5ID0gc2F0dXJkYXk7XG5leHBvcnRzLnRpbWVTYXR1cmRheXMgPSBzYXR1cmRheXM7XG5leHBvcnRzLnRpbWVNb250aCA9IG1vbnRoO1xuZXhwb3J0cy50aW1lTW9udGhzID0gbW9udGhzO1xuZXhwb3J0cy50aW1lWWVhciA9IHllYXI7XG5leHBvcnRzLnRpbWVZZWFycyA9IHllYXJzO1xuZXhwb3J0cy51dGNNaW51dGUgPSB1dGNNaW51dGU7XG5leHBvcnRzLnV0Y01pbnV0ZXMgPSB1dGNNaW51dGVzO1xuZXhwb3J0cy51dGNIb3VyID0gdXRjSG91cjtcbmV4cG9ydHMudXRjSG91cnMgPSB1dGNIb3VycztcbmV4cG9ydHMudXRjRGF5ID0gdXRjRGF5O1xuZXhwb3J0cy51dGNEYXlzID0gdXRjRGF5cztcbmV4cG9ydHMudXRjV2VlayA9IHV0Y1N1bmRheTtcbmV4cG9ydHMudXRjV2Vla3MgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNTdW5kYXkgPSB1dGNTdW5kYXk7XG5leHBvcnRzLnV0Y1N1bmRheXMgPSB1dGNTdW5kYXlzO1xuZXhwb3J0cy51dGNNb25kYXkgPSB1dGNNb25kYXk7XG5leHBvcnRzLnV0Y01vbmRheXMgPSB1dGNNb25kYXlzO1xuZXhwb3J0cy51dGNUdWVzZGF5ID0gdXRjVHVlc2RheTtcbmV4cG9ydHMudXRjVHVlc2RheXMgPSB1dGNUdWVzZGF5cztcbmV4cG9ydHMudXRjV2VkbmVzZGF5ID0gdXRjV2VkbmVzZGF5O1xuZXhwb3J0cy51dGNXZWRuZXNkYXlzID0gdXRjV2VkbmVzZGF5cztcbmV4cG9ydHMudXRjVGh1cnNkYXkgPSB1dGNUaHVyc2RheTtcbmV4cG9ydHMudXRjVGh1cnNkYXlzID0gdXRjVGh1cnNkYXlzO1xuZXhwb3J0cy51dGNGcmlkYXkgPSB1dGNGcmlkYXk7XG5leHBvcnRzLnV0Y0ZyaWRheXMgPSB1dGNGcmlkYXlzO1xuZXhwb3J0cy51dGNTYXR1cmRheSA9IHV0Y1NhdHVyZGF5O1xuZXhwb3J0cy51dGNTYXR1cmRheXMgPSB1dGNTYXR1cmRheXM7XG5leHBvcnRzLnV0Y01vbnRoID0gdXRjTW9udGg7XG5leHBvcnRzLnV0Y01vbnRocyA9IHV0Y01vbnRocztcbmV4cG9ydHMudXRjWWVhciA9IHV0Y1llYXI7XG5leHBvcnRzLnV0Y1llYXJzID0gdXRjWWVhcnM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4iLCIvLyBodHRwczovL2QzanMub3JnL2QzLXRpbWVyLyBWZXJzaW9uIDEuMC43LiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBmcmFtZSA9IDA7XG52YXIgdGltZW91dCA9IDA7XG52YXIgaW50ZXJ2YWwgPSAwO1xudmFyIHBva2VEZWxheSA9IDEwMDA7XG52YXIgdGFza0hlYWQ7XG52YXIgdGFza1RhaWw7XG52YXIgY2xvY2tMYXN0ID0gMDtcbnZhciBjbG9ja05vdyA9IDA7XG52YXIgY2xvY2tTa2V3ID0gMDtcbnZhciBjbG9jayA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJvYmplY3RcIiAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG52YXIgc2V0RnJhbWUgPSB0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAxNyk7IH07XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5mdW5jdGlvbiBUaW1lcigpIHtcbiAgdGhpcy5fY2FsbCA9XG4gIHRoaXMuX3RpbWUgPVxuICB0aGlzLl9uZXh0ID0gbnVsbDtcbn1cblxuVGltZXIucHJvdG90eXBlID0gdGltZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVGltZXIsXG4gIHJlc3RhcnQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbGxiYWNrIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgIHRpbWUgPSAodGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZSkgKyAoZGVsYXkgPT0gbnVsbCA/IDAgOiArZGVsYXkpO1xuICAgIGlmICghdGhpcy5fbmV4dCAmJiB0YXNrVGFpbCAhPT0gdGhpcykge1xuICAgICAgaWYgKHRhc2tUYWlsKSB0YXNrVGFpbC5fbmV4dCA9IHRoaXM7XG4gICAgICBlbHNlIHRhc2tIZWFkID0gdGhpcztcbiAgICAgIHRhc2tUYWlsID0gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fY2FsbCA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgIHNsZWVwKCk7XG4gIH0sXG4gIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9jYWxsKSB7XG4gICAgICB0aGlzLl9jYWxsID0gbnVsbDtcbiAgICAgIHRoaXMuX3RpbWUgPSBJbmZpbml0eTtcbiAgICAgIHNsZWVwKCk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiB0aW1lcihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXI7XG4gIHQucmVzdGFydChjYWxsYmFjaywgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKG51bGwsIGUpO1xuICAgIHQgPSB0Ll9uZXh0O1xuICB9XG4gIC0tZnJhbWU7XG59XG5cbmZ1bmN0aW9uIHdha2UoKSB7XG4gIGNsb2NrTm93ID0gKGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpKSArIGNsb2NrU2tldztcbiAgZnJhbWUgPSB0aW1lb3V0ID0gMDtcbiAgdHJ5IHtcbiAgICB0aW1lckZsdXNoKCk7XG4gIH0gZmluYWxseSB7XG4gICAgZnJhbWUgPSAwO1xuICAgIG5hcCgpO1xuICAgIGNsb2NrTm93ID0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2tlKCkge1xuICB2YXIgbm93ID0gY2xvY2subm93KCksIGRlbGF5ID0gbm93IC0gY2xvY2tMYXN0O1xuICBpZiAoZGVsYXkgPiBwb2tlRGVsYXkpIGNsb2NrU2tldyAtPSBkZWxheSwgY2xvY2tMYXN0ID0gbm93O1xufVxuXG5mdW5jdGlvbiBuYXAoKSB7XG4gIHZhciB0MCwgdDEgPSB0YXNrSGVhZCwgdDIsIHRpbWUgPSBJbmZpbml0eTtcbiAgd2hpbGUgKHQxKSB7XG4gICAgaWYgKHQxLl9jYWxsKSB7XG4gICAgICBpZiAodGltZSA+IHQxLl90aW1lKSB0aW1lID0gdDEuX3RpbWU7XG4gICAgICB0MCA9IHQxLCB0MSA9IHQxLl9uZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiA9IHQxLl9uZXh0LCB0MS5fbmV4dCA9IG51bGw7XG4gICAgICB0MSA9IHQwID8gdDAuX25leHQgPSB0MiA6IHRhc2tIZWFkID0gdDI7XG4gICAgfVxuICB9XG4gIHRhc2tUYWlsID0gdDA7XG4gIHNsZWVwKHRpbWUpO1xufVxuXG5mdW5jdGlvbiBzbGVlcCh0aW1lKSB7XG4gIGlmIChmcmFtZSkgcmV0dXJuOyAvLyBTb29uZXN0IGFsYXJtIGFscmVhZHkgc2V0LCBvciB3aWxsIGJlLlxuICBpZiAodGltZW91dCkgdGltZW91dCA9IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgdmFyIGRlbGF5ID0gdGltZSAtIGNsb2NrTm93OyAvLyBTdHJpY3RseSBsZXNzIHRoYW4gaWYgd2UgcmVjb21wdXRlZCBjbG9ja05vdy5cbiAgaWYgKGRlbGF5ID4gMjQpIHtcbiAgICBpZiAodGltZSA8IEluZmluaXR5KSB0aW1lb3V0ID0gc2V0VGltZW91dCh3YWtlLCB0aW1lIC0gY2xvY2subm93KCkgLSBjbG9ja1NrZXcpO1xuICAgIGlmIChpbnRlcnZhbCkgaW50ZXJ2YWwgPSBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWludGVydmFsKSBjbG9ja0xhc3QgPSBjbG9jay5ub3coKSwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChwb2tlLCBwb2tlRGVsYXkpO1xuICAgIGZyYW1lID0gMSwgc2V0RnJhbWUod2FrZSk7XG4gIH1cbn1cblxudmFyIHRpbWVvdXQkMSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgZGVsYXkgPSBkZWxheSA9PSBudWxsID8gMCA6ICtkZWxheTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uKGVsYXBzZWQpIHtcbiAgICB0LnN0b3AoKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkICsgZGVsYXkpO1xuICB9LCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufTtcblxudmFyIGludGVydmFsJDEgPSBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgdmFyIHQgPSBuZXcgVGltZXIsIHRvdGFsID0gZGVsYXk7XG4gIGlmIChkZWxheSA9PSBudWxsKSByZXR1cm4gdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSksIHQ7XG4gIGRlbGF5ID0gK2RlbGF5LCB0aW1lID0gdGltZSA9PSBudWxsID8gbm93KCkgOiArdGltZTtcbiAgdC5yZXN0YXJ0KGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIGVsYXBzZWQgKz0gdG90YWw7XG4gICAgdC5yZXN0YXJ0KHRpY2ssIHRvdGFsICs9IGRlbGF5LCB0aW1lKTtcbiAgICBjYWxsYmFjayhlbGFwc2VkKTtcbiAgfSwgZGVsYXksIHRpbWUpO1xuICByZXR1cm4gdDtcbn07XG5cbmV4cG9ydHMubm93ID0gbm93O1xuZXhwb3J0cy50aW1lciA9IHRpbWVyO1xuZXhwb3J0cy50aW1lckZsdXNoID0gdGltZXJGbHVzaDtcbmV4cG9ydHMudGltZW91dCA9IHRpbWVvdXQkMTtcbmV4cG9ydHMuaW50ZXJ2YWwgPSBpbnRlcnZhbCQxO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy10cmFuc2l0aW9uLyBWZXJzaW9uIDEuMS4xLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy10aW1lcicpLCByZXF1aXJlKCdkMy1pbnRlcnBvbGF0ZScpLCByZXF1aXJlKCdkMy1jb2xvcicpLCByZXF1aXJlKCdkMy1lYXNlJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1zZWxlY3Rpb24nLCAnZDMtZGlzcGF0Y2gnLCAnZDMtdGltZXInLCAnZDMtaW50ZXJwb2xhdGUnLCAnZDMtY29sb3InLCAnZDMtZWFzZSddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxkM1NlbGVjdGlvbixkM0Rpc3BhdGNoLGQzVGltZXIsZDNJbnRlcnBvbGF0ZSxkM0NvbG9yLGQzRWFzZSkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9uID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiZW5kXCIsIFwiaW50ZXJydXB0XCIpO1xudmFyIGVtcHR5VHdlZW4gPSBbXTtcblxudmFyIENSRUFURUQgPSAwO1xudmFyIFNDSEVEVUxFRCA9IDE7XG52YXIgU1RBUlRJTkcgPSAyO1xudmFyIFNUQVJURUQgPSAzO1xudmFyIFJVTk5JTkcgPSA0O1xudmFyIEVORElORyA9IDU7XG52YXIgRU5ERUQgPSA2O1xuXG52YXIgc2NoZWR1bGUgPSBmdW5jdGlvbihub2RlLCBuYW1lLCBpZCwgaW5kZXgsIGdyb3VwLCB0aW1pbmcpIHtcbiAgdmFyIHNjaGVkdWxlcyA9IG5vZGUuX190cmFuc2l0aW9uO1xuICBpZiAoIXNjaGVkdWxlcykgbm9kZS5fX3RyYW5zaXRpb24gPSB7fTtcbiAgZWxzZSBpZiAoaWQgaW4gc2NoZWR1bGVzKSByZXR1cm47XG4gIGNyZWF0ZShub2RlLCBpZCwge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgaW5kZXg6IGluZGV4LCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgZ3JvdXA6IGdyb3VwLCAvLyBGb3IgY29udGV4dCBkdXJpbmcgY2FsbGJhY2suXG4gICAgb246IGVtcHR5T24sXG4gICAgdHdlZW46IGVtcHR5VHdlZW4sXG4gICAgdGltZTogdGltaW5nLnRpbWUsXG4gICAgZGVsYXk6IHRpbWluZy5kZWxheSxcbiAgICBkdXJhdGlvbjogdGltaW5nLmR1cmF0aW9uLFxuICAgIGVhc2U6IHRpbWluZy5lYXNlLFxuICAgIHRpbWVyOiBudWxsLFxuICAgIHN0YXRlOiBDUkVBVEVEXG4gIH0pO1xufTtcblxuZnVuY3Rpb24gaW5pdChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBnZXQobm9kZSwgaWQpO1xuICBpZiAoc2NoZWR1bGUuc3RhdGUgPiBDUkVBVEVEKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzY2hlZHVsZWRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gc2V0KG5vZGUsIGlkKSB7XG4gIHZhciBzY2hlZHVsZSA9IGdldChub2RlLCBpZCk7XG4gIGlmIChzY2hlZHVsZS5zdGF0ZSA+IFNUQVJUSU5HKSB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbGF0ZTsgYWxyZWFkeSBzdGFydGVkXCIpO1xuICByZXR1cm4gc2NoZWR1bGU7XG59XG5cbmZ1bmN0aW9uIGdldChub2RlLCBpZCkge1xuICB2YXIgc2NoZWR1bGUgPSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgaWYgKCFzY2hlZHVsZSB8fCAhKHNjaGVkdWxlID0gc2NoZWR1bGVbaWRdKSkgdGhyb3cgbmV3IEVycm9yKFwidHJhbnNpdGlvbiBub3QgZm91bmRcIik7XG4gIHJldHVybiBzY2hlZHVsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlKG5vZGUsIGlkLCBzZWxmKSB7XG4gIHZhciBzY2hlZHVsZXMgPSBub2RlLl9fdHJhbnNpdGlvbixcbiAgICAgIHR3ZWVuO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIHNlbGYgdGltZXIgd2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBjcmVhdGVkLlxuICAvLyBOb3RlIHRoZSBhY3R1YWwgZGVsYXkgaXMgbm90IGtub3duIHVudGlsIHRoZSBmaXJzdCBjYWxsYmFjayFcbiAgc2NoZWR1bGVzW2lkXSA9IHNlbGY7XG4gIHNlbGYudGltZXIgPSBkM1RpbWVyLnRpbWVyKHNjaGVkdWxlLCAwLCBzZWxmLnRpbWUpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGVsYXBzZWQpIHtcbiAgICBzZWxmLnN0YXRlID0gU0NIRURVTEVEO1xuICAgIHNlbGYudGltZXIucmVzdGFydChzdGFydCwgc2VsZi5kZWxheSwgc2VsZi50aW1lKTtcblxuICAgIC8vIElmIHRoZSBlbGFwc2VkIGRlbGF5IGlzIGxlc3MgdGhhbiBvdXIgZmlyc3Qgc2xlZXAsIHN0YXJ0IGltbWVkaWF0ZWx5LlxuICAgIGlmIChzZWxmLmRlbGF5IDw9IGVsYXBzZWQpIHN0YXJ0KGVsYXBzZWQgLSBzZWxmLmRlbGF5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0KGVsYXBzZWQpIHtcbiAgICB2YXIgaSwgaiwgbiwgbztcblxuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyBub3QgU0NIRURVTEVELCB0aGVuIHdlIHByZXZpb3VzbHkgZXJyb3JlZCBvbiBzdGFydC5cbiAgICBpZiAoc2VsZi5zdGF0ZSAhPT0gU0NIRURVTEVEKSByZXR1cm4gc3RvcCgpO1xuXG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgbyA9IHNjaGVkdWxlc1tpXTtcbiAgICAgIGlmIChvLm5hbWUgIT09IHNlbGYubmFtZSkgY29udGludWU7XG5cbiAgICAgIC8vIFdoaWxlIHRoaXMgZWxlbWVudCBhbHJlYWR5IGhhcyBhIHN0YXJ0aW5nIHRyYW5zaXRpb24gZHVyaW5nIHRoaXMgZnJhbWUsXG4gICAgICAvLyBkZWZlciBzdGFydGluZyBhbiBpbnRlcnJ1cHRpbmcgdHJhbnNpdGlvbiB1bnRpbCB0aGF0IHRyYW5zaXRpb24gaGFzIGFcbiAgICAgIC8vIGNoYW5jZSB0byB0aWNrIChhbmQgcG9zc2libHkgZW5kKTsgc2VlIGQzL2QzLXRyYW5zaXRpb24jNTQhXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gU1RBUlRFRCkgcmV0dXJuIGQzVGltZXIudGltZW91dChzdGFydCk7XG5cbiAgICAgIC8vIEludGVycnVwdCB0aGUgYWN0aXZlIHRyYW5zaXRpb24sIGlmIGFueS5cbiAgICAgIC8vIERpc3BhdGNoIHRoZSBpbnRlcnJ1cHQgZXZlbnQuXG4gICAgICBpZiAoby5zdGF0ZSA9PT0gUlVOTklORykge1xuICAgICAgICBvLnN0YXRlID0gRU5ERUQ7XG4gICAgICAgIG8udGltZXIuc3RvcCgpO1xuICAgICAgICBvLm9uLmNhbGwoXCJpbnRlcnJ1cHRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgby5pbmRleCwgby5ncm91cCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG5cbiAgICAgIC8vIENhbmNlbCBhbnkgcHJlLWVtcHRlZCB0cmFuc2l0aW9ucy4gTm8gaW50ZXJydXB0IGV2ZW50IGlzIGRpc3BhdGNoZWRcbiAgICAgIC8vIGJlY2F1c2UgdGhlIGNhbmNlbGxlZCB0cmFuc2l0aW9ucyBuZXZlciBzdGFydGVkLiBOb3RlIHRoYXQgdGhpcyBhbHNvXG4gICAgICAvLyByZW1vdmVzIHRoaXMgdHJhbnNpdGlvbiBmcm9tIHRoZSBwZW5kaW5nIGxpc3QhXG4gICAgICBlbHNlIGlmICgraSA8IGlkKSB7XG4gICAgICAgIG8uc3RhdGUgPSBFTkRFRDtcbiAgICAgICAgby50aW1lci5zdG9wKCk7XG4gICAgICAgIGRlbGV0ZSBzY2hlZHVsZXNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgdGhlIGZpcnN0IHRpY2sgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGZyYW1lOyBzZWUgZDMvZDMjMTU3Ni5cbiAgICAvLyBOb3RlIHRoZSB0cmFuc2l0aW9uIG1heSBiZSBjYW5jZWxlZCBhZnRlciBzdGFydCBhbmQgYmVmb3JlIHRoZSBmaXJzdCB0aWNrIVxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIHNjaGVkdWxlZCBiZWZvcmUgdGhlIHN0YXJ0IGV2ZW50OyBzZWUgZDMvZDMtdHJhbnNpdGlvbiMxNiFcbiAgICAvLyBBc3N1bWluZyB0aGlzIGlzIHN1Y2Nlc3NmdWwsIHN1YnNlcXVlbnQgY2FsbGJhY2tzIGdvIHN0cmFpZ2h0IHRvIHRpY2suXG4gICAgZDNUaW1lci50aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHNlbGYuc3RhdGUgPT09IFNUQVJURUQpIHtcbiAgICAgICAgc2VsZi5zdGF0ZSA9IFJVTk5JTkc7XG4gICAgICAgIHNlbGYudGltZXIucmVzdGFydCh0aWNrLCBzZWxmLmRlbGF5LCBzZWxmLnRpbWUpO1xuICAgICAgICB0aWNrKGVsYXBzZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIHN0YXJ0IGV2ZW50LlxuICAgIC8vIE5vdGUgdGhpcyBtdXN0IGJlIGRvbmUgYmVmb3JlIHRoZSB0d2VlbiBhcmUgaW5pdGlhbGl6ZWQuXG4gICAgc2VsZi5zdGF0ZSA9IFNUQVJUSU5HO1xuICAgIHNlbGYub24uY2FsbChcInN0YXJ0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApO1xuICAgIGlmIChzZWxmLnN0YXRlICE9PSBTVEFSVElORykgcmV0dXJuOyAvLyBpbnRlcnJ1cHRlZFxuICAgIHNlbGYuc3RhdGUgPSBTVEFSVEVEO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgdHdlZW4sIGRlbGV0aW5nIG51bGwgdHdlZW4uXG4gICAgdHdlZW4gPSBuZXcgQXJyYXkobiA9IHNlbGYudHdlZW4ubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBqID0gLTE7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChvID0gc2VsZi50d2VlbltpXS52YWx1ZS5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIHNlbGYuaW5kZXgsIHNlbGYuZ3JvdXApKSB7XG4gICAgICAgIHR3ZWVuWysral0gPSBvO1xuICAgICAgfVxuICAgIH1cbiAgICB0d2Vlbi5sZW5ndGggPSBqICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpY2soZWxhcHNlZCkge1xuICAgIHZhciB0ID0gZWxhcHNlZCA8IHNlbGYuZHVyYXRpb24gPyBzZWxmLmVhc2UuY2FsbChudWxsLCBlbGFwc2VkIC8gc2VsZi5kdXJhdGlvbikgOiAoc2VsZi50aW1lci5yZXN0YXJ0KHN0b3ApLCBzZWxmLnN0YXRlID0gRU5ESU5HLCAxKSxcbiAgICAgICAgaSA9IC0xLFxuICAgICAgICBuID0gdHdlZW4ubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHR3ZWVuW2ldLmNhbGwobnVsbCwgdCk7XG4gICAgfVxuXG4gICAgLy8gRGlzcGF0Y2ggdGhlIGVuZCBldmVudC5cbiAgICBpZiAoc2VsZi5zdGF0ZSA9PT0gRU5ESU5HKSB7XG4gICAgICBzZWxmLm9uLmNhbGwoXCJlbmRcIiwgbm9kZSwgbm9kZS5fX2RhdGFfXywgc2VsZi5pbmRleCwgc2VsZi5ncm91cCk7XG4gICAgICBzdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBzZWxmLnN0YXRlID0gRU5ERUQ7XG4gICAgc2VsZi50aW1lci5zdG9wKCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpZF07XG4gICAgZm9yICh2YXIgaSBpbiBzY2hlZHVsZXMpIHJldHVybjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGRlbGV0ZSBub2RlLl9fdHJhbnNpdGlvbjtcbiAgfVxufVxuXG52YXIgaW50ZXJydXB0ID0gZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGFjdGl2ZSxcbiAgICAgIGVtcHR5ID0gdHJ1ZSxcbiAgICAgIGk7XG5cbiAgaWYgKCFzY2hlZHVsZXMpIHJldHVybjtcblxuICBuYW1lID0gbmFtZSA9PSBudWxsID8gbnVsbCA6IG5hbWUgKyBcIlwiO1xuXG4gIGZvciAoaSBpbiBzY2hlZHVsZXMpIHtcbiAgICBpZiAoKHNjaGVkdWxlID0gc2NoZWR1bGVzW2ldKS5uYW1lICE9PSBuYW1lKSB7IGVtcHR5ID0gZmFsc2U7IGNvbnRpbnVlOyB9XG4gICAgYWN0aXZlID0gc2NoZWR1bGUuc3RhdGUgPiBTVEFSVElORyAmJiBzY2hlZHVsZS5zdGF0ZSA8IEVORElORztcbiAgICBzY2hlZHVsZS5zdGF0ZSA9IEVOREVEO1xuICAgIHNjaGVkdWxlLnRpbWVyLnN0b3AoKTtcbiAgICBpZiAoYWN0aXZlKSBzY2hlZHVsZS5vbi5jYWxsKFwiaW50ZXJydXB0XCIsIG5vZGUsIG5vZGUuX19kYXRhX18sIHNjaGVkdWxlLmluZGV4LCBzY2hlZHVsZS5ncm91cCk7XG4gICAgZGVsZXRlIHNjaGVkdWxlc1tpXTtcbiAgfVxuXG4gIGlmIChlbXB0eSkgZGVsZXRlIG5vZGUuX190cmFuc2l0aW9uO1xufTtcblxudmFyIHNlbGVjdGlvbl9pbnRlcnJ1cHQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgaW50ZXJydXB0KHRoaXMsIG5hbWUpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIHR3ZWVuUmVtb3ZlKGlkLCBuYW1lKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2hlZHVsZSA9IHNldCh0aGlzLCBpZCksXG4gICAgICAgIHR3ZWVuID0gc2NoZWR1bGUudHdlZW47XG5cbiAgICAvLyBJZiB0aGlzIG5vZGUgc2hhcmVkIHR3ZWVuIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIHR3ZWVuIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmICh0d2VlbiAhPT0gdHdlZW4wKSB7XG4gICAgICB0d2VlbjEgPSB0d2VlbjAgPSB0d2VlbjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gdHdlZW4xLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAodHdlZW4xW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICB0d2VlbjEgPSB0d2VlbjEuc2xpY2UoKTtcbiAgICAgICAgICB0d2VlbjEuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NoZWR1bGUudHdlZW4gPSB0d2VlbjE7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHR3ZWVuRnVuY3Rpb24oaWQsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciB0d2VlbjAsIHR3ZWVuMTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpLFxuICAgICAgICB0d2VlbiA9IHNjaGVkdWxlLnR3ZWVuO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCB0d2VlbiB3aXRoIHRoZSBwcmV2aW91cyBub2RlLFxuICAgIC8vIGp1c3QgYXNzaWduIHRoZSB1cGRhdGVkIHNoYXJlZCB0d2VlbiBhbmQgd2XigJlyZSBkb25lIVxuICAgIC8vIE90aGVyd2lzZSwgY29weS1vbi13cml0ZS5cbiAgICBpZiAodHdlZW4gIT09IHR3ZWVuMCkge1xuICAgICAgdHdlZW4xID0gKHR3ZWVuMCA9IHR3ZWVuKS5zbGljZSgpO1xuICAgICAgZm9yICh2YXIgdCA9IHtuYW1lOiBuYW1lLCB2YWx1ZTogdmFsdWV9LCBpID0gMCwgbiA9IHR3ZWVuMS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKHR3ZWVuMVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgdHdlZW4xW2ldID0gdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPT09IG4pIHR3ZWVuMS5wdXNoKHQpO1xuICAgIH1cblxuICAgIHNjaGVkdWxlLnR3ZWVuID0gdHdlZW4xO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl90d2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIG5hbWUgKz0gXCJcIjtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXQodGhpcy5ub2RlKCksIGlkKS50d2VlbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IHR3ZWVuLmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKCh0ID0gdHdlZW5baV0pLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHQudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuZWFjaCgodmFsdWUgPT0gbnVsbCA/IHR3ZWVuUmVtb3ZlIDogdHdlZW5GdW5jdGlvbikoaWQsIG5hbWUsIHZhbHVlKSk7XG59O1xuXG5mdW5jdGlvbiB0d2VlblZhbHVlKHRyYW5zaXRpb24sIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHRyYW5zaXRpb24uX2lkO1xuXG4gIHRyYW5zaXRpb24uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzZXQodGhpcywgaWQpO1xuICAgIChzY2hlZHVsZS52YWx1ZSB8fCAoc2NoZWR1bGUudmFsdWUgPSB7fSkpW25hbWVdID0gdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0KG5vZGUsIGlkKS52YWx1ZVtuYW1lXTtcbiAgfTtcbn1cblxudmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYztcbiAgcmV0dXJuICh0eXBlb2YgYiA9PT0gXCJudW1iZXJcIiA/IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVOdW1iZXJcbiAgICAgIDogYiBpbnN0YW5jZW9mIGQzQ29sb3IuY29sb3IgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlUmdiXG4gICAgICA6IChjID0gZDNDb2xvci5jb2xvcihiKSkgPyAoYiA9IGMsIGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVSZ2IpXG4gICAgICA6IGQzSW50ZXJwb2xhdGUuaW50ZXJwb2xhdGVTdHJpbmcpKGEsIGIpO1xufTtcblxuZnVuY3Rpb24gYXR0clJlbW92ZShuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0clJlbW92ZU5TKGZ1bGxuYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUxKSB7XG4gIHZhciB2YWx1ZTAwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyQ29uc3RhbnROUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHJGdW5jdGlvbihuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUpIHtcbiAgdmFyIHZhbHVlMDAsXG4gICAgICB2YWx1ZTEwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCwgdmFsdWUxID0gdmFsdWUodGhpcyk7XG4gICAgaWYgKHZhbHVlMSA9PSBudWxsKSByZXR1cm4gdm9pZCB0aGlzLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB2YWx1ZTAgPSB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMTAgPSB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRyRnVuY3Rpb25OUyhmdWxsbmFtZSwgaW50ZXJwb2xhdGUkJDEsIHZhbHVlKSB7XG4gIHZhciB2YWx1ZTAwLFxuICAgICAgdmFsdWUxMCxcbiAgICAgIGludGVycG9sYXRlMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTAsIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgcmV0dXJuIHZvaWQgdGhpcy5yZW1vdmVBdHRyaWJ1dGVOUyhmdWxsbmFtZS5zcGFjZSwgZnVsbG5hbWUubG9jYWwpO1xuICAgIHZhbHVlMCA9IHRoaXMuZ2V0QXR0cmlidXRlTlMoZnVsbG5hbWUuc3BhY2UsIGZ1bGxuYW1lLmxvY2FsKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMTAgPSB2YWx1ZTEpO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl9hdHRyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgdmFyIGZ1bGxuYW1lID0gZDNTZWxlY3Rpb24ubmFtZXNwYWNlKG5hbWUpLCBpID0gZnVsbG5hbWUgPT09IFwidHJhbnNmb3JtXCIgPyBkM0ludGVycG9sYXRlLmludGVycG9sYXRlVHJhbnNmb3JtU3ZnIDogaW50ZXJwb2xhdGU7XG4gIHJldHVybiB0aGlzLmF0dHJUd2VlbihuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgPyAoZnVsbG5hbWUubG9jYWwgPyBhdHRyRnVuY3Rpb25OUyA6IGF0dHJGdW5jdGlvbikoZnVsbG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJhdHRyLlwiICsgbmFtZSwgdmFsdWUpKVxuICAgICAgOiB2YWx1ZSA9PSBudWxsID8gKGZ1bGxuYW1lLmxvY2FsID8gYXR0clJlbW92ZU5TIDogYXR0clJlbW92ZSkoZnVsbG5hbWUpXG4gICAgICA6IChmdWxsbmFtZS5sb2NhbCA/IGF0dHJDb25zdGFudE5TIDogYXR0ckNvbnN0YW50KShmdWxsbmFtZSwgaSwgdmFsdWUgKyBcIlwiKSk7XG59O1xuXG5mdW5jdGlvbiBhdHRyVHdlZW5OUyhmdWxsbmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKGZ1bGxuYW1lLnNwYWNlLCBmdWxsbmFtZS5sb2NhbCwgaSh0KSk7XG4gICAgfTtcbiAgfVxuICB0d2Vlbi5fdmFsdWUgPSB2YWx1ZTtcbiAgcmV0dXJuIHR3ZWVuO1xufVxuXG5mdW5jdGlvbiBhdHRyVHdlZW4obmFtZSwgdmFsdWUpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBpKHQpKTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbnZhciB0cmFuc2l0aW9uX2F0dHJUd2VlbiA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gIHZhciBrZXkgPSBcImF0dHIuXCIgKyBuYW1lO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHJldHVybiAoa2V5ID0gdGhpcy50d2VlbihrZXkpKSAmJiBrZXkuX3ZhbHVlO1xuICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCBudWxsKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB0aHJvdyBuZXcgRXJyb3I7XG4gIHZhciBmdWxsbmFtZSA9IGQzU2VsZWN0aW9uLm5hbWVzcGFjZShuYW1lKTtcbiAgcmV0dXJuIHRoaXMudHdlZW4oa2V5LCAoZnVsbG5hbWUubG9jYWwgPyBhdHRyVHdlZW5OUyA6IGF0dHJUd2VlbikoZnVsbG5hbWUsIHZhbHVlKSk7XG59O1xuXG5mdW5jdGlvbiBkZWxheUZ1bmN0aW9uKGlkLCB2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaW5pdCh0aGlzLCBpZCkuZGVsYXkgPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGVsYXlDb25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBpbml0KHRoaXMsIGlkKS5kZWxheSA9IHZhbHVlO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl9kZWxheSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoXG4gICAgICA/IHRoaXMuZWFjaCgodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICA/IGRlbGF5RnVuY3Rpb25cbiAgICAgICAgICA6IGRlbGF5Q29uc3RhbnQpKGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmRlbGF5O1xufTtcblxuZnVuY3Rpb24gZHVyYXRpb25GdW5jdGlvbihpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHNldCh0aGlzLCBpZCkuZHVyYXRpb24gPSArdmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHVyYXRpb25Db25zdGFudChpZCwgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID0gK3ZhbHVlLCBmdW5jdGlvbigpIHtcbiAgICBzZXQodGhpcywgaWQpLmR1cmF0aW9uID0gdmFsdWU7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX2R1cmF0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIGlkID0gdGhpcy5faWQ7XG5cbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5lYWNoKCh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgID8gZHVyYXRpb25GdW5jdGlvblxuICAgICAgICAgIDogZHVyYXRpb25Db25zdGFudCkoaWQsIHZhbHVlKSlcbiAgICAgIDogZ2V0KHRoaXMubm9kZSgpLCBpZCkuZHVyYXRpb247XG59O1xuXG5mdW5jdGlvbiBlYXNlQ29uc3RhbnQoaWQsIHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgc2V0KHRoaXMsIGlkKS5lYXNlID0gdmFsdWU7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX2Vhc2UgPSBmdW5jdGlvbih2YWx1ZSkge1xuICB2YXIgaWQgPSB0aGlzLl9pZDtcblxuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmVhY2goZWFzZUNvbnN0YW50KGlkLCB2YWx1ZSkpXG4gICAgICA6IGdldCh0aGlzLm5vZGUoKSwgaWQpLmVhc2U7XG59O1xuXG52YXIgdHJhbnNpdGlvbl9maWx0ZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICBpZiAodHlwZW9mIG1hdGNoICE9PSBcImZ1bmN0aW9uXCIpIG1hdGNoID0gZDNTZWxlY3Rpb24ubWF0Y2hlcihtYXRjaCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IFtdLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChub2RlID0gZ3JvdXBbaV0pICYmIG1hdGNoLmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApKSB7XG4gICAgICAgIHN1Ymdyb3VwLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKHN1Ymdyb3VwcywgdGhpcy5fcGFyZW50cywgdGhpcy5fbmFtZSwgdGhpcy5faWQpO1xufTtcblxudmFyIHRyYW5zaXRpb25fbWVyZ2UgPSBmdW5jdGlvbih0cmFuc2l0aW9uKSB7XG4gIGlmICh0cmFuc2l0aW9uLl9pZCAhPT0gdGhpcy5faWQpIHRocm93IG5ldyBFcnJvcjtcblxuICBmb3IgKHZhciBncm91cHMwID0gdGhpcy5fZ3JvdXBzLCBncm91cHMxID0gdHJhbnNpdGlvbi5fZ3JvdXBzLCBtMCA9IGdyb3VwczAubGVuZ3RoLCBtMSA9IGdyb3VwczEubGVuZ3RoLCBtID0gTWF0aC5taW4obTAsIG0xKSwgbWVyZ2VzID0gbmV3IEFycmF5KG0wKSwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cDAgPSBncm91cHMwW2pdLCBncm91cDEgPSBncm91cHMxW2pdLCBuID0gZ3JvdXAwLmxlbmd0aCwgbWVyZ2UgPSBtZXJnZXNbal0gPSBuZXcgQXJyYXkobiksIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwMFtpXSB8fCBncm91cDFbaV0pIHtcbiAgICAgICAgbWVyZ2VbaV0gPSBub2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBqIDwgbTA7ICsraikge1xuICAgIG1lcmdlc1tqXSA9IGdyb3VwczBbal07XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24obWVyZ2VzLCB0aGlzLl9wYXJlbnRzLCB0aGlzLl9uYW1lLCB0aGlzLl9pZCk7XG59O1xuXG5mdW5jdGlvbiBzdGFydChuYW1lKSB7XG4gIHJldHVybiAobmFtZSArIFwiXCIpLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykuZXZlcnkoZnVuY3Rpb24odCkge1xuICAgIHZhciBpID0gdC5pbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoaSA+PSAwKSB0ID0gdC5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gIXQgfHwgdCA9PT0gXCJzdGFydFwiO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gb25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG9uMCwgb24xLCBzaXQgPSBzdGFydChuYW1lKSA/IGluaXQgOiBzZXQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2NoZWR1bGUgPSBzaXQodGhpcywgaWQpLFxuICAgICAgICBvbiA9IHNjaGVkdWxlLm9uO1xuXG4gICAgLy8gSWYgdGhpcyBub2RlIHNoYXJlZCBhIGRpc3BhdGNoIHdpdGggdGhlIHByZXZpb3VzIG5vZGUsXG4gICAgLy8ganVzdCBhc3NpZ24gdGhlIHVwZGF0ZWQgc2hhcmVkIGRpc3BhdGNoIGFuZCB3ZeKAmXJlIGRvbmUhXG4gICAgLy8gT3RoZXJ3aXNlLCBjb3B5LW9uLXdyaXRlLlxuICAgIGlmIChvbiAhPT0gb24wKSAob24xID0gKG9uMCA9IG9uKS5jb3B5KCkpLm9uKG5hbWUsIGxpc3RlbmVyKTtcblxuICAgIHNjaGVkdWxlLm9uID0gb24xO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl9vbiA9IGZ1bmN0aW9uKG5hbWUsIGxpc3RlbmVyKSB7XG4gIHZhciBpZCA9IHRoaXMuX2lkO1xuXG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMlxuICAgICAgPyBnZXQodGhpcy5ub2RlKCksIGlkKS5vbi5vbihuYW1lKVxuICAgICAgOiB0aGlzLmVhY2gob25GdW5jdGlvbihpZCwgbmFtZSwgbGlzdGVuZXIpKTtcbn07XG5cbmZ1bmN0aW9uIHJlbW92ZUZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fX3RyYW5zaXRpb24pIGlmICgraSAhPT0gaWQpIHJldHVybjtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH07XG59XG5cbnZhciB0cmFuc2l0aW9uX3JlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5vbihcImVuZC5yZW1vdmVcIiwgcmVtb3ZlRnVuY3Rpb24odGhpcy5faWQpKTtcbn07XG5cbnZhciB0cmFuc2l0aW9uX3NlbGVjdCA9IGZ1bmN0aW9uKHNlbGVjdCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZCA9IHRoaXMuX2lkO1xuXG4gIGlmICh0eXBlb2Ygc2VsZWN0ICE9PSBcImZ1bmN0aW9uXCIpIHNlbGVjdCA9IGQzU2VsZWN0aW9uLnNlbGVjdG9yKHNlbGVjdCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgc3ViZ3JvdXBzID0gbmV3IEFycmF5KG0pLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBzdWJncm91cCA9IHN1Ymdyb3Vwc1tqXSA9IG5ldyBBcnJheShuKSwgbm9kZSwgc3Vibm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICgobm9kZSA9IGdyb3VwW2ldKSAmJiAoc3Vibm9kZSA9IHNlbGVjdC5jYWxsKG5vZGUsIG5vZGUuX19kYXRhX18sIGksIGdyb3VwKSkpIHtcbiAgICAgICAgaWYgKFwiX19kYXRhX19cIiBpbiBub2RlKSBzdWJub2RlLl9fZGF0YV9fID0gbm9kZS5fX2RhdGFfXztcbiAgICAgICAgc3ViZ3JvdXBbaV0gPSBzdWJub2RlO1xuICAgICAgICBzY2hlZHVsZShzdWJncm91cFtpXSwgbmFtZSwgaWQsIGksIHN1Ymdyb3VwLCBnZXQobm9kZSwgaWQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZCk7XG59O1xuXG52YXIgdHJhbnNpdGlvbl9zZWxlY3RBbGwgPSBmdW5jdGlvbihzZWxlY3QpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLl9uYW1lLFxuICAgICAgaWQgPSB0aGlzLl9pZDtcblxuICBpZiAodHlwZW9mIHNlbGVjdCAhPT0gXCJmdW5jdGlvblwiKSBzZWxlY3QgPSBkM1NlbGVjdGlvbi5zZWxlY3RvckFsbChzZWxlY3QpO1xuXG4gIGZvciAodmFyIGdyb3VwcyA9IHRoaXMuX2dyb3VwcywgbSA9IGdyb3Vwcy5sZW5ndGgsIHN1Ymdyb3VwcyA9IFtdLCBwYXJlbnRzID0gW10sIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yICh2YXIgZ3JvdXAgPSBncm91cHNbal0sIG4gPSBncm91cC5sZW5ndGgsIG5vZGUsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAobm9kZSA9IGdyb3VwW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGNoaWxkcmVuID0gc2VsZWN0LmNhbGwobm9kZSwgbm9kZS5fX2RhdGFfXywgaSwgZ3JvdXApLCBjaGlsZCwgaW5oZXJpdCA9IGdldChub2RlLCBpZCksIGsgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBrIDwgbDsgKytrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkID0gY2hpbGRyZW5ba10pIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGNoaWxkLCBuYW1lLCBpZCwgaywgY2hpbGRyZW4sIGluaGVyaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWJncm91cHMucHVzaChjaGlsZHJlbik7XG4gICAgICAgIHBhcmVudHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oc3ViZ3JvdXBzLCBwYXJlbnRzLCBuYW1lLCBpZCk7XG59O1xuXG52YXIgU2VsZWN0aW9uID0gZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcblxudmFyIHRyYW5zaXRpb25fc2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuX2dyb3VwcywgdGhpcy5fcGFyZW50cyk7XG59O1xuXG5mdW5jdGlvbiBzdHlsZVJlbW92ZShuYW1lLCBpbnRlcnBvbGF0ZSQkMSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwID0gZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9ICh0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpLCBkM1NlbGVjdGlvbi5zdHlsZSh0aGlzLCBuYW1lKSk7XG4gICAgcmV0dXJuIHZhbHVlMCA9PT0gdmFsdWUxID8gbnVsbFxuICAgICAgICA6IHZhbHVlMCA9PT0gdmFsdWUwMCAmJiB2YWx1ZTEgPT09IHZhbHVlMTAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEwID0gdmFsdWUxKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVSZW1vdmVFbmQobmFtZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gc3R5bGVDb25zdGFudChuYW1lLCBpbnRlcnBvbGF0ZSQkMSwgdmFsdWUxKSB7XG4gIHZhciB2YWx1ZTAwLFxuICAgICAgaW50ZXJwb2xhdGUwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlMCA9IGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpO1xuICAgIHJldHVybiB2YWx1ZTAgPT09IHZhbHVlMSA/IG51bGxcbiAgICAgICAgOiB2YWx1ZTAgPT09IHZhbHVlMDAgPyBpbnRlcnBvbGF0ZTBcbiAgICAgICAgOiBpbnRlcnBvbGF0ZTAgPSBpbnRlcnBvbGF0ZSQkMSh2YWx1ZTAwID0gdmFsdWUwLCB2YWx1ZTEpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBzdHlsZUZ1bmN0aW9uKG5hbWUsIGludGVycG9sYXRlJCQxLCB2YWx1ZSkge1xuICB2YXIgdmFsdWUwMCxcbiAgICAgIHZhbHVlMTAsXG4gICAgICBpbnRlcnBvbGF0ZTA7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmFsdWUwID0gZDNTZWxlY3Rpb24uc3R5bGUodGhpcywgbmFtZSksXG4gICAgICAgIHZhbHVlMSA9IHZhbHVlKHRoaXMpO1xuICAgIGlmICh2YWx1ZTEgPT0gbnVsbCkgdmFsdWUxID0gKHRoaXMuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSksIGQzU2VsZWN0aW9uLnN0eWxlKHRoaXMsIG5hbWUpKTtcbiAgICByZXR1cm4gdmFsdWUwID09PSB2YWx1ZTEgPyBudWxsXG4gICAgICAgIDogdmFsdWUwID09PSB2YWx1ZTAwICYmIHZhbHVlMSA9PT0gdmFsdWUxMCA/IGludGVycG9sYXRlMFxuICAgICAgICA6IGludGVycG9sYXRlMCA9IGludGVycG9sYXRlJCQxKHZhbHVlMDAgPSB2YWx1ZTAsIHZhbHVlMTAgPSB2YWx1ZTEpO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl9zdHlsZSA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBwcmlvcml0eSkge1xuICB2YXIgaSA9IChuYW1lICs9IFwiXCIpID09PSBcInRyYW5zZm9ybVwiID8gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVRyYW5zZm9ybUNzcyA6IGludGVycG9sYXRlO1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHRoaXNcbiAgICAgICAgICAuc3R5bGVUd2VlbihuYW1lLCBzdHlsZVJlbW92ZShuYW1lLCBpKSlcbiAgICAgICAgICAub24oXCJlbmQuc3R5bGUuXCIgKyBuYW1lLCBzdHlsZVJlbW92ZUVuZChuYW1lKSlcbiAgICAgIDogdGhpcy5zdHlsZVR3ZWVuKG5hbWUsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgPyBzdHlsZUZ1bmN0aW9uKG5hbWUsIGksIHR3ZWVuVmFsdWUodGhpcywgXCJzdHlsZS5cIiArIG5hbWUsIHZhbHVlKSlcbiAgICAgICAgICA6IHN0eWxlQ29uc3RhbnQobmFtZSwgaSwgdmFsdWUgKyBcIlwiKSwgcHJpb3JpdHkpO1xufTtcblxuZnVuY3Rpb24gc3R5bGVUd2VlbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgZnVuY3Rpb24gdHdlZW4oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLCBpID0gdmFsdWUuYXBwbHkobm9kZSwgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gaSAmJiBmdW5jdGlvbih0KSB7XG4gICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIGkodCksIHByaW9yaXR5KTtcbiAgICB9O1xuICB9XG4gIHR3ZWVuLl92YWx1ZSA9IHZhbHVlO1xuICByZXR1cm4gdHdlZW47XG59XG5cbnZhciB0cmFuc2l0aW9uX3N0eWxlVHdlZW4gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpIHtcbiAgdmFyIGtleSA9IFwic3R5bGUuXCIgKyAobmFtZSArPSBcIlwiKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSByZXR1cm4gKGtleSA9IHRoaXMudHdlZW4oa2V5KSkgJiYga2V5Ll92YWx1ZTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiB0aGlzLnR3ZWVuKGtleSwgbnVsbCk7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yO1xuICByZXR1cm4gdGhpcy50d2VlbihrZXksIHN0eWxlVHdlZW4obmFtZSwgdmFsdWUsIHByaW9yaXR5ID09IG51bGwgPyBcIlwiIDogcHJpb3JpdHkpKTtcbn07XG5cbmZ1bmN0aW9uIHRleHRDb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0RnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZTEgPSB2YWx1ZSh0aGlzKTtcbiAgICB0aGlzLnRleHRDb250ZW50ID0gdmFsdWUxID09IG51bGwgPyBcIlwiIDogdmFsdWUxO1xuICB9O1xufVxuXG52YXIgdHJhbnNpdGlvbl90ZXh0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMudHdlZW4oXCJ0ZXh0XCIsIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICA/IHRleHRGdW5jdGlvbih0d2VlblZhbHVlKHRoaXMsIFwidGV4dFwiLCB2YWx1ZSkpXG4gICAgICA6IHRleHRDb25zdGFudCh2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIikpO1xufTtcblxudmFyIHRyYW5zaXRpb25fdHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmFtZSA9IHRoaXMuX25hbWUsXG4gICAgICBpZDAgPSB0aGlzLl9pZCxcbiAgICAgIGlkMSA9IG5ld0lkKCk7XG5cbiAgZm9yICh2YXIgZ3JvdXBzID0gdGhpcy5fZ3JvdXBzLCBtID0gZ3JvdXBzLmxlbmd0aCwgaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICBmb3IgKHZhciBncm91cCA9IGdyb3Vwc1tqXSwgbiA9IGdyb3VwLmxlbmd0aCwgbm9kZSwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChub2RlID0gZ3JvdXBbaV0pIHtcbiAgICAgICAgdmFyIGluaGVyaXQgPSBnZXQobm9kZSwgaWQwKTtcbiAgICAgICAgc2NoZWR1bGUobm9kZSwgbmFtZSwgaWQxLCBpLCBncm91cCwge1xuICAgICAgICAgIHRpbWU6IGluaGVyaXQudGltZSArIGluaGVyaXQuZGVsYXkgKyBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGRlbGF5OiAwLFxuICAgICAgICAgIGR1cmF0aW9uOiBpbmhlcml0LmR1cmF0aW9uLFxuICAgICAgICAgIGVhc2U6IGluaGVyaXQuZWFzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFRyYW5zaXRpb24oZ3JvdXBzLCB0aGlzLl9wYXJlbnRzLCBuYW1lLCBpZDEpO1xufTtcblxudmFyIGlkID0gMDtcblxuZnVuY3Rpb24gVHJhbnNpdGlvbihncm91cHMsIHBhcmVudHMsIG5hbWUsIGlkKSB7XG4gIHRoaXMuX2dyb3VwcyA9IGdyb3VwcztcbiAgdGhpcy5fcGFyZW50cyA9IHBhcmVudHM7XG4gIHRoaXMuX25hbWUgPSBuYW1lO1xuICB0aGlzLl9pZCA9IGlkO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIGQzU2VsZWN0aW9uLnNlbGVjdGlvbigpLnRyYW5zaXRpb24obmFtZSk7XG59XG5cbmZ1bmN0aW9uIG5ld0lkKCkge1xuICByZXR1cm4gKytpZDtcbn1cblxudmFyIHNlbGVjdGlvbl9wcm90b3R5cGUgPSBkM1NlbGVjdGlvbi5zZWxlY3Rpb24ucHJvdG90eXBlO1xuXG5UcmFuc2l0aW9uLnByb3RvdHlwZSA9IHRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVHJhbnNpdGlvbixcbiAgc2VsZWN0OiB0cmFuc2l0aW9uX3NlbGVjdCxcbiAgc2VsZWN0QWxsOiB0cmFuc2l0aW9uX3NlbGVjdEFsbCxcbiAgZmlsdGVyOiB0cmFuc2l0aW9uX2ZpbHRlcixcbiAgbWVyZ2U6IHRyYW5zaXRpb25fbWVyZ2UsXG4gIHNlbGVjdGlvbjogdHJhbnNpdGlvbl9zZWxlY3Rpb24sXG4gIHRyYW5zaXRpb246IHRyYW5zaXRpb25fdHJhbnNpdGlvbixcbiAgY2FsbDogc2VsZWN0aW9uX3Byb3RvdHlwZS5jYWxsLFxuICBub2Rlczogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlcyxcbiAgbm9kZTogc2VsZWN0aW9uX3Byb3RvdHlwZS5ub2RlLFxuICBzaXplOiBzZWxlY3Rpb25fcHJvdG90eXBlLnNpemUsXG4gIGVtcHR5OiBzZWxlY3Rpb25fcHJvdG90eXBlLmVtcHR5LFxuICBlYWNoOiBzZWxlY3Rpb25fcHJvdG90eXBlLmVhY2gsXG4gIG9uOiB0cmFuc2l0aW9uX29uLFxuICBhdHRyOiB0cmFuc2l0aW9uX2F0dHIsXG4gIGF0dHJUd2VlbjogdHJhbnNpdGlvbl9hdHRyVHdlZW4sXG4gIHN0eWxlOiB0cmFuc2l0aW9uX3N0eWxlLFxuICBzdHlsZVR3ZWVuOiB0cmFuc2l0aW9uX3N0eWxlVHdlZW4sXG4gIHRleHQ6IHRyYW5zaXRpb25fdGV4dCxcbiAgcmVtb3ZlOiB0cmFuc2l0aW9uX3JlbW92ZSxcbiAgdHdlZW46IHRyYW5zaXRpb25fdHdlZW4sXG4gIGRlbGF5OiB0cmFuc2l0aW9uX2RlbGF5LFxuICBkdXJhdGlvbjogdHJhbnNpdGlvbl9kdXJhdGlvbixcbiAgZWFzZTogdHJhbnNpdGlvbl9lYXNlXG59O1xuXG52YXIgZGVmYXVsdFRpbWluZyA9IHtcbiAgdGltZTogbnVsbCwgLy8gU2V0IG9uIHVzZS5cbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiAyNTAsXG4gIGVhc2U6IGQzRWFzZS5lYXNlQ3ViaWNJbk91dFxufTtcblxuZnVuY3Rpb24gaW5oZXJpdChub2RlLCBpZCkge1xuICB2YXIgdGltaW5nO1xuICB3aGlsZSAoISh0aW1pbmcgPSBub2RlLl9fdHJhbnNpdGlvbikgfHwgISh0aW1pbmcgPSB0aW1pbmdbaWRdKSkge1xuICAgIGlmICghKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFRpbWluZy50aW1lID0gZDNUaW1lci5ub3coKSwgZGVmYXVsdFRpbWluZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWluZztcbn1cblxudmFyIHNlbGVjdGlvbl90cmFuc2l0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgaWQsXG4gICAgICB0aW1pbmc7XG5cbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBUcmFuc2l0aW9uKSB7XG4gICAgaWQgPSBuYW1lLl9pZCwgbmFtZSA9IG5hbWUuX25hbWU7XG4gIH0gZWxzZSB7XG4gICAgaWQgPSBuZXdJZCgpLCAodGltaW5nID0gZGVmYXVsdFRpbWluZykudGltZSA9IGQzVGltZXIubm93KCksIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gIH1cblxuICBmb3IgKHZhciBncm91cHMgPSB0aGlzLl9ncm91cHMsIG0gPSBncm91cHMubGVuZ3RoLCBqID0gMDsgaiA8IG07ICsraikge1xuICAgIGZvciAodmFyIGdyb3VwID0gZ3JvdXBzW2pdLCBuID0gZ3JvdXAubGVuZ3RoLCBub2RlLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG5vZGUgPSBncm91cFtpXSkge1xuICAgICAgICBzY2hlZHVsZShub2RlLCBuYW1lLCBpZCwgaSwgZ3JvdXAsIHRpbWluZyB8fCBpbmhlcml0KG5vZGUsIGlkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2l0aW9uKGdyb3VwcywgdGhpcy5fcGFyZW50cywgbmFtZSwgaWQpO1xufTtcblxuZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS5pbnRlcnJ1cHQgPSBzZWxlY3Rpb25faW50ZXJydXB0O1xuZDNTZWxlY3Rpb24uc2VsZWN0aW9uLnByb3RvdHlwZS50cmFuc2l0aW9uID0gc2VsZWN0aW9uX3RyYW5zaXRpb247XG5cbnZhciByb290ID0gW251bGxdO1xuXG52YXIgYWN0aXZlID0gZnVuY3Rpb24obm9kZSwgbmFtZSkge1xuICB2YXIgc2NoZWR1bGVzID0gbm9kZS5fX3RyYW5zaXRpb24sXG4gICAgICBzY2hlZHVsZSxcbiAgICAgIGk7XG5cbiAgaWYgKHNjaGVkdWxlcykge1xuICAgIG5hbWUgPSBuYW1lID09IG51bGwgPyBudWxsIDogbmFtZSArIFwiXCI7XG4gICAgZm9yIChpIGluIHNjaGVkdWxlcykge1xuICAgICAgaWYgKChzY2hlZHVsZSA9IHNjaGVkdWxlc1tpXSkuc3RhdGUgPiBTQ0hFRFVMRUQgJiYgc2NoZWR1bGUubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRyYW5zaXRpb24oW1tub2RlXV0sIHJvb3QsIG5hbWUsICtpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmV4cG9ydHMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb247XG5leHBvcnRzLmFjdGl2ZSA9IGFjdGl2ZTtcbmV4cG9ydHMuaW50ZXJydXB0ID0gaW50ZXJydXB0O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuIiwiLy8gaHR0cHM6Ly9kM2pzLm9yZy9kMy12b3Jvbm9pLyBWZXJzaW9uIDEuMS4yLiBDb3B5cmlnaHQgMjAxNyBNaWtlIEJvc3RvY2suXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBjb25zdGFudCA9IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufTtcblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGRbMV07XG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrVHJlZSgpIHtcbiAgdGhpcy5fID0gbnVsbDsgLy8gcm9vdCBub2RlXG59XG5cbmZ1bmN0aW9uIFJlZEJsYWNrTm9kZShub2RlKSB7XG4gIG5vZGUuVSA9IC8vIHBhcmVudCBub2RlXG4gIG5vZGUuQyA9IC8vIGNvbG9yIC0gdHJ1ZSBmb3IgcmVkLCBmYWxzZSBmb3IgYmxhY2tcbiAgbm9kZS5MID0gLy8gbGVmdCBub2RlXG4gIG5vZGUuUiA9IC8vIHJpZ2h0IG5vZGVcbiAgbm9kZS5QID0gLy8gcHJldmlvdXMgbm9kZVxuICBub2RlLk4gPSBudWxsOyAvLyBuZXh0IG5vZGVcbn1cblxuUmVkQmxhY2tUcmVlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFJlZEJsYWNrVHJlZSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uKGFmdGVyLCBub2RlKSB7XG4gICAgdmFyIHBhcmVudCwgZ3JhbmRwYSwgdW5jbGU7XG5cbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIG5vZGUuUCA9IGFmdGVyO1xuICAgICAgbm9kZS5OID0gYWZ0ZXIuTjtcbiAgICAgIGlmIChhZnRlci5OKSBhZnRlci5OLlAgPSBub2RlO1xuICAgICAgYWZ0ZXIuTiA9IG5vZGU7XG4gICAgICBpZiAoYWZ0ZXIuUikge1xuICAgICAgICBhZnRlciA9IGFmdGVyLlI7XG4gICAgICAgIHdoaWxlIChhZnRlci5MKSBhZnRlciA9IGFmdGVyLkw7XG4gICAgICAgIGFmdGVyLkwgPSBub2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZ0ZXIuUiA9IG5vZGU7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuXykge1xuICAgICAgYWZ0ZXIgPSBSZWRCbGFja0ZpcnN0KHRoaXMuXyk7XG4gICAgICBub2RlLlAgPSBudWxsO1xuICAgICAgbm9kZS5OID0gYWZ0ZXI7XG4gICAgICBhZnRlci5QID0gYWZ0ZXIuTCA9IG5vZGU7XG4gICAgICBwYXJlbnQgPSBhZnRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5QID0gbm9kZS5OID0gbnVsbDtcbiAgICAgIHRoaXMuXyA9IG5vZGU7XG4gICAgICBwYXJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBub2RlLkwgPSBub2RlLlIgPSBudWxsO1xuICAgIG5vZGUuVSA9IHBhcmVudDtcbiAgICBub2RlLkMgPSB0cnVlO1xuXG4gICAgYWZ0ZXIgPSBub2RlO1xuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LkMpIHtcbiAgICAgIGdyYW5kcGEgPSBwYXJlbnQuVTtcbiAgICAgIGlmIChwYXJlbnQgPT09IGdyYW5kcGEuTCkge1xuICAgICAgICB1bmNsZSA9IGdyYW5kcGEuUjtcbiAgICAgICAgaWYgKHVuY2xlICYmIHVuY2xlLkMpIHtcbiAgICAgICAgICBwYXJlbnQuQyA9IHVuY2xlLkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIGFmdGVyID0gZ3JhbmRwYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYWZ0ZXIgPT09IHBhcmVudC5SKSB7XG4gICAgICAgICAgICBSZWRCbGFja1JvdGF0ZUxlZnQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgZ3JhbmRwYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuY2xlID0gZ3JhbmRwYS5MO1xuICAgICAgICBpZiAodW5jbGUgJiYgdW5jbGUuQykge1xuICAgICAgICAgIHBhcmVudC5DID0gdW5jbGUuQyA9IGZhbHNlO1xuICAgICAgICAgIGdyYW5kcGEuQyA9IHRydWU7XG4gICAgICAgICAgYWZ0ZXIgPSBncmFuZHBhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhZnRlciA9PT0gcGFyZW50LkwpIHtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICAgIGFmdGVyID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50LkMgPSBmYWxzZTtcbiAgICAgICAgICBncmFuZHBhLkMgPSB0cnVlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBncmFuZHBhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyZW50ID0gYWZ0ZXIuVTtcbiAgICB9XG4gICAgdGhpcy5fLkMgPSBmYWxzZTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5OKSBub2RlLk4uUCA9IG5vZGUuUDtcbiAgICBpZiAobm9kZS5QKSBub2RlLlAuTiA9IG5vZGUuTjtcbiAgICBub2RlLk4gPSBub2RlLlAgPSBudWxsO1xuXG4gICAgdmFyIHBhcmVudCA9IG5vZGUuVSxcbiAgICAgICAgc2libGluZyxcbiAgICAgICAgbGVmdCA9IG5vZGUuTCxcbiAgICAgICAgcmlnaHQgPSBub2RlLlIsXG4gICAgICAgIG5leHQsXG4gICAgICAgIHJlZDtcblxuICAgIGlmICghbGVmdCkgbmV4dCA9IHJpZ2h0O1xuICAgIGVsc2UgaWYgKCFyaWdodCkgbmV4dCA9IGxlZnQ7XG4gICAgZWxzZSBuZXh0ID0gUmVkQmxhY2tGaXJzdChyaWdodCk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LkwgPT09IG5vZGUpIHBhcmVudC5MID0gbmV4dDtcbiAgICAgIGVsc2UgcGFyZW50LlIgPSBuZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl8gPSBuZXh0O1xuICAgIH1cblxuICAgIGlmIChsZWZ0ICYmIHJpZ2h0KSB7XG4gICAgICByZWQgPSBuZXh0LkM7XG4gICAgICBuZXh0LkMgPSBub2RlLkM7XG4gICAgICBuZXh0LkwgPSBsZWZ0O1xuICAgICAgbGVmdC5VID0gbmV4dDtcbiAgICAgIGlmIChuZXh0ICE9PSByaWdodCkge1xuICAgICAgICBwYXJlbnQgPSBuZXh0LlU7XG4gICAgICAgIG5leHQuVSA9IG5vZGUuVTtcbiAgICAgICAgbm9kZSA9IG5leHQuUjtcbiAgICAgICAgcGFyZW50LkwgPSBub2RlO1xuICAgICAgICBuZXh0LlIgPSByaWdodDtcbiAgICAgICAgcmlnaHQuVSA9IG5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0LlUgPSBwYXJlbnQ7XG4gICAgICAgIHBhcmVudCA9IG5leHQ7XG4gICAgICAgIG5vZGUgPSBuZXh0LlI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZCA9IG5vZGUuQztcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIGlmIChub2RlKSBub2RlLlUgPSBwYXJlbnQ7XG4gICAgaWYgKHJlZCkgcmV0dXJuO1xuICAgIGlmIChub2RlICYmIG5vZGUuQykgeyBub2RlLkMgPSBmYWxzZTsgcmV0dXJuOyB9XG5cbiAgICBkbyB7XG4gICAgICBpZiAobm9kZSA9PT0gdGhpcy5fKSBicmVhaztcbiAgICAgIGlmIChub2RlID09PSBwYXJlbnQuTCkge1xuICAgICAgICBzaWJsaW5nID0gcGFyZW50LlI7XG4gICAgICAgIGlmIChzaWJsaW5nLkMpIHtcbiAgICAgICAgICBzaWJsaW5nLkMgPSBmYWxzZTtcbiAgICAgICAgICBwYXJlbnQuQyA9IHRydWU7XG4gICAgICAgICAgUmVkQmxhY2tSb3RhdGVMZWZ0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5SO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxuICAgICAgICAgICAgfHwgKHNpYmxpbmcuUiAmJiBzaWJsaW5nLlIuQykpIHtcbiAgICAgICAgICBpZiAoIXNpYmxpbmcuUiB8fCAhc2libGluZy5SLkMpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuTC5DID0gZmFsc2U7XG4gICAgICAgICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgICAgICAgUmVkQmxhY2tSb3RhdGVSaWdodCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuUjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBwYXJlbnQpO1xuICAgICAgICAgIG5vZGUgPSB0aGlzLl87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgaWYgKHNpYmxpbmcuQykge1xuICAgICAgICAgIHNpYmxpbmcuQyA9IGZhbHNlO1xuICAgICAgICAgIHBhcmVudC5DID0gdHJ1ZTtcbiAgICAgICAgICBSZWRCbGFja1JvdGF0ZVJpZ2h0KHRoaXMsIHBhcmVudCk7XG4gICAgICAgICAgc2libGluZyA9IHBhcmVudC5MO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc2libGluZy5MICYmIHNpYmxpbmcuTC5DKVxuICAgICAgICAgIHx8IChzaWJsaW5nLlIgJiYgc2libGluZy5SLkMpKSB7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nLkwgfHwgIXNpYmxpbmcuTC5DKSB7XG4gICAgICAgICAgICBzaWJsaW5nLlIuQyA9IGZhbHNlO1xuICAgICAgICAgICAgc2libGluZy5DID0gdHJ1ZTtcbiAgICAgICAgICAgIFJlZEJsYWNrUm90YXRlTGVmdCh0aGlzLCBzaWJsaW5nKTtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQuTDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2libGluZy5DID0gcGFyZW50LkM7XG4gICAgICAgICAgcGFyZW50LkMgPSBzaWJsaW5nLkwuQyA9IGZhbHNlO1xuICAgICAgICAgIFJlZEJsYWNrUm90YXRlUmlnaHQodGhpcywgcGFyZW50KTtcbiAgICAgICAgICBub2RlID0gdGhpcy5fO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzaWJsaW5nLkMgPSB0cnVlO1xuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5VO1xuICAgIH0gd2hpbGUgKCFub2RlLkMpO1xuXG4gICAgaWYgKG5vZGUpIG5vZGUuQyA9IGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZWRCbGFja1JvdGF0ZUxlZnQodHJlZSwgbm9kZSkge1xuICB2YXIgcCA9IG5vZGUsXG4gICAgICBxID0gbm9kZS5SLFxuICAgICAgcGFyZW50ID0gcC5VO1xuXG4gIGlmIChwYXJlbnQpIHtcbiAgICBpZiAocGFyZW50LkwgPT09IHApIHBhcmVudC5MID0gcTtcbiAgICBlbHNlIHBhcmVudC5SID0gcTtcbiAgfSBlbHNlIHtcbiAgICB0cmVlLl8gPSBxO1xuICB9XG5cbiAgcS5VID0gcGFyZW50O1xuICBwLlUgPSBxO1xuICBwLlIgPSBxLkw7XG4gIGlmIChwLlIpIHAuUi5VID0gcDtcbiAgcS5MID0gcDtcbn1cblxuZnVuY3Rpb24gUmVkQmxhY2tSb3RhdGVSaWdodCh0cmVlLCBub2RlKSB7XG4gIHZhciBwID0gbm9kZSxcbiAgICAgIHEgPSBub2RlLkwsXG4gICAgICBwYXJlbnQgPSBwLlU7XG5cbiAgaWYgKHBhcmVudCkge1xuICAgIGlmIChwYXJlbnQuTCA9PT0gcCkgcGFyZW50LkwgPSBxO1xuICAgIGVsc2UgcGFyZW50LlIgPSBxO1xuICB9IGVsc2Uge1xuICAgIHRyZWUuXyA9IHE7XG4gIH1cblxuICBxLlUgPSBwYXJlbnQ7XG4gIHAuVSA9IHE7XG4gIHAuTCA9IHEuUjtcbiAgaWYgKHAuTCkgcC5MLlUgPSBwO1xuICBxLlIgPSBwO1xufVxuXG5mdW5jdGlvbiBSZWRCbGFja0ZpcnN0KG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUuTCkgbm9kZSA9IG5vZGUuTDtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2UobGVmdCwgcmlnaHQsIHYwLCB2MSkge1xuICB2YXIgZWRnZSA9IFtudWxsLCBudWxsXSxcbiAgICAgIGluZGV4ID0gZWRnZXMucHVzaChlZGdlKSAtIDE7XG4gIGVkZ2UubGVmdCA9IGxlZnQ7XG4gIGVkZ2UucmlnaHQgPSByaWdodDtcbiAgaWYgKHYwKSBzZXRFZGdlRW5kKGVkZ2UsIGxlZnQsIHJpZ2h0LCB2MCk7XG4gIGlmICh2MSkgc2V0RWRnZUVuZChlZGdlLCByaWdodCwgbGVmdCwgdjEpO1xuICBjZWxsc1tsZWZ0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIGNlbGxzW3JpZ2h0LmluZGV4XS5oYWxmZWRnZXMucHVzaChpbmRleCk7XG4gIHJldHVybiBlZGdlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb3JkZXJFZGdlKGxlZnQsIHYwLCB2MSkge1xuICB2YXIgZWRnZSA9IFt2MCwgdjFdO1xuICBlZGdlLmxlZnQgPSBsZWZ0O1xuICByZXR1cm4gZWRnZTtcbn1cblxuZnVuY3Rpb24gc2V0RWRnZUVuZChlZGdlLCBsZWZ0LCByaWdodCwgdmVydGV4KSB7XG4gIGlmICghZWRnZVswXSAmJiAhZWRnZVsxXSkge1xuICAgIGVkZ2VbMF0gPSB2ZXJ0ZXg7XG4gICAgZWRnZS5sZWZ0ID0gbGVmdDtcbiAgICBlZGdlLnJpZ2h0ID0gcmlnaHQ7XG4gIH0gZWxzZSBpZiAoZWRnZS5sZWZ0ID09PSByaWdodCkge1xuICAgIGVkZ2VbMV0gPSB2ZXJ0ZXg7XG4gIH0gZWxzZSB7XG4gICAgZWRnZVswXSA9IHZlcnRleDtcbiAgfVxufVxuXG4vLyBMaWFuZ+KAk0JhcnNreSBsaW5lIGNsaXBwaW5nLlxuZnVuY3Rpb24gY2xpcEVkZ2UoZWRnZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGEgPSBlZGdlWzBdLFxuICAgICAgYiA9IGVkZ2VbMV0sXG4gICAgICBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICB0MCA9IDAsXG4gICAgICB0MSA9IDEsXG4gICAgICBkeCA9IGJ4IC0gYXgsXG4gICAgICBkeSA9IGJ5IC0gYXksXG4gICAgICByO1xuXG4gIHIgPSB4MCAtIGF4O1xuICBpZiAoIWR4ICYmIHIgPiAwKSByZXR1cm47XG4gIHIgLz0gZHg7XG4gIGlmIChkeCA8IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9IGVsc2UgaWYgKGR4ID4gMCkge1xuICAgIGlmIChyID4gdDEpIHJldHVybjtcbiAgICBpZiAociA+IHQwKSB0MCA9IHI7XG4gIH1cblxuICByID0geDEgLSBheDtcbiAgaWYgKCFkeCAmJiByIDwgMCkgcmV0dXJuO1xuICByIC89IGR4O1xuICBpZiAoZHggPCAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfSBlbHNlIGlmIChkeCA+IDApIHtcbiAgICBpZiAociA8IHQwKSByZXR1cm47XG4gICAgaWYgKHIgPCB0MSkgdDEgPSByO1xuICB9XG5cbiAgciA9IHkwIC0gYXk7XG4gIGlmICghZHkgJiYgciA+IDApIHJldHVybjtcbiAgciAvPSBkeTtcbiAgaWYgKGR5IDwgMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH0gZWxzZSBpZiAoZHkgPiAwKSB7XG4gICAgaWYgKHIgPiB0MSkgcmV0dXJuO1xuICAgIGlmIChyID4gdDApIHQwID0gcjtcbiAgfVxuXG4gIHIgPSB5MSAtIGF5O1xuICBpZiAoIWR5ICYmIHIgPCAwKSByZXR1cm47XG4gIHIgLz0gZHk7XG4gIGlmIChkeSA8IDApIHtcbiAgICBpZiAociA+IHQxKSByZXR1cm47XG4gICAgaWYgKHIgPiB0MCkgdDAgPSByO1xuICB9IGVsc2UgaWYgKGR5ID4gMCkge1xuICAgIGlmIChyIDwgdDApIHJldHVybjtcbiAgICBpZiAociA8IHQxKSB0MSA9IHI7XG4gIH1cblxuICBpZiAoISh0MCA+IDApICYmICEodDEgPCAxKSkgcmV0dXJuIHRydWU7IC8vIFRPRE8gQmV0dGVyIGNoZWNrP1xuXG4gIGlmICh0MCA+IDApIGVkZ2VbMF0gPSBbYXggKyB0MCAqIGR4LCBheSArIHQwICogZHldO1xuICBpZiAodDEgPCAxKSBlZGdlWzFdID0gW2F4ICsgdDEgKiBkeCwgYXkgKyB0MSAqIGR5XTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3RFZGdlKGVkZ2UsIHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciB2MSA9IGVkZ2VbMV07XG4gIGlmICh2MSkgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHYwID0gZWRnZVswXSxcbiAgICAgIGxlZnQgPSBlZGdlLmxlZnQsXG4gICAgICByaWdodCA9IGVkZ2UucmlnaHQsXG4gICAgICBseCA9IGxlZnRbMF0sXG4gICAgICBseSA9IGxlZnRbMV0sXG4gICAgICByeCA9IHJpZ2h0WzBdLFxuICAgICAgcnkgPSByaWdodFsxXSxcbiAgICAgIGZ4ID0gKGx4ICsgcngpIC8gMixcbiAgICAgIGZ5ID0gKGx5ICsgcnkpIC8gMixcbiAgICAgIGZtLFxuICAgICAgZmI7XG5cbiAgaWYgKHJ5ID09PSBseSkge1xuICAgIGlmIChmeCA8IHgwIHx8IGZ4ID49IHgxKSByZXR1cm47XG4gICAgaWYgKGx4ID4gcngpIHtcbiAgICAgIGlmICghdjApIHYwID0gW2Z4LCB5MF07XG4gICAgICBlbHNlIGlmICh2MFsxXSA+PSB5MSkgcmV0dXJuO1xuICAgICAgdjEgPSBbZngsIHkxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF2MCkgdjAgPSBbZngsIHkxXTtcbiAgICAgIGVsc2UgaWYgKHYwWzFdIDwgeTApIHJldHVybjtcbiAgICAgIHYxID0gW2Z4LCB5MF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZtID0gKGx4IC0gcngpIC8gKHJ5IC0gbHkpO1xuICAgIGZiID0gZnkgLSBmbSAqIGZ4O1xuICAgIGlmIChmbSA8IC0xIHx8IGZtID4gMSkge1xuICAgICAgaWYgKGx4ID4gcngpIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgICAgZWxzZSBpZiAodjBbMV0gPj0geTEpIHJldHVybjtcbiAgICAgICAgdjEgPSBbKHkxIC0gZmIpIC8gZm0sIHkxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdjApIHYwID0gWyh5MSAtIGZiKSAvIGZtLCB5MV07XG4gICAgICAgIGVsc2UgaWYgKHYwWzFdIDwgeTApIHJldHVybjtcbiAgICAgICAgdjEgPSBbKHkwIC0gZmIpIC8gZm0sIHkwXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGx5IDwgcnkpIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICAgIGVsc2UgaWYgKHYwWzBdID49IHgxKSByZXR1cm47XG4gICAgICAgIHYxID0gW3gxLCBmbSAqIHgxICsgZmJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF2MCkgdjAgPSBbeDEsIGZtICogeDEgKyBmYl07XG4gICAgICAgIGVsc2UgaWYgKHYwWzBdIDwgeDApIHJldHVybjtcbiAgICAgICAgdjEgPSBbeDAsIGZtICogeDAgKyBmYl07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZWRnZVswXSA9IHYwO1xuICBlZGdlWzFdID0gdjE7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjbGlwRWRnZXMoeDAsIHkwLCB4MSwgeTEpIHtcbiAgdmFyIGkgPSBlZGdlcy5sZW5ndGgsXG4gICAgICBlZGdlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIWNvbm5lY3RFZGdlKGVkZ2UgPSBlZGdlc1tpXSwgeDAsIHkwLCB4MSwgeTEpXG4gICAgICAgIHx8ICFjbGlwRWRnZShlZGdlLCB4MCwgeTAsIHgxLCB5MSlcbiAgICAgICAgfHwgIShNYXRoLmFicyhlZGdlWzBdWzBdIC0gZWRnZVsxXVswXSkgPiBlcHNpbG9uXG4gICAgICAgICAgICB8fCBNYXRoLmFicyhlZGdlWzBdWzFdIC0gZWRnZVsxXVsxXSkgPiBlcHNpbG9uKSkge1xuICAgICAgZGVsZXRlIGVkZ2VzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDZWxsKHNpdGUpIHtcbiAgcmV0dXJuIGNlbGxzW3NpdGUuaW5kZXhdID0ge1xuICAgIHNpdGU6IHNpdGUsXG4gICAgaGFsZmVkZ2VzOiBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiBjZWxsSGFsZmVkZ2VBbmdsZShjZWxsLCBlZGdlKSB7XG4gIHZhciBzaXRlID0gY2VsbC5zaXRlLFxuICAgICAgdmEgPSBlZGdlLmxlZnQsXG4gICAgICB2YiA9IGVkZ2UucmlnaHQ7XG4gIGlmIChzaXRlID09PSB2YikgdmIgPSB2YSwgdmEgPSBzaXRlO1xuICBpZiAodmIpIHJldHVybiBNYXRoLmF0YW4yKHZiWzFdIC0gdmFbMV0sIHZiWzBdIC0gdmFbMF0pO1xuICBpZiAoc2l0ZSA9PT0gdmEpIHZhID0gZWRnZVsxXSwgdmIgPSBlZGdlWzBdO1xuICBlbHNlIHZhID0gZWRnZVswXSwgdmIgPSBlZGdlWzFdO1xuICByZXR1cm4gTWF0aC5hdGFuMih2YVswXSAtIHZiWzBdLCB2YlsxXSAtIHZhWzFdKTtcbn1cblxuZnVuY3Rpb24gY2VsbEhhbGZlZGdlU3RhcnQoY2VsbCwgZWRnZSkge1xuICByZXR1cm4gZWRnZVsrKGVkZ2UubGVmdCAhPT0gY2VsbC5zaXRlKV07XG59XG5cbmZ1bmN0aW9uIGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlKSB7XG4gIHJldHVybiBlZGdlWysoZWRnZS5sZWZ0ID09PSBjZWxsLnNpdGUpXTtcbn1cblxuZnVuY3Rpb24gc29ydENlbGxIYWxmZWRnZXMoKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gY2VsbHMubGVuZ3RoLCBjZWxsLCBoYWxmZWRnZXMsIGosIG07IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGNlbGwgPSBjZWxsc1tpXSkgJiYgKG0gPSAoaGFsZmVkZ2VzID0gY2VsbC5oYWxmZWRnZXMpLmxlbmd0aCkpIHtcbiAgICAgIHZhciBpbmRleCA9IG5ldyBBcnJheShtKSxcbiAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShtKTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIGluZGV4W2pdID0gaiwgYXJyYXlbal0gPSBjZWxsSGFsZmVkZ2VBbmdsZShjZWxsLCBlZGdlc1toYWxmZWRnZXNbal1dKTtcbiAgICAgIGluZGV4LnNvcnQoZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gYXJyYXlbal0gLSBhcnJheVtpXTsgfSk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBhcnJheVtqXSA9IGhhbGZlZGdlc1tpbmRleFtqXV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSBoYWxmZWRnZXNbal0gPSBhcnJheVtqXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xpcENlbGxzKHgwLCB5MCwgeDEsIHkxKSB7XG4gIHZhciBuQ2VsbHMgPSBjZWxscy5sZW5ndGgsXG4gICAgICBpQ2VsbCxcbiAgICAgIGNlbGwsXG4gICAgICBzaXRlLFxuICAgICAgaUhhbGZlZGdlLFxuICAgICAgaGFsZmVkZ2VzLFxuICAgICAgbkhhbGZlZGdlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRYLFxuICAgICAgc3RhcnRZLFxuICAgICAgZW5kLFxuICAgICAgZW5kWCxcbiAgICAgIGVuZFksXG4gICAgICBjb3ZlciA9IHRydWU7XG5cbiAgZm9yIChpQ2VsbCA9IDA7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgaWYgKGNlbGwgPSBjZWxsc1tpQ2VsbF0pIHtcbiAgICAgIHNpdGUgPSBjZWxsLnNpdGU7XG4gICAgICBoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcztcbiAgICAgIGlIYWxmZWRnZSA9IGhhbGZlZGdlcy5sZW5ndGg7XG5cbiAgICAgIC8vIFJlbW92ZSBhbnkgZGFuZ2xpbmcgY2xpcHBlZCBlZGdlcy5cbiAgICAgIHdoaWxlIChpSGFsZmVkZ2UtLSkge1xuICAgICAgICBpZiAoIWVkZ2VzW2hhbGZlZGdlc1tpSGFsZmVkZ2VdXSkge1xuICAgICAgICAgIGhhbGZlZGdlcy5zcGxpY2UoaUhhbGZlZGdlLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbnNlcnQgYW55IGJvcmRlciBlZGdlcyBhcyBuZWNlc3NhcnkuXG4gICAgICBpSGFsZmVkZ2UgPSAwLCBuSGFsZmVkZ2VzID0gaGFsZmVkZ2VzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpSGFsZmVkZ2UgPCBuSGFsZmVkZ2VzKSB7XG4gICAgICAgIGVuZCA9IGNlbGxIYWxmZWRnZUVuZChjZWxsLCBlZGdlc1toYWxmZWRnZXNbaUhhbGZlZGdlXV0pLCBlbmRYID0gZW5kWzBdLCBlbmRZID0gZW5kWzFdO1xuICAgICAgICBzdGFydCA9IGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2hhbGZlZGdlc1srK2lIYWxmZWRnZSAlIG5IYWxmZWRnZXNdXSksIHN0YXJ0WCA9IHN0YXJ0WzBdLCBzdGFydFkgPSBzdGFydFsxXTtcbiAgICAgICAgaWYgKE1hdGguYWJzKGVuZFggLSBzdGFydFgpID4gZXBzaWxvbiB8fCBNYXRoLmFicyhlbmRZIC0gc3RhcnRZKSA+IGVwc2lsb24pIHtcbiAgICAgICAgICBoYWxmZWRnZXMuc3BsaWNlKGlIYWxmZWRnZSwgMCwgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIGVuZCxcbiAgICAgICAgICAgICAgTWF0aC5hYnMoZW5kWCAtIHgwKSA8IGVwc2lsb24gJiYgeTEgLSBlbmRZID4gZXBzaWxvbiA/IFt4MCwgTWF0aC5hYnMoc3RhcnRYIC0geDApIDwgZXBzaWxvbiA/IHN0YXJ0WSA6IHkxXVxuICAgICAgICAgICAgICA6IE1hdGguYWJzKGVuZFkgLSB5MSkgPCBlcHNpbG9uICYmIHgxIC0gZW5kWCA+IGVwc2lsb24gPyBbTWF0aC5hYnMoc3RhcnRZIC0geTEpIDwgZXBzaWxvbiA/IHN0YXJ0WCA6IHgxLCB5MV1cbiAgICAgICAgICAgICAgOiBNYXRoLmFicyhlbmRYIC0geDEpIDwgZXBzaWxvbiAmJiBlbmRZIC0geTAgPiBlcHNpbG9uID8gW3gxLCBNYXRoLmFicyhzdGFydFggLSB4MSkgPCBlcHNpbG9uID8gc3RhcnRZIDogeTBdXG4gICAgICAgICAgICAgIDogTWF0aC5hYnMoZW5kWSAtIHkwKSA8IGVwc2lsb24gJiYgZW5kWCAtIHgwID4gZXBzaWxvbiA/IFtNYXRoLmFicyhzdGFydFkgLSB5MCkgPCBlcHNpbG9uID8gc3RhcnRYIDogeDAsIHkwXVxuICAgICAgICAgICAgICA6IG51bGwpKSAtIDEpO1xuICAgICAgICAgICsrbkhhbGZlZGdlcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkhhbGZlZGdlcykgY292ZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSB3ZXJlbuKAmXQgYW55IGVkZ2VzLCBoYXZlIHRoZSBjbG9zZXN0IHNpdGUgY292ZXIgdGhlIGV4dGVudC5cbiAgLy8gSXQgZG9lc27igJl0IG1hdHRlciB3aGljaCBjb3JuZXIgb2YgdGhlIGV4dGVudCB3ZSBtZWFzdXJlIVxuICBpZiAoY292ZXIpIHtcbiAgICB2YXIgZHgsIGR5LCBkMiwgZGMgPSBJbmZpbml0eTtcblxuICAgIGZvciAoaUNlbGwgPSAwLCBjb3ZlciA9IG51bGw7IGlDZWxsIDwgbkNlbGxzOyArK2lDZWxsKSB7XG4gICAgICBpZiAoY2VsbCA9IGNlbGxzW2lDZWxsXSkge1xuICAgICAgICBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICBkeCA9IHNpdGVbMF0gLSB4MDtcbiAgICAgICAgZHkgPSBzaXRlWzFdIC0geTA7XG4gICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIGlmIChkMiA8IGRjKSBkYyA9IGQyLCBjb3ZlciA9IGNlbGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvdmVyKSB7XG4gICAgICB2YXIgdjAwID0gW3gwLCB5MF0sIHYwMSA9IFt4MCwgeTFdLCB2MTEgPSBbeDEsIHkxXSwgdjEwID0gW3gxLCB5MF07XG4gICAgICBjb3Zlci5oYWxmZWRnZXMucHVzaChcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUgPSBjb3Zlci5zaXRlLCB2MDAsIHYwMSkpIC0gMSxcbiAgICAgICAgZWRnZXMucHVzaChjcmVhdGVCb3JkZXJFZGdlKHNpdGUsIHYwMSwgdjExKSkgLSAxLFxuICAgICAgICBlZGdlcy5wdXNoKGNyZWF0ZUJvcmRlckVkZ2Uoc2l0ZSwgdjExLCB2MTApKSAtIDEsXG4gICAgICAgIGVkZ2VzLnB1c2goY3JlYXRlQm9yZGVyRWRnZShzaXRlLCB2MTAsIHYwMCkpIC0gMVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBMYXN0bHkgZGVsZXRlIGFueSBjZWxscyB3aXRoIG5vIGVkZ2VzOyB0aGVzZSB3ZXJlIGVudGlyZWx5IGNsaXBwZWQuXG4gIGZvciAoaUNlbGwgPSAwOyBpQ2VsbCA8IG5DZWxsczsgKytpQ2VsbCkge1xuICAgIGlmIChjZWxsID0gY2VsbHNbaUNlbGxdKSB7XG4gICAgICBpZiAoIWNlbGwuaGFsZmVkZ2VzLmxlbmd0aCkge1xuICAgICAgICBkZWxldGUgY2VsbHNbaUNlbGxdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgY2lyY2xlUG9vbCA9IFtdO1xuXG52YXIgZmlyc3RDaXJjbGU7XG5cbmZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLnggPVxuICB0aGlzLnkgPVxuICB0aGlzLmFyYyA9XG4gIHRoaXMuc2l0ZSA9XG4gIHRoaXMuY3kgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhdHRhY2hDaXJjbGUoYXJjKSB7XG4gIHZhciBsQXJjID0gYXJjLlAsXG4gICAgICByQXJjID0gYXJjLk47XG5cbiAgaWYgKCFsQXJjIHx8ICFyQXJjKSByZXR1cm47XG5cbiAgdmFyIGxTaXRlID0gbEFyYy5zaXRlLFxuICAgICAgY1NpdGUgPSBhcmMuc2l0ZSxcbiAgICAgIHJTaXRlID0gckFyYy5zaXRlO1xuXG4gIGlmIChsU2l0ZSA9PT0gclNpdGUpIHJldHVybjtcblxuICB2YXIgYnggPSBjU2l0ZVswXSxcbiAgICAgIGJ5ID0gY1NpdGVbMV0sXG4gICAgICBheCA9IGxTaXRlWzBdIC0gYngsXG4gICAgICBheSA9IGxTaXRlWzFdIC0gYnksXG4gICAgICBjeCA9IHJTaXRlWzBdIC0gYngsXG4gICAgICBjeSA9IHJTaXRlWzFdIC0gYnk7XG5cbiAgdmFyIGQgPSAyICogKGF4ICogY3kgLSBheSAqIGN4KTtcbiAgaWYgKGQgPj0gLWVwc2lsb24yKSByZXR1cm47XG5cbiAgdmFyIGhhID0gYXggKiBheCArIGF5ICogYXksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgeCA9IChjeSAqIGhhIC0gYXkgKiBoYykgLyBkLFxuICAgICAgeSA9IChheCAqIGhjIC0gY3ggKiBoYSkgLyBkO1xuXG4gIHZhciBjaXJjbGUgPSBjaXJjbGVQb29sLnBvcCgpIHx8IG5ldyBDaXJjbGU7XG4gIGNpcmNsZS5hcmMgPSBhcmM7XG4gIGNpcmNsZS5zaXRlID0gY1NpdGU7XG4gIGNpcmNsZS54ID0geCArIGJ4O1xuICBjaXJjbGUueSA9IChjaXJjbGUuY3kgPSB5ICsgYnkpICsgTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpOyAvLyB5IGJvdHRvbVxuXG4gIGFyYy5jaXJjbGUgPSBjaXJjbGU7XG5cbiAgdmFyIGJlZm9yZSA9IG51bGwsXG4gICAgICBub2RlID0gY2lyY2xlcy5fO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKGNpcmNsZS55IDwgbm9kZS55IHx8IChjaXJjbGUueSA9PT0gbm9kZS55ICYmIGNpcmNsZS54IDw9IG5vZGUueCkpIHtcbiAgICAgIGlmIChub2RlLkwpIG5vZGUgPSBub2RlLkw7XG4gICAgICBlbHNlIHsgYmVmb3JlID0gbm9kZS5QOyBicmVhazsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobm9kZS5SKSBub2RlID0gbm9kZS5SO1xuICAgICAgZWxzZSB7IGJlZm9yZSA9IG5vZGU7IGJyZWFrOyB9XG4gICAgfVxuICB9XG5cbiAgY2lyY2xlcy5pbnNlcnQoYmVmb3JlLCBjaXJjbGUpO1xuICBpZiAoIWJlZm9yZSkgZmlyc3RDaXJjbGUgPSBjaXJjbGU7XG59XG5cbmZ1bmN0aW9uIGRldGFjaENpcmNsZShhcmMpIHtcbiAgdmFyIGNpcmNsZSA9IGFyYy5jaXJjbGU7XG4gIGlmIChjaXJjbGUpIHtcbiAgICBpZiAoIWNpcmNsZS5QKSBmaXJzdENpcmNsZSA9IGNpcmNsZS5OO1xuICAgIGNpcmNsZXMucmVtb3ZlKGNpcmNsZSk7XG4gICAgY2lyY2xlUG9vbC5wdXNoKGNpcmNsZSk7XG4gICAgUmVkQmxhY2tOb2RlKGNpcmNsZSk7XG4gICAgYXJjLmNpcmNsZSA9IG51bGw7XG4gIH1cbn1cblxudmFyIGJlYWNoUG9vbCA9IFtdO1xuXG5mdW5jdGlvbiBCZWFjaCgpIHtcbiAgUmVkQmxhY2tOb2RlKHRoaXMpO1xuICB0aGlzLmVkZ2UgPVxuICB0aGlzLnNpdGUgPVxuICB0aGlzLmNpcmNsZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJlYWNoKHNpdGUpIHtcbiAgdmFyIGJlYWNoID0gYmVhY2hQb29sLnBvcCgpIHx8IG5ldyBCZWFjaDtcbiAgYmVhY2guc2l0ZSA9IHNpdGU7XG4gIHJldHVybiBiZWFjaDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoQmVhY2goYmVhY2gpIHtcbiAgZGV0YWNoQ2lyY2xlKGJlYWNoKTtcbiAgYmVhY2hlcy5yZW1vdmUoYmVhY2gpO1xuICBiZWFjaFBvb2wucHVzaChiZWFjaCk7XG4gIFJlZEJsYWNrTm9kZShiZWFjaCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUJlYWNoKGJlYWNoKSB7XG4gIHZhciBjaXJjbGUgPSBiZWFjaC5jaXJjbGUsXG4gICAgICB4ID0gY2lyY2xlLngsXG4gICAgICB5ID0gY2lyY2xlLmN5LFxuICAgICAgdmVydGV4ID0gW3gsIHldLFxuICAgICAgcHJldmlvdXMgPSBiZWFjaC5QLFxuICAgICAgbmV4dCA9IGJlYWNoLk4sXG4gICAgICBkaXNhcHBlYXJpbmcgPSBbYmVhY2hdO1xuXG4gIGRldGFjaEJlYWNoKGJlYWNoKTtcblxuICB2YXIgbEFyYyA9IHByZXZpb3VzO1xuICB3aGlsZSAobEFyYy5jaXJjbGVcbiAgICAgICYmIE1hdGguYWJzKHggLSBsQXJjLmNpcmNsZS54KSA8IGVwc2lsb25cbiAgICAgICYmIE1hdGguYWJzKHkgLSBsQXJjLmNpcmNsZS5jeSkgPCBlcHNpbG9uKSB7XG4gICAgcHJldmlvdXMgPSBsQXJjLlA7XG4gICAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gICAgZGV0YWNoQmVhY2gobEFyYyk7XG4gICAgbEFyYyA9IHByZXZpb3VzO1xuICB9XG5cbiAgZGlzYXBwZWFyaW5nLnVuc2hpZnQobEFyYyk7XG4gIGRldGFjaENpcmNsZShsQXJjKTtcblxuICB2YXIgckFyYyA9IG5leHQ7XG4gIHdoaWxlIChyQXJjLmNpcmNsZVxuICAgICAgJiYgTWF0aC5hYnMoeCAtIHJBcmMuY2lyY2xlLngpIDwgZXBzaWxvblxuICAgICAgJiYgTWF0aC5hYnMoeSAtIHJBcmMuY2lyY2xlLmN5KSA8IGVwc2lsb24pIHtcbiAgICBuZXh0ID0gckFyYy5OO1xuICAgIGRpc2FwcGVhcmluZy5wdXNoKHJBcmMpO1xuICAgIGRldGFjaEJlYWNoKHJBcmMpO1xuICAgIHJBcmMgPSBuZXh0O1xuICB9XG5cbiAgZGlzYXBwZWFyaW5nLnB1c2gockFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbkFyY3MgPSBkaXNhcHBlYXJpbmcubGVuZ3RoLFxuICAgICAgaUFyYztcbiAgZm9yIChpQXJjID0gMTsgaUFyYyA8IG5BcmNzOyArK2lBcmMpIHtcbiAgICByQXJjID0gZGlzYXBwZWFyaW5nW2lBcmNdO1xuICAgIGxBcmMgPSBkaXNhcHBlYXJpbmdbaUFyYyAtIDFdO1xuICAgIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgdmVydGV4KTtcbiAgfVxuXG4gIGxBcmMgPSBkaXNhcHBlYXJpbmdbMF07XG4gIHJBcmMgPSBkaXNhcHBlYXJpbmdbbkFyY3MgLSAxXTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIHJBcmMuc2l0ZSwgbnVsbCwgdmVydGV4KTtcblxuICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gIGF0dGFjaENpcmNsZShyQXJjKTtcbn1cblxuZnVuY3Rpb24gYWRkQmVhY2goc2l0ZSkge1xuICB2YXIgeCA9IHNpdGVbMF0sXG4gICAgICBkaXJlY3RyaXggPSBzaXRlWzFdLFxuICAgICAgbEFyYyxcbiAgICAgIHJBcmMsXG4gICAgICBkeGwsXG4gICAgICBkeHIsXG4gICAgICBub2RlID0gYmVhY2hlcy5fO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgZHhsID0gbGVmdEJyZWFrUG9pbnQobm9kZSwgZGlyZWN0cml4KSAtIHg7XG4gICAgaWYgKGR4bCA+IGVwc2lsb24pIG5vZGUgPSBub2RlLkw7IGVsc2Uge1xuICAgICAgZHhyID0geCAtIHJpZ2h0QnJlYWtQb2ludChub2RlLCBkaXJlY3RyaXgpO1xuICAgICAgaWYgKGR4ciA+IGVwc2lsb24pIHtcbiAgICAgICAgaWYgKCFub2RlLlIpIHtcbiAgICAgICAgICBsQXJjID0gbm9kZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZS5SO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGR4bCA+IC1lcHNpbG9uKSB7XG4gICAgICAgICAgbEFyYyA9IG5vZGUuUDtcbiAgICAgICAgICByQXJjID0gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChkeHIgPiAtZXBzaWxvbikge1xuICAgICAgICAgIGxBcmMgPSBub2RlO1xuICAgICAgICAgIHJBcmMgPSBub2RlLk47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbEFyYyA9IHJBcmMgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNyZWF0ZUNlbGwoc2l0ZSk7XG4gIHZhciBuZXdBcmMgPSBjcmVhdGVCZWFjaChzaXRlKTtcbiAgYmVhY2hlcy5pbnNlcnQobEFyYywgbmV3QXJjKTtcblxuICBpZiAoIWxBcmMgJiYgIXJBcmMpIHJldHVybjtcblxuICBpZiAobEFyYyA9PT0gckFyYykge1xuICAgIGRldGFjaENpcmNsZShsQXJjKTtcbiAgICByQXJjID0gY3JlYXRlQmVhY2gobEFyYy5zaXRlKTtcbiAgICBiZWFjaGVzLmluc2VydChuZXdBcmMsIHJBcmMpO1xuICAgIG5ld0FyYy5lZGdlID0gckFyYy5lZGdlID0gY3JlYXRlRWRnZShsQXJjLnNpdGUsIG5ld0FyYy5zaXRlKTtcbiAgICBhdHRhY2hDaXJjbGUobEFyYyk7XG4gICAgYXR0YWNoQ2lyY2xlKHJBcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghckFyYykgeyAvLyAmJiBsQXJjXG4gICAgbmV3QXJjLmVkZ2UgPSBjcmVhdGVFZGdlKGxBcmMuc2l0ZSwgbmV3QXJjLnNpdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVsc2UgbEFyYyAhPT0gckFyY1xuICBkZXRhY2hDaXJjbGUobEFyYyk7XG4gIGRldGFjaENpcmNsZShyQXJjKTtcblxuICB2YXIgbFNpdGUgPSBsQXJjLnNpdGUsXG4gICAgICBheCA9IGxTaXRlWzBdLFxuICAgICAgYXkgPSBsU2l0ZVsxXSxcbiAgICAgIGJ4ID0gc2l0ZVswXSAtIGF4LFxuICAgICAgYnkgPSBzaXRlWzFdIC0gYXksXG4gICAgICByU2l0ZSA9IHJBcmMuc2l0ZSxcbiAgICAgIGN4ID0gclNpdGVbMF0gLSBheCxcbiAgICAgIGN5ID0gclNpdGVbMV0gLSBheSxcbiAgICAgIGQgPSAyICogKGJ4ICogY3kgLSBieSAqIGN4KSxcbiAgICAgIGhiID0gYnggKiBieCArIGJ5ICogYnksXG4gICAgICBoYyA9IGN4ICogY3ggKyBjeSAqIGN5LFxuICAgICAgdmVydGV4ID0gWyhjeSAqIGhiIC0gYnkgKiBoYykgLyBkICsgYXgsIChieCAqIGhjIC0gY3ggKiBoYikgLyBkICsgYXldO1xuXG4gIHNldEVkZ2VFbmQockFyYy5lZGdlLCBsU2l0ZSwgclNpdGUsIHZlcnRleCk7XG4gIG5ld0FyYy5lZGdlID0gY3JlYXRlRWRnZShsU2l0ZSwgc2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgckFyYy5lZGdlID0gY3JlYXRlRWRnZShzaXRlLCByU2l0ZSwgbnVsbCwgdmVydGV4KTtcbiAgYXR0YWNoQ2lyY2xlKGxBcmMpO1xuICBhdHRhY2hDaXJjbGUockFyYyk7XG59XG5cbmZ1bmN0aW9uIGxlZnRCcmVha1BvaW50KGFyYywgZGlyZWN0cml4KSB7XG4gIHZhciBzaXRlID0gYXJjLnNpdGUsXG4gICAgICByZm9jeCA9IHNpdGVbMF0sXG4gICAgICByZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwYnkyID0gcmZvY3kgLSBkaXJlY3RyaXg7XG5cbiAgaWYgKCFwYnkyKSByZXR1cm4gcmZvY3g7XG5cbiAgdmFyIGxBcmMgPSBhcmMuUDtcbiAgaWYgKCFsQXJjKSByZXR1cm4gLUluZmluaXR5O1xuXG4gIHNpdGUgPSBsQXJjLnNpdGU7XG4gIHZhciBsZm9jeCA9IHNpdGVbMF0sXG4gICAgICBsZm9jeSA9IHNpdGVbMV0sXG4gICAgICBwbGJ5MiA9IGxmb2N5IC0gZGlyZWN0cml4O1xuXG4gIGlmICghcGxieTIpIHJldHVybiBsZm9jeDtcblxuICB2YXIgaGwgPSBsZm9jeCAtIHJmb2N4LFxuICAgICAgYWJ5MiA9IDEgLyBwYnkyIC0gMSAvIHBsYnkyLFxuICAgICAgYiA9IGhsIC8gcGxieTI7XG5cbiAgaWYgKGFieTIpIHJldHVybiAoLWIgKyBNYXRoLnNxcnQoYiAqIGIgLSAyICogYWJ5MiAqIChobCAqIGhsIC8gKC0yICogcGxieTIpIC0gbGZvY3kgKyBwbGJ5MiAvIDIgKyByZm9jeSAtIHBieTIgLyAyKSkpIC8gYWJ5MiArIHJmb2N4O1xuXG4gIHJldHVybiAocmZvY3ggKyBsZm9jeCkgLyAyO1xufVxuXG5mdW5jdGlvbiByaWdodEJyZWFrUG9pbnQoYXJjLCBkaXJlY3RyaXgpIHtcbiAgdmFyIHJBcmMgPSBhcmMuTjtcbiAgaWYgKHJBcmMpIHJldHVybiBsZWZ0QnJlYWtQb2ludChyQXJjLCBkaXJlY3RyaXgpO1xuICB2YXIgc2l0ZSA9IGFyYy5zaXRlO1xuICByZXR1cm4gc2l0ZVsxXSA9PT0gZGlyZWN0cml4ID8gc2l0ZVswXSA6IEluZmluaXR5O1xufVxuXG52YXIgZXBzaWxvbiA9IDFlLTY7XG52YXIgZXBzaWxvbjIgPSAxZS0xMjtcbnZhciBiZWFjaGVzO1xudmFyIGNlbGxzO1xudmFyIGNpcmNsZXM7XG52YXIgZWRnZXM7XG5cbmZ1bmN0aW9uIHRyaWFuZ2xlQXJlYShhLCBiLCBjKSB7XG4gIHJldHVybiAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBhWzFdKSAtIChhWzBdIC0gYlswXSkgKiAoY1sxXSAtIGFbMV0pO1xufVxuXG5mdW5jdGlvbiBsZXhpY29ncmFwaGljKGEsIGIpIHtcbiAgcmV0dXJuIGJbMV0gLSBhWzFdXG4gICAgICB8fCBiWzBdIC0gYVswXTtcbn1cblxuZnVuY3Rpb24gRGlhZ3JhbShzaXRlcywgZXh0ZW50KSB7XG4gIHZhciBzaXRlID0gc2l0ZXMuc29ydChsZXhpY29ncmFwaGljKS5wb3AoKSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY2lyY2xlO1xuXG4gIGVkZ2VzID0gW107XG4gIGNlbGxzID0gbmV3IEFycmF5KHNpdGVzLmxlbmd0aCk7XG4gIGJlYWNoZXMgPSBuZXcgUmVkQmxhY2tUcmVlO1xuICBjaXJjbGVzID0gbmV3IFJlZEJsYWNrVHJlZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNpcmNsZSA9IGZpcnN0Q2lyY2xlO1xuICAgIGlmIChzaXRlICYmICghY2lyY2xlIHx8IHNpdGVbMV0gPCBjaXJjbGUueSB8fCAoc2l0ZVsxXSA9PT0gY2lyY2xlLnkgJiYgc2l0ZVswXSA8IGNpcmNsZS54KSkpIHtcbiAgICAgIGlmIChzaXRlWzBdICE9PSB4IHx8IHNpdGVbMV0gIT09IHkpIHtcbiAgICAgICAgYWRkQmVhY2goc2l0ZSk7XG4gICAgICAgIHggPSBzaXRlWzBdLCB5ID0gc2l0ZVsxXTtcbiAgICAgIH1cbiAgICAgIHNpdGUgPSBzaXRlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKGNpcmNsZSkge1xuICAgICAgcmVtb3ZlQmVhY2goY2lyY2xlLmFyYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHNvcnRDZWxsSGFsZmVkZ2VzKCk7XG5cbiAgaWYgKGV4dGVudCkge1xuICAgIHZhciB4MCA9ICtleHRlbnRbMF1bMF0sXG4gICAgICAgIHkwID0gK2V4dGVudFswXVsxXSxcbiAgICAgICAgeDEgPSArZXh0ZW50WzFdWzBdLFxuICAgICAgICB5MSA9ICtleHRlbnRbMV1bMV07XG4gICAgY2xpcEVkZ2VzKHgwLCB5MCwgeDEsIHkxKTtcbiAgICBjbGlwQ2VsbHMoeDAsIHkwLCB4MSwgeTEpO1xuICB9XG5cbiAgdGhpcy5lZGdlcyA9IGVkZ2VzO1xuICB0aGlzLmNlbGxzID0gY2VsbHM7XG5cbiAgYmVhY2hlcyA9XG4gIGNpcmNsZXMgPVxuICBlZGdlcyA9XG4gIGNlbGxzID0gbnVsbDtcbn1cblxuRGlhZ3JhbS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaWFncmFtLFxuXG4gIHBvbHlnb25zOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzO1xuXG4gICAgcmV0dXJuIHRoaXMuY2VsbHMubWFwKGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgIHZhciBwb2x5Z29uID0gY2VsbC5oYWxmZWRnZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGNlbGxIYWxmZWRnZVN0YXJ0KGNlbGwsIGVkZ2VzW2ldKTsgfSk7XG4gICAgICBwb2x5Z29uLmRhdGEgPSBjZWxsLnNpdGUuZGF0YTtcbiAgICAgIHJldHVybiBwb2x5Z29uO1xuICAgIH0pO1xuICB9LFxuXG4gIHRyaWFuZ2xlczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyaWFuZ2xlcyA9IFtdLFxuICAgICAgICBlZGdlcyA9IHRoaXMuZWRnZXM7XG5cbiAgICB0aGlzLmNlbGxzLmZvckVhY2goZnVuY3Rpb24oY2VsbCwgaSkge1xuICAgICAgaWYgKCEobSA9IChoYWxmZWRnZXMgPSBjZWxsLmhhbGZlZGdlcykubGVuZ3RoKSkgcmV0dXJuO1xuICAgICAgdmFyIHNpdGUgPSBjZWxsLnNpdGUsXG4gICAgICAgICAgaGFsZmVkZ2VzLFxuICAgICAgICAgIGogPSAtMSxcbiAgICAgICAgICBtLFxuICAgICAgICAgIHMwLFxuICAgICAgICAgIGUxID0gZWRnZXNbaGFsZmVkZ2VzW20gLSAxXV0sXG4gICAgICAgICAgczEgPSBlMS5sZWZ0ID09PSBzaXRlID8gZTEucmlnaHQgOiBlMS5sZWZ0O1xuXG4gICAgICB3aGlsZSAoKytqIDwgbSkge1xuICAgICAgICBzMCA9IHMxO1xuICAgICAgICBlMSA9IGVkZ2VzW2hhbGZlZGdlc1tqXV07XG4gICAgICAgIHMxID0gZTEubGVmdCA9PT0gc2l0ZSA/IGUxLnJpZ2h0IDogZTEubGVmdDtcbiAgICAgICAgaWYgKHMwICYmIHMxICYmIGkgPCBzMC5pbmRleCAmJiBpIDwgczEuaW5kZXggJiYgdHJpYW5nbGVBcmVhKHNpdGUsIHMwLCBzMSkgPCAwKSB7XG4gICAgICAgICAgdHJpYW5nbGVzLnB1c2goW3NpdGUuZGF0YSwgczAuZGF0YSwgczEuZGF0YV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xuICB9LFxuXG4gIGxpbmtzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGdlcy5maWx0ZXIoZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UucmlnaHQ7XG4gICAgfSkubWFwKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogZWRnZS5sZWZ0LmRhdGEsXG4gICAgICAgIHRhcmdldDogZWRnZS5yaWdodC5kYXRhXG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICAgIHZhciB0aGF0ID0gdGhpcywgaTAsIGkxID0gdGhhdC5fZm91bmQgfHwgMCwgbiA9IHRoYXQuY2VsbHMubGVuZ3RoLCBjZWxsO1xuXG4gICAgLy8gVXNlIHRoZSBwcmV2aW91c2x5LWZvdW5kIGNlbGwsIG9yIHN0YXJ0IHdpdGggYW4gYXJiaXRyYXJ5IG9uZS5cbiAgICB3aGlsZSAoIShjZWxsID0gdGhhdC5jZWxsc1tpMV0pKSBpZiAoKytpMSA+PSBuKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgZHggPSB4IC0gY2VsbC5zaXRlWzBdLCBkeSA9IHkgLSBjZWxsLnNpdGVbMV0sIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgaGFsZi1lZGdlcyB0byBmaW5kIGEgY2xvc2VyIGNlbGwsIGlmIGFueS5cbiAgICBkbyB7XG4gICAgICBjZWxsID0gdGhhdC5jZWxsc1tpMCA9IGkxXSwgaTEgPSBudWxsO1xuICAgICAgY2VsbC5oYWxmZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBlZGdlID0gdGhhdC5lZGdlc1tlXSwgdiA9IGVkZ2UubGVmdDtcbiAgICAgICAgaWYgKCh2ID09PSBjZWxsLnNpdGUgfHwgIXYpICYmICEodiA9IGVkZ2UucmlnaHQpKSByZXR1cm47XG4gICAgICAgIHZhciB2eCA9IHggLSB2WzBdLCB2eSA9IHkgLSB2WzFdLCB2MiA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuICAgICAgICBpZiAodjIgPCBkMikgZDIgPSB2MiwgaTEgPSB2LmluZGV4O1xuICAgICAgfSk7XG4gICAgfSB3aGlsZSAoaTEgIT09IG51bGwpO1xuXG4gICAgdGhhdC5fZm91bmQgPSBpMDtcblxuICAgIHJldHVybiByYWRpdXMgPT0gbnVsbCB8fCBkMiA8PSByYWRpdXMgKiByYWRpdXMgPyBjZWxsLnNpdGUgOiBudWxsO1xuICB9XG59O1xuXG52YXIgdm9yb25vaSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgeCQkMSA9IHgsXG4gICAgICB5JCQxID0geSxcbiAgICAgIGV4dGVudCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gdm9yb25vaShkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBEaWFncmFtKGRhdGEubWFwKGZ1bmN0aW9uKGQsIGkpIHtcbiAgICAgIHZhciBzID0gW01hdGgucm91bmQoeCQkMShkLCBpLCBkYXRhKSAvIGVwc2lsb24pICogZXBzaWxvbiwgTWF0aC5yb3VuZCh5JCQxKGQsIGksIGRhdGEpIC8gZXBzaWxvbikgKiBlcHNpbG9uXTtcbiAgICAgIHMuaW5kZXggPSBpO1xuICAgICAgcy5kYXRhID0gZDtcbiAgICAgIHJldHVybiBzO1xuICAgIH0pLCBleHRlbnQpO1xuICB9XG5cbiAgdm9yb25vaS5wb2x5Z29ucyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdm9yb25vaShkYXRhKS5wb2x5Z29ucygpO1xuICB9O1xuXG4gIHZvcm9ub2kubGlua3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgcmV0dXJuIHZvcm9ub2koZGF0YSkubGlua3MoKTtcbiAgfTtcblxuICB2b3Jvbm9pLnRyaWFuZ2xlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdm9yb25vaShkYXRhKS50cmlhbmdsZXMoKTtcbiAgfTtcblxuICB2b3Jvbm9pLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCQkMSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCB2b3Jvbm9pKSA6IHgkJDE7XG4gIH07XG5cbiAgdm9yb25vaS55ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHkkJDEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgdm9yb25vaSkgOiB5JCQxO1xuICB9O1xuXG4gIHZvcm9ub2kuZXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGV4dGVudCA9IF8gPT0gbnVsbCA/IG51bGwgOiBbWytfWzBdWzBdLCArX1swXVsxXV0sIFsrX1sxXVswXSwgK19bMV1bMV1dXSwgdm9yb25vaSkgOiBleHRlbnQgJiYgW1tleHRlbnRbMF1bMF0sIGV4dGVudFswXVsxXV0sIFtleHRlbnRbMV1bMF0sIGV4dGVudFsxXVsxXV1dO1xuICB9O1xuXG4gIHZvcm9ub2kuc2l6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSBfID09IG51bGwgPyBudWxsIDogW1swLCAwXSwgWytfWzBdLCArX1sxXV1dLCB2b3Jvbm9pKSA6IGV4dGVudCAmJiBbZXh0ZW50WzFdWzBdIC0gZXh0ZW50WzBdWzBdLCBleHRlbnRbMV1bMV0gLSBleHRlbnRbMF1bMV1dO1xuICB9O1xuXG4gIHJldHVybiB2b3Jvbm9pO1xufTtcblxuZXhwb3J0cy52b3Jvbm9pID0gdm9yb25vaTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtem9vbS8gVmVyc2lvbiAxLjcuMS4gQ29weXJpZ2h0IDIwMTcgTWlrZSBCb3N0b2NrLlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdkMy1kaXNwYXRjaCcpLCByZXF1aXJlKCdkMy1kcmFnJyksIHJlcXVpcmUoJ2QzLWludGVycG9sYXRlJyksIHJlcXVpcmUoJ2QzLXNlbGVjdGlvbicpLCByZXF1aXJlKCdkMy10cmFuc2l0aW9uJykpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdkMy1kaXNwYXRjaCcsICdkMy1kcmFnJywgJ2QzLWludGVycG9sYXRlJywgJ2QzLXNlbGVjdGlvbicsICdkMy10cmFuc2l0aW9uJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5kMyA9IGdsb2JhbC5kMyB8fCB7fSksZ2xvYmFsLmQzLGdsb2JhbC5kMyxnbG9iYWwuZDMsZ2xvYmFsLmQzLGdsb2JhbC5kMykpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMsZDNEaXNwYXRjaCxkM0RyYWcsZDNJbnRlcnBvbGF0ZSxkM1NlbGVjdGlvbixkM1RyYW5zaXRpb24pIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RhbnQgPSBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIFpvb21FdmVudCh0YXJnZXQsIHR5cGUsIHRyYW5zZm9ybSkge1xuICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShrLCB4LCB5KSB7XG4gIHRoaXMuayA9IGs7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBUcmFuc2Zvcm0sXG4gIHNjYWxlOiBmdW5jdGlvbihrKSB7XG4gICAgcmV0dXJuIGsgPT09IDEgPyB0aGlzIDogbmV3IFRyYW5zZm9ybSh0aGlzLmsgKiBrLCB0aGlzLngsIHRoaXMueSk7XG4gIH0sXG4gIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB4ID09PSAwICYgeSA9PT0gMCA/IHRoaXMgOiBuZXcgVHJhbnNmb3JtKHRoaXMuaywgdGhpcy54ICsgdGhpcy5rICogeCwgdGhpcy55ICsgdGhpcy5rICogeSk7XG4gIH0sXG4gIGFwcGx5OiBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBbcG9pbnRbMF0gKiB0aGlzLmsgKyB0aGlzLngsIHBvaW50WzFdICogdGhpcy5rICsgdGhpcy55XTtcbiAgfSxcbiAgYXBwbHlYOiBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHggKiB0aGlzLmsgKyB0aGlzLng7XG4gIH0sXG4gIGFwcGx5WTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5ICogdGhpcy5rICsgdGhpcy55O1xuICB9LFxuICBpbnZlcnQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIFsobG9jYXRpb25bMF0gLSB0aGlzLngpIC8gdGhpcy5rLCAobG9jYXRpb25bMV0gLSB0aGlzLnkpIC8gdGhpcy5rXTtcbiAgfSxcbiAgaW52ZXJ0WDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiAoeCAtIHRoaXMueCkgLyB0aGlzLms7XG4gIH0sXG4gIGludmVydFk6IGZ1bmN0aW9uKHkpIHtcbiAgICByZXR1cm4gKHkgLSB0aGlzLnkpIC8gdGhpcy5rO1xuICB9LFxuICByZXNjYWxlWDogZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4LmNvcHkoKS5kb21haW4oeC5yYW5nZSgpLm1hcCh0aGlzLmludmVydFgsIHRoaXMpLm1hcCh4LmludmVydCwgeCkpO1xuICB9LFxuICByZXNjYWxlWTogZnVuY3Rpb24oeSkge1xuICAgIHJldHVybiB5LmNvcHkoKS5kb21haW4oeS5yYW5nZSgpLm1hcCh0aGlzLmludmVydFksIHRoaXMpLm1hcCh5LmludmVydCwgeSkpO1xuICB9LFxuICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIikgc2NhbGUoXCIgKyB0aGlzLmsgKyBcIilcIjtcbiAgfVxufTtcblxudmFyIGlkZW50aXR5ID0gbmV3IFRyYW5zZm9ybSgxLCAwLCAwKTtcblxudHJhbnNmb3JtLnByb3RvdHlwZSA9IFRyYW5zZm9ybS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybShub2RlKSB7XG4gIHJldHVybiBub2RlLl9fem9vbSB8fCBpZGVudGl0eTtcbn1cblxuZnVuY3Rpb24gbm9wcm9wYWdhdGlvbigpIHtcbiAgZDNTZWxlY3Rpb24uZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbnZhciBub2V2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGQzU2VsZWN0aW9uLmV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xufTtcblxuLy8gSWdub3JlIHJpZ2h0LWNsaWNrLCBzaW5jZSB0aGF0IHNob3VsZCBvcGVuIHRoZSBjb250ZXh0IG1lbnUuXG5mdW5jdGlvbiBkZWZhdWx0RmlsdGVyKCkge1xuICByZXR1cm4gIWQzU2VsZWN0aW9uLmV2ZW50LmJ1dHRvbjtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEV4dGVudCgpIHtcbiAgdmFyIGUgPSB0aGlzLCB3LCBoO1xuICBpZiAoZSBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpIHtcbiAgICBlID0gZS5vd25lclNWR0VsZW1lbnQgfHwgZTtcbiAgICB3ID0gZS53aWR0aC5iYXNlVmFsLnZhbHVlO1xuICAgIGggPSBlLmhlaWdodC5iYXNlVmFsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHcgPSBlLmNsaWVudFdpZHRoO1xuICAgIGggPSBlLmNsaWVudEhlaWdodDtcbiAgfVxuICByZXR1cm4gW1swLCAwXSwgW3csIGhdXTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSgpIHtcbiAgcmV0dXJuIHRoaXMuX196b29tIHx8IGlkZW50aXR5O1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0V2hlZWxEZWx0YSgpIHtcbiAgcmV0dXJuIC1kM1NlbGVjdGlvbi5ldmVudC5kZWx0YVkgKiAoZDNTZWxlY3Rpb24uZXZlbnQuZGVsdGFNb2RlID8gMTIwIDogMSkgLyA1MDA7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRUb3VjaGFibGUoKSB7XG4gIHJldHVybiBcIm9udG91Y2hzdGFydFwiIGluIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDb25zdHJhaW4odHJhbnNmb3JtJCQxLCBleHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkge1xuICB2YXIgZHgwID0gdHJhbnNmb3JtJCQxLmludmVydFgoZXh0ZW50WzBdWzBdKSAtIHRyYW5zbGF0ZUV4dGVudFswXVswXSxcbiAgICAgIGR4MSA9IHRyYW5zZm9ybSQkMS5pbnZlcnRYKGV4dGVudFsxXVswXSkgLSB0cmFuc2xhdGVFeHRlbnRbMV1bMF0sXG4gICAgICBkeTAgPSB0cmFuc2Zvcm0kJDEuaW52ZXJ0WShleHRlbnRbMF1bMV0pIC0gdHJhbnNsYXRlRXh0ZW50WzBdWzFdLFxuICAgICAgZHkxID0gdHJhbnNmb3JtJCQxLmludmVydFkoZXh0ZW50WzFdWzFdKSAtIHRyYW5zbGF0ZUV4dGVudFsxXVsxXTtcbiAgcmV0dXJuIHRyYW5zZm9ybSQkMS50cmFuc2xhdGUoXG4gICAgZHgxID4gZHgwID8gKGR4MCArIGR4MSkgLyAyIDogTWF0aC5taW4oMCwgZHgwKSB8fCBNYXRoLm1heCgwLCBkeDEpLFxuICAgIGR5MSA+IGR5MCA/IChkeTAgKyBkeTEpIC8gMiA6IE1hdGgubWluKDAsIGR5MCkgfHwgTWF0aC5tYXgoMCwgZHkxKVxuICApO1xufVxuXG52YXIgem9vbSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZmlsdGVyID0gZGVmYXVsdEZpbHRlcixcbiAgICAgIGV4dGVudCA9IGRlZmF1bHRFeHRlbnQsXG4gICAgICBjb25zdHJhaW4gPSBkZWZhdWx0Q29uc3RyYWluLFxuICAgICAgd2hlZWxEZWx0YSA9IGRlZmF1bHRXaGVlbERlbHRhLFxuICAgICAgdG91Y2hhYmxlID0gZGVmYXVsdFRvdWNoYWJsZSxcbiAgICAgIHNjYWxlRXh0ZW50ID0gWzAsIEluZmluaXR5XSxcbiAgICAgIHRyYW5zbGF0ZUV4dGVudCA9IFtbLUluZmluaXR5LCAtSW5maW5pdHldLCBbSW5maW5pdHksIEluZmluaXR5XV0sXG4gICAgICBkdXJhdGlvbiA9IDI1MCxcbiAgICAgIGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZS5pbnRlcnBvbGF0ZVpvb20sXG4gICAgICBnZXN0dXJlcyA9IFtdLFxuICAgICAgbGlzdGVuZXJzID0gZDNEaXNwYXRjaC5kaXNwYXRjaChcInN0YXJ0XCIsIFwiem9vbVwiLCBcImVuZFwiKSxcbiAgICAgIHRvdWNoc3RhcnRpbmcsXG4gICAgICB0b3VjaGVuZGluZyxcbiAgICAgIHRvdWNoRGVsYXkgPSA1MDAsXG4gICAgICB3aGVlbERlbGF5ID0gMTUwLFxuICAgICAgY2xpY2tEaXN0YW5jZTIgPSAwO1xuXG4gIGZ1bmN0aW9uIHpvb20oc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uXG4gICAgICAgIC5wcm9wZXJ0eShcIl9fem9vbVwiLCBkZWZhdWx0VHJhbnNmb3JtKVxuICAgICAgICAub24oXCJ3aGVlbC56b29tXCIsIHdoZWVsZWQpXG4gICAgICAgIC5vbihcIm1vdXNlZG93bi56b29tXCIsIG1vdXNlZG93bmVkKVxuICAgICAgICAub24oXCJkYmxjbGljay56b29tXCIsIGRibGNsaWNrZWQpXG4gICAgICAuZmlsdGVyKHRvdWNoYWJsZSlcbiAgICAgICAgLm9uKFwidG91Y2hzdGFydC56b29tXCIsIHRvdWNoc3RhcnRlZClcbiAgICAgICAgLm9uKFwidG91Y2htb3ZlLnpvb21cIiwgdG91Y2htb3ZlZClcbiAgICAgICAgLm9uKFwidG91Y2hlbmQuem9vbSB0b3VjaGNhbmNlbC56b29tXCIsIHRvdWNoZW5kZWQpXG4gICAgICAgIC5zdHlsZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIilcbiAgICAgICAgLnN0eWxlKFwiLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yXCIsIFwicmdiYSgwLDAsMCwwKVwiKTtcbiAgfVxuXG4gIHpvb20udHJhbnNmb3JtID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgdHJhbnNmb3JtJCQxKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGNvbGxlY3Rpb24uc2VsZWN0aW9uID8gY29sbGVjdGlvbi5zZWxlY3Rpb24oKSA6IGNvbGxlY3Rpb247XG4gICAgc2VsZWN0aW9uLnByb3BlcnR5KFwiX196b29tXCIsIGRlZmF1bHRUcmFuc2Zvcm0pO1xuICAgIGlmIChjb2xsZWN0aW9uICE9PSBzZWxlY3Rpb24pIHtcbiAgICAgIHNjaGVkdWxlKGNvbGxlY3Rpb24sIHRyYW5zZm9ybSQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGlvbi5pbnRlcnJ1cHQoKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIC5zdGFydCgpXG4gICAgICAgICAgICAuem9vbShudWxsLCB0eXBlb2YgdHJhbnNmb3JtJCQxID09PSBcImZ1bmN0aW9uXCIgPyB0cmFuc2Zvcm0kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRyYW5zZm9ybSQkMSlcbiAgICAgICAgICAgIC5lbmQoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB6b29tLnNjYWxlQnkgPSBmdW5jdGlvbihzZWxlY3Rpb24sIGspIHtcbiAgICB6b29tLnNjYWxlVG8oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBrMCA9IHRoaXMuX196b29tLmssXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBrMCAqIGsxO1xuICAgIH0pO1xuICB9O1xuXG4gIHpvb20uc2NhbGVUbyA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgaykge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZSA9IGV4dGVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgICAgcDAgPSBjZW50cm9pZChlKSxcbiAgICAgICAgICBwMSA9IHQwLmludmVydChwMCksXG4gICAgICAgICAgazEgPSB0eXBlb2YgayA9PT0gXCJmdW5jdGlvblwiID8gay5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogaztcbiAgICAgIHJldHVybiBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQwLCBrMSksIHAwLCBwMSksIGUsIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgfSk7XG4gIH07XG5cbiAgem9vbS50cmFuc2xhdGVCeSA9IGZ1bmN0aW9uKHNlbGVjdGlvbiwgeCwgeSkge1xuICAgIHpvb20udHJhbnNmb3JtKHNlbGVjdGlvbiwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWluKHRoaXMuX196b29tLnRyYW5zbGF0ZShcbiAgICAgICAgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIiA/IHguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHgsXG4gICAgICAgIHR5cGVvZiB5ID09PSBcImZ1bmN0aW9uXCIgPyB5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB5XG4gICAgICApLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9KTtcbiAgfTtcblxuICB6b29tLnRyYW5zbGF0ZVRvID0gZnVuY3Rpb24oc2VsZWN0aW9uLCB4LCB5KSB7XG4gICAgem9vbS50cmFuc2Zvcm0oc2VsZWN0aW9uLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBlID0gZXh0ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICAgIHAgPSBjZW50cm9pZChlKTtcbiAgICAgIHJldHVybiBjb25zdHJhaW4oaWRlbnRpdHkudHJhbnNsYXRlKHBbMF0sIHBbMV0pLnNjYWxlKHQuaykudHJhbnNsYXRlKFxuICAgICAgICB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8gLXguYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC14LFxuICAgICAgICB0eXBlb2YgeSA9PT0gXCJmdW5jdGlvblwiID8gLXkuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IC15XG4gICAgICApLCBlLCB0cmFuc2xhdGVFeHRlbnQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNjYWxlKHRyYW5zZm9ybSQkMSwgaykge1xuICAgIGsgPSBNYXRoLm1heChzY2FsZUV4dGVudFswXSwgTWF0aC5taW4oc2NhbGVFeHRlbnRbMV0sIGspKTtcbiAgICByZXR1cm4gayA9PT0gdHJhbnNmb3JtJCQxLmsgPyB0cmFuc2Zvcm0kJDEgOiBuZXcgVHJhbnNmb3JtKGssIHRyYW5zZm9ybSQkMS54LCB0cmFuc2Zvcm0kJDEueSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2xhdGUodHJhbnNmb3JtJCQxLCBwMCwgcDEpIHtcbiAgICB2YXIgeCA9IHAwWzBdIC0gcDFbMF0gKiB0cmFuc2Zvcm0kJDEuaywgeSA9IHAwWzFdIC0gcDFbMV0gKiB0cmFuc2Zvcm0kJDEuaztcbiAgICByZXR1cm4geCA9PT0gdHJhbnNmb3JtJCQxLnggJiYgeSA9PT0gdHJhbnNmb3JtJCQxLnkgPyB0cmFuc2Zvcm0kJDEgOiBuZXcgVHJhbnNmb3JtKHRyYW5zZm9ybSQkMS5rLCB4LCB5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbnRyb2lkKGV4dGVudCkge1xuICAgIHJldHVybiBbKCtleHRlbnRbMF1bMF0gKyArZXh0ZW50WzFdWzBdKSAvIDIsICgrZXh0ZW50WzBdWzFdICsgK2V4dGVudFsxXVsxXSkgLyAyXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKHRyYW5zaXRpb24sIHRyYW5zZm9ybSQkMSwgY2VudGVyKSB7XG4gICAgdHJhbnNpdGlvblxuICAgICAgICAub24oXCJzdGFydC56b29tXCIsIGZ1bmN0aW9uKCkgeyBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cykuc3RhcnQoKTsgfSlcbiAgICAgICAgLm9uKFwiaW50ZXJydXB0Lnpvb20gZW5kLnpvb21cIiwgZnVuY3Rpb24oKSB7IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKS5lbmQoKTsgfSlcbiAgICAgICAgLnR3ZWVuKFwiem9vbVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgICAgIGcgPSBnZXN0dXJlKHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBlID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpLFxuICAgICAgICAgICAgICBwID0gY2VudGVyIHx8IGNlbnRyb2lkKGUpLFxuICAgICAgICAgICAgICB3ID0gTWF0aC5tYXgoZVsxXVswXSAtIGVbMF1bMF0sIGVbMV1bMV0gLSBlWzBdWzFdKSxcbiAgICAgICAgICAgICAgYSA9IHRoYXQuX196b29tLFxuICAgICAgICAgICAgICBiID0gdHlwZW9mIHRyYW5zZm9ybSQkMSA9PT0gXCJmdW5jdGlvblwiID8gdHJhbnNmb3JtJCQxLmFwcGx5KHRoYXQsIGFyZ3MpIDogdHJhbnNmb3JtJCQxLFxuICAgICAgICAgICAgICBpID0gaW50ZXJwb2xhdGUoYS5pbnZlcnQocCkuY29uY2F0KHcgLyBhLmspLCBiLmludmVydChwKS5jb25jYXQodyAvIGIuaykpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih0KSB7XG4gICAgICAgICAgICBpZiAodCA9PT0gMSkgdCA9IGI7IC8vIEF2b2lkIHJvdW5kaW5nIGVycm9yIG9uIGVuZC5cbiAgICAgICAgICAgIGVsc2UgeyB2YXIgbCA9IGkodCksIGsgPSB3IC8gbFsyXTsgdCA9IG5ldyBUcmFuc2Zvcm0oaywgcFswXSAtIGxbMF0gKiBrLCBwWzFdIC0gbFsxXSAqIGspOyB9XG4gICAgICAgICAgICBnLnpvb20obnVsbCwgdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXN0dXJlKHRoYXQsIGFyZ3MpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGdlc3R1cmVzLmxlbmd0aCwgZzsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKChnID0gZ2VzdHVyZXNbaV0pLnRoYXQgPT09IHRoYXQpIHtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgR2VzdHVyZSh0aGF0LCBhcmdzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEdlc3R1cmUodGhhdCwgYXJncykge1xuICAgIHRoaXMudGhhdCA9IHRoYXQ7XG4gICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgdGhpcy5hY3RpdmUgPSAwO1xuICAgIHRoaXMuZXh0ZW50ID0gZXh0ZW50LmFwcGx5KHRoYXQsIGFyZ3MpO1xuICB9XG5cbiAgR2VzdHVyZS5wcm90b3R5cGUgPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCsrdGhpcy5hY3RpdmUgPT09IDEpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGdlc3R1cmVzLnB1c2godGhpcykgLSAxO1xuICAgICAgICB0aGlzLmVtaXQoXCJzdGFydFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgem9vbTogZnVuY3Rpb24oa2V5LCB0cmFuc2Zvcm0kJDEpIHtcbiAgICAgIGlmICh0aGlzLm1vdXNlICYmIGtleSAhPT0gXCJtb3VzZVwiKSB0aGlzLm1vdXNlWzFdID0gdHJhbnNmb3JtJCQxLmludmVydCh0aGlzLm1vdXNlWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMCAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDBbMV0gPSB0cmFuc2Zvcm0kJDEuaW52ZXJ0KHRoaXMudG91Y2gwWzBdKTtcbiAgICAgIGlmICh0aGlzLnRvdWNoMSAmJiBrZXkgIT09IFwidG91Y2hcIikgdGhpcy50b3VjaDFbMV0gPSB0cmFuc2Zvcm0kJDEuaW52ZXJ0KHRoaXMudG91Y2gxWzBdKTtcbiAgICAgIHRoaXMudGhhdC5fX3pvb20gPSB0cmFuc2Zvcm0kJDE7XG4gICAgICB0aGlzLmVtaXQoXCJ6b29tXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGhpcy5hY3RpdmUgPT09IDApIHtcbiAgICAgICAgZ2VzdHVyZXMuc3BsaWNlKHRoaXMuaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZW1pdDogZnVuY3Rpb24odHlwZSkge1xuICAgICAgZDNTZWxlY3Rpb24uY3VzdG9tRXZlbnQobmV3IFpvb21FdmVudCh6b29tLCB0eXBlLCB0aGlzLnRoYXQuX196b29tKSwgbGlzdGVuZXJzLmFwcGx5LCBsaXN0ZW5lcnMsIFt0eXBlLCB0aGlzLnRoYXQsIHRoaXMuYXJnc10pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB3aGVlbGVkKCkge1xuICAgIGlmICghZmlsdGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHJldHVybjtcbiAgICB2YXIgZyA9IGdlc3R1cmUodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgdCA9IHRoaXMuX196b29tLFxuICAgICAgICBrID0gTWF0aC5tYXgoc2NhbGVFeHRlbnRbMF0sIE1hdGgubWluKHNjYWxlRXh0ZW50WzFdLCB0LmsgKiBNYXRoLnBvdygyLCB3aGVlbERlbHRhLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpKSksXG4gICAgICAgIHAgPSBkM1NlbGVjdGlvbi5tb3VzZSh0aGlzKTtcblxuICAgIC8vIElmIHRoZSBtb3VzZSBpcyBpbiB0aGUgc2FtZSBsb2NhdGlvbiBhcyBiZWZvcmUsIHJldXNlIGl0LlxuICAgIC8vIElmIHRoZXJlIHdlcmUgcmVjZW50IHdoZWVsIGV2ZW50cywgcmVzZXQgdGhlIHdoZWVsIGlkbGUgdGltZW91dC5cbiAgICBpZiAoZy53aGVlbCkge1xuICAgICAgaWYgKGcubW91c2VbMF1bMF0gIT09IHBbMF0gfHwgZy5tb3VzZVswXVsxXSAhPT0gcFsxXSkge1xuICAgICAgICBnLm1vdXNlWzFdID0gdC5pbnZlcnQoZy5tb3VzZVswXSA9IHApO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KGcud2hlZWwpO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgd2hlZWwgZXZlbnQgd29u4oCZdCB0cmlnZ2VyIGEgdHJhbnNmb3JtIGNoYW5nZSwgaWdub3JlIGl0LlxuICAgIGVsc2UgaWYgKHQuayA9PT0gaykgcmV0dXJuO1xuXG4gICAgLy8gT3RoZXJ3aXNlLCBjYXB0dXJlIHRoZSBtb3VzZSBwb2ludCBhbmQgbG9jYXRpb24gYXQgdGhlIHN0YXJ0LlxuICAgIGVsc2Uge1xuICAgICAgZy5tb3VzZSA9IFtwLCB0LmludmVydChwKV07XG4gICAgICBkM1RyYW5zaXRpb24uaW50ZXJydXB0KHRoaXMpO1xuICAgICAgZy5zdGFydCgpO1xuICAgIH1cblxuICAgIG5vZXZlbnQoKTtcbiAgICBnLndoZWVsID0gc2V0VGltZW91dCh3aGVlbGlkbGVkLCB3aGVlbERlbGF5KTtcbiAgICBnLnpvb20oXCJtb3VzZVwiLCBjb25zdHJhaW4odHJhbnNsYXRlKHNjYWxlKHQsIGspLCBnLm1vdXNlWzBdLCBnLm1vdXNlWzFdKSwgZy5leHRlbnQsIHRyYW5zbGF0ZUV4dGVudCkpO1xuXG4gICAgZnVuY3Rpb24gd2hlZWxpZGxlZCgpIHtcbiAgICAgIGcud2hlZWwgPSBudWxsO1xuICAgICAgZy5lbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VzZWRvd25lZCgpIHtcbiAgICBpZiAodG91Y2hlbmRpbmcgfHwgIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHYgPSBkM1NlbGVjdGlvbi5zZWxlY3QoZDNTZWxlY3Rpb24uZXZlbnQudmlldykub24oXCJtb3VzZW1vdmUuem9vbVwiLCBtb3VzZW1vdmVkLCB0cnVlKS5vbihcIm1vdXNldXAuem9vbVwiLCBtb3VzZXVwcGVkLCB0cnVlKSxcbiAgICAgICAgcCA9IGQzU2VsZWN0aW9uLm1vdXNlKHRoaXMpLFxuICAgICAgICB4MCA9IGQzU2VsZWN0aW9uLmV2ZW50LmNsaWVudFgsXG4gICAgICAgIHkwID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WTtcblxuICAgIGQzRHJhZy5kcmFnRGlzYWJsZShkM1NlbGVjdGlvbi5ldmVudC52aWV3KTtcbiAgICBub3Byb3BhZ2F0aW9uKCk7XG4gICAgZy5tb3VzZSA9IFtwLCB0aGlzLl9fem9vbS5pbnZlcnQocCldO1xuICAgIGQzVHJhbnNpdGlvbi5pbnRlcnJ1cHQodGhpcyk7XG4gICAgZy5zdGFydCgpO1xuXG4gICAgZnVuY3Rpb24gbW91c2Vtb3ZlZCgpIHtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIGlmICghZy5tb3ZlZCkge1xuICAgICAgICB2YXIgZHggPSBkM1NlbGVjdGlvbi5ldmVudC5jbGllbnRYIC0geDAsIGR5ID0gZDNTZWxlY3Rpb24uZXZlbnQuY2xpZW50WSAtIHkwO1xuICAgICAgICBnLm1vdmVkID0gZHggKiBkeCArIGR5ICogZHkgPiBjbGlja0Rpc3RhbmNlMjtcbiAgICAgIH1cbiAgICAgIGcuem9vbShcIm1vdXNlXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUoZy50aGF0Ll9fem9vbSwgZy5tb3VzZVswXSA9IGQzU2VsZWN0aW9uLm1vdXNlKGcudGhhdCksIGcubW91c2VbMV0pLCBnLmV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2V1cHBlZCgpIHtcbiAgICAgIHYub24oXCJtb3VzZW1vdmUuem9vbSBtb3VzZXVwLnpvb21cIiwgbnVsbCk7XG4gICAgICBkM0RyYWcuZHJhZ0VuYWJsZShkM1NlbGVjdGlvbi5ldmVudC52aWV3LCBnLm1vdmVkKTtcbiAgICAgIG5vZXZlbnQoKTtcbiAgICAgIGcuZW5kKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGJsY2xpY2tlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIHQwID0gdGhpcy5fX3pvb20sXG4gICAgICAgIHAwID0gZDNTZWxlY3Rpb24ubW91c2UodGhpcyksXG4gICAgICAgIHAxID0gdDAuaW52ZXJ0KHAwKSxcbiAgICAgICAgazEgPSB0MC5rICogKGQzU2VsZWN0aW9uLmV2ZW50LnNoaWZ0S2V5ID8gMC41IDogMiksXG4gICAgICAgIHQxID0gY29uc3RyYWluKHRyYW5zbGF0ZShzY2FsZSh0MCwgazEpLCBwMCwgcDEpLCBleHRlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdHJhbnNsYXRlRXh0ZW50KTtcblxuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAoZHVyYXRpb24gPiAwKSBkM1NlbGVjdGlvbi5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5jYWxsKHNjaGVkdWxlLCB0MSwgcDApO1xuICAgIGVsc2UgZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLmNhbGwoem9vbS50cmFuc2Zvcm0sIHQxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoc3RhcnRlZCgpIHtcbiAgICBpZiAoIWZpbHRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpKSByZXR1cm47XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgc3RhcnRlZCxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0LCBwO1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHQgPSB0b3VjaGVzW2ldLCBwID0gZDNTZWxlY3Rpb24udG91Y2godGhpcywgdG91Y2hlcywgdC5pZGVudGlmaWVyKTtcbiAgICAgIHAgPSBbcCwgdGhpcy5fX3pvb20uaW52ZXJ0KHApLCB0LmlkZW50aWZpZXJdO1xuICAgICAgaWYgKCFnLnRvdWNoMCkgZy50b3VjaDAgPSBwLCBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGVsc2UgaWYgKCFnLnRvdWNoMSkgZy50b3VjaDEgPSBwO1xuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSBkYmx0YXAsIHJlcm91dGUgdG8gdGhlIChvcHRpb25hbCkgZGJsY2xpY2suem9vbSBoYW5kbGVyLlxuICAgIGlmICh0b3VjaHN0YXJ0aW5nKSB7XG4gICAgICB0b3VjaHN0YXJ0aW5nID0gY2xlYXJUaW1lb3V0KHRvdWNoc3RhcnRpbmcpO1xuICAgICAgaWYgKCFnLnRvdWNoMSkge1xuICAgICAgICBnLmVuZCgpO1xuICAgICAgICBwID0gZDNTZWxlY3Rpb24uc2VsZWN0KHRoaXMpLm9uKFwiZGJsY2xpY2suem9vbVwiKTtcbiAgICAgICAgaWYgKHApIHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGFydGVkKSB7XG4gICAgICB0b3VjaHN0YXJ0aW5nID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgdG91Y2hzdGFydGluZyA9IG51bGw7IH0sIHRvdWNoRGVsYXkpO1xuICAgICAgZDNUcmFuc2l0aW9uLmludGVycnVwdCh0aGlzKTtcbiAgICAgIGcuc3RhcnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0b3VjaG1vdmVkKCkge1xuICAgIHZhciBnID0gZ2VzdHVyZSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB0b3VjaGVzID0gZDNTZWxlY3Rpb24uZXZlbnQuY2hhbmdlZFRvdWNoZXMsXG4gICAgICAgIG4gPSB0b3VjaGVzLmxlbmd0aCwgaSwgdCwgcCwgbDtcblxuICAgIG5vZXZlbnQoKTtcbiAgICBpZiAodG91Y2hzdGFydGluZykgdG91Y2hzdGFydGluZyA9IGNsZWFyVGltZW91dCh0b3VjaHN0YXJ0aW5nKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gdG91Y2hlc1tpXSwgcCA9IGQzU2VsZWN0aW9uLnRvdWNoKHRoaXMsIHRvdWNoZXMsIHQuaWRlbnRpZmllcik7XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDBbMF0gPSBwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZy50b3VjaDFbMF0gPSBwO1xuICAgIH1cbiAgICB0ID0gZy50aGF0Ll9fem9vbTtcbiAgICBpZiAoZy50b3VjaDEpIHtcbiAgICAgIHZhciBwMCA9IGcudG91Y2gwWzBdLCBsMCA9IGcudG91Y2gwWzFdLFxuICAgICAgICAgIHAxID0gZy50b3VjaDFbMF0sIGwxID0gZy50b3VjaDFbMV0sXG4gICAgICAgICAgZHAgPSAoZHAgPSBwMVswXSAtIHAwWzBdKSAqIGRwICsgKGRwID0gcDFbMV0gLSBwMFsxXSkgKiBkcCxcbiAgICAgICAgICBkbCA9IChkbCA9IGwxWzBdIC0gbDBbMF0pICogZGwgKyAoZGwgPSBsMVsxXSAtIGwwWzFdKSAqIGRsO1xuICAgICAgdCA9IHNjYWxlKHQsIE1hdGguc3FydChkcCAvIGRsKSk7XG4gICAgICBwID0gWyhwMFswXSArIHAxWzBdKSAvIDIsIChwMFsxXSArIHAxWzFdKSAvIDJdO1xuICAgICAgbCA9IFsobDBbMF0gKyBsMVswXSkgLyAyLCAobDBbMV0gKyBsMVsxXSkgLyAyXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZy50b3VjaDApIHAgPSBnLnRvdWNoMFswXSwgbCA9IGcudG91Y2gwWzFdO1xuICAgIGVsc2UgcmV0dXJuO1xuICAgIGcuem9vbShcInRvdWNoXCIsIGNvbnN0cmFpbih0cmFuc2xhdGUodCwgcCwgbCksIGcuZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvdWNoZW5kZWQoKSB7XG4gICAgdmFyIGcgPSBnZXN0dXJlKHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHRvdWNoZXMgPSBkM1NlbGVjdGlvbi5ldmVudC5jaGFuZ2VkVG91Y2hlcyxcbiAgICAgICAgbiA9IHRvdWNoZXMubGVuZ3RoLCBpLCB0O1xuXG4gICAgbm9wcm9wYWdhdGlvbigpO1xuICAgIGlmICh0b3VjaGVuZGluZykgY2xlYXJUaW1lb3V0KHRvdWNoZW5kaW5nKTtcbiAgICB0b3VjaGVuZGluZyA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRvdWNoZW5kaW5nID0gbnVsbDsgfSwgdG91Y2hEZWxheSk7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IHRvdWNoZXNbaV07XG4gICAgICBpZiAoZy50b3VjaDAgJiYgZy50b3VjaDBbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gwO1xuICAgICAgZWxzZSBpZiAoZy50b3VjaDEgJiYgZy50b3VjaDFbMl0gPT09IHQuaWRlbnRpZmllcikgZGVsZXRlIGcudG91Y2gxO1xuICAgIH1cbiAgICBpZiAoZy50b3VjaDEgJiYgIWcudG91Y2gwKSBnLnRvdWNoMCA9IGcudG91Y2gxLCBkZWxldGUgZy50b3VjaDE7XG4gICAgaWYgKGcudG91Y2gwKSBnLnRvdWNoMFsxXSA9IHRoaXMuX196b29tLmludmVydChnLnRvdWNoMFswXSk7XG4gICAgZWxzZSBnLmVuZCgpO1xuICB9XG5cbiAgem9vbS53aGVlbERlbHRhID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHdoZWVsRGVsdGEgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgem9vbSkgOiB3aGVlbERlbHRhO1xuICB9O1xuXG4gIHpvb20uZmlsdGVyID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGZpbHRlciA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoISFfKSwgem9vbSkgOiBmaWx0ZXI7XG4gIH07XG5cbiAgem9vbS50b3VjaGFibGUgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodG91Y2hhYmxlID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCghIV8pLCB6b29tKSA6IHRvdWNoYWJsZTtcbiAgfTtcblxuICB6b29tLmV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChleHRlbnQgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KFtbK19bMF1bMF0sICtfWzBdWzFdXSwgWytfWzFdWzBdLCArX1sxXVsxXV1dKSwgem9vbSkgOiBleHRlbnQ7XG4gIH07XG5cbiAgem9vbS5zY2FsZUV4dGVudCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzY2FsZUV4dGVudFswXSA9ICtfWzBdLCBzY2FsZUV4dGVudFsxXSA9ICtfWzFdLCB6b29tKSA6IFtzY2FsZUV4dGVudFswXSwgc2NhbGVFeHRlbnRbMV1dO1xuICB9O1xuXG4gIHpvb20udHJhbnNsYXRlRXh0ZW50ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRyYW5zbGF0ZUV4dGVudFswXVswXSA9ICtfWzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMF0gPSArX1sxXVswXSwgdHJhbnNsYXRlRXh0ZW50WzBdWzFdID0gK19bMF1bMV0sIHRyYW5zbGF0ZUV4dGVudFsxXVsxXSA9ICtfWzFdWzFdLCB6b29tKSA6IFtbdHJhbnNsYXRlRXh0ZW50WzBdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMF1bMV1dLCBbdHJhbnNsYXRlRXh0ZW50WzFdWzBdLCB0cmFuc2xhdGVFeHRlbnRbMV1bMV1dXTtcbiAgfTtcblxuICB6b29tLmNvbnN0cmFpbiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjb25zdHJhaW4gPSBfLCB6b29tKSA6IGNvbnN0cmFpbjtcbiAgfTtcblxuICB6b29tLmR1cmF0aW9uID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGR1cmF0aW9uID0gK18sIHpvb20pIDogZHVyYXRpb247XG4gIH07XG5cbiAgem9vbS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpbnRlcnBvbGF0ZSA9IF8sIHpvb20pIDogaW50ZXJwb2xhdGU7XG4gIH07XG5cbiAgem9vbS5vbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IGxpc3RlbmVycy5vbi5hcHBseShsaXN0ZW5lcnMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHZhbHVlID09PSBsaXN0ZW5lcnMgPyB6b29tIDogdmFsdWU7XG4gIH07XG5cbiAgem9vbS5jbGlja0Rpc3RhbmNlID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGNsaWNrRGlzdGFuY2UyID0gKF8gPSArXykgKiBfLCB6b29tKSA6IE1hdGguc3FydChjbGlja0Rpc3RhbmNlMik7XG4gIH07XG5cbiAgcmV0dXJuIHpvb207XG59O1xuXG5leHBvcnRzLnpvb20gPSB6b29tO1xuZXhwb3J0cy56b29tVHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuZXhwb3J0cy56b29tSWRlbnRpdHkgPSBpZGVudGl0eTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGQzQXJyYXkgPSByZXF1aXJlKCdkMy1hcnJheScpO1xudmFyIGQzQXhpcyA9IHJlcXVpcmUoJ2QzLWF4aXMnKTtcbnZhciBkM0JydXNoID0gcmVxdWlyZSgnZDMtYnJ1c2gnKTtcbnZhciBkM0Nob3JkID0gcmVxdWlyZSgnZDMtY2hvcmQnKTtcbnZhciBkM0NvbGxlY3Rpb24gPSByZXF1aXJlKCdkMy1jb2xsZWN0aW9uJyk7XG52YXIgZDNDb2xvciA9IHJlcXVpcmUoJ2QzLWNvbG9yJyk7XG52YXIgZDNDb250b3VyID0gcmVxdWlyZSgnZDMtY29udG91cicpO1xudmFyIGQzRGlzcGF0Y2ggPSByZXF1aXJlKCdkMy1kaXNwYXRjaCcpO1xudmFyIGQzRHJhZyA9IHJlcXVpcmUoJ2QzLWRyYWcnKTtcbnZhciBkM0RzdiA9IHJlcXVpcmUoJ2QzLWRzdicpO1xudmFyIGQzRWFzZSA9IHJlcXVpcmUoJ2QzLWVhc2UnKTtcbnZhciBkM0ZldGNoID0gcmVxdWlyZSgnZDMtZmV0Y2gnKTtcbnZhciBkM0ZvcmNlID0gcmVxdWlyZSgnZDMtZm9yY2UnKTtcbnZhciBkM0Zvcm1hdCA9IHJlcXVpcmUoJ2QzLWZvcm1hdCcpO1xudmFyIGQzR2VvID0gcmVxdWlyZSgnZDMtZ2VvJyk7XG52YXIgZDNIaWVyYXJjaHkgPSByZXF1aXJlKCdkMy1oaWVyYXJjaHknKTtcbnZhciBkM0ludGVycG9sYXRlID0gcmVxdWlyZSgnZDMtaW50ZXJwb2xhdGUnKTtcbnZhciBkM1BhdGggPSByZXF1aXJlKCdkMy1wYXRoJyk7XG52YXIgZDNQb2x5Z29uID0gcmVxdWlyZSgnZDMtcG9seWdvbicpO1xudmFyIGQzUXVhZHRyZWUgPSByZXF1aXJlKCdkMy1xdWFkdHJlZScpO1xudmFyIGQzUmFuZG9tID0gcmVxdWlyZSgnZDMtcmFuZG9tJyk7XG52YXIgZDNTY2FsZSA9IHJlcXVpcmUoJ2QzLXNjYWxlJyk7XG52YXIgZDNTY2FsZUNocm9tYXRpYyA9IHJlcXVpcmUoJ2QzLXNjYWxlLWNocm9tYXRpYycpO1xudmFyIGQzU2VsZWN0aW9uID0gcmVxdWlyZSgnZDMtc2VsZWN0aW9uJyk7XG52YXIgZDNTaGFwZSA9IHJlcXVpcmUoJ2QzLXNoYXBlJyk7XG52YXIgZDNUaW1lID0gcmVxdWlyZSgnZDMtdGltZScpO1xudmFyIGQzVGltZUZvcm1hdCA9IHJlcXVpcmUoJ2QzLXRpbWUtZm9ybWF0Jyk7XG52YXIgZDNUaW1lciA9IHJlcXVpcmUoJ2QzLXRpbWVyJyk7XG52YXIgZDNUcmFuc2l0aW9uID0gcmVxdWlyZSgnZDMtdHJhbnNpdGlvbicpO1xudmFyIGQzVm9yb25vaSA9IHJlcXVpcmUoJ2QzLXZvcm9ub2knKTtcbnZhciBkM1pvb20gPSByZXF1aXJlKCdkMy16b29tJyk7XG5cbnZhciB2ZXJzaW9uID0gXCI1LjQuMFwiO1xuXG5PYmplY3Qua2V5cyhkM0FycmF5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNBcnJheVtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzQXhpcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzQXhpc1trZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzQnJ1c2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0JydXNoW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNDaG9yZCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzQ2hvcmRba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM0NvbGxlY3Rpb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0NvbGxlY3Rpb25ba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM0NvbG9yKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNDb2xvcltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzQ29udG91cikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzQ29udG91cltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzRGlzcGF0Y2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0Rpc3BhdGNoW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNEcmFnKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNEcmFnW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNEc3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0RzdltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzRWFzZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzRWFzZVtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzRmV0Y2gpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0ZldGNoW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNGb3JjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzRm9yY2Vba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM0Zvcm1hdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzRm9ybWF0W2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNHZW8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM0dlb1trZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzSGllcmFyY2h5KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNIaWVyYXJjaHlba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM0ludGVycG9sYXRlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNJbnRlcnBvbGF0ZVtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzUGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzUGF0aFtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzUG9seWdvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzUG9seWdvbltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzUXVhZHRyZWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM1F1YWR0cmVlW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNSYW5kb20pLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM1JhbmRvbVtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzU2NhbGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM1NjYWxlW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNTY2FsZUNocm9tYXRpYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzU2NhbGVDaHJvbWF0aWNba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM1NlbGVjdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzU2VsZWN0aW9uW2tleV07IH0pO1xuT2JqZWN0LmtleXMoZDNTaGFwZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzU2hhcGVba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM1RpbWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM1RpbWVba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM1RpbWVGb3JtYXQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBkM1RpbWVGb3JtYXRba2V5XTsgfSk7XG5PYmplY3Qua2V5cyhkM1RpbWVyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgZXhwb3J0c1trZXldID0gZDNUaW1lcltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzVHJhbnNpdGlvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzVHJhbnNpdGlvbltrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzVm9yb25vaSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzVm9yb25vaVtrZXldOyB9KTtcbk9iamVjdC5rZXlzKGQzWm9vbSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IGV4cG9ydHNba2V5XSA9IGQzWm9vbVtrZXldOyB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJldmVudFwiLCB7Z2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGQzU2VsZWN0aW9uLmV2ZW50OyB9fSk7XG4iLCIvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgKi9cbi8qKlxuICogQ29weXJpZ2h0IDIwMTItMjAxNyBDcmFpZyBDYW1wYmVsbFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIE1vdXNldHJhcCBpcyBhIHNpbXBsZSBrZXlib2FyZCBzaG9ydGN1dCBsaWJyYXJ5IGZvciBKYXZhc2NyaXB0IHdpdGhcbiAqIG5vIGV4dGVybmFsIGRlcGVuZGVuY2llc1xuICpcbiAqIEB2ZXJzaW9uIDEuNi4yXG4gKiBAdXJsIGNyYWlnLmlzL2tpbGxpbmcvbWljZVxuICovXG4oZnVuY3Rpb24od2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG5cbiAgICAvLyBDaGVjayBpZiBtb3VzZXRyYXAgaXMgdXNlZCBpbnNpZGUgYnJvd3NlciwgaWYgbm90LCByZXR1cm5cbiAgICBpZiAoIXdpbmRvdykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWFwcGluZyBvZiBzcGVjaWFsIGtleWNvZGVzIHRvIHRoZWlyIGNvcnJlc3BvbmRpbmcga2V5c1xuICAgICAqXG4gICAgICogZXZlcnl0aGluZyBpbiB0aGlzIGRpY3Rpb25hcnkgY2Fubm90IHVzZSBrZXlwcmVzcyBldmVudHNcbiAgICAgKiBzbyBpdCBoYXMgdG8gYmUgaGVyZSB0byBtYXAgdG8gdGhlIGNvcnJlY3Qga2V5Y29kZXMgZm9yXG4gICAgICoga2V5dXAva2V5ZG93biBldmVudHNcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdmFyIF9NQVAgPSB7XG4gICAgICAgIDg6ICdiYWNrc3BhY2UnLFxuICAgICAgICA5OiAndGFiJyxcbiAgICAgICAgMTM6ICdlbnRlcicsXG4gICAgICAgIDE2OiAnc2hpZnQnLFxuICAgICAgICAxNzogJ2N0cmwnLFxuICAgICAgICAxODogJ2FsdCcsXG4gICAgICAgIDIwOiAnY2Fwc2xvY2snLFxuICAgICAgICAyNzogJ2VzYycsXG4gICAgICAgIDMyOiAnc3BhY2UnLFxuICAgICAgICAzMzogJ3BhZ2V1cCcsXG4gICAgICAgIDM0OiAncGFnZWRvd24nLFxuICAgICAgICAzNTogJ2VuZCcsXG4gICAgICAgIDM2OiAnaG9tZScsXG4gICAgICAgIDM3OiAnbGVmdCcsXG4gICAgICAgIDM4OiAndXAnLFxuICAgICAgICAzOTogJ3JpZ2h0JyxcbiAgICAgICAgNDA6ICdkb3duJyxcbiAgICAgICAgNDU6ICdpbnMnLFxuICAgICAgICA0NjogJ2RlbCcsXG4gICAgICAgIDkxOiAnbWV0YScsXG4gICAgICAgIDkzOiAnbWV0YScsXG4gICAgICAgIDIyNDogJ21ldGEnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIG1hcHBpbmcgZm9yIHNwZWNpYWwgY2hhcmFjdGVycyBzbyB0aGV5IGNhbiBzdXBwb3J0XG4gICAgICpcbiAgICAgKiB0aGlzIGRpY3Rpb25hcnkgaXMgb25seSB1c2VkIGluY2FzZSB5b3Ugd2FudCB0byBiaW5kIGFcbiAgICAgKiBrZXl1cCBvciBrZXlkb3duIGV2ZW50IHRvIG9uZSBvZiB0aGVzZSBrZXlzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfS0VZQ09ERV9NQVAgPSB7XG4gICAgICAgIDEwNjogJyonLFxuICAgICAgICAxMDc6ICcrJyxcbiAgICAgICAgMTA5OiAnLScsXG4gICAgICAgIDExMDogJy4nLFxuICAgICAgICAxMTEgOiAnLycsXG4gICAgICAgIDE4NjogJzsnLFxuICAgICAgICAxODc6ICc9JyxcbiAgICAgICAgMTg4OiAnLCcsXG4gICAgICAgIDE4OTogJy0nLFxuICAgICAgICAxOTA6ICcuJyxcbiAgICAgICAgMTkxOiAnLycsXG4gICAgICAgIDE5MjogJ2AnLFxuICAgICAgICAyMTk6ICdbJyxcbiAgICAgICAgMjIwOiAnXFxcXCcsXG4gICAgICAgIDIyMTogJ10nLFxuICAgICAgICAyMjI6ICdcXCcnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHRoaXMgaXMgYSBtYXBwaW5nIG9mIGtleXMgdGhhdCByZXF1aXJlIHNoaWZ0IG9uIGEgVVMga2V5cGFkXG4gICAgICogYmFjayB0byB0aGUgbm9uIHNoaWZ0IGVxdWl2ZWxlbnRzXG4gICAgICpcbiAgICAgKiB0aGlzIGlzIHNvIHlvdSBjYW4gdXNlIGtleXVwIGV2ZW50cyB3aXRoIHRoZXNlIGtleXNcbiAgICAgKlxuICAgICAqIG5vdGUgdGhhdCB0aGlzIHdpbGwgb25seSB3b3JrIHJlbGlhYmx5IG9uIFVTIGtleWJvYXJkc1xuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB2YXIgX1NISUZUX01BUCA9IHtcbiAgICAgICAgJ34nOiAnYCcsXG4gICAgICAgICchJzogJzEnLFxuICAgICAgICAnQCc6ICcyJyxcbiAgICAgICAgJyMnOiAnMycsXG4gICAgICAgICckJzogJzQnLFxuICAgICAgICAnJSc6ICc1JyxcbiAgICAgICAgJ14nOiAnNicsXG4gICAgICAgICcmJzogJzcnLFxuICAgICAgICAnKic6ICc4JyxcbiAgICAgICAgJygnOiAnOScsXG4gICAgICAgICcpJzogJzAnLFxuICAgICAgICAnXyc6ICctJyxcbiAgICAgICAgJysnOiAnPScsXG4gICAgICAgICc6JzogJzsnLFxuICAgICAgICAnXFxcIic6ICdcXCcnLFxuICAgICAgICAnPCc6ICcsJyxcbiAgICAgICAgJz4nOiAnLicsXG4gICAgICAgICc/JzogJy8nLFxuICAgICAgICAnfCc6ICdcXFxcJ1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiB0aGlzIGlzIGEgbGlzdCBvZiBzcGVjaWFsIHN0cmluZ3MgeW91IGNhbiB1c2UgdG8gbWFwXG4gICAgICogdG8gbW9kaWZpZXIga2V5cyB3aGVuIHlvdSBzcGVjaWZ5IHlvdXIga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHZhciBfU1BFQ0lBTF9BTElBU0VTID0ge1xuICAgICAgICAnb3B0aW9uJzogJ2FsdCcsXG4gICAgICAgICdjb21tYW5kJzogJ21ldGEnLFxuICAgICAgICAncmV0dXJuJzogJ2VudGVyJyxcbiAgICAgICAgJ2VzY2FwZSc6ICdlc2MnLFxuICAgICAgICAncGx1cyc6ICcrJyxcbiAgICAgICAgJ21vZCc6IC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pID8gJ21ldGEnIDogJ2N0cmwnXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBmbGlwcGVkIHZlcnNpb24gb2YgX01BUCBmcm9tIGFib3ZlXG4gICAgICogbmVlZGVkIHRvIGNoZWNrIGlmIHdlIHNob3VsZCB1c2Uga2V5cHJlc3Mgb3Igbm90IHdoZW4gbm8gYWN0aW9uXG4gICAgICogaXMgc3BlY2lmaWVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB2YXIgX1JFVkVSU0VfTUFQO1xuXG4gICAgLyoqXG4gICAgICogbG9vcCB0aHJvdWdoIHRoZSBmIGtleXMsIGYxIHRvIGYxOSBhbmQgYWRkIHRoZW0gdG8gdGhlIG1hcFxuICAgICAqIHByb2dyYW1hdGljYWxseVxuICAgICAqL1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMjA7ICsraSkge1xuICAgICAgICBfTUFQWzExMSArIGldID0gJ2YnICsgaTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBsb29wIHRocm91Z2ggdG8gbWFwIG51bWJlcnMgb24gdGhlIG51bWVyaWMga2V5cGFkXG4gICAgICovXG4gICAgZm9yIChpID0gMDsgaSA8PSA5OyArK2kpIHtcblxuICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIHVzZSBhIHN0cmluZyBjYXVzZSBvdGhlcndpc2Ugc2luY2UgMCBpcyBmYWxzZXlcbiAgICAgICAgLy8gbW91c2V0cmFwIHdpbGwgbmV2ZXIgZmlyZSBmb3IgbnVtcGFkIDAgcHJlc3NlZCBhcyBwYXJ0IG9mIGEga2V5ZG93blxuICAgICAgICAvLyBldmVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2NhbXBiZWxsL21vdXNldHJhcC9wdWxsLzI1OFxuICAgICAgICBfTUFQW2kgKyA5Nl0gPSBpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogY3Jvc3MgYnJvd3NlciBhZGQgZXZlbnQgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR8SFRNTERvY3VtZW50fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9hZGRFdmVudChvYmplY3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChvYmplY3QuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgb2JqZWN0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iamVjdC5hdHRhY2hFdmVudCgnb24nICsgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHRha2VzIHRoZSBldmVudCBhbmQgcmV0dXJucyB0aGUga2V5IGNoYXJhY3RlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfY2hhcmFjdGVyRnJvbUV2ZW50KGUpIHtcblxuICAgICAgICAvLyBmb3Iga2V5cHJlc3MgZXZlbnRzIHdlIHNob3VsZCByZXR1cm4gdGhlIGNoYXJhY3RlciBhcyBpc1xuICAgICAgICBpZiAoZS50eXBlID09ICdrZXlwcmVzcycpIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGUgc2hpZnQga2V5IGlzIG5vdCBwcmVzc2VkIHRoZW4gaXQgaXMgc2FmZSB0byBhc3N1bWVcbiAgICAgICAgICAgIC8vIHRoYXQgd2Ugd2FudCB0aGUgY2hhcmFjdGVyIHRvIGJlIGxvd2VyY2FzZS4gIHRoaXMgbWVhbnMgaWZcbiAgICAgICAgICAgIC8vIHlvdSBhY2NpZGVudGFsbHkgaGF2ZSBjYXBzIGxvY2sgb24gdGhlbiB5b3VyIGtleSBiaW5kaW5nc1xuICAgICAgICAgICAgLy8gd2lsbCBjb250aW51ZSB0byB3b3JrXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgc2lkZSBlZmZlY3QgdGhhdCBtaWdodCBub3QgYmUgZGVzaXJlZCBpcyBpZiB5b3VcbiAgICAgICAgICAgIC8vIGJpbmQgc29tZXRoaW5nIGxpa2UgJ0EnIGNhdXNlIHlvdSB3YW50IHRvIHRyaWdnZXIgYW5cbiAgICAgICAgICAgIC8vIGV2ZW50IHdoZW4gY2FwaXRhbCBBIGlzIHByZXNzZWQgY2FwcyBsb2NrIHdpbGwgbm8gbG9uZ2VyXG4gICAgICAgICAgICAvLyB0cmlnZ2VyIHRoZSBldmVudC4gIHNoaWZ0K2Egd2lsbCB0aG91Z2guXG4gICAgICAgICAgICBpZiAoIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoYXJhY3RlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBub24ga2V5cHJlc3MgZXZlbnRzIHRoZSBzcGVjaWFsIG1hcHMgYXJlIG5lZWRlZFxuICAgICAgICBpZiAoX01BUFtlLndoaWNoXSkge1xuICAgICAgICAgICAgcmV0dXJuIF9NQVBbZS53aGljaF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX0tFWUNPREVfTUFQW2Uud2hpY2hdKSB7XG4gICAgICAgICAgICByZXR1cm4gX0tFWUNPREVfTUFQW2Uud2hpY2hdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGluIHRoZSBzcGVjaWFsIG1hcFxuXG4gICAgICAgIC8vIHdpdGgga2V5ZG93biBhbmQga2V5dXAgZXZlbnRzIHRoZSBjaGFyYWN0ZXIgc2VlbXMgdG8gYWx3YXlzXG4gICAgICAgIC8vIGNvbWUgaW4gYXMgYW4gdXBwZXJjYXNlIGNoYXJhY3RlciB3aGV0aGVyIHlvdSBhcmUgcHJlc3Npbmcgc2hpZnRcbiAgICAgICAgLy8gb3Igbm90LiAgd2Ugc2hvdWxkIG1ha2Ugc3VyZSBpdCBpcyBhbHdheXMgbG93ZXJjYXNlIGZvciBjb21wYXJpc29uc1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShlLndoaWNoKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGNoZWNrcyBpZiB0d28gYXJyYXlzIGFyZSBlcXVhbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzMVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyczJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfbW9kaWZpZXJzTWF0Y2gobW9kaWZpZXJzMSwgbW9kaWZpZXJzMikge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXJzMS5zb3J0KCkuam9pbignLCcpID09PSBtb2RpZmllcnMyLnNvcnQoKS5qb2luKCcsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGFrZXMgYSBrZXkgZXZlbnQgYW5kIGZpZ3VyZXMgb3V0IHdoYXQgdGhlIG1vZGlmaWVycyBhcmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2V2ZW50TW9kaWZpZXJzKGUpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IFtdO1xuXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnc2hpZnQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ2FsdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUuY3RybEtleSkge1xuICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goJ2N0cmwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlLm1ldGFLZXkpIHtcbiAgICAgICAgICAgIG1vZGlmaWVycy5wdXNoKCdtZXRhJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kaWZpZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByZXZlbnRzIGRlZmF1bHQgZm9yIHRoaXMgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgZnVuY3Rpb24gX3ByZXZlbnREZWZhdWx0KGUpIHtcbiAgICAgICAgaWYgKGUucHJldmVudERlZmF1bHQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdG9wcyBwcm9wb2dhdGlvbiBmb3IgdGhpcyBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfc3RvcFByb3BhZ2F0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRldGVybWluZXMgaWYgdGhlIGtleWNvZGUgc3BlY2lmaWVkIGlzIGEgbW9kaWZpZXIga2V5IG9yIG5vdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9pc01vZGlmaWVyKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID09ICdzaGlmdCcgfHwga2V5ID09ICdjdHJsJyB8fCBrZXkgPT0gJ2FsdCcgfHwga2V5ID09ICdtZXRhJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXZlcnNlcyB0aGUgbWFwIGxvb2t1cCBzbyB0aGF0IHdlIGNhbiBsb29rIGZvciBzcGVjaWZpYyBrZXlzXG4gICAgICogdG8gc2VlIHdoYXQgY2FuIGFuZCBjYW4ndCB1c2Uga2V5cHJlc3NcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfZ2V0UmV2ZXJzZU1hcCgpIHtcbiAgICAgICAgaWYgKCFfUkVWRVJTRV9NQVApIHtcbiAgICAgICAgICAgIF9SRVZFUlNFX01BUCA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIF9NQVApIHtcblxuICAgICAgICAgICAgICAgIC8vIHB1bGwgb3V0IHRoZSBudW1lcmljIGtleXBhZCBmcm9tIGhlcmUgY2F1c2Uga2V5cHJlc3Mgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gYmUgYWJsZSB0byBkZXRlY3QgdGhlIGtleXMgZnJvbSB0aGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgaWYgKGtleSA+IDk1ICYmIGtleSA8IDExMikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX01BUC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9SRVZFUlNFX01BUFtfTUFQW2tleV1dID0ga2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX1JFVkVSU0VfTUFQO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHBpY2tzIHRoZSBiZXN0IGFjdGlvbiBiYXNlZCBvbiB0aGUga2V5IGNvbWJpbmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gY2hhcmFjdGVyIGZvciBrZXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvbiBwYXNzZWQgaW5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfcGlja0Jlc3RBY3Rpb24oa2V5LCBtb2RpZmllcnMsIGFjdGlvbikge1xuXG4gICAgICAgIC8vIGlmIG5vIGFjdGlvbiB3YXMgcGlja2VkIGluIHdlIHNob3VsZCB0cnkgdG8gcGljayB0aGUgb25lXG4gICAgICAgIC8vIHRoYXQgd2UgdGhpbmsgd291bGQgd29yayBiZXN0IGZvciB0aGlzIGtleVxuICAgICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICAgICAgYWN0aW9uID0gX2dldFJldmVyc2VNYXAoKVtrZXldID8gJ2tleWRvd24nIDogJ2tleXByZXNzJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1vZGlmaWVyIGtleXMgZG9uJ3Qgd29yayBhcyBleHBlY3RlZCB3aXRoIGtleXByZXNzLFxuICAgICAgICAvLyBzd2l0Y2ggdG8ga2V5ZG93blxuICAgICAgICBpZiAoYWN0aW9uID09ICdrZXlwcmVzcycgJiYgbW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgYWN0aW9uID0gJ2tleWRvd24nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBmcm9tIGEgc3RyaW5nIGtleSBjb21iaW5hdGlvbiB0byBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBjb21iaW5hdGlvbiBsaWtlIFwiY29tbWFuZCtzaGlmdCtsXCJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBfa2V5c0Zyb21TdHJpbmcoY29tYmluYXRpb24pIHtcbiAgICAgICAgaWYgKGNvbWJpbmF0aW9uID09PSAnKycpIHtcbiAgICAgICAgICAgIHJldHVybiBbJysnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbWJpbmF0aW9uID0gY29tYmluYXRpb24ucmVwbGFjZSgvXFwrezJ9L2csICcrcGx1cycpO1xuICAgICAgICByZXR1cm4gY29tYmluYXRpb24uc3BsaXQoJysnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGluZm8gZm9yIGEgc3BlY2lmaWMga2V5IGNvbWJpbmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGNvbWJpbmF0aW9uIGtleSBjb21iaW5hdGlvbiAoXCJjb21tYW5kK3NcIiBvciBcImFcIiBvciBcIipcIilcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmc9fSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRLZXlJbmZvKGNvbWJpbmF0aW9uLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIGtleXM7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbW9kaWZpZXJzID0gW107XG5cbiAgICAgICAgLy8gdGFrZSB0aGUga2V5cyBmcm9tIHRoaXMgcGF0dGVybiBhbmQgZmlndXJlIG91dCB3aGF0IHRoZSBhY3R1YWxcbiAgICAgICAgLy8gcGF0dGVybiBpcyBhbGwgYWJvdXRcbiAgICAgICAga2V5cyA9IF9rZXlzRnJvbVN0cmluZyhjb21iaW5hdGlvbik7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBrZXkgbmFtZXNcbiAgICAgICAgICAgIGlmIChfU1BFQ0lBTF9BTElBU0VTW2tleV0pIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBfU1BFQ0lBTF9BTElBU0VTW2tleV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IGEga2V5cHJlc3MgZXZlbnQgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGJlIHNtYXJ0IGFib3V0IHVzaW5nIHNoaWZ0IGtleXNcbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBvbmx5IHdvcmsgZm9yIFVTIGtleWJvYXJkcyBob3dldmVyXG4gICAgICAgICAgICBpZiAoYWN0aW9uICYmIGFjdGlvbiAhPSAna2V5cHJlc3MnICYmIF9TSElGVF9NQVBba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleSA9IF9TSElGVF9NQVBba2V5XTtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMucHVzaCgnc2hpZnQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhpcyBrZXkgaXMgYSBtb2RpZmllciB0aGVuIGFkZCBpdCB0byB0aGUgbGlzdCBvZiBtb2RpZmllcnNcbiAgICAgICAgICAgIGlmIChfaXNNb2RpZmllcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB3aGF0IHRoZSBrZXkgY29tYmluYXRpb24gaXNcbiAgICAgICAgLy8gd2Ugd2lsbCB0cnkgdG8gcGljayB0aGUgYmVzdCBldmVudCBmb3IgaXRcbiAgICAgICAgYWN0aW9uID0gX3BpY2tCZXN0QWN0aW9uKGtleSwgbW9kaWZpZXJzLCBhY3Rpb24pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyczogbW9kaWZpZXJzLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBfYmVsb25nc1RvKGVsZW1lbnQsIGFuY2VzdG9yKSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbWVudCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9iZWxvbmdzVG8oZWxlbWVudC5wYXJlbnROb2RlLCBhbmNlc3Rvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTW91c2V0cmFwKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHRhcmdldEVsZW1lbnQgPSB0YXJnZXRFbGVtZW50IHx8IGRvY3VtZW50O1xuXG4gICAgICAgIGlmICghKHNlbGYgaW5zdGFuY2VvZiBNb3VzZXRyYXApKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vdXNldHJhcCh0YXJnZXRFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBlbGVtZW50IHRvIGF0dGFjaCBrZXkgZXZlbnRzIHRvXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi50YXJnZXQgPSB0YXJnZXRFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhIGxpc3Qgb2YgYWxsIHRoZSBjYWxsYmFja3Mgc2V0dXAgdmlhIE1vdXNldHJhcC5iaW5kKClcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2NhbGxiYWNrcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkaXJlY3QgbWFwIG9mIHN0cmluZyBjb21iaW5hdGlvbnMgdG8gY2FsbGJhY2tzIHVzZWQgZm9yIHRyaWdnZXIoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZi5fZGlyZWN0TWFwID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGtlZXBzIHRyYWNrIG9mIHdoYXQgbGV2ZWwgZWFjaCBzZXF1ZW5jZSBpcyBhdCBzaW5jZSBtdWx0aXBsZVxuICAgICAgICAgKiBzZXF1ZW5jZXMgY2FuIHN0YXJ0IG91dCB3aXRoIHRoZSBzYW1lIHNlcXVlbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX3NlcXVlbmNlTGV2ZWxzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhcmlhYmxlIHRvIHN0b3JlIHRoZSBzZXRUaW1lb3V0IGNhbGxcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge251bGx8bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9yZXNldFRpbWVyO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0ZW1wb3Jhcnkgc3RhdGUgd2hlcmUgd2Ugd2lsbCBpZ25vcmUgdGhlIG5leHQga2V5dXBcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW58c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9pZ25vcmVOZXh0S2V5dXAgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogdGVtcG9yYXJ5IHN0YXRlIHdoZXJlIHdlIHdpbGwgaWdub3JlIHRoZSBuZXh0IGtleXByZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9pZ25vcmVOZXh0S2V5cHJlc3MgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogYXJlIHdlIGN1cnJlbnRseSBpbnNpZGUgb2YgYSBzZXF1ZW5jZT9cbiAgICAgICAgICogdHlwZSBvZiBhY3Rpb24gKFwia2V5dXBcIiBvciBcImtleWRvd25cIiBvciBcImtleXByZXNzXCIpIG9yIGZhbHNlXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufHN0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHZhciBfbmV4dEV4cGVjdGVkQWN0aW9uID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlc2V0cyBhbGwgc2VxdWVuY2UgY291bnRlcnMgZXhjZXB0IGZvciB0aGUgb25lcyBwYXNzZWQgaW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRvTm90UmVzZXRcbiAgICAgICAgICogQHJldHVybnMgdm9pZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX3Jlc2V0U2VxdWVuY2VzKGRvTm90UmVzZXQpIHtcbiAgICAgICAgICAgIGRvTm90UmVzZXQgPSBkb05vdFJlc2V0IHx8IHt9O1xuXG4gICAgICAgICAgICB2YXIgYWN0aXZlU2VxdWVuY2VzID0gZmFsc2UsXG4gICAgICAgICAgICAgICAga2V5O1xuXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBfc2VxdWVuY2VMZXZlbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9Ob3RSZXNldFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVNlcXVlbmNlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfc2VxdWVuY2VMZXZlbHNba2V5XSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghYWN0aXZlU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICAgICAgX25leHRFeHBlY3RlZEFjdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZpbmRzIGFsbCBjYWxsYmFja3MgdGhhdCBtYXRjaCBiYXNlZCBvbiB0aGUga2V5Y29kZSwgbW9kaWZpZXJzLFxuICAgICAgICAgKiBhbmQgYWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyYWN0ZXJcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR8T2JqZWN0fSBlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VxdWVuY2VOYW1lIC0gbmFtZSBvZiB0aGUgc2VxdWVuY2Ugd2UgYXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gY29tYmluYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXI9fSBsZXZlbFxuICAgICAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZ2V0TWF0Y2hlcyhjaGFyYWN0ZXIsIG1vZGlmaWVycywgZSwgc2VxdWVuY2VOYW1lLCBjb21iaW5hdGlvbiwgbGV2ZWwpIHtcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrO1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBhY3Rpb24gPSBlLnR5cGU7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBldmVudHMgcmVsYXRlZCB0byB0aGlzIGtleWNvZGVcbiAgICAgICAgICAgIGlmICghc2VsZi5fY2FsbGJhY2tzW2NoYXJhY3Rlcl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGEgbW9kaWZpZXIga2V5IGlzIGNvbWluZyB1cCBvbiBpdHMgb3duIHdlIHNob3VsZCBhbGxvdyBpdFxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PSAna2V5dXAnICYmIF9pc01vZGlmaWVyKGNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcnMgPSBbY2hhcmFjdGVyXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBrZXkgdGhhdCB3YXMgcHJlc3NlZFxuICAgICAgICAgICAgLy8gYW5kIHNlZSBpZiBhbnkgb2YgdGhlbSBtYXRjaFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBzZWxmLl9jYWxsYmFja3NbY2hhcmFjdGVyXVtpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgc2VxdWVuY2UgbmFtZSBpcyBub3Qgc3BlY2lmaWVkLCBidXQgdGhpcyBpcyBhIHNlcXVlbmNlIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIHdyb25nIGxldmVsIHRoZW4gbW92ZSBvbnRvIHRoZSBuZXh0IG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKCFzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2suc2VxICYmIF9zZXF1ZW5jZUxldmVsc1tjYWxsYmFjay5zZXFdICE9IGNhbGxiYWNrLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhY3Rpb24gd2UgYXJlIGxvb2tpbmcgZm9yIGRvZXNuJ3QgbWF0Y2ggdGhlIGFjdGlvbiB3ZSBnb3RcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIHNob3VsZCBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAhPSBjYWxsYmFjay5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIGtleXByZXNzIGV2ZW50IGFuZCB0aGUgbWV0YSBrZXkgYW5kIGNvbnRyb2wga2V5XG4gICAgICAgICAgICAgICAgLy8gYXJlIG5vdCBwcmVzc2VkIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIG9ubHkgbG9vayBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG90aGVyd2lzZSBjaGVjayB0aGUgbW9kaWZpZXJzIGFzIHdlbGxcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIGNocm9tZSB3aWxsIG5vdCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBjb250cm9sIGlzIGRvd25cbiAgICAgICAgICAgICAgICAvLyBzYWZhcmkgd2lsbCBmaXJlIGEga2V5cHJlc3MgaWYgbWV0YSBvciBtZXRhK3NoaWZ0IGlzIGRvd25cbiAgICAgICAgICAgICAgICAvLyBmaXJlZm94IHdpbGwgZmlyZSBhIGtleXByZXNzIGlmIG1ldGEgb3IgY29udHJvbCBpcyBkb3duXG4gICAgICAgICAgICAgICAgaWYgKChhY3Rpb24gPT0gJ2tleXByZXNzJyAmJiAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkpIHx8IF9tb2RpZmllcnNNYXRjaChtb2RpZmllcnMsIGNhbGxiYWNrLm1vZGlmaWVycykpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVuIHlvdSBiaW5kIGEgY29tYmluYXRpb24gb3Igc2VxdWVuY2UgYSBzZWNvbmQgdGltZSBpdFxuICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgb3ZlcndyaXRlIHRoZSBmaXJzdCBvbmUuICBpZiBhIHNlcXVlbmNlTmFtZSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBjb21iaW5hdGlvbiBpcyBzcGVjaWZpZWQgaW4gdGhpcyBjYWxsIGl0IGRvZXMganVzdCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0b2RvIG1ha2UgZGVsZXRpbmcgaXRzIG93biBtZXRob2Q/XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVDb21ibyA9ICFzZXF1ZW5jZU5hbWUgJiYgY2FsbGJhY2suY29tYm8gPT0gY29tYmluYXRpb247XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGVTZXF1ZW5jZSA9IHNlcXVlbmNlTmFtZSAmJiBjYWxsYmFjay5zZXEgPT0gc2VxdWVuY2VOYW1lICYmIGNhbGxiYWNrLmxldmVsID09IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQ29tYm8gfHwgZGVsZXRlU2VxdWVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbGxiYWNrc1tjaGFyYWN0ZXJdLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhY3R1YWxseSBjYWxscyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICpcbiAgICAgICAgICogaWYgeW91ciBjYWxsYmFjayBmdW5jdGlvbiByZXR1cm5zIGZhbHNlIHRoaXMgd2lsbCB1c2UgdGhlIGpxdWVyeVxuICAgICAgICAgKiBjb252ZW50aW9uIC0gcHJldmVudCBkZWZhdWx0IGFuZCBzdG9wIHByb3BvZ2F0aW9uIG9uIHRoZSBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUsIGNvbWJvLCBzZXF1ZW5jZSkge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGV2ZW50IHNob3VsZCBub3QgaGFwcGVuIHN0b3AgaGVyZVxuICAgICAgICAgICAgaWYgKHNlbGYuc3RvcENhbGxiYWNrKGUsIGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCwgY29tYm8sIHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGUsIGNvbWJvKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgICAgICAgICAgX3N0b3BQcm9wYWdhdGlvbihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYW5kbGVzIGEgY2hhcmFjdGVyIGtleSBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2hhcmFjdGVyXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIHNlbGYuX2hhbmRsZUtleSA9IGZ1bmN0aW9uKGNoYXJhY3RlciwgbW9kaWZpZXJzLCBlKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gX2dldE1hdGNoZXMoY2hhcmFjdGVyLCBtb2RpZmllcnMsIGUpO1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICB2YXIgZG9Ob3RSZXNldCA9IHt9O1xuICAgICAgICAgICAgdmFyIG1heExldmVsID0gMDtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWF4TGV2ZWwgZm9yIHNlcXVlbmNlcyBzbyB3ZSBjYW4gb25seSBleGVjdXRlIHRoZSBsb25nZXN0IGNhbGxiYWNrIHNlcXVlbmNlXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5zZXEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4TGV2ZWwgPSBNYXRoLm1heChtYXhMZXZlbCwgY2FsbGJhY2tzW2ldLmxldmVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBtYXRjaGluZyBjYWxsYmFja3MgZm9yIHRoaXMga2V5IGV2ZW50XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBmaXJlIGZvciBhbGwgc2VxdWVuY2UgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIGlmIGZvciBleGFtcGxlIHlvdSBoYXZlIG11bHRpcGxlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIGJvdW5kIHN1Y2ggYXMgXCJnIGlcIiBhbmQgXCJnIHRcIiB0aGV5IGJvdGggbmVlZCB0byBmaXJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIGZvciBtYXRjaGluZyBnIGNhdXNlIG90aGVyd2lzZSB5b3UgY2FuIG9ubHkgZXZlclxuICAgICAgICAgICAgICAgIC8vIG1hdGNoIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzW2ldLnNlcSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZSBjYWxsYmFja3MgZm9yIHRoZSBtYXhMZXZlbCB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnNlcXVlbmNlcyBmcm9tIGFsc28gZmlyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlICdhIG9wdGlvbiBiJyBzaG91bGQgbm90IGNhdXNlICdvcHRpb24gYicgdG8gZmlyZVxuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCAnb3B0aW9uIGInIGlzIHBhcnQgb2YgdGhlIG90aGVyIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGFueSBzZXF1ZW5jZXMgdGhhdCBkbyBub3QgbWF0Y2ggaGVyZSB3aWxsIGJlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWxvdyBieSB0aGUgX3Jlc2V0U2VxdWVuY2VzIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXS5sZXZlbCAhPSBtYXhMZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzZWRTZXF1ZW5jZUNhbGxiYWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIGEgbGlzdCBvZiB3aGljaCBzZXF1ZW5jZXMgd2VyZSBtYXRjaGVzIGZvciBsYXRlclxuICAgICAgICAgICAgICAgICAgICBkb05vdFJlc2V0W2NhbGxiYWNrc1tpXS5zZXFdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUsIGNhbGxiYWNrc1tpXS5jb21ibywgY2FsbGJhY2tzW2ldLnNlcSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIHdlcmUgbm8gc2VxdWVuY2UgbWF0Y2hlcyBidXQgd2UgYXJlIHN0aWxsIGhlcmVcbiAgICAgICAgICAgICAgICAvLyB0aGF0IG1lYW5zIHRoaXMgaXMgYSByZWd1bGFyIG1hdGNoIHNvIHdlIHNob3VsZCBmaXJlIHRoYXRcbiAgICAgICAgICAgICAgICBpZiAoIXByb2Nlc3NlZFNlcXVlbmNlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZpcmVDYWxsYmFjayhjYWxsYmFja3NbaV0uY2FsbGJhY2ssIGUsIGNhbGxiYWNrc1tpXS5jb21ibyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUga2V5IHlvdSBwcmVzc2VkIG1hdGNoZXMgdGhlIHR5cGUgb2Ygc2VxdWVuY2Ugd2l0aG91dFxuICAgICAgICAgICAgLy8gYmVpbmcgYSBtb2RpZmllciAoaWUgXCJrZXl1cFwiIG9yIFwia2V5cHJlc3NcIikgdGhlbiB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIHJlc2V0IGFsbCBzZXF1ZW5jZXMgdGhhdCB3ZXJlIG5vdCBtYXRjaGVkIGJ5IHRoaXMgZXZlbnRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHNvLCBmb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgdGhlIHNlcXVlbmNlIFwiaCBhIHRcIiBhbmQgeW91XG4gICAgICAgICAgICAvLyB0eXBlIFwiaCBlIGEgciB0XCIgaXQgZG9lcyBub3QgbWF0Y2guICBpbiB0aGlzIGNhc2UgdGhlIFwiZVwiIHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIHRoZSBzZXF1ZW5jZSB0byByZXNldFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIG1vZGlmaWVyIGtleXMgYXJlIGlnbm9yZWQgYmVjYXVzZSB5b3UgY2FuIGhhdmUgYSBzZXF1ZW5jZVxuICAgICAgICAgICAgLy8gdGhhdCBjb250YWlucyBtb2RpZmllcnMgc3VjaCBhcyBcImVudGVyIGN0cmwrc3BhY2VcIiBhbmQgaW4gbW9zdFxuICAgICAgICAgICAgLy8gY2FzZXMgdGhlIG1vZGlmaWVyIGtleSB3aWxsIGJlIHByZXNzZWQgYmVmb3JlIHRoZSBuZXh0IGtleVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGFsc28gaWYgeW91IGhhdmUgYSBzZXF1ZW5jZSBzdWNoIGFzIFwiY3RybCtiIGFcIiB0aGVuIHByZXNzaW5nIHRoZVxuICAgICAgICAgICAgLy8gXCJiXCIga2V5IHdpbGwgdHJpZ2dlciBhIFwia2V5cHJlc3NcIiBhbmQgYSBcImtleWRvd25cIlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHRoZSBcImtleWRvd25cIiBpcyBleHBlY3RlZCB3aGVuIHRoZXJlIGlzIGEgbW9kaWZpZXIsIGJ1dCB0aGVcbiAgICAgICAgICAgIC8vIFwia2V5cHJlc3NcIiBlbmRzIHVwIG1hdGNoaW5nIHRoZSBfbmV4dEV4cGVjdGVkQWN0aW9uIHNpbmNlIGl0IG9jY3Vyc1xuICAgICAgICAgICAgLy8gYWZ0ZXIgYW5kIHRoYXQgY2F1c2VzIHRoZSBzZXF1ZW5jZSB0byByZXNldFxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIHdlIGlnbm9yZSBrZXlwcmVzc2VzIGluIGEgc2VxdWVuY2UgdGhhdCBkaXJlY3RseSBmb2xsb3cgYSBrZXlkb3duXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHNhbWUgY2hhcmFjdGVyXG4gICAgICAgICAgICB2YXIgaWdub3JlVGhpc0tleXByZXNzID0gZS50eXBlID09ICdrZXlwcmVzcycgJiYgX2lnbm9yZU5leHRLZXlwcmVzcztcbiAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gX25leHRFeHBlY3RlZEFjdGlvbiAmJiAhX2lzTW9kaWZpZXIoY2hhcmFjdGVyKSAmJiAhaWdub3JlVGhpc0tleXByZXNzKSB7XG4gICAgICAgICAgICAgICAgX3Jlc2V0U2VxdWVuY2VzKGRvTm90UmVzZXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfaWdub3JlTmV4dEtleXByZXNzID0gcHJvY2Vzc2VkU2VxdWVuY2VDYWxsYmFjayAmJiBlLnR5cGUgPT0gJ2tleWRvd24nO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBoYW5kbGVzIGEga2V5ZG93biBldmVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9oYW5kbGVLZXlFdmVudChlKSB7XG5cbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSBlLndoaWNoIGZvciBrZXkgZXZlbnRzXG4gICAgICAgICAgICAvLyBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDI4NTYyNy9qYXZhc2NyaXB0LWtleWNvZGUtdnMtY2hhcmNvZGUtdXR0ZXItY29uZnVzaW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUud2hpY2ggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgZS53aGljaCA9IGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoYXJhY3RlciA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG5cbiAgICAgICAgICAgIC8vIG5vIGNoYXJhY3RlciBmb3VuZCB0aGVuIHN0b3BcbiAgICAgICAgICAgIGlmICghY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBuZWVkIHRvIHVzZSA9PT0gZm9yIHRoZSBjaGFyYWN0ZXIgY2hlY2sgYmVjYXVzZSB0aGUgY2hhcmFjdGVyIGNhbiBiZSAwXG4gICAgICAgICAgICBpZiAoZS50eXBlID09ICdrZXl1cCcgJiYgX2lnbm9yZU5leHRLZXl1cCA9PT0gY2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgX2lnbm9yZU5leHRLZXl1cCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi5oYW5kbGVLZXkoY2hhcmFjdGVyLCBfZXZlbnRNb2RpZmllcnMoZSksIGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB0byBzZXQgYSAxIHNlY29uZCB0aW1lb3V0IG9uIHRoZSBzcGVjaWZpZWQgc2VxdWVuY2VcbiAgICAgICAgICpcbiAgICAgICAgICogdGhpcyBpcyBzbyBhZnRlciBlYWNoIGtleSBwcmVzcyBpbiB0aGUgc2VxdWVuY2UgeW91IGhhdmUgMSBzZWNvbmRcbiAgICAgICAgICogdG8gcHJlc3MgdGhlIG5leHQga2V5IGJlZm9yZSB5b3UgaGF2ZSB0byBzdGFydCBvdmVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9yZXNldFNlcXVlbmNlVGltZXIoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3Jlc2V0VGltZXIpO1xuICAgICAgICAgICAgX3Jlc2V0VGltZXIgPSBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTAwMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgYSBrZXkgc2VxdWVuY2UgdG8gYW4gZXZlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbWJvIC0gY29tYm8gc3BlY2lmaWVkIGluIGJpbmQgY2FsbFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5kU2VxdWVuY2UoY29tYm8sIGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcblxuICAgICAgICAgICAgLy8gc3RhcnQgb2ZmIGJ5IGFkZGluZyBhIHNlcXVlbmNlIGxldmVsIHJlY29yZCBmb3IgdGhpcyBjb21iaW5hdGlvblxuICAgICAgICAgICAgLy8gYW5kIHNldHRpbmcgdGhlIGxldmVsIHRvIDBcbiAgICAgICAgICAgIF9zZXF1ZW5jZUxldmVsc1tjb21ib10gPSAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIHRvIGluY3JlYXNlIHRoZSBzZXF1ZW5jZSBsZXZlbCBmb3IgdGhpcyBzZXF1ZW5jZSBhbmQgcmVzZXRcbiAgICAgICAgICAgICAqIGFsbCBvdGhlciBzZXF1ZW5jZXMgdGhhdCB3ZXJlIGFjdGl2ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXh0QWN0aW9uXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbmNyZWFzZVNlcXVlbmNlKG5leHRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9uZXh0RXhwZWN0ZWRBY3Rpb24gPSBuZXh0QWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICArK19zZXF1ZW5jZUxldmVsc1tjb21ib107XG4gICAgICAgICAgICAgICAgICAgIF9yZXNldFNlcXVlbmNlVGltZXIoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHdyYXBzIHRoZSBzcGVjaWZpZWQgY2FsbGJhY2sgaW5zaWRlIG9mIGFub3RoZXIgZnVuY3Rpb24gaW4gb3JkZXJcbiAgICAgICAgICAgICAqIHRvIHJlc2V0IGFsbCBzZXF1ZW5jZSBjb3VudGVycyBhcyBzb29uIGFzIHRoaXMgc2VxdWVuY2UgaXMgZG9uZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2NhbGxiYWNrQW5kUmVzZXQoZSkge1xuICAgICAgICAgICAgICAgIF9maXJlQ2FsbGJhY2soY2FsbGJhY2ssIGUsIGNvbWJvKTtcblxuICAgICAgICAgICAgICAgIC8vIHdlIHNob3VsZCBpZ25vcmUgdGhlIG5leHQga2V5IHVwIGlmIHRoZSBhY3Rpb24gaXMga2V5IGRvd25cbiAgICAgICAgICAgICAgICAvLyBvciBrZXlwcmVzcy4gIHRoaXMgaXMgc28gaWYgeW91IGZpbmlzaCBhIHNlcXVlbmNlIGFuZFxuICAgICAgICAgICAgICAgIC8vIHJlbGVhc2UgdGhlIGtleSB0aGUgZmluYWwga2V5IHdpbGwgbm90IHRyaWdnZXIgYSBrZXl1cFxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdrZXl1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX2lnbm9yZU5leHRLZXl1cCA9IF9jaGFyYWN0ZXJGcm9tRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gd2VpcmQgcmFjZSBjb25kaXRpb24gaWYgYSBzZXF1ZW5jZSBlbmRzIHdpdGggdGhlIGtleVxuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgc2VxdWVuY2UgYmVnaW5zIHdpdGhcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KF9yZXNldFNlcXVlbmNlcywgMTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2gga2V5cyBvbmUgYXQgYSB0aW1lIGFuZCBiaW5kIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgLy8gZnVuY3Rpb24uICBmb3IgYW55IGtleSBsZWFkaW5nIHVwIHRvIHRoZSBmaW5hbCBvbmUgaXQgc2hvdWxkXG4gICAgICAgICAgICAvLyBpbmNyZWFzZSB0aGUgc2VxdWVuY2UuIGFmdGVyIHRoZSBmaW5hbCwgaXQgc2hvdWxkIHJlc2V0IGFsbCBzZXF1ZW5jZXNcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpZiBhbiBhY3Rpb24gaXMgc3BlY2lmaWVkIGluIHRoZSBvcmlnaW5hbCBiaW5kIGNhbGwgdGhlbiB0aGF0IHdpbGxcbiAgICAgICAgICAgIC8vIGJlIHVzZWQgdGhyb3VnaG91dC4gIG90aGVyd2lzZSB3ZSB3aWxsIHBhc3MgdGhlIGFjdGlvbiB0aGF0IHRoZVxuICAgICAgICAgICAgLy8gbmV4dCBrZXkgaW4gdGhlIHNlcXVlbmNlIHNob3VsZCBtYXRjaC4gIHRoaXMgYWxsb3dzIGEgc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIHRvIG1peCBhbmQgbWF0Y2gga2V5cHJlc3MgYW5kIGtleWRvd24gZXZlbnRzIGRlcGVuZGluZyBvbiB3aGljaFxuICAgICAgICAgICAgLy8gb25lcyBhcmUgYmV0dGVyIHN1aXRlZCB0byB0aGUga2V5IHByb3ZpZGVkXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNGaW5hbCA9IGkgKyAxID09PSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZENhbGxiYWNrID0gaXNGaW5hbCA/IF9jYWxsYmFja0FuZFJlc2V0IDogX2luY3JlYXNlU2VxdWVuY2UoYWN0aW9uIHx8IF9nZXRLZXlJbmZvKGtleXNbaSArIDFdKS5hY3Rpb24pO1xuICAgICAgICAgICAgICAgIF9iaW5kU2luZ2xlKGtleXNbaV0sIHdyYXBwZWRDYWxsYmFjaywgYWN0aW9uLCBjb21ibywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgYSBzaW5nbGUga2V5Ym9hcmQgY29tYmluYXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbWJpbmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VxdWVuY2VOYW1lIC0gbmFtZSBvZiBzZXF1ZW5jZSBpZiBwYXJ0IG9mIHNlcXVlbmNlXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gbGV2ZWwgLSB3aGF0IHBhcnQgb2YgdGhlIHNlcXVlbmNlIHRoZSBjb21tYW5kIGlzXG4gICAgICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9iaW5kU2luZ2xlKGNvbWJpbmF0aW9uLCBjYWxsYmFjaywgYWN0aW9uLCBzZXF1ZW5jZU5hbWUsIGxldmVsKSB7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIGEgZGlyZWN0IG1hcHBlZCByZWZlcmVuY2UgZm9yIHVzZSB3aXRoIE1vdXNldHJhcC50cmlnZ2VyXG4gICAgICAgICAgICBzZWxmLl9kaXJlY3RNYXBbY29tYmluYXRpb24gKyAnOicgKyBhY3Rpb25dID0gY2FsbGJhY2s7XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBtdWx0aXBsZSBzcGFjZXMgaW4gYSByb3cgYmVjb21lIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgICAgICBjb21iaW5hdGlvbiA9IGNvbWJpbmF0aW9uLnJlcGxhY2UoL1xccysvZywgJyAnKTtcblxuICAgICAgICAgICAgdmFyIHNlcXVlbmNlID0gY29tYmluYXRpb24uc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIHZhciBpbmZvO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIHBhdHRlcm4gaXMgYSBzZXF1ZW5jZSBvZiBrZXlzIHRoZW4gcnVuIHRocm91Z2ggdGhpcyBtZXRob2RcbiAgICAgICAgICAgIC8vIHRvIHJlcHJvY2VzcyBlYWNoIHBhdHRlcm4gb25lIGtleSBhdCBhIHRpbWVcbiAgICAgICAgICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgX2JpbmRTZXF1ZW5jZShjb21iaW5hdGlvbiwgc2VxdWVuY2UsIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5mbyA9IF9nZXRLZXlJbmZvKGNvbWJpbmF0aW9uLCBhY3Rpb24pO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgdG8gaW5pdGlhbGl6ZSBhcnJheSBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgICAvLyBhIGNhbGxiYWNrIGlzIGFkZGVkIGZvciB0aGlzIGtleVxuICAgICAgICAgICAgc2VsZi5fY2FsbGJhY2tzW2luZm8ua2V5XSA9IHNlbGYuX2NhbGxiYWNrc1tpbmZvLmtleV0gfHwgW107XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBhbiBleGlzdGluZyBtYXRjaCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgICAgIF9nZXRNYXRjaGVzKGluZm8ua2V5LCBpbmZvLm1vZGlmaWVycywge3R5cGU6IGluZm8uYWN0aW9ufSwgc2VxdWVuY2VOYW1lLCBjb21iaW5hdGlvbiwgbGV2ZWwpO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhpcyBjYWxsIGJhY2sgdG8gdGhlIGFycmF5XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlcXVlbmNlIHB1dCBpdCBhdCB0aGUgYmVnaW5uaW5nXG4gICAgICAgICAgICAvLyBpZiBub3QgcHV0IGl0IGF0IHRoZSBlbmRcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyB0aGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSB3YXkgdGhlc2UgYXJlIHByb2Nlc3NlZCBleHBlY3RzXG4gICAgICAgICAgICAvLyB0aGUgc2VxdWVuY2Ugb25lcyB0byBjb21lIGZpcnN0XG4gICAgICAgICAgICBzZWxmLl9jYWxsYmFja3NbaW5mby5rZXldW3NlcXVlbmNlTmFtZSA/ICd1bnNoaWZ0JyA6ICdwdXNoJ10oe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IGluZm8ubW9kaWZpZXJzLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogaW5mby5hY3Rpb24sXG4gICAgICAgICAgICAgICAgc2VxOiBzZXF1ZW5jZU5hbWUsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIGNvbWJvOiBjb21iaW5hdGlvblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogYmluZHMgbXVsdGlwbGUgY29tYmluYXRpb25zIHRvIHRoZSBzYW1lIGNhbGxiYWNrXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbWJpbmF0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IGFjdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICAgICAqL1xuICAgICAgICBzZWxmLl9iaW5kTXVsdGlwbGUgPSBmdW5jdGlvbihjb21iaW5hdGlvbnMsIGNhbGxiYWNrLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tYmluYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgX2JpbmRTaW5nbGUoY29tYmluYXRpb25zW2ldLCBjYWxsYmFjaywgYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBzdGFydCFcbiAgICAgICAgX2FkZEV2ZW50KHRhcmdldEVsZW1lbnQsICdrZXlwcmVzcycsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgICAgIF9hZGRFdmVudCh0YXJnZXRFbGVtZW50LCAna2V5ZG93bicsIF9oYW5kbGVLZXlFdmVudCk7XG4gICAgICAgIF9hZGRFdmVudCh0YXJnZXRFbGVtZW50LCAna2V5dXAnLCBfaGFuZGxlS2V5RXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGJpbmRzIGFuIGV2ZW50IHRvIG1vdXNldHJhcFxuICAgICAqXG4gICAgICogY2FuIGJlIGEgc2luZ2xlIGtleSwgYSBjb21iaW5hdGlvbiBvZiBrZXlzIHNlcGFyYXRlZCB3aXRoICssXG4gICAgICogYW4gYXJyYXkgb2Yga2V5cywgb3IgYSBzZXF1ZW5jZSBvZiBrZXlzIHNlcGFyYXRlZCBieSBzcGFjZXNcbiAgICAgKlxuICAgICAqIGJlIHN1cmUgdG8gbGlzdCB0aGUgbW9kaWZpZXIga2V5cyBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCB0aGVcbiAgICAgKiBjb3JyZWN0IGtleSBlbmRzIHVwIGdldHRpbmcgYm91bmQgKHRoZSBsYXN0IGtleSBpbiB0aGUgcGF0dGVybilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBrZXlzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvbiAtICdrZXlwcmVzcycsICdrZXlkb3duJywgb3IgJ2tleXVwJ1xuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihrZXlzLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAga2V5cyA9IGtleXMgaW5zdGFuY2VvZiBBcnJheSA/IGtleXMgOiBba2V5c107XG4gICAgICAgIHNlbGYuX2JpbmRNdWx0aXBsZS5jYWxsKHNlbGYsIGtleXMsIGNhbGxiYWNrLCBhY3Rpb24pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdW5iaW5kcyBhbiBldmVudCB0byBtb3VzZXRyYXBcbiAgICAgKlxuICAgICAqIHRoZSB1bmJpbmRpbmcgc2V0cyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBrZXkgY29tYm9cbiAgICAgKiB0byBhbiBlbXB0eSBmdW5jdGlvbiBhbmQgZGVsZXRlcyB0aGUgY29ycmVzcG9uZGluZyBrZXkgaW4gdGhlXG4gICAgICogX2RpcmVjdE1hcCBkaWN0LlxuICAgICAqXG4gICAgICogVE9ETzogYWN0dWFsbHkgcmVtb3ZlIHRoaXMgZnJvbSB0aGUgX2NhbGxiYWNrcyBkaWN0aW9uYXJ5IGluc3RlYWRcbiAgICAgKiBvZiBiaW5kaW5nIGFuIGVtcHR5IGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiB0aGUga2V5Y29tYm8rYWN0aW9uIGhhcyB0byBiZSBleGFjdGx5IHRoZSBzYW1lIGFzXG4gICAgICogaXQgd2FzIGRlZmluZWQgaW4gdGhlIGJpbmQgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihrZXlzLCBhY3Rpb24pIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gc2VsZi5iaW5kLmNhbGwoc2VsZiwga2V5cywgZnVuY3Rpb24oKSB7fSwgYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogdHJpZ2dlcnMgYW4gZXZlbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGJvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5c1xuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYWN0aW9uXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uKGtleXMsIGFjdGlvbikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxmLl9kaXJlY3RNYXBba2V5cyArICc6JyArIGFjdGlvbl0pIHtcbiAgICAgICAgICAgIHNlbGYuX2RpcmVjdE1hcFtrZXlzICsgJzonICsgYWN0aW9uXSh7fSwga2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIHJlc2V0cyB0aGUgbGlicmFyeSBiYWNrIHRvIGl0cyBpbml0aWFsIHN0YXRlLiAgdGhpcyBpcyB1c2VmdWxcbiAgICAgKiBpZiB5b3Ugd2FudCB0byBjbGVhciBvdXQgdGhlIGN1cnJlbnQga2V5Ym9hcmQgc2hvcnRjdXRzIGFuZCBiaW5kXG4gICAgICogbmV3IG9uZXMgLSBmb3IgZXhhbXBsZSBpZiB5b3Ugc3dpdGNoIHRvIGFub3RoZXIgcGFnZVxuICAgICAqXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgICAgc2VsZi5fZGlyZWN0TWFwID0ge307XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBzaG91bGQgd2Ugc3RvcCB0aGlzIGV2ZW50IGJlZm9yZSBmaXJpbmcgb2ZmIGNhbGxiYWNrc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSBmdW5jdGlvbihlLCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBoYXMgdGhlIGNsYXNzIFwibW91c2V0cmFwXCIgdGhlbiBubyBuZWVkIHRvIHN0b3BcbiAgICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX2JlbG9uZ3NUbyhlbGVtZW50LCBzZWxmLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3AgZm9yIGlucHV0LCBzZWxlY3QsIGFuZCB0ZXh0YXJlYVxuICAgICAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09ICdJTlBVVCcgfHwgZWxlbWVudC50YWdOYW1lID09ICdTRUxFQ1QnIHx8IGVsZW1lbnQudGFnTmFtZSA9PSAnVEVYVEFSRUEnIHx8IGVsZW1lbnQuaXNDb250ZW50RWRpdGFibGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIGV4cG9zZXMgX2hhbmRsZUtleSBwdWJsaWNseSBzbyBpdCBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIE1vdXNldHJhcC5wcm90b3R5cGUuaGFuZGxlS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHNlbGYuX2hhbmRsZUtleS5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBhbGxvdyBjdXN0b20ga2V5IG1hcHBpbmdzXG4gICAgICovXG4gICAgTW91c2V0cmFwLmFkZEtleWNvZGVzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIF9NQVBba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIF9SRVZFUlNFX01BUCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIGdsb2JhbCBtb3VzZXRyYXAgZnVuY3Rpb25zXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBuZWVkZWQgdG8gYWxsb3cgdGhlIGdsb2JhbCBtb3VzZXRyYXAgZnVuY3Rpb25zIHRvIHdvcmtcbiAgICAgKiBub3cgdGhhdCBtb3VzZXRyYXAgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBNb3VzZXRyYXAuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZG9jdW1lbnRNb3VzZXRyYXAgPSBNb3VzZXRyYXAoZG9jdW1lbnQpO1xuICAgICAgICBmb3IgKHZhciBtZXRob2QgaW4gZG9jdW1lbnRNb3VzZXRyYXApIHtcbiAgICAgICAgICAgIGlmIChtZXRob2QuY2hhckF0KDApICE9PSAnXycpIHtcbiAgICAgICAgICAgICAgICBNb3VzZXRyYXBbbWV0aG9kXSA9IChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50TW91c2V0cmFwW21ldGhvZF0uYXBwbHkoZG9jdW1lbnRNb3VzZXRyYXAsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSAobWV0aG9kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgTW91c2V0cmFwLmluaXQoKTtcblxuICAgIC8vIGV4cG9zZSBtb3VzZXRyYXAgdG8gdGhlIGdsb2JhbCBvYmplY3RcbiAgICB3aW5kb3cuTW91c2V0cmFwID0gTW91c2V0cmFwO1xuXG4gICAgLy8gZXhwb3NlIGFzIGEgY29tbW9uIGpzIG1vZHVsZVxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1vdXNldHJhcDtcbiAgICB9XG5cbiAgICAvLyBleHBvc2UgbW91c2V0cmFwIGFzIGFuIEFNRCBtb2R1bGVcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBNb3VzZXRyYXA7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGwsIHR5cGVvZiAgd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbCk7XG4iXX0=
